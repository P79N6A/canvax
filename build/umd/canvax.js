(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Canvax = factory());
}(this, (function () { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var _$1 = {};
var breaker = {};
var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var toString = ObjProto.toString;
var hasOwnProperty = ObjProto.hasOwnProperty;

var nativeForEach = ArrayProto.forEach;
var nativeFilter = ArrayProto.filter;
var nativeIndexOf = ArrayProto.indexOf;
var nativeIsArray = Array.isArray;
var nativeKeys = Object.keys;

_$1.values = function (obj) {
  var keys = _$1.keys(obj);
  var length = keys.length;
  var values = new Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[keys[i]];
  }
  return values;
};

_$1.keys = nativeKeys || function (obj) {
  if (obj !== Object(obj)) throw new TypeError('Invalid object');
  var keys = [];
  for (var key in obj) {
    if (_$1.has(obj, key)) keys.push(key);
  }return keys;
};

_$1.has = function (obj, key) {
  return hasOwnProperty.call(obj, key);
};

var each = _$1.each = _$1.forEach = function (obj, iterator, context) {
  if (obj == null) return;
  if (nativeForEach && obj.forEach === nativeForEach) {
    obj.forEach(iterator, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, length = obj.length; i < length; i++) {
      if (iterator.call(context, obj[i], i, obj) === breaker) return;
    }
  } else {
    var keys = _$1.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
    }
  }
};

_$1.compact = function (array) {
  return _$1.filter(array, _$1.identity);
};

_$1.filter = _$1.select = function (obj, iterator, context) {
  var results = [];
  if (obj == null) return results;
  if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
  each(obj, function (value, index, list) {
    if (iterator.call(context, value, index, list)) results.push(value);
  });
  return results;
};

each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {
  _$1['is' + name] = function (obj) {
    return toString.call(obj) == '[object ' + name + ']';
  };
});

{
  _$1.isFunction = function (obj) {
    return typeof obj === 'function';
  };
}

_$1.isFinite = function (obj) {
  return isFinite(obj) && !isNaN(parseFloat(obj));
};

_$1.isNaN = function (obj) {
  return _$1.isNumber(obj) && obj != +obj;
};

_$1.isBoolean = function (obj) {
  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
};

_$1.isNull = function (obj) {
  return obj === null;
};

_$1.isEmpty = function (obj) {
  if (obj == null) return true;
  if (_$1.isArray(obj) || _$1.isString(obj)) return obj.length === 0;
  for (var key in obj) {
    if (_$1.has(obj, key)) return false;
  }return true;
};

_$1.isElement = function (obj) {
  return !!(obj && obj.nodeType === 1);
};

_$1.isArray = nativeIsArray || function (obj) {
  return toString.call(obj) == '[object Array]';
};

_$1.isObject = function (obj) {
  return obj === Object(obj);
};

_$1.identity = function (value) {
  return value;
};

_$1.indexOf = function (array, item, isSorted) {
  if (array == null) return -1;
  var i = 0,
      length = array.length;
  if (isSorted) {
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else {
      i = _$1.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
  }
  if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
  for (; i < length; i++) {
    if (array[i] === item) return i;
  }return -1;
};

_$1.isWindow = function (obj) {
  return obj != null && obj == obj.window;
};
_$1.isPlainObject = function (obj) {
  // Because of IE, we also have to check the presence of the constructor property.
  // Make sure that DOM nodes and window objects don't pass through, as well
  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== "object" || obj.nodeType || _$1.isWindow(obj)) {
    return false;
  }
  try {
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
      return false;
    }
  } catch (e) {
    // IE8,9 Will throw exceptions on certain host objects #9897
    return false;
  }
  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {}

  return key === undefined || hasOwn.call(obj, key);
};

/**
*
*如果是深度extend，第一个参数就设置为true
*/
_$1.extend = function () {
  var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== "object" && !_$1.isFunction(target)) {
    target = {};
  }
  if (length === i) {
    target = this;
    --i;
  }
  for (; i < length; i++) {
    if ((options = arguments[i]) != null) {
      for (name in options) {
        src = target[name];
        copy = options[name];
        if (target === copy) {
          continue;
        }
        if (deep && copy && (_$1.isPlainObject(copy) || (copyIsArray = _$1.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && _$1.isArray(src) ? src : [];
          } else {
            clone = src && _$1.isPlainObject(src) ? src : {};
          }
          target[name] = _$1.extend(deep, clone, copy);
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }
  return target;
};
_$1.clone = function (obj) {
  if (!_$1.isObject(obj)) return obj;
  return _$1.isArray(obj) ? obj.slice() : _$1.extend(true, {}, obj);
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com 
*/
var Utils = {
    mainFrameRate: 60, //默认主帧率
    now: 0,
    /*像素检测专用*/
    _pixelCtx: null,
    __emptyFunc: function __emptyFunc() {},
    //retina 屏幕优化
    _devicePixelRatio: window.devicePixelRatio || 1,
    _UID: 0, //该值为向上的自增长整数值
    getUID: function getUID() {
        return this._UID++;
    },
    createId: function createId(name) {
        if (!name) {
            debugger;
        }
        //if end with a digit, then append an undersBase before appending
        var charCode = name.charCodeAt(name.length - 1);
        if (charCode >= 48 && charCode <= 57) name += "_";
        return name + Utils.getUID();
    },
    canvasSupport: function canvasSupport() {
        return !!document.createElement('canvas').getContext;
    },
    createObject: function createObject(proto, constructor) {
        var newProto;
        var ObjectCreate = Object.create;
        if (ObjectCreate) {
            newProto = ObjectCreate(proto);
        } else {
            Utils.__emptyFunc.prototype = proto;
            newProto = new Utils.__emptyFunc();
        }
        newProto.constructor = constructor;
        return newProto;
    },
    creatClass: function creatClass(r, s, px) {
        if (!s || !r) {
            return r;
        }
        var sp = s.prototype,
            rp;
        // add prototype chain
        rp = Utils.createObject(sp, r);
        r.prototype = _$1.extend(rp, r.prototype);
        r.superclass = Utils.createObject(sp, s);
        // add prototype overrides
        if (px) {
            _$1.extend(rp, px);
        }
        return r;
    },
    initElement: function initElement(canvas) {
        if (window.FlashCanvas && FlashCanvas.initElement) {
            FlashCanvas.initElement(canvas);
        }
    },
    //做一次简单的opt参数校验，保证在用户不传opt的时候 或者传了opt但是里面没有context的时候报错
    checkOpt: function checkOpt(opt) {
        if (!opt) {
            return {
                context: {}
            };
        } else if (opt && !opt.context) {
            opt.context = {};
            return opt;
        } else {
            return opt;
        }
    },

    /**
     * 按照css的顺序，返回一个[上,右,下,左]
     */
    getCssOrderArr: function getCssOrderArr(r) {
        var r1;
        var r2;
        var r3;
        var r4;

        if (typeof r === 'number') {
            r1 = r2 = r3 = r4 = r;
        } else if (r instanceof Array) {
            if (r.length === 1) {
                r1 = r2 = r3 = r4 = r[0];
            } else if (r.length === 2) {
                r1 = r3 = r[0];
                r2 = r4 = r[1];
            } else if (r.length === 3) {
                r1 = r[0];
                r2 = r4 = r[1];
                r3 = r[2];
            } else {
                r1 = r[0];
                r2 = r[1];
                r3 = r[2];
                r4 = r[3];
            }
        } else {
            r1 = r2 = r3 = r4 = 0;
        }
        return [r1, r2, r3, r4];
    },

    isWebGLSupported: function isWebGLSupported() {
        var contextOptions = { stencil: true };
        try {
            if (!window.WebGLRenderingContext) //不存在直接return
                {
                    return false;
                }
            var canvas = document.createElement('canvas'),
                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
            return !!(gl && gl.getContextAttributes().stencil); //还要确实检测是否支持webGL模式
        } catch (e) {
            return false;
        }
    }
};

/**
 * Point
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 */
var Point = function () {
    function Point() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        classCallCheck(this, Point);

        if (arguments.length == 1 && _typeof(arguments[0]) == 'object') {
            var arg = arguments[0];
            if ("x" in arg && "y" in arg) {
                this.x = arg.x * 1;
                this.y = arg.y * 1;
            } else {
                var i = 0;
                for (var p in arg) {
                    if (i == 0) {
                        this.x = arg[p] * 1;
                    } else {
                        this.y = arg[p] * 1;
                        break;
                    }
                    i++;
                }
            }
        } else {
            this.x = x * 1;
            this.y = y * 1;
        }
    }

    createClass(Point, [{
        key: "toArray",
        value: function toArray$$1() {
            return [this.x, this.y];
        }
    }]);
    return Point;
}();

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * canvas 上委托的事件管理
 */
var CanvaxEvent = function CanvaxEvent(evt, params) {

    var eventType = "CanvaxEvent";
    if (_$1.isString(evt)) {
        eventType = evt;
    }
    if (_$1.isObject(evt) && evt.type) {
        eventType = evt.type;
    }

    this.target = null;
    this.currentTarget = null;
    this.type = eventType;
    this.point = null;

    this._stopPropagation = false; //默认不阻止事件冒泡
};
CanvaxEvent.prototype = {
    stopPropagation: function stopPropagation() {
        this._stopPropagation = true;
    }
};

var settings = {
  //设备分辨率
  RESOLUTION: window.devicePixelRatio || 1,

  /**
   * Target frames per millisecond.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 0.06
   */
  TARGET_FPMS: 0.06,

  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   *
   * @static
   * @memberof PIXI.settings
   * @type {boolean}
   * @default true
   */
  MIPMAP_TEXTURES: true,

  /**
   * Default filter resolution.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,

  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000

  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,

  /**
   * The prefix that denotes a URL is for a retina asset.
   *
   * @static
   * @memberof PIXI.settings
   * @type {RegExp|string}
   * @example `@2x`
   * @default /@(.+)x/
   */
  RETINA_PREFIX: /@(.+)x/,

  /**
   * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
   * or {@link PIXI.CanvasRenderer}.
   *
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} view=null
   * @property {number} resolution=1
   * @property {boolean} antialias=false
   * @property {boolean} forceFXAA=false
   * @property {boolean} autoResize=false
   * @property {boolean} transparent=false
   * @property {number} backgroundColor=0x000000
   * @property {boolean} clearBeforeRender=true
   * @property {boolean} preserveDrawingBuffer=false
   * @property {boolean} roundPixels=false
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: true,
    forceFXAA: false,
    autoResize: false,
    transparent: true,
    backgroundColor: 0x000000,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    roundPixels: false
  },

  /**
   * Default transform type.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.TRANSFORM_MODE}
   * @default PIXI.TRANSFORM_MODE.STATIC
   */
  TRANSFORM_MODE: 0,

  /**
   * Default Garbage Collection mode.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: 0,

  /**
   * Default Garbage Collection max idle.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,

  /**
   * Default Garbage Collection maximum check count.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,

  /**
   * Default wrap modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: 0,

  /**
   * The scale modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: 0,

  /**
   * Default specify float precision in shaders.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION: 'mediump'

};

var addOrRmoveEventHand = function addOrRmoveEventHand(domHand, ieHand) {
    if (document[domHand]) {
        var _ret = function () {
            var eventDomFn = function eventDomFn(el, type, fn) {
                if (el.length) {
                    for (var i = 0; i < el.length; i++) {
                        eventDomFn(el[i], type, fn);
                    }
                } else {
                    el[domHand](type, fn, false);
                }
            };

            
            return {
                v: eventDomFn
            };
        }();

        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    } else {
        var _ret2 = function () {
            var eventFn = function eventFn(el, type, fn) {
                if (el.length) {
                    for (var i = 0; i < el.length; i++) {
                        eventFn(el[i], type, fn);
                    }
                } else {
                    el[ieHand]("on" + type, function () {
                        return fn.call(el, window.event);
                    });
                }
            };

            
            return {
                v: eventFn
            };
        }();

        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    }
};

var $ = {
    // dom操作相关代码
    query: function query(el) {
        if (_$1.isString(el)) {
            return document.getElementById(el);
        }
        if (el.nodeType == 1) {
            //则为一个element本身
            return el;
        }
        if (el.length) {
            return el[0];
        }
        return null;
    },
    offset: function offset(el) {
        var box = el.getBoundingClientRect(),
            doc = el.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,


        // for ie  
        clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,


        // In Internet Explorer 7 getBoundingClientRect property is treated as physical, 
        // while others are logical. Make all logical, like in IE8. 
        zoom = 1;
        if (body.getBoundingClientRect) {
            var bound = body.getBoundingClientRect();
            zoom = (bound.right - bound.left) / body.clientWidth;
        }
        if (zoom > 1) {
            clientTop = 0;
            clientLeft = 0;
        }
        var top = box.top / zoom + (window.pageYOffset || docElem && docElem.scrollTop / zoom || body.scrollTop / zoom) - clientTop,
            left = box.left / zoom + (window.pageXOffset || docElem && docElem.scrollLeft / zoom || body.scrollLeft / zoom) - clientLeft;

        return {
            top: top,
            left: left
        };
    },
    addEvent: addOrRmoveEventHand("addEventListener", "attachEvent"),
    removeEvent: addOrRmoveEventHand("removeEventListener", "detachEvent"),
    pageX: function pageX(e) {
        if (e.pageX) return e.pageX;else if (e.clientX) return e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);else return null;
    },
    pageY: function pageY(e) {
        if (e.pageY) return e.pageY;else if (e.clientY) return e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);else return null;
    },
    /**
     * 创建dom
     * @param {string} id dom id 待用
     * @param {string} type : dom type， such as canvas, div etc.
     */
    createCanvas: function createCanvas(_width, _height, id) {
        var canvas = document.createElement("canvas");
        canvas.style.position = 'absolute';
        canvas.style.width = _width + 'px';
        canvas.style.height = _height + 'px';
        canvas.style.left = 0;
        canvas.style.top = 0;
        canvas.setAttribute('width', _width * settings.RESOLUTION);
        canvas.setAttribute('height', _height * settings.RESOLUTION);
        canvas.setAttribute('id', id);
        return canvas;
    },
    createView: function createView(_width, _height, id) {
        var view = document.createElement("div");
        view.className = "canvax-view";
        view.style.cssText += "position:relative;width:" + _width + "px;height:" + _height + "px;";

        var stage_c = document.createElement("div");
        view.style.cssText += "position:absolute;width:" + _width + "px;height:" + _height + "px;";

        //用来存放一些dom元素
        var dom_c = document.createElement("div");
        view.style.cssText += "position:absolute;width:" + _width + "px;height:" + _height + "px;";

        view.appendChild(stage_c);
        view.appendChild(dom_c);

        return {
            view: view,
            stage_c: stage_c,
            dom_c: dom_c
        };
    }
    //dom相关代码结束
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 */
var _mouseEventTypes = ["click", "dblclick", "mousedown", "mousemove", "mouseup", "mouseout"];
var _hammerEventTypes = ["pan", "panstart", "panmove", "panend", "pancancel", "panleft", "panright", "panup", "pandown", "press", "pressup", "swipe", "swipeleft", "swiperight", "swipeup", "swipedown", "tap"];

var EventHandler = function EventHandler(canvax, opt) {
    this.canvax = canvax;

    this.curPoints = [new Point(0, 0)]; //X,Y 的 point 集合, 在touch下面则为 touch的集合，只是这个touch被添加了对应的x，y
    //当前激活的点对应的obj，在touch下可以是个数组,和上面的 curPoints 对应
    this.curPointsTarget = [];

    this._touching = false;
    //正在拖动，前提是_touching=true
    this._draging = false;

    //当前的鼠标状态
    this._cursor = "default";

    this.target = this.canvax.view;
    this.types = [];

    //mouse体统中不需要配置drag,touch中会用到第三方的touch库，每个库的事件名称可能不一样，
    //就要这里配置，默认实现的是hammerjs的,所以默认可以在项目里引入hammerjs http://hammerjs.github.io/
    this.drag = {
        start: "panstart",
        move: "panmove",
        end: "panend"
    };

    _$1.extend(true, this, opt);
};

//这样的好处是document.compareDocumentPosition只会在定义的时候执行一次。
var contains = document.compareDocumentPosition ? function (parent, child) {
    if (!child) {
        return false;
    }
    return !!(parent.compareDocumentPosition(child) & 16);
} : function (parent, child) {
    if (!child) {
        return false;
    }
    return child !== child && (parent.contains ? parent.contains(child) : true);
};

EventHandler.prototype = {
    init: function init() {

        //依次添加上浏览器的自带事件侦听
        var me = this;
        if (me.target.nodeType == undefined) {
            //如果target.nodeType没有的话， 说明该target为一个jQuery对象 or kissy 对象or hammer对象
            //即为第三方库，那么就要对接第三方库的事件系统。默认实现hammer的大部分事件系统
            if (!me.types || me.types.length == 0) {
                me.types = _hammerEventTypes;
            }
        } else if (me.target.nodeType == 1) {
            me.types = _mouseEventTypes;
        }

        _$1.each(me.types, function (type) {
            //不再关心浏览器环境是否 'ontouchstart' in window 
            //而是直接只管传给事件模块的是一个原生dom还是 jq对象 or hammer对象等
            if (me.target.nodeType == 1) {
                $.addEvent(me.target, type, function (e) {
                    me.__mouseHandler(e);
                });
            } else {
                me.target.on(type, function (e) {
                    me.__libHandler(e);
                });
            }
        });
    },
    /*
    * 原生事件系统------------------------------------------------begin
    * 鼠标事件处理函数
    **/
    __mouseHandler: function __mouseHandler(e) {
        var me = this;
        var root = me.canvax;

        root.updateViewOffset();

        me.curPoints = [new Point($.pageX(e) - root.viewOffset.left, $.pageY(e) - root.viewOffset.top)];

        //理论上来说，这里拿到point了后，就要计算这个point对应的target来push到curPointsTarget里，
        //但是因为在drag的时候其实是可以不用计算对应target的。
        //所以放在了下面的me.__getcurPointsTarget( e , curMousePoint );常规mousemove中执行

        var curMousePoint = me.curPoints[0];
        var curMouseTarget = me.curPointsTarget[0];

        //模拟drag,mouseover,mouseout 部分代码 begin-------------------------------------------------

        //mousedown的时候 如果 curMouseTarget.dragEnabled 为true。就要开始准备drag了
        if (e.type == "mousedown") {
            //如果curTarget 的数组为空或者第一个为false ，，，
            if (!curMouseTarget) {
                var obj = root.getObjectsUnderPoint(curMousePoint, 1)[0];
                if (obj) {
                    me.curPointsTarget = [obj];
                }
            }
            curMouseTarget = me.curPointsTarget[0];
            if (curMouseTarget && curMouseTarget.dragEnabled) {
                //鼠标事件已经摸到了一个
                me._touching = true;
            }
        }

        if (e.type == "mouseup" || e.type == "mouseout" && !contains(root.view, e.toElement || e.relatedTarget)) {
            if (me._draging == true) {
                //说明刚刚在拖动
                me._dragEnd(e, curMouseTarget, 0);
                curMouseTarget.fire("dragend");
            }
            me._draging = false;
            me._touching = false;
        }

        if (e.type == "mouseout") {
            if (!contains(root.view, e.toElement || e.relatedTarget)) {
                me.__getcurPointsTarget(e, curMousePoint);
            }
        } else if (e.type == "mousemove") {
            //|| e.type == "mousedown" ){
            //拖动过程中就不在做其他的mouseover检测，drag优先
            if (me._touching && e.type == "mousemove" && curMouseTarget) {
                //说明正在拖动啊
                if (!me._draging) {
                    //begin drag
                    curMouseTarget.fire("dragstart");
                    //先把本尊给隐藏了
                    curMouseTarget.context.globalAlpha = 0;
                    //然后克隆一个副本到activeStage

                    var cloneObject = me._clone2hoverStage(curMouseTarget, 0);
                    cloneObject.context.globalAlpha = curMouseTarget._globalAlpha;
                } else {
                    //drag move ing
                    me._dragMoveHander(e, curMouseTarget, 0);
                }
                me._draging = true;
            } else {
                //常规mousemove检测
                //move事件中，需要不停的搜索target，这个开销挺大，
                //后续可以优化，加上和帧率相当的延迟处理
                me.__getcurPointsTarget(e, curMousePoint);
            }
        } else {
            //其他的事件就直接在target上面派发事件
            var child = curMouseTarget;
            if (!child) {
                child = root;
            }
            me.__dispatchEventInChilds(e, [child]);
            me._cursorHander(child);
        }

        if (root.preventDefault) {
            //阻止默认浏览器动作(W3C) 
            if (e && e.preventDefault) {
                e.preventDefault();
            } else {
                window.event.returnValue = false;
            }
        }
    },
    __getcurPointsTarget: function __getcurPointsTarget(e, point) {
        var me = this;
        var root = me.canvax;
        var oldObj = me.curPointsTarget[0];

        if (oldObj && !oldObj.context) {
            oldObj = null;
        }

        var e = new CanvaxEvent(e);

        if (e.type == "mousemove" && oldObj && oldObj._hoverClass && oldObj.pointChkPriority && oldObj.getChildInPoint(point)) {
            //小优化,鼠标move的时候。计算频率太大，所以。做此优化
            //如果有target存在，而且当前元素正在hoverStage中，而且当前鼠标还在target内,就没必要取检测整个displayList了
            //开发派发常规mousemove事件
            e.target = e.currentTarget = oldObj;
            e.point = oldObj.globalToLocal(point);
            oldObj.dispatchEvent(e);
            return;
        }
        var obj = root.getObjectsUnderPoint(point, 1)[0];

        if (oldObj && oldObj != obj || e.type == "mouseout") {
            if (oldObj && oldObj.context) {
                me.curPointsTarget[0] = null;
                e.type = "mouseout";
                e.toTarget = obj;
                e.target = e.currentTarget = oldObj;
                e.point = oldObj.globalToLocal(point);
                oldObj.dispatchEvent(e);
            }
        }

        if (obj && oldObj != obj) {
            //&& obj._hoverable 已经 干掉了
            me.curPointsTarget[0] = obj;
            e.type = "mouseover";
            e.fromTarget = oldObj;
            e.target = e.currentTarget = obj;
            e.point = obj.globalToLocal(point);
            obj.dispatchEvent(e);
        }

        if (e.type == "mousemove" && obj) {
            e.target = e.currentTarget = oldObj;
            e.point = oldObj.globalToLocal(point);
            oldObj.dispatchEvent(e);
        }
        me._cursorHander(obj, oldObj);
    },
    _cursorHander: function _cursorHander(obj, oldObj) {
        if (!obj && !oldObj) {
            this._setCursor("default");
        }
        if (obj && oldObj != obj && obj.context) {
            this._setCursor(obj.context.cursor);
        }
    },
    _setCursor: function _setCursor(cursor) {
        if (this._cursor == cursor) {
            //如果两次要设置的鼠标状态是一样的
            return;
        }
        this.canvax.view.style.cursor = cursor;
        this._cursor = cursor;
    },
    /*
    * 原生事件系统------------------------------------------------end
    */

    /*
     *第三方库的事件系统------------------------------------------------begin
     *触屏事件处理函数
     * */
    __libHandler: function __libHandler(e) {
        var me = this;
        var root = me.canvax;
        root.updateViewOffset();
        // touch 下的 curPointsTarget 从touches中来
        //获取canvax坐标系统里面的坐标
        me.curPoints = me.__getCanvaxPointInTouchs(e);
        if (!me._draging) {
            //如果在draging的话，target已经是选中了的，可以不用 检测了
            me.curPointsTarget = me.__getChildInTouchs(me.curPoints);
        }
        if (me.curPointsTarget.length > 0) {
            //drag开始
            if (e.type == me.drag.start) {
                //dragstart的时候touch已经准备好了target， curPointsTarget 里面只要有一个是有效的
                //就认为drags开始
                _$1.each(me.curPointsTarget, function (child, i) {
                    if (child && child.dragEnabled) {
                        //只要有一个元素就认为正在准备drag了
                        me._draging = true;
                        //然后克隆一个副本到activeStage
                        me._clone2hoverStage(child, i);
                        //先把本尊给隐藏了
                        child.context.globalAlpha = 0;

                        child.fire("dragstart");

                        return false;
                    }
                });
            }

            //dragIng
            if (e.type == me.drag.move) {
                if (me._draging) {
                    _$1.each(me.curPointsTarget, function (child, i) {
                        if (child && child.dragEnabled) {
                            me._dragMoveHander(e, child, i);
                        }
                    });
                }
            }

            //drag结束
            if (e.type == me.drag.end) {
                if (me._draging) {
                    _$1.each(me.curPointsTarget, function (child, i) {
                        if (child && child.dragEnabled) {
                            me._dragEnd(e, child, 0);
                            child.fire("dragend");
                        }
                    });
                    me._draging = false;
                }
            }
            me.__dispatchEventInChilds(e, me.curPointsTarget);
        } else {
            //如果当前没有一个target，就把事件派发到canvax上面
            me.__dispatchEventInChilds(e, [root]);
        }
    },
    //从touchs中获取到对应touch , 在上面添加上canvax坐标系统的x，y
    __getCanvaxPointInTouchs: function __getCanvaxPointInTouchs(e) {
        var me = this;
        var root = me.canvax;
        var curTouchs = [];
        _$1.each(e.point, function (touch) {
            curTouchs.push({
                x: CanvaxEvent.pageX(touch) - root.viewOffset.left,
                y: CanvaxEvent.pageY(touch) - root.viewOffset.top
            });
        });
        return curTouchs;
    },
    __getChildInTouchs: function __getChildInTouchs(touchs) {
        var me = this;
        var root = me.canvax;
        var touchesTarget = [];
        _$1.each(touchs, function (touch) {
            touchesTarget.push(root.getObjectsUnderPoint(touch, 1)[0]);
        });
        return touchesTarget;
    },
    /*
    *第三方库的事件系统------------------------------------------------begin
    */

    /*
     *@param {array} childs 
     * */
    __dispatchEventInChilds: function __dispatchEventInChilds(e, childs) {
        if (!childs && !("length" in childs)) {
            return false;
        }
        var me = this;
        var hasChild = false;
        _$1.each(childs, function (child, i) {
            if (child) {
                hasChild = true;
                var ce = new CanvaxEvent(e);
                ce.target = ce.currentTarget = child || this;
                ce.stagePoint = me.curPoints[i];
                ce.point = ce.target.globalToLocal(ce.stagePoint);
                child.dispatchEvent(ce);
            }
        });
        return hasChild;
    },
    //克隆一个元素到hover stage中去
    _clone2hoverStage: function _clone2hoverStage(target, i) {
        var me = this;
        var root = me.canvax;
        var _dragDuplicate = root._bufferStage.getChildById(target.id);
        if (!_dragDuplicate) {
            _dragDuplicate = target.clone(true);
            _dragDuplicate._transform = target.getConcatenatedMatrix();

            /**
             *TODO: 因为后续可能会有手动添加的 元素到_bufferStage 里面来
             *比如tips
             *这类手动添加进来的肯定是因为需要显示在最外层的。在hover元素之上。
             *所有自动添加的hover元素都默认添加在_bufferStage的最底层
             **/
            root._bufferStage.addChildAt(_dragDuplicate, 0);
        }
        _dragDuplicate.context.globalAlpha = target._globalAlpha;
        target._dragPoint = target.globalToLocal(me.curPoints[i]);
        return _dragDuplicate;
    },
    //drag 中 的处理函数
    _dragMoveHander: function _dragMoveHander(e, target, i) {
        var me = this;
        var root = me.canvax;
        var _point = target.globalToLocal(me.curPoints[i]);

        //要对应的修改本尊的位置，但是要告诉引擎不要watch这个时候的变化
        target._notWatch = true;
        var _moveStage = target.moveing;
        target.moveing = true;
        target.context.x += _point.x - target._dragPoint.x;
        target.context.y += _point.y - target._dragPoint.y;
        target.fire("dragmove");
        target.moveing = _moveStage;
        target._notWatch = false;
        //同步完毕本尊的位置

        //这里只能直接修改_transform 。 不能用下面的修改x，y的方式。
        var _dragDuplicate = root._bufferStage.getChildById(target.id);
        _dragDuplicate._transform = target.getConcatenatedMatrix();
        //以为直接修改的_transform不会出发心跳上报， 渲染引擎不制动这个stage需要绘制。
        //所以要手动出发心跳包
        _dragDuplicate.heartBeat();
    },
    //drag结束的处理函数
    _dragEnd: function _dragEnd(e, target, i) {
        var me = this;
        var root = me.canvax;

        //_dragDuplicate 复制在_bufferStage 中的副本
        var _dragDuplicate = root._bufferStage.getChildById(target.id);
        _dragDuplicate.destroy();

        target.context.globalAlpha = target._globalAlpha;
    }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 事件管理类
 */
/**
 * 构造函数.
 * @name EventDispatcher
 * @class EventDispatcher类是可调度事件的类的基类，它允许显示列表上的任何对象都是一个事件目标。
 */
var EventManager = function EventManager() {
    //事件映射表，格式为：{type1:[listener1, listener2], type2:[listener3, listener4]}
    this._eventMap = {};
};

EventManager.prototype = {
    /*
     * 注册事件侦听器对象，以使侦听器能够接收事件通知。
     */
    _addEventListener: function _addEventListener(type, listener) {

        if (typeof listener != "function") {
            //listener必须是个function呐亲
            return false;
        }
        var addResult = true;
        var self = this;
        _$1.each(type.split(" "), function (type) {
            var map = self._eventMap[type];
            if (!map) {
                map = self._eventMap[type] = [];
                map.push(listener);
                self._eventEnabled = true;
                return true;
            }

            if (_$1.indexOf(map, listener) == -1) {
                map.push(listener);
                self._eventEnabled = true;
                return true;
            }

            addResult = false;
        });
        return addResult;
    },
    /**
     * 删除事件侦听器。
     */
    _removeEventListener: function _removeEventListener(type, listener) {
        if (arguments.length == 1) return this.removeEventListenerByType(type);

        var map = this._eventMap[type];
        if (!map) {
            return false;
        }

        for (var i = 0; i < map.length; i++) {
            var li = map[i];
            if (li === listener) {
                map.splice(i, 1);
                if (map.length == 0) {
                    delete this._eventMap[type];
                    //如果这个如果这个时候child没有任何事件侦听
                    if (_$1.isEmpty(this._eventMap)) {
                        //那么该元素不再接受事件的检测
                        this._eventEnabled = false;
                    }
                }
                return true;
            }
        }

        return false;
    },
    /**
     * 删除指定类型的所有事件侦听器。
     */
    _removeEventListenerByType: function _removeEventListenerByType(type) {
        var map = this._eventMap[type];
        if (!map) {
            delete this._eventMap[type];

            //如果这个如果这个时候child没有任何事件侦听
            if (_$1.isEmpty(this._eventMap)) {
                //那么该元素不再接受事件的检测
                this._eventEnabled = false;
            }

            return true;
        }
        return false;
    },
    /**
     * 删除所有事件侦听器。
     */
    _removeAllEventListeners: function _removeAllEventListeners() {
        this._eventMap = {};
        this._eventEnabled = false;
    },
    /**
    * 派发事件，调用事件侦听器。
    */
    _dispatchEvent: function _dispatchEvent(e) {
        var map = this._eventMap[e.type];

        if (map) {
            if (!e.target) e.target = this;
            map = map.slice();

            for (var i = 0; i < map.length; i++) {
                var listener = map[i];
                if (typeof listener == "function") {
                    listener.call(this, e);
                }
            }
        }

        if (!e._stopPropagation) {
            //向上冒泡
            if (this.parent) {
                e.currentTarget = this.parent;
                this.parent._dispatchEvent(e);
            }
        }
        return true;
    },
    /**
       * 检查是否为指定事件类型注册了任何侦听器。
       */
    _hasEventListener: function _hasEventListener(type) {
        var map = this._eventMap[type];
        return map != null && map.length > 0;
    }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 事件派发类
 */
var EventDispatcher = function EventDispatcher() {
    EventDispatcher.superclass.constructor.call(this, name);
};

Utils.creatClass(EventDispatcher, EventManager, {
    on: function on(type, listener) {
        this._addEventListener(type, listener);
        return this;
    },
    addEventListener: function addEventListener(type, listener) {
        this._addEventListener(type, listener);
        return this;
    },
    un: function un(type, listener) {
        this._removeEventListener(type, listener);
        return this;
    },
    removeEventListener: function removeEventListener(type, listener) {
        this._removeEventListener(type, listener);
        return this;
    },
    removeEventListenerByType: function removeEventListenerByType(type) {
        this._removeEventListenerByType(type);
        return this;
    },
    removeAllEventListeners: function removeAllEventListeners() {
        this._removeAllEventListeners();
        return this;
    },

    //params 要传给evt的eventhandler处理函数的参数，会被merge到Canvax event中
    fire: function fire(eventType, params) {
        var e = new CanvaxEvent(eventType);

        if (params) {
            for (var p in params) {
                if (p in e) {
                    //params中的数据不能覆盖event属性
                    console.log(p + "属性不能覆盖CanvaxEvent属性");
                } else {
                    e[p] = params[p];
                }
            }
        }

        var me = this;
        _$1.each(eventType.split(" "), function (eType) {
            e.currentTarget = me;
            me.dispatchEvent(e);
        });
        return this;
    },
    dispatchEvent: function dispatchEvent(event) {
        //this instanceof DisplayObjectContainer ==> this.children
        //TODO: 这里import DisplayObjectContainer 的话，在displayObject里面的import EventDispatcher from "../event/EventDispatcher";
        //会得到一个undefined，感觉是成了一个循环依赖的问题，所以这里换用简单的判断来判断自己是一个容易，拥有children
        if (this.children && event.point) {
            var target = this.getObjectsUnderPoint(event.point, 1)[0];
            if (target) {
                target.dispatchEvent(event);
            }
            return;
        }

        if (this.context && event.type == "mouseover") {
            //记录dispatchEvent之前的心跳
            var preHeartBeat = this._heartBeatNum;
            var pregAlpha = this.context.globalAlpha;
            this._dispatchEvent(event);
            if (preHeartBeat != this._heartBeatNum) {
                this._hoverClass = true;
                if (this.hoverClone) {
                    var canvax = this.getStage().parent;
                    //然后clone一份obj，添加到_bufferStage 中
                    var activShape = this.clone(true);
                    activShape._transform = this.getConcatenatedMatrix();
                    canvax._bufferStage.addChildAt(activShape, 0);
                    //然后把自己隐藏了
                    this._globalAlpha = pregAlpha;
                    this.context.globalAlpha = 0;
                }
            }
            return;
        }

        this._dispatchEvent(event);

        if (this.context && event.type == "mouseout") {
            if (this._hoverClass) {
                //说明刚刚over的时候有添加样式
                var canvax = this.getStage().parent;
                this._hoverClass = false;

                canvax._bufferStage.removeChildById(this.id);

                if (this._globalAlpha) {
                    this.context.globalAlpha = this._globalAlpha;
                    delete this._globalAlpha;
                }
            }
        }

        return this;
    },
    hasEvent: function hasEvent(type) {
        return this._hasEventListener(type);
    },
    hasEventListener: function hasEventListener(type) {
        return this._hasEventListener(type);
    },
    hover: function hover(overFun, outFun) {
        this.on("mouseover", overFun);
        this.on("mouseout", outFun);
        return this;
    },
    once: function once(type, listener) {
        var me = this;
        var onceHandle = function onceHandle() {
            listener.apply(me, arguments);
            this.un(type, onceHandle);
        };
        this.on(type, onceHandle);
        return this;
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * | a | c | tx|
 * | b | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 *
 *
 * Matrix 矩阵库 用于整个系统的几何变换计算
 */

var Matrix = function Matrix(a, b, c, d, tx, ty) {
    this.a = a != undefined ? a : 1;
    this.b = b != undefined ? b : 0;
    this.c = c != undefined ? c : 0;
    this.d = d != undefined ? d : 1;
    this.tx = tx != undefined ? tx : 0;
    this.ty = ty != undefined ? ty : 0;
    this.array = null;
};

Matrix.prototype = {
    concat: function concat(mtx) {
        var a = this.a;
        var c = this.c;
        var tx = this.tx;

        this.a = a * mtx.a + this.b * mtx.c;
        this.b = a * mtx.b + this.b * mtx.d;
        this.c = c * mtx.a + this.d * mtx.c;
        this.d = c * mtx.b + this.d * mtx.d;
        this.tx = tx * mtx.a + this.ty * mtx.c + mtx.tx;
        this.ty = tx * mtx.b + this.ty * mtx.d + mtx.ty;
        return this;
    },
    concatTransform: function concatTransform(x, y, scaleX, scaleY, rotation) {
        var cos = 1;
        var sin = 0;
        if (rotation % 360) {
            var r = rotation * Math.PI / 180;
            cos = Math.cos(r);
            sin = Math.sin(r);
        }

        this.concat(new Matrix(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y));
        return this;
    },
    rotate: function rotate(angle) {
        //目前已经提供对顺时针逆时针两个方向旋转的支持
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);

        var a = this.a;
        var c = this.c;
        var tx = this.tx;

        if (angle > 0) {
            this.a = a * cos - this.b * sin;
            this.b = a * sin + this.b * cos;
            this.c = c * cos - this.d * sin;
            this.d = c * sin + this.d * cos;
            this.tx = tx * cos - this.ty * sin;
            this.ty = tx * sin + this.ty * cos;
        } else {
            var st = Math.sin(Math.abs(angle));
            var ct = Math.cos(Math.abs(angle));

            this.a = a * ct + this.b * st;
            this.b = -a * st + this.b * ct;
            this.c = c * ct + this.d * st;
            this.d = -c * st + ct * this.d;
            this.tx = ct * tx + st * this.ty;
            this.ty = ct * this.ty - st * tx;
        }
        return this;
    },
    scale: function scale(sx, sy) {
        this.a *= sx;
        this.d *= sy;
        this.tx *= sx;
        this.ty *= sy;
        return this;
    },
    translate: function translate(dx, dy) {
        this.tx += dx;
        this.ty += dy;
        return this;
    },
    identity: function identity() {
        //初始化
        this.a = this.d = 1;
        this.b = this.c = this.tx = this.ty = 0;
        return this;
    },
    invert: function invert() {
        //逆向矩阵
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var tx = this.tx;
        var i = a * d - b * c;

        this.a = d / i;
        this.b = -b / i;
        this.c = -c / i;
        this.d = a / i;
        this.tx = (c * this.ty - d * tx) / i;
        this.ty = -(a * this.ty - b * tx) / i;
        return this;
    },
    clone: function clone() {
        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
    },
    toArray: function toArray(transpose, out) {
        if (arguments.length == 0) {
            //canvas2d 中不会有任何的参数传入
            return [this.a, this.b, this.c, this.d, this.tx, this.ty];
        }

        //webgl的glsl需要用的时候，需要传入transpose 来转换为一个3*3完整矩阵
        if (!this.array) {
            this.array = new Float32Array(9);
        }

        var array = out || this.array;

        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }

        return array;
    },
    /**
     * 矩阵左乘向量
     */
    mulVector: function mulVector(v) {
        var aa = this.a,
            ac = this.c,
            atx = this.tx;
        var ab = this.b,
            ad = this.d,
            aty = this.ty;

        var out = [0, 0];
        out[0] = v[0] * aa + v[1] * ac + atx;
        out[1] = v[0] * ab + v[1] * ad + aty;

        return out;
    }
};

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

var TWEEN = TWEEN || function () {

	var _tweens = [];

	return {

		getAll: function getAll() {

			return _tweens;
		},

		removeAll: function removeAll() {

			_tweens = [];
		},

		add: function add(tween) {

			_tweens.push(tween);
		},

		remove: function remove(tween) {

			var i = _$1.indexOf(_tweens, tween); //_tweens.indexOf(tween);

			if (i !== -1) {
				_tweens.splice(i, 1);
			}
		},

		update: function update(time, preserve) {

			if (_tweens.length === 0) {
				return false;
			}

			var i = 0;

			time = time !== undefined ? time : TWEEN.now();

			while (i < _tweens.length) {

				/* old 
    if (_tweens[i].update(time) || preserve) {
    i++;
    } else {
    _tweens.splice(i, 1);
    }
    */

				//new code
				//in real world, tween.update has chance to remove itself, so we have to handle this situation.
				//in certain cases, onUpdateCallback will remove instances in _tweens, which make _tweens.splice(i, 1) fail
				//@litao.lt@alibaba-inc.com
				var _t = _tweens[i];
				var _updateRes = _t.update(time);

				if (!_tweens[i]) {
					break;
				}
				if (_t === _tweens[i]) {
					if (_updateRes || preserve) {
						i++;
					} else {
						_tweens.splice(i, 1);
					}
				}
			}

			return true;
		}
	};
}();

// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof window === 'undefined' && typeof process !== 'undefined') {
	TWEEN.now = function () {
		var time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use window.performance.now if it is available.
else if (typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined) {
		// This must be bound, because directly assigning this function
		// leads to an invocation exception in Chrome.
		TWEEN.now = window.performance.now.bind(window.performance);
	}
	// Use Date.now if it is available.
	else if (Date.now !== undefined) {
			TWEEN.now = Date.now;
		}
		// Otherwise, use 'new Date().getTime()'.
		else {
				TWEEN.now = function () {
					return new Date().getTime();
				};
			}

TWEEN.Tween = function (object) {

	var _object = object;
	var _valuesStart = {};
	var _valuesEnd = {};
	var _valuesStartRepeat = {};
	var _duration = 1000;
	var _repeat = 0;
	var _repeatDelayTime;
	var _yoyo = false;
	var _isPlaying = false;
	var _reversed = false;
	var _delayTime = 0;
	var _startTime = null;
	var _easingFunction = TWEEN.Easing.Linear.None;
	var _interpolationFunction = TWEEN.Interpolation.Linear;
	var _chainedTweens = [];
	var _onStartCallback = null;
	var _onStartCallbackFired = false;
	var _onUpdateCallback = null;
	var _onCompleteCallback = null;
	var _onStopCallback = null;

	this.to = function (properties, duration) {

		_valuesEnd = properties;

		if (duration !== undefined) {
			_duration = duration;
		}

		return this;
	};

	this.start = function (time) {

		TWEEN.add(this);

		_isPlaying = true;

		_onStartCallbackFired = false;

		_startTime = time !== undefined ? time : TWEEN.now();
		_startTime += _delayTime;

		for (var property in _valuesEnd) {

			// Check if an Array was provided as property value
			if (_valuesEnd[property] instanceof Array) {

				if (_valuesEnd[property].length === 0) {
					continue;
				}

				// Create a local copy of the Array with the start value at the front
				_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
			}

			// If `to()` specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (_object[property] === undefined) {
				continue;
			}

			// Save the starting value.
			_valuesStart[property] = _object[property];

			if (_valuesStart[property] instanceof Array === false) {
				_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
			}

			_valuesStartRepeat[property] = _valuesStart[property] || 0;
		}

		return this;
	};

	this.stop = function () {

		if (!_isPlaying) {
			return this;
		}

		TWEEN.remove(this);
		_isPlaying = false;

		if (_onStopCallback !== null) {
			_onStopCallback.call(_object, _object);
		}

		this.stopChainedTweens();
		return this;
	};

	this.end = function () {

		this.update(_startTime + _duration);
		return this;
	};

	this.stopChainedTweens = function () {

		for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
			_chainedTweens[i].stop();
		}
	};

	this.delay = function (amount) {

		_delayTime = amount;
		return this;
	};

	this.repeat = function (times) {

		_repeat = times;
		return this;
	};

	this.repeatDelay = function (amount) {

		_repeatDelayTime = amount;
		return this;
	};

	this.yoyo = function (yoyo) {

		_yoyo = yoyo;
		return this;
	};

	this.easing = function (easing) {

		_easingFunction = easing;
		return this;
	};

	this.interpolation = function (interpolation) {

		_interpolationFunction = interpolation;
		return this;
	};

	this.chain = function () {

		_chainedTweens = arguments;
		return this;
	};

	this.onStart = function (callback) {

		_onStartCallback = callback;
		return this;
	};

	this.onUpdate = function (callback) {

		_onUpdateCallback = callback;
		return this;
	};

	this.onComplete = function (callback) {

		_onCompleteCallback = callback;
		return this;
	};

	this.onStop = function (callback) {

		_onStopCallback = callback;
		return this;
	};

	this.update = function (time) {

		var property;
		var elapsed;
		var value;

		if (time < _startTime) {
			return true;
		}

		if (_onStartCallbackFired === false) {

			if (_onStartCallback !== null) {
				_onStartCallback.call(_object, _object);
			}

			_onStartCallbackFired = true;
		}

		elapsed = (time - _startTime) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		value = _easingFunction(elapsed);

		for (property in _valuesEnd) {

			// Don't update properties that do not exist in the source object
			if (_valuesStart[property] === undefined) {
				continue;
			}

			var start = _valuesStart[property] || 0;
			var end = _valuesEnd[property];

			if (end instanceof Array) {

				_object[property] = _interpolationFunction(end, value);
			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if (typeof end === 'string') {

					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
						end = start + parseFloat(end);
					} else {
						end = parseFloat(end);
					}
				}

				// Protect against non numeric properties.
				if (typeof end === 'number') {
					_object[property] = start + (end - start) * value;
				}
			}
		}

		if (_onUpdateCallback !== null) {
			_onUpdateCallback.call(_object, value);
		}

		if (elapsed === 1) {

			if (_repeat > 0) {

				if (isFinite(_repeat)) {
					_repeat--;
				}

				// Reassign starting values, restart by making startTime = now
				for (property in _valuesStartRepeat) {

					if (typeof _valuesEnd[property] === 'string') {
						_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);
					}

					if (_yoyo) {
						var tmp = _valuesStartRepeat[property];

						_valuesStartRepeat[property] = _valuesEnd[property];
						_valuesEnd[property] = tmp;
					}

					_valuesStart[property] = _valuesStartRepeat[property];
				}

				if (_yoyo) {
					_reversed = !_reversed;
				}

				if (_repeatDelayTime !== undefined) {
					_startTime = time + _repeatDelayTime;
				} else {
					_startTime = time + _delayTime;
				}

				return true;
			} else {

				if (_onCompleteCallback !== null) {

					_onCompleteCallback.call(_object, _object);
				}

				for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
					// Make the chained tweens start exactly at the time they should,
					// even if the `update()` method was called way past the duration of the tween
					_chainedTweens[i].start(_startTime + _duration);
				}

				return false;
			}
		}

		return true;
	};
};

TWEEN.Easing = {

	Linear: {

		None: function None(k) {

			return k;
		}

	},

	Quadratic: {

		In: function In(k) {

			return k * k;
		},

		Out: function Out(k) {

			return k * (2 - k);
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}

			return -0.5 * (--k * (k - 2) - 1);
		}

	},

	Cubic: {

		In: function In(k) {

			return k * k * k;
		},

		Out: function Out(k) {

			return --k * k * k + 1;
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k + 2);
		}

	},

	Quartic: {

		In: function In(k) {

			return k * k * k * k;
		},

		Out: function Out(k) {

			return 1 - --k * k * k * k;
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}

			return -0.5 * ((k -= 2) * k * k * k - 2);
		}

	},

	Quintic: {

		In: function In(k) {

			return k * k * k * k * k;
		},

		Out: function Out(k) {

			return --k * k * k * k * k + 1;
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k * k * k + 2);
		}

	},

	Sinusoidal: {

		In: function In(k) {

			return 1 - Math.cos(k * Math.PI / 2);
		},

		Out: function Out(k) {

			return Math.sin(k * Math.PI / 2);
		},

		InOut: function InOut(k) {

			return 0.5 * (1 - Math.cos(Math.PI * k));
		}

	},

	Exponential: {

		In: function In(k) {

			return k === 0 ? 0 : Math.pow(1024, k - 1);
		},

		Out: function Out(k) {

			return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
		},

		InOut: function InOut(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}

			return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
		}

	},

	Circular: {

		In: function In(k) {

			return 1 - Math.sqrt(1 - k * k);
		},

		Out: function Out(k) {

			return Math.sqrt(1 - --k * k);
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return -0.5 * (Math.sqrt(1 - k * k) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
		}

	},

	Elastic: {

		In: function In(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
		},

		Out: function Out(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
		},

		InOut: function InOut(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			k *= 2;

			if (k < 1) {
				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
		}

	},

	Back: {

		In: function In(k) {

			var s = 1.70158;

			return k * k * ((s + 1) * k - s);
		},

		Out: function Out(k) {

			var s = 1.70158;

			return --k * k * ((s + 1) * k + s) + 1;
		},

		InOut: function InOut(k) {

			var s = 1.70158 * 1.525;

			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}

			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
		}

	},

	Bounce: {

		In: function In(k) {

			return 1 - TWEEN.Easing.Bounce.Out(1 - k);
		},

		Out: function Out(k) {

			if (k < 1 / 2.75) {
				return 7.5625 * k * k;
			} else if (k < 2 / 2.75) {
				return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
			} else if (k < 2.5 / 2.75) {
				return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
			} else {
				return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
			}
		},

		InOut: function InOut(k) {

			if (k < 0.5) {
				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
			}

			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
		}

	}

};

TWEEN.Interpolation = {

	Linear: function Linear(v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.Linear;

		if (k < 0) {
			return fn(v[0], v[1], f);
		}

		if (k > 1) {
			return fn(v[m], v[m - 1], m - f);
		}

		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
	},

	Bezier: function Bezier(v, k) {

		var b = 0;
		var n = v.length - 1;
		var pw = Math.pow;
		var bn = TWEEN.Interpolation.Utils.Bernstein;

		for (var i = 0; i <= n; i++) {
			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
		}

		return b;
	},

	CatmullRom: function CatmullRom(v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.CatmullRom;

		if (v[0] === v[m]) {

			if (k < 0) {
				i = Math.floor(f = m * (1 + k));
			}

			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
		} else {

			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
		}
	},

	Utils: {

		Linear: function Linear(p0, p1, t) {

			return (p1 - p0) * t + p0;
		},

		Bernstein: function Bernstein(n, i) {

			var fc = TWEEN.Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);
		},

		Factorial: function () {

			var a = [1];

			return function (n) {

				var s = 1;

				if (a[n]) {
					return a[n];
				}

				for (var i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;
				return s;
			};
		}(),

		CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
		}

	}

};

/**
 * 设置 AnimationFrame begin
 */
var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
}
if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}
if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
}

//管理所有图表的渲染任务
var _taskList = []; //[{ id : task: }...]
var _requestAid = null;

function enabledAnimationFrame() {
    if (!_requestAid) {
        _requestAid = requestAnimationFrame(function () {
            //console.log("frame__" + _taskList.length);
            //if ( Tween.getAll().length ) {
            TWEEN.update(); //tween自己会做length判断
            //};
            var currTaskList = _taskList;
            _taskList = [];
            _requestAid = null;
            while (currTaskList.length > 0) {
                currTaskList.shift().task();
            }
        });
    }
    return _requestAid;
}

/*
 * @param task 要加入到渲染帧队列中的任务
 * @result frameid
 */
function registFrame($frame) {
    if (!$frame) {
        return;
    }
    _taskList.push($frame);
    return enabledAnimationFrame();
}

/*
 *  @param task 要从渲染帧队列中删除的任务
 */
function destroyFrame($frame) {
    var d_result = false;
    for (var i = 0, l = _taskList.length; i < l; i++) {
        if (_taskList[i].id === $frame.id) {
            d_result = true;
            _taskList.splice(i, 1);
            i--;
            l--;
        }
    }
    if (_taskList.length == 0) {
        cancelAnimationFrame(_requestAid);
        _requestAid = null;
    }
    return d_result;
}

/* 
 * @param opt {from , to , onUpdate , onComplete , ......}
 * @result tween
 */
function registTween(options) {
    var opt = _$1.extend({
        from: null,
        to: null,
        duration: 500,
        onStart: function onStart() {},
        onUpdate: function onUpdate() {},
        onComplete: function onComplete() {},
        onStop: function onStop() {},
        repeat: 0,
        delay: 0,
        easing: 'Linear.None',
        desc: '' //动画描述，方便查找bug
    }, options);

    var tween = {};
    var tid = "tween_" + Utils.getUID();
    opt.id && (tid = tid + "_" + opt.id);

    if (opt.from && opt.to) {
        (function () {
            var animate = function animate() {

                if (tween._isCompleteed || tween._isStoped) {
                    tween = null;
                    return;
                }
                registFrame({
                    id: tid,
                    task: animate,
                    desc: opt.desc,
                    tween: tween
                });
            };

            tween = new TWEEN.Tween(opt.from).to(opt.to, opt.duration).onStart(function () {
                opt.onStart.apply(this);
            }).onUpdate(function () {
                opt.onUpdate.apply(this);
            }).onComplete(function () {
                destroyFrame({
                    id: tid
                });
                tween._isCompleteed = true;
                opt.onComplete.apply(this, [this]); //执行用户的conComplete
            }).onStop(function () {
                destroyFrame({
                    id: tid
                });
                tween._isStoped = true;
                opt.onStop.apply(this, [this]);
            }).repeat(opt.repeat).delay(opt.delay).easing(TWEEN.Easing[opt.easing.split(".")[0]][opt.easing.split(".")[1]]);

            tween.id = tid;
            tween.start();

            
            animate();
        })();
    }
    return tween;
}
/*
 * @param tween
 * @result void(0)
 */
function destroyTween(tween, msg) {
    tween.stop();
}

var AnimationFrame = {
    registFrame: registFrame,
    destroyFrame: destroyFrame,
    registTween: registTween,
    destroyTween: destroyTween
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 属性工厂，ie下面用VBS提供支持
 * 来给整个引擎提供心跳包的触发机制
 */
//定义封装好的兼容大部分浏览器的defineProperties 的 属性工厂
var unwatchOne = {
    "$skipArray": 0,
    "$watch": 1,
    "$fire": 2, //主要是get set 显性设置的 触发
    "$model": 3,
    "$accessor": 4,
    "$owner": 5,
    //"path"       : 6, //这个应该是唯一一个不用watch的不带$的成员了吧，因为地图等的path是在太大
    "$parent": 7 //用于建立数据的关系链
};

function Observe(scope, model, watchMore) {

    var stopRepeatAssign = true;

    var skipArray = scope.$skipArray,
        //要忽略监控的属性名列表
    pmodel = {},
        //要返回的对象
    accessores = {},
        //内部用于转换的对象
    VBPublics = _$1.keys(unwatchOne); //用于IE6-8

    model = model || {}; //这是pmodel上的$model属性
    watchMore = watchMore || {}; //以$开头但要强制监听的属性
    skipArray = _$1.isArray(skipArray) ? skipArray.concat(VBPublics) : VBPublics;

    function loop(name, val) {
        if (!unwatchOne[name] || unwatchOne[name] && name.charAt(0) !== "$") {
            model[name] = val;
        }
        var valueType = typeof val === "undefined" ? "undefined" : _typeof(val);
        if (valueType === "function") {
            if (!unwatchOne[name]) {
                VBPublics.push(name); //函数无需要转换
            }
        } else {
            if (_$1.indexOf(skipArray, name) !== -1 || name.charAt(0) === "$" && !watchMore[name]) {
                return VBPublics.push(name);
            }
            var accessor = function accessor(neo) {
                //创建监控属性或数组，自变量，由用户触发其改变
                var value = accessor.value,
                    preValue = value,
                    complexValue;

                if (arguments.length) {
                    //写操作
                    //set 的 值的 类型
                    var neoType = typeof neo === "undefined" ? "undefined" : _typeof(neo);

                    if (stopRepeatAssign) {
                        return; //阻止重复赋值
                    }
                    if (value !== neo) {
                        if (neo && neoType === "object" && !(neo instanceof Array) && !neo.addColorStop // neo instanceof CanvasGradient
                        ) {
                                value = neo.$model ? neo : Observe(neo, neo);
                                complexValue = value.$model;
                            } else {
                            //如果是其他数据类型
                            //if( neoType === "array" ){
                            //    value = _.clone(neo);
                            //} else {
                            value = neo;
                            //}
                        }
                        accessor.value = value;
                        model[name] = complexValue ? complexValue : value; //更新$model中的值
                        if (!complexValue) {
                            pmodel.$fire && pmodel.$fire(name, value, preValue);
                        }
                        if (valueType != neoType) {
                            //如果set的值类型已经改变，
                            //那么也要把对应的valueType修改为对应的neoType
                            valueType = neoType;
                        }
                        var hasWatchModel = pmodel;
                        //所有的赋值都要触发watch的监听事件
                        if (!pmodel.$watch) {
                            while (hasWatchModel.$parent) {
                                hasWatchModel = hasWatchModel.$parent;
                            }
                        }
                        if (hasWatchModel.$watch) {
                            hasWatchModel.$watch.call(hasWatchModel, name, value, preValue);
                        }
                    }
                } else {
                    //读操作
                    //读的时候，发现value是个obj，而且还没有defineProperty
                    //那么就临时defineProperty一次
                    if (value && valueType === "object" && !(value instanceof Array) && !value.$model && !value.addColorStop) {
                        //建立和父数据节点的关系
                        value.$parent = pmodel;
                        value = Observe(value, value);

                        //accessor.value 重新复制为defineProperty过后的对象
                        accessor.value = value;
                    }
                    return value;
                }
            };
            accessor.value = val;

            accessores[name] = {
                set: accessor,
                get: accessor,
                enumerable: true
            };
        }
    }

    for (var i in scope) {
        loop(i, scope[i]);
    }

    pmodel = defineProperties(pmodel, accessores, VBPublics); //生成一个空的ViewModel

    _$1.forEach(VBPublics, function (name) {
        if (scope[name]) {
            //先为函数等不被监控的属性赋值
            if (typeof scope[name] == "function") {
                pmodel[name] = function () {
                    scope[name].apply(this, arguments);
                };
            } else {
                pmodel[name] = scope[name];
            }
        }
    });

    pmodel.$model = model;
    pmodel.$accessor = accessores;

    pmodel.hasOwnProperty = function (name) {
        return name in pmodel.$model;
    };

    stopRepeatAssign = false;

    return pmodel;
}
var defineProperty$1 = Object.defineProperty;
//如果浏览器不支持ecma262v5的Object.defineProperties或者存在BUG，比如IE8
//标准浏览器使用__defineGetter__, __defineSetter__实现
try {
    defineProperty$1({}, "_", {
        value: "x"
    });
    var defineProperties = Object.defineProperties;
} catch (e) {
    if ("__defineGetter__" in Object) {
        defineProperty$1 = function defineProperty$$1(obj, prop, desc) {
            if ('value' in desc) {
                obj[prop] = desc.value;
            }
            if ('get' in desc) {
                obj.__defineGetter__(prop, desc.get);
            }
            if ('set' in desc) {
                obj.__defineSetter__(prop, desc.set);
            }
            return obj;
        };
        defineProperties = function defineProperties(obj, descs) {
            for (var prop in descs) {
                if (descs.hasOwnProperty(prop)) {
                    defineProperty$1(obj, prop, descs[prop]);
                }
            }
            return obj;
        };
    }
}
//IE6-8使用VBScript类的set get语句实现
if (!defineProperties && window.VBArray) {
    (function () {
        var VBMediator = function VBMediator(description, name, value) {
            var fn = description[name] && description[name].set;
            if (arguments.length === 3) {
                fn(value);
            } else {
                return fn();
            }
        };

        window.execScript(["Function parseVB(code)", "\tExecuteGlobal(code)", "End Function"].join("\n"), "VBScript");

        
        defineProperties = function defineProperties(publics, description, array) {
            publics = array.slice(0);
            publics.push("hasOwnProperty");
            var className = "VBClass" + setTimeout("1"),
                owner = {},
                buffer = [];
            buffer.push("Class " + className, "\tPrivate [__data__], [__proxy__]", "\tPublic Default Function [__const__](d, p)", "\t\tSet [__data__] = d: set [__proxy__] = p", "\t\tSet [__const__] = Me", //链式调用
            "\tEnd Function");
            _$1.forEach(publics, function (name) {
                //添加公共属性,如果此时不加以后就没机会了
                if (owner[name] !== true) {
                    owner[name] = true; //因为VBScript对象不能像JS那样随意增删属性
                    buffer.push("\tPublic [" + name + "]"); //你可以预先放到skipArray中
                }
            });
            for (var name in description) {
                owner[name] = true;
                buffer.push(
                //由于不知对方会传入什么,因此set, let都用上
                "\tPublic Property Let [" + name + "](val)", //setter
                "\t\tCall [__proxy__]([__data__], \"" + name + "\", val)", "\tEnd Property", "\tPublic Property Set [" + name + "](val)", //setter
                "\t\tCall [__proxy__]([__data__], \"" + name + "\", val)", "\tEnd Property", "\tPublic Property Get [" + name + "]", //getter
                "\tOn Error Resume Next", //必须优先使用set语句,否则它会误将数组当字符串返回
                "\t\tSet[" + name + "] = [__proxy__]([__data__],\"" + name + "\")", "\tIf Err.Number <> 0 Then", "\t\t[" + name + "] = [__proxy__]([__data__],\"" + name + "\")", "\tEnd If", "\tOn Error Goto 0", "\tEnd Property");
            }
            buffer.push("End Class"); //类定义完毕
            buffer.push("Function " + className + "Factory(a, b)", //创建实例并传入两个关键的参数
            "\tDim o", "\tSet o = (New " + className + ")(a, b)", "\tSet " + className + "Factory = o", "End Function");
            window.parseVB(buffer.join("\r\n")); //先创建一个VB类工厂
            return window[className + "Factory"](description, VBMediator); //得到其产品
        };
    })();
}

var RENDERER_TYPE = {
    UNKNOWN: 0,
    WEBGL: 1,
    CANVAS: 2
};

var DRAW_MODES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
};

var SHAPES = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3,
    RREC: 4
};



var CONTEXT_DEFAULT = {
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1,
    scaleOrigin: {
        x: 0,
        y: 0
    },
    rotation: 0,
    rotateOrigin: {
        x: 0,
        y: 0
    },
    visible: true,
    globalAlpha: 1

};
var SHAPE_CONTEXT_DEFAULT = {
    cursor: "default",

    fillAlpha: 1, //context2d里没有，自定义
    fillStyle: null, //"#000000",

    lineCap: null, //默认都是直角
    lineJoin: null, //这两个目前webgl里面没实现
    miterLimit: null, //miterLimit 属性设置或返回最大斜接长度,只有当 lineJoin 属性为 "miter" 时，miterLimit 才有效。

    lineAlpha: 1, //context2d里没有，自定义
    strokeStyle: null,
    lineType: "solid", //context2d里没有，自定义线条的type，默认为实线
    lineWidth: null
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3 DisplayList 的 现实对象基类
 */
var DisplayObject = function DisplayObject(opt) {
    DisplayObject.superclass.constructor.apply(this, arguments);

    //如果用户没有传入context设置，就默认为空的对象
    opt = Utils.checkOpt(opt);

    //相对父级元素的矩阵
    this._transform = null;

    //心跳次数
    this._heartBeatNum = 0;

    //元素对应的stage元素
    this.stage = null;

    //元素的父元素
    this.parent = null;

    this._eventEnabled = false; //是否响应事件交互,在添加了事件侦听后会自动设置为true

    this.dragEnabled = true; //"dragEnabled" in opt ? opt.dragEnabled : false;   //是否启用元素的拖拽

    this.xyToInt = "xyToInt" in opt ? opt.xyToInt : true; //是否对xy坐标统一int处理，默认为true，但是有的时候可以由外界用户手动指定是否需要计算为int，因为有的时候不计算比较好，比如，进度图表中，再sector的两端添加两个圆来做圆角的进度条的时候，圆circle不做int计算，才能和sector更好的衔接

    this.moveing = false; //如果元素在最轨道运动中的时候，最好把这个设置为true，这样能保证轨迹的丝搬顺滑，否则因为xyToInt的原因，会有跳跃

    //创建好context
    this._createContext(opt);

    this.id = Utils.createId(this.type || "displayObject");

    this.init.apply(this, arguments);

    //所有属性准备好了后，先要计算一次this._updateTransform()得到_tansform
    this._updateTransform();
};

Utils.creatClass(DisplayObject, EventDispatcher, {
    init: function init() {},
    _createContext: function _createContext(opt) {
        var self = this;
        //所有显示对象，都有一个类似canvas.context类似的 context属性
        //用来存取改显示对象所有和显示有关的属性，坐标，样式等。
        //该对象为Coer.Observe()工厂函数生成
        self.context = null;

        //提供给Coer.Observe() 来 给 self.context 设置 propertys
        //这里不能用_.extend， 因为要保证_contextATTRS的纯粹，只覆盖下面已有的属性
        var _contextATTRS = _$1.extend(_$1.clone(CONTEXT_DEFAULT), opt.context, true);

        //有些引擎内部设置context属性的时候是不用上报心跳的，比如做热点检测的时候
        self._notWatch = false;

        _contextATTRS.$owner = self;
        _contextATTRS.$watch = function (name, value, preValue) {

            //下面的这些属性变化，都会需要重新组织矩阵属性 _transform 
            var transFormProps = ["x", "y", "scaleX", "scaleY", "rotation", "scaleOrigin", "rotateOrigin, lineWidth"];

            if (_$1.indexOf(transFormProps, name) >= 0) {
                this.$owner._updateTransform();
            }

            if (this.$owner._notWatch) {
                return;
            }

            if (this.$owner.$watch) {
                this.$owner.$watch(name, value, preValue);
            }

            this.$owner.heartBeat({
                convertType: "context",
                shape: this.$owner,
                name: name,
                value: value,
                preValue: preValue
            });
        };

        //执行init之前，应该就根据参数，把context组织好线
        self.context = Observe(_contextATTRS);
    },
    /* @myself 是否生成自己的镜像 
     * 克隆又两种，一种是镜像，另外一种是绝对意义上面的新个体
     * 默认为绝对意义上面的新个体，新对象id不能相同
     * 镜像基本上是框架内部在实现  镜像的id相同 主要用来把自己画到另外的stage里面，比如
     * mouseover和mouseout的时候调用*/
    clone: function clone(myself) {
        var conf = {
            id: this.id,
            context: _$1.clone(this.context.$model)
        };

        var newObj;
        if (this.type == 'text') {
            newObj = new this.constructor(this.text, conf);
        } else {
            newObj = new this.constructor(conf);
        }

        newObj.id = conf.id;

        if (this.children) {
            newObj.children = this.children;
        }

        if (!myself) {
            newObj.id = Utils.createId(newObj.type);
        }
        return newObj;
    },
    heartBeat: function heartBeat(opt) {
        //stage存在，才说self代表的display已经被添加到了displayList中，绘图引擎需要知道其改变后
        //的属性，所以，通知到stage.displayAttrHasChange
        var stage = this.getStage();
        if (stage) {
            this._heartBeatNum++;
            stage.heartBeat && stage.heartBeat(opt);
        }
    },
    getCurrentWidth: function getCurrentWidth() {
        return Math.abs(this.context.width * this.context.scaleX);
    },
    getCurrentHeight: function getCurrentHeight() {
        return Math.abs(this.context.height * this.context.scaleY);
    },
    getStage: function getStage() {
        if (this.stage) {
            return this.stage;
        }
        var p = this;
        if (p.type != "stage") {
            while (p.parent) {
                p = p.parent;
                if (p.type == "stage") {
                    break;
                }
            }
            if (p.type !== "stage") {
                //如果得到的顶点display 的type不是Stage,也就是说不是stage元素
                //那么只能说明这个p所代表的顶端display 还没有添加到displayList中，也就是没有没添加到
                //stage舞台的childen队列中，不在引擎渲染范围内
                return false;
            }
        }
        //一直回溯到顶层object， 即是stage， stage的parent为null
        this.stage = p;
        return p;
    },
    localToGlobal: function localToGlobal(point, container) {
        !point && (point = new Point(0, 0));
        var cm = this.getConcatenatedMatrix(container);

        if (cm == null) return Point(0, 0);
        var m = new Matrix(1, 0, 0, 1, point.x, point.y);
        m.concat(cm);
        return new Point(m.tx, m.ty); //{x:m.tx, y:m.ty};
    },
    globalToLocal: function globalToLocal(point, container) {
        !point && (point = new Point(0, 0));

        if (this.type == "stage") {
            return point;
        }
        var cm = this.getConcatenatedMatrix(container);

        if (cm == null) return new Point(0, 0); //{x:0, y:0};
        cm.invert();
        var m = new Matrix(1, 0, 0, 1, point.x, point.y);
        m.concat(cm);
        return new Point(m.tx, m.ty); //{x:m.tx, y:m.ty};
    },
    localToTarget: function localToTarget(point, target) {
        var p = localToGlobal(point);
        return target.globalToLocal(p);
    },
    getConcatenatedMatrix: function getConcatenatedMatrix(container) {
        var cm = new Matrix();
        for (var o = this; o != null; o = o.parent) {
            cm.concat(o._transform);
            if (!o.parent || container && o.parent && o.parent == container || o.parent && o.parent.type == "stage") {
                //if( o.type == "stage" || (o.parent && container && o.parent.type == container.type ) ) {
                return cm; //break;
            }
        }
        return cm;
    },
    /*
     *设置元素的是否响应事件检测
     *@bool  Boolean 类型
     */
    setEventEnable: function setEventEnable(bool) {
        if (_$1.isBoolean(bool)) {
            this._eventEnabled = bool;
            return true;
        }
        return false;
    },
    /*
     *查询自己在parent的队列中的位置
     */
    getIndex: function getIndex() {
        if (!this.parent) {
            return;
        }
        return _$1.indexOf(this.parent.children, this);
    },
    /*
     *元素在z轴方向向下移动
     *@num 移动的层级
     */
    toBack: function toBack(num) {
        if (!this.parent) {
            return;
        }
        var fromIndex = this.getIndex();
        var toIndex = 0;

        if (_$1.isNumber(num)) {
            if (num == 0) {
                //原地不动
                return;
            }
            toIndex = fromIndex - num;
        }
        var me = this.parent.children.splice(fromIndex, 1)[0];
        if (toIndex < 0) {
            toIndex = 0;
        }
        this.parent.addChildAt(me, toIndex);
    },
    /*
     *元素在z轴方向向上移动
     *@num 移动的层数量 默认到顶端
     */
    toFront: function toFront(num) {
        if (!this.parent) {
            return;
        }
        var fromIndex = this.getIndex();
        var pcl = this.parent.children.length;
        var toIndex = pcl;

        if (_$1.isNumber(num)) {
            if (num == 0) {
                //原地不动
                return;
            }
            toIndex = fromIndex + num + 1;
        }
        var me = this.parent.children.splice(fromIndex, 1)[0];
        if (toIndex > pcl) {
            toIndex = pcl;
        }
        this.parent.addChildAt(me, toIndex - 1);
    },
    _updateTransform: function _updateTransform() {
        var _transform = new Matrix();
        _transform.identity();
        var context = this.context;
        //是否需要Transform
        if (context.scaleX !== 1 || context.scaleY !== 1) {
            //如果有缩放
            //缩放的原点坐标
            var origin = new Point(context.scaleOrigin);
            if (origin.x || origin.y) {
                _transform.translate(-origin.x, -origin.y);
            }
            _transform.scale(context.scaleX, context.scaleY);
            if (origin.x || origin.y) {
                _transform.translate(origin.x, origin.y);
            }
        }

        var rotation = context.rotation;
        if (rotation) {
            //如果有旋转
            //旋转的原点坐标
            var origin = new Point(context.rotateOrigin);
            if (origin.x || origin.y) {
                _transform.translate(-origin.x, -origin.y);
            }
            _transform.rotate(rotation % 360 * Math.PI / 180);
            if (origin.x || origin.y) {
                _transform.translate(origin.x, origin.y);
            }
        }

        //如果有位移
        var x, y;
        if (this.xyToInt && !this.moveing) {
            //当这个元素在做轨迹运动的时候，比如drag，animation如果实时的调整这个x ， y
            //那么该元素的轨迹会有跳跃的情况发生。所以加个条件过滤，
            var x = parseInt(context.x);
            var y = parseInt(context.y);

            if (parseInt(context.lineWidth, 10) % 2 == 1 && context.strokeStyle) {
                x += 0.5;
                y += 0.5;
            }
        } else {
            x = context.x;
            y = context.y;
        }

        if (x != 0 || y != 0) {
            _transform.translate(x, y);
        }
        this._transform = _transform;
        return _transform;
    },
    //显示对象的选取检测处理函数
    getChildInPoint: function getChildInPoint(point) {

        var result = false; //检测的结果

        //第一步，吧glob的point转换到对应的obj的层级内的坐标系统
        if (this.type != "stage" && this.parent && this.parent.type != "stage") {
            point = this.parent.globalToLocal(point);
        }

        var x = point.x;
        var y = point.y;

        //对鼠标的坐标也做相同的变换
        if (this._transform) {
            var inverseMatrix = this._transform.clone().invert();
            var originPos = [x, y];
            originPos = inverseMatrix.mulVector(originPos);

            x = originPos[0];
            y = originPos[1];
        }

        if (this.graphics) {
            result = this.graphics.containsPoint({ x: x, y: y });
        }

        return result;
    },
    /*
    * animate
    * @param toContent 要动画变形到的属性集合
    * @param options tween 动画参数
    */
    animate: function animate(toContent, options) {
        var to = toContent;
        var from = {};
        for (var p in to) {
            from[p] = this.context[p];
        }
        !options && (options = {});
        options.from = from;
        options.to = to;

        var self = this;
        var upFun = function upFun() {};
        if (options.onUpdate) {
            upFun = options.onUpdate;
        }
        var tween;
        options.onUpdate = function () {
            //如果context不存在说明该obj已经被destroy了，那么要把他的tween给destroy
            if (!self.context && tween) {
                AnimationFrame.destroyTween(tween);
                tween = null;
                return;
            }
            for (var p in this) {
                self.context[p] = this[p];
            }
            upFun.apply(self, [this]);
        };
        var compFun = function compFun() {};
        if (options.onComplete) {
            compFun = options.onComplete;
        }
        options.onComplete = function (opt) {
            compFun.apply(self, arguments);
        };
        tween = AnimationFrame.registTween(options);
        return tween;
    },

    //渲染相关部分，迁移到renderers中去
    _render: function _render(ctx) {
        if (!this.context.visible || this.context.globalAlpha <= 0) {
            return;
        }
        ctx.save();

        var transForm = this._transform;
        if (!transForm) {
            transForm = this._updateTransform();
        }
        //运用矩阵开始变形
        ctx.transform.apply(ctx, transForm.toArray());

        //设置样式，文本有自己的设置样式方式
        if (this.type != "text") {
            var style = this.context.$model;
            for (var p in style) {
                if (p != "textBaseline" && p in ctx) {
                    if (style[p] || _$1.isNumber(style[p])) {
                        if (p == "globalAlpha") {
                            //透明度要从父节点继承
                            ctx[p] *= style[p];
                        } else {
                            ctx[p] = style[p];
                        }
                    }
                }
            }
        }

        this.render(ctx);
        ctx.restore();
    },
    render: function render(ctx) {
        //基类不提供render的具体实现，由后续具体的派生类各自实现
    },
    //从树中删除
    remove: function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent = null;
        }
    },
    //元素的自我销毁
    destroy: function destroy() {
        this.remove();
        this.fire("destroy");
        //把自己从父节点中删除了后做自我清除，释放内存
        this.context = null;
        delete this.context;
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3的DisplayList 中的容器类
 */
var DisplayObjectContainer = function DisplayObjectContainer(opt) {
    var self = this;
    self.children = [];
    self.mouseChildren = [];
    DisplayObjectContainer.superclass.constructor.apply(this, arguments);

    //所有的容器默认支持event 检测，因为 可能有里面的shape是eventEnable是true的
    //如果用户有强制的需求让容器下的所有元素都 不可检测，可以调用
    //DisplayObjectContainer的 setEventEnable() 方法
    self._eventEnabled = true;
};

Utils.creatClass(DisplayObjectContainer, DisplayObject, {
    addChild: function addChild(child) {
        if (!child) {
            return;
        }
        if (this.getChildIndex(child) != -1) {
            child.parent = this;
            return child;
        }
        //如果他在别的子元素中，那么就从别人那里删除了
        if (child.parent) {
            child.parent.removeChild(child);
        }
        this.children.push(child);
        child.parent = this;
        if (this.heartBeat) {
            this.heartBeat({
                convertType: "children",
                target: child,
                src: this
            });
        }

        if (this._afterAddChild) {
            this._afterAddChild(child);
        }

        return child;
    },
    addChildAt: function addChildAt(child, index) {
        if (this.getChildIndex(child) != -1) {
            child.parent = this;
            return child;
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        this.children.splice(index, 0, child);
        child.parent = this;

        //上报children心跳
        if (this.heartBeat) {
            this.heartBeat({
                convertType: "children",
                target: child,
                src: this
            });
        }

        if (this._afterAddChild) {
            this._afterAddChild(child, index);
        }

        return child;
    },
    removeChild: function removeChild(child) {
        return this.removeChildAt(_$1.indexOf(this.children, child));
    },
    removeChildAt: function removeChildAt(index) {
        if (index < 0 || index > this.children.length - 1) {
            return false;
        }
        var child = this.children[index];
        if (child != null) {
            child.parent = null;
        }
        this.children.splice(index, 1);

        if (this.heartBeat) {
            this.heartBeat({
                convertType: "children",
                target: child,
                src: this
            });
        }

        if (this._afterDelChild) {
            this._afterDelChild(child, index);
        }

        return child;
    },
    removeChildById: function removeChildById(id) {
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i].id == id) {
                return this.removeChildAt(i);
            }
        }
        return false;
    },
    removeAllChildren: function removeAllChildren() {
        while (this.children.length > 0) {
            this.removeChildAt(0);
        }
    },
    //集合类的自我销毁
    destroy: function destroy() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent = null;
        }
        this.fire("destroy");
        //依次销毁所有子元素
        for (var i = 0, l = this.children.length; i < l; i++) {
            this.getChildAt(i).destroy();
            i--;
            l--;
        }
    },
    /*
     *@id 元素的id
     *@boolen 是否深度查询，默认就在第一层子元素中查询
     **/
    getChildById: function getChildById(id, boolen) {
        if (!boolen) {
            for (var i = 0, len = this.children.length; i < len; i++) {
                if (this.children[i].id == id) {
                    return this.children[i];
                }
            }
        } else {
            //深度查询
            //TODO:暂时未实现
            return null;
        }
        return null;
    },
    getChildAt: function getChildAt(index) {
        if (index < 0 || index > this.children.length - 1) return null;
        return this.children[index];
    },
    getChildIndex: function getChildIndex(child) {
        return _$1.indexOf(this.children, child);
    },
    setChildIndex: function setChildIndex(child, index) {
        if (child.parent != this) return;
        var oldIndex = _$1.indexOf(this.children, child);
        if (index == oldIndex) return;
        this.children.splice(oldIndex, 1);
        this.children.splice(index, 0, child);
    },
    getNumChildren: function getNumChildren() {
        return this.children.length;
    },
    //获取x,y点上的所有object  num 需要返回的obj数量
    getObjectsUnderPoint: function getObjectsUnderPoint(point, num) {
        var result = [];

        for (var i = this.children.length - 1; i >= 0; i--) {
            var child = this.children[i];

            if (child == null || !child._eventEnabled && !child.dragEnabled || !child.context.visible) {
                continue;
            }
            if (child instanceof DisplayObjectContainer) {
                //是集合
                if (child.mouseChildren && child.getNumChildren() > 0) {
                    var objs = child.getObjectsUnderPoint(point);
                    if (objs.length > 0) {
                        result = result.concat(objs);
                    }
                }
            } else {
                //非集合，可以开始做getChildInPoint了
                if (child.getChildInPoint(point)) {
                    result.push(child);
                    if (num != undefined && !isNaN(num)) {
                        if (result.length == num) {
                            return result;
                        }
                    }
                }
            }
        }
        return result;
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * stage 类， 再as3中，stage则代表整个舞台。是唯一的根节点
 * 但是再canvax中，因为分层设计的需要。stage 舞台 同样代表一个canvas元素，但是不是再整个引擎设计
 * 里面， 不是唯一的根节点。而是会交由canvax类来统一管理其层级
 */
var Stage = function Stage() {
    var self = this;
    self.type = "stage";
    self.canvas = null;
    self.ctx = null; //渲染的时候由renderer决定,这里不做初始值
    //stage正在渲染中
    self.stageRending = false;
    self._isReady = false;
    Stage.superclass.constructor.apply(this, arguments);
};
Utils.creatClass(Stage, DisplayObjectContainer, {
    init: function init() {},
    //由canvax的afterAddChild 回调
    initStage: function initStage(canvas, width, height) {
        var self = this;
        self.canvas = canvas;
        self.context.width = width;
        self.context.height = height;
        self.context.scaleX = Utils._devicePixelRatio;
        self.context.scaleY = Utils._devicePixelRatio;
        self._isReady = true;
    },
    heartBeat: function heartBeat(opt) {
        //shape , name , value , preValue 
        //displayList中某个属性改变了
        if (!this._isReady) {
            //在stage还没初始化完毕的情况下，无需做任何处理
            return;
        }
        opt || (opt = {}); //如果opt为空，说明就是无条件刷新
        opt.stage = this;

        //TODO临时先这么处理
        this.parent && this.parent.heartBeat(opt);
    }
});

var SystemRenderer = function () {
    function SystemRenderer() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDERER_TYPE.UNKNOWN;
        var app = arguments[1];
        var options = arguments[2];
        classCallCheck(this, SystemRenderer);

        this.type = type; //2canvas,1webgl
        this.app = app;

        // prepare options
        if (options) {
            for (var i in settings.RENDER_OPTIONS) {
                if (typeof options[i] === 'undefined') {
                    options[i] = settings.RENDER_OPTIONS[i];
                }
            }
        } else {
            options = settings.RENDER_OPTIONS;
        }

        this.options = options;

        this.requestAid = null;

        this._heartBeat = false; //心跳，默认为false，即false的时候引擎处于静默状态 true则启动渲染

        this._preRenderTime = 0;
    }

    //如果引擎处于静默状态的话，就会启动


    createClass(SystemRenderer, [{
        key: 'startEnter',
        value: function startEnter() {
            var self = this;
            if (!self.requestAid) {
                self.requestAid = AnimationFrame.registFrame({
                    id: "enterFrame", //同时肯定只有一个enterFrame的task
                    task: function task() {
                        self.enterFrame.apply(self);
                    }
                });
            }
        }
    }, {
        key: 'enterFrame',
        value: function enterFrame() {
            var self = this;
            //不管怎么样，enterFrame执行了就要把
            //requestAid null 掉
            self.requestAid = null;
            Utils.now = new Date().getTime();
            if (self._heartBeat) {

                var _begin = new Date().getTime();
                self.render(this.app);
                var _end = new Date().getTime();
                console.log(_end - _begin);

                self._heartBeat = false;
                //渲染完了，打上最新时间挫
                self._preRenderTime = new Date().getTime();
            }
        }
    }, {
        key: '_convertCanvax',
        value: function _convertCanvax(opt) {
            var me = this;
            _$1.each(me.app.children, function (stage) {
                stage.context[opt.name] = opt.value;
            });
        }
    }, {
        key: 'heartBeat',
        value: function heartBeat(opt) {
            //displayList中某个属性改变了
            var self = this;
            if (opt) {
                //心跳包有两种，一种是某元素的可视属性改变了。一种是children有变动
                //分别对应convertType  为 context  and children
                if (opt.convertType == "context") {
                    var stage = opt.stage;
                    var shape = opt.shape;
                    var name = opt.name;
                    var value = opt.value;
                    var preValue = opt.preValue;

                    if (shape.type == "canvax") {
                        self._convertCanvax(opt);
                    } else {
                        if (!self.app.convertStages[stage.id]) {
                            self.app.convertStages[stage.id] = {
                                stage: stage,
                                convertShapes: {}
                            };
                        }
                        if (shape) {
                            if (!self.app.convertStages[stage.id].convertShapes[shape.id]) {
                                self.app.convertStages[stage.id].convertShapes[shape.id] = {
                                    shape: shape,
                                    convertType: opt.convertType
                                };
                            } else {
                                //如果已经上报了该 shape 的心跳。
                                return;
                            }
                        }
                    }
                }

                if (opt.convertType == "children") {
                    //元素结构变化，比如addchild removeChild等
                    var target = opt.target;
                    var stage = opt.src.getStage();
                    if (stage || target.type == "stage") {
                        //如果操作的目标元素是Stage
                        stage = stage || target;
                        if (!self.app.convertStages[stage.id]) {
                            self.app.convertStages[stage.id] = {
                                stage: stage,
                                convertShapes: {}
                            };
                        }
                    }
                }

                if (!opt.convertType) {
                    //无条件要求刷新
                    var stage = opt.stage;
                    if (!self.app.convertStages[stage.id]) {
                        self.app.convertStages[stage.id] = {
                            stage: stage,
                            convertShapes: {}
                        };
                    }
                }
            } else {
                //无条件要求全部刷新，一般用在resize等。
                _$1.each(self.app.children, function (stage, i) {
                    self.app.convertStages[stage.id] = {
                        stage: stage,
                        convertShapes: {}
                    };
                });
            }
            if (!self._heartBeat) {
                //如果发现引擎在静默状态，那么就唤醒引擎
                self._heartBeat = true;
                self.startEnter();
            } else {
                //否则智慧继续确认心跳
                self._heartBeat = true;
            }
        }
    }]);
    return SystemRenderer;
}();

var CanvasGraphicsRenderer = function () {
    function CanvasGraphicsRenderer(renderer) {
        classCallCheck(this, CanvasGraphicsRenderer);

        this.renderer = renderer;
    }

    /**
    * @param displayObject
    * @stage 也可以displayObject.getStage()获取。
    */


    createClass(CanvasGraphicsRenderer, [{
        key: 'render',
        value: function render(displayObject, stage) {

            var graphics = displayObject.graphics;
            var renderer = this.renderer;
            var ctx = stage.ctx;
            var context = displayObject.context;

            if (displayObject.parent) {
                context.globalAlpha *= displayObject.parent.context.globalAlpha;
            }

            for (var i = 0; i < graphics.graphicsData.length; i++) {
                var data = graphics.graphicsData[i];
                var shape = data.shape;

                var fillStyle = data.fillStyle;
                var strokeStyle = data.strokeStyle;

                ctx.lineWidth = data.lineWidth;

                if (data.type === SHAPES.POLY) {
                    ctx.beginPath();

                    this.renderPolygon(shape.points, shape.closed, ctx);

                    if (data.hasFill()) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    if (data.hasLine()) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.stroke();
                    }
                } else if (data.type === SHAPES.RECT) {
                    if (data.hasFill()) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                    }
                    if (data.hasLine()) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                    }
                } else if (data.type === SHAPES.CIRC) {

                    // TODO - need to be Undefined!
                    ctx.beginPath();
                    ctx.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                    ctx.closePath();

                    if (data.hasFill()) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    if (data.hasLine()) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.stroke();
                    }
                } else if (data.type === SHAPES.ELIP) {
                    var w = shape.width * 2;
                    var h = shape.height * 2;

                    var x = shape.x - w / 2;
                    var y = shape.y - h / 2;

                    ctx.beginPath();

                    var kappa = 0.5522848;
                    var ox = w / 2 * kappa; // control point offset horizontal
                    var oy = h / 2 * kappa; // control point offset vertical
                    var xe = x + w; // x-end
                    var ye = y + h; // y-end
                    var xm = x + w / 2; // x-middle
                    var ym = y + h / 2; // y-middle

                    ctx.moveTo(x, ym);
                    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

                    ctx.closePath();

                    if (data.hasFill()) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    if (data.hasLine()) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.stroke();
                    }
                }
            }
        }
    }, {
        key: 'renderPolygon',
        value: function renderPolygon(points, close, ctx) {
            ctx.moveTo(points[0], points[1]);

            for (var j = 1; j < points.length / 2; ++j) {
                ctx.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            if (close) {
                ctx.closePath();
            }
        }
    }]);
    return CanvasGraphicsRenderer;
}();

var CanvasRenderer = function (_SystemRenderer) {
    inherits(CanvasRenderer, _SystemRenderer);

    function CanvasRenderer(app) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        classCallCheck(this, CanvasRenderer);

        var _this = possibleConstructorReturn(this, (CanvasRenderer.__proto__ || Object.getPrototypeOf(CanvasRenderer)).call(this, RENDERER_TYPE.CANVAS, app, options));

        _this.CGR = new CanvasGraphicsRenderer(_this);
        return _this;
    }

    createClass(CanvasRenderer, [{
        key: 'render',
        value: function render(app) {
            var me = this;
            me.app = app;
            _$1.each(_$1.values(app.convertStages), function (convertStage) {
                me.renderStage(convertStage.stage);
            });
            app.convertStages = {};
        }
    }, {
        key: 'renderStage',
        value: function renderStage(stage) {
            if (!stage.ctx) {
                stage.ctx = stage.canvas.getContext("2d");
            }
            stage.stageRending = true;
            this._clear(stage);
            this._render(stage);
            stage.stageRending = false;
        }
    }, {
        key: '_render',
        value: function _render(stage, displayObject) {
            if (!displayObject) {
                displayObject = stage;
            }

            if (!displayObject.context.visible || displayObject.context.globalAlpha <= 0) {
                return;
            }

            var ctx = stage.ctx;

            ctx.save();

            var transForm = displayObject._transform;
            if (!transForm) {
                transForm = displayObject._updateTransform();
            }
            //运用矩阵开始变形
            ctx.transform.apply(ctx, transForm.toArray());

            if (displayObject.graphics) {
                this.CGR.render(displayObject, stage);
            }

            if (displayObject.children) {
                for (var i = 0, len = displayObject.children.length; i < len; i++) {
                    this._render(stage, displayObject.children[i]);
                }
            }

            ctx.restore();
        }
    }, {
        key: '_clear',
        value: function _clear(stage) {
            //TODO:这里有点 奇怪， 之前的版本clearRect的时候，不需要 *RESOLUTION（分辨率）
            stage.ctx.clearRect(0, 0, this.app.width * settings.RESOLUTION, this.app.height * settings.RESOLUTION);
        }
    }]);
    return CanvasRenderer;
}(SystemRenderer);

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 */
var Point$2 = function () {
  /**
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  function Point() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    classCallCheck(this, Point);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;
  }

  /**
   * Creates a clone of this point
   *
   * @return {PIXI.Point} a copy of the point
   */


  createClass(Point, [{
    key: "clone",
    value: function clone() {
      return new Point(this.x, this.y);
    }

    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.Point} p - The point to copy.
     */

  }, {
    key: "copy",
    value: function copy(p) {
      this.set(p.x, p.y);
    }

    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.Point} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */

  }, {
    key: "equals",
    value: function equals(p) {
      return p.x === this.x && p.y === this.y;
    }

    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */

  }, {
    key: "set",
    value: function set$$1(x, y) {
      this.x = x || 0;
      this.y = y || (y !== 0 ? this.x : 0);
    }
  }]);
  return Point;
}();

var arcToSegmentsCache = {};
var segmentToBezierCache = {};
var boundsOfCurveCache = {};
var _join = Array.prototype.join;

/* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
 * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
 * http://mozilla.org/MPL/2.0/
 */
function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
  var argsString = _join.call(arguments);
  if (arcToSegmentsCache[argsString]) {
    return arcToSegmentsCache[argsString];
  }

  var PI = Math.PI,
      th = rotateX * PI / 180,
      sinTh = Math.sin(th),
      cosTh = Math.cos(th),
      fromX = 0,
      fromY = 0;

  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
      py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
      rx2 = rx * rx,
      ry2 = ry * ry,
      py2 = py * py,
      px2 = px * px,
      pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
      root = 0;

  if (pl < 0) {
    var s = Math.sqrt(1 - pl / (rx2 * ry2));
    rx *= s;
    ry *= s;
  } else {
    root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));
  }

  var cx = root * rx * py / ry,
      cy = -root * ry * px / rx,
      cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
      cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
      mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
      dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

  if (sweep === 0 && dtheta > 0) {
    dtheta -= 2 * PI;
  } else if (sweep === 1 && dtheta < 0) {
    dtheta += 2 * PI;
  }

  // Convert into cubic bezier segments <= 90deg
  var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
      result = [],
      mDelta = dtheta / segments,
      mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
      th3 = mTheta + mDelta;

  for (var i = 0; i < segments; i++) {
    result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
    fromX = result[i][4];
    fromY = result[i][5];
    mTheta = th3;
    th3 += mDelta;
  }
  arcToSegmentsCache[argsString] = result;
  return result;
}

function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
  var argsString2 = _join.call(arguments);
  if (segmentToBezierCache[argsString2]) {
    return segmentToBezierCache[argsString2];
  }

  var costh2 = Math.cos(th2),
      sinth2 = Math.sin(th2),
      costh3 = Math.cos(th3),
      sinth3 = Math.sin(th3),
      toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
      toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
      cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2),
      cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2),
      cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3),
      cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);

  segmentToBezierCache[argsString2] = [cp1X, cp1Y, cp2X, cp2Y, toX, toY];
  return segmentToBezierCache[argsString2];
}

/*
 * Private
 */
function calcVectorAngle(ux, uy, vx, vy) {
  var ta = Math.atan2(uy, ux),
      tb = Math.atan2(vy, vx);
  if (tb >= ta) {
    return tb - ta;
  } else {
    return 2 * Math.PI - (ta - tb);
  }
}

/**
 * Draws arc
 * @param {graphics} graphics
 * @param {Number} fx
 * @param {Number} fy
 * @param {Array} coords
 */
var drawArc = function drawArc(graphics, fx, fy, coords) {
  var rx = coords[0],
      ry = coords[1],
      rot = coords[2],
      large = coords[3],
      sweep = coords[4],
      tx = coords[5],
      ty = coords[6],
      segs = [[], [], [], []],
      segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

  for (var i = 0, len = segsNorm.length; i < len; i++) {
    segs[i][0] = segsNorm[i][0] + fx;
    segs[i][1] = segsNorm[i][1] + fy;
    segs[i][2] = segsNorm[i][2] + fx;
    segs[i][3] = segsNorm[i][3] + fy;
    segs[i][4] = segsNorm[i][4] + fx;
    segs[i][5] = segsNorm[i][5] + fy;
    graphics.bezierCurveTo.apply(graphics, segs[i]);
  }
};

/**
 * Calculate bounding box of a elliptic-arc
 * @param {Number} fx start point of arc
 * @param {Number} fy
 * @param {Number} rx horizontal radius
 * @param {Number} ry vertical radius
 * @param {Number} rot angle of horizontal axe
 * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
 * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
 * @param {Number} tx end point of arc
 * @param {Number} ty
 */
var getBoundsOfArc = function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

  var fromX = 0,
      fromY = 0,
      bound,
      bounds = [],
      segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

  for (var i = 0, len = segs.length; i < len; i++) {
    bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
    bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
    bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
    fromX = segs[i][4];
    fromY = segs[i][5];
  }
  return bounds;
};

/**
 * Calculate bounding box of a beziercurve
 * @param {Number} x0 starting point
 * @param {Number} y0
 * @param {Number} x1 first control point
 * @param {Number} y1
 * @param {Number} x2 secondo control point
 * @param {Number} y2
 * @param {Number} x3 end of beizer
 * @param {Number} y3
 */
// taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
  var argsString = _join.call(arguments);
  if (boundsOfCurveCache[argsString]) {
    return boundsOfCurveCache[argsString];
  }

  var sqrt = Math.sqrt,
      min = Math.min,
      max = Math.max,
      abs = Math.abs,
      tvalues = [],
      bounds = [[], []],
      a,
      b,
      c,
      t,
      t1,
      t2,
      b2ac,
      sqrtb2ac;

  b = 6 * x0 - 12 * x1 + 6 * x2;
  a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
  c = 3 * x1 - 3 * x0;

  for (var i = 0; i < 2; ++i) {
    if (i > 0) {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (abs(a) < 1e-12) {
      if (abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (0 < t && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    b2ac = b * b - 4 * c * a;
    if (b2ac < 0) {
      continue;
    }
    sqrtb2ac = sqrt(b2ac);
    t1 = (-b + sqrtb2ac) / (2 * a);
    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }
    t2 = (-b - sqrtb2ac) / (2 * a);
    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var x,
      y,
      j = tvalues.length,
      jlen = j,
      mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[0][j] = x;

    y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    bounds[1][j] = y;
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  var result = [{
    x: min.apply(null, bounds[0]),
    y: min.apply(null, bounds[1])
  }, {
    x: max.apply(null, bounds[0]),
    y: max.apply(null, bounds[1])
  }];
  boundsOfCurveCache[argsString] = result;
  return result;
}

var Arc = {
  drawArc: drawArc,
  getBoundsOfCurve: getBoundsOfCurve,
  getBoundsOfArc: getBoundsOfArc
};

/**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 */

var Rectangle = function () {
    /**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
     * @param {number} [width=0] - The overall width of this rectangle
     * @param {number} [height=0] - The overall height of this rectangle
     */
    function Rectangle() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        classCallCheck(this, Rectangle);

        /**
         * @member {number}
         * @default 0
         */
        this.x = x;

        /**
         * @member {number}
         * @default 0
         */
        this.y = y;

        /**
         * @member {number}
         * @default 0
         */
        this.width = width;

        /**
         * @member {number}
         * @default 0
         */
        this.height = height;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */
        this.type = SHAPES.RECT;
    }

    /**
     * returns the left edge of the rectangle
     *
     * @member {number}
     */


    createClass(Rectangle, [{
        key: 'clone',


        /**
         * Creates a clone of this Rectangle
         *
         * @return {PIXI.Rectangle} a copy of the rectangle
         */
        value: function clone() {
            return new Rectangle(this.x, this.y, this.width, this.height);
        }

        /**
         * Copies another rectangle to this one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to copy.
         * @return {PIXI.Rectangle} Returns itself.
         */

    }, {
        key: 'copy',
        value: function copy(rectangle) {
            this.x = rectangle.x;
            this.y = rectangle.y;
            this.width = rectangle.width;
            this.height = rectangle.height;

            return this;
        }

        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this Rectangle
         */

    }, {
        key: 'contains',
        value: function contains(x, y) {
            if (this.width <= 0 || this.height <= 0) {
                return false;
            }

            if (x >= this.x && x < this.x + this.width) {
                if (y >= this.y && y < this.y + this.height) {
                    return true;
                }
            }

            return false;
        }

        /**
         * Pads the rectangle making it grow in all directions.
         *
         * @param {number} paddingX - The horizontal padding amount.
         * @param {number} paddingY - The vertical padding amount.
         */

    }, {
        key: 'pad',
        value: function pad(paddingX, paddingY) {
            paddingX = paddingX || 0;
            paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);

            this.x -= paddingX;
            this.y -= paddingY;

            this.width += paddingX * 2;
            this.height += paddingY * 2;
        }

        /**
         * Fits this rectangle around the passed one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
         */

    }, {
        key: 'fit',
        value: function fit(rectangle) {
            if (this.x < rectangle.x) {
                this.width += this.x;
                if (this.width < 0) {
                    this.width = 0;
                }

                this.x = rectangle.x;
            }

            if (this.y < rectangle.y) {
                this.height += this.y;
                if (this.height < 0) {
                    this.height = 0;
                }
                this.y = rectangle.y;
            }

            if (this.x + this.width > rectangle.x + rectangle.width) {
                this.width = rectangle.width - this.x;
                if (this.width < 0) {
                    this.width = 0;
                }
            }

            if (this.y + this.height > rectangle.y + rectangle.height) {
                this.height = rectangle.height - this.y;
                if (this.height < 0) {
                    this.height = 0;
                }
            }
        }

        /**
         * Enlarges this rectangle to include the passed rectangle.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to include.
         */

    }, {
        key: 'enlarge',
        value: function enlarge(rectangle) {
            var x1 = Math.min(this.x, rectangle.x);
            var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
            var y1 = Math.min(this.y, rectangle.y);
            var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);

            this.x = x1;
            this.width = x2 - x1;
            this.y = y1;
            this.height = y2 - y1;
        }
    }, {
        key: 'left',
        get: function get$$1() {
            return this.x;
        }

        /**
         * returns the right edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'right',
        get: function get$$1() {
            return this.x + this.width;
        }

        /**
         * returns the top edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'top',
        get: function get$$1() {
            return this.y;
        }

        /**
         * returns the bottom edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'bottom',
        get: function get$$1() {
            return this.y + this.height;
        }

        /**
         * A constant empty rectangle.
         *
         * @static
         * @constant
         */

    }], [{
        key: 'EMPTY',
        get: function get$$1() {
            return new Rectangle(0, 0, 0, 0);
        }
    }]);
    return Rectangle;
}();

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */

var Circle = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this circle
   * @param {number} [y=0] - The Y coordinate of the center of this circle
   * @param {number} [radius=0] - The radius of the circle
   */
  function Circle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    classCallCheck(this, Circle);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.CIRC
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.CIRC;

    this.closed = true;
  }

  /**
   * Creates a clone of this Circle instance
   *
   * @return {PIXI.Circle} a copy of the Circle
   */


  createClass(Circle, [{
    key: 'clone',
    value: function clone() {
      return new Circle(this.x, this.y, this.radius);
    }

    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */

  }, {
    key: 'contains',
    value: function contains(x, y) {
      if (this.radius <= 0) {
        return false;
      }

      var r2 = this.radius * this.radius;
      var dx = this.x - x;
      var dy = this.y - y;

      dx *= dx;
      dy *= dy;

      return dx + dy <= r2;
    }

    /**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */

  }, {
    key: 'getBounds',
    value: function getBounds() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
  }]);
  return Circle;
}();

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */

var Ellipse = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this circle
   * @param {number} [y=0] - The Y coordinate of the center of this circle
   * @param {number} [width=0] - The half width of this ellipse
   * @param {number} [height=0] - The half height of this ellipse
   */
  function Ellipse() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    classCallCheck(this, Ellipse);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.ELIP
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.ELIP;

    this.closed = true;
  }

  /**
   * Creates a clone of this Ellipse instance
   *
   * @return {PIXI.Ellipse} a copy of the ellipse
   */


  createClass(Ellipse, [{
    key: 'clone',
    value: function clone() {
      return new Ellipse(this.x, this.y, this.width, this.height);
    }

    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */

  }, {
    key: 'contains',
    value: function contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }

      // normalize the coords to an ellipse with center 0,0
      var normx = (x - this.x) / this.width;
      var normy = (y - this.y) / this.height;

      normx *= normx;
      normy *= normy;

      return normx + normy <= 1;
    }

    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */

  }, {
    key: 'getBounds',
    value: function getBounds() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
  }]);
  return Ellipse;
}();

/**
 * @class
 * @memberof PIXI
 */

var Polygon = function () {
    /**
     * @param {PIXI.Point[]|number[]} points - This can be an array of Points
     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
     *  the arguments passed can be all the points of the polygon e.g.
     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
     */
    function Polygon() {
        for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
            points[_key] = arguments[_key];
        }

        classCallCheck(this, Polygon);

        if (Array.isArray(points[0])) {
            points = points[0];
        }

        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof Point$2) {
            var p = [];

            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }

            points = p;
        }

        this.closed = true;

        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = SHAPES.POLY;
    }

    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */


    createClass(Polygon, [{
        key: 'clone',
        value: function clone() {
            return new Polygon(this.points.slice());
        }

        /**
         * Closes the polygon, adding points if necessary.
         *
         */

    }, {
        key: 'close',
        value: function close() {
            var points = this.points;
            if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
                points.push(points[0], points[1]);
            }
            this.closed = true;
        }
    }, {
        key: 'contains',
        value: function contains(x, y) {
            return this._isInsidePolygon_WindingNumber(x, y);
        }

        /**
         * 多边形包含判断 Nonzero Winding Number Rule
         */

    }, {
        key: '_isInsidePolygon_WindingNumber',
        value: function _isInsidePolygon_WindingNumber(x, y) {
            var points = this.points;
            var wn = 0;
            for (var shiftP, shift = points[1] > y, i = 3; i < points.length; i += 2) {
                shiftP = shift;
                shift = points[i] > y;
                if (shiftP != shift) {
                    var n = (shiftP ? 1 : 0) - (shift ? 1 : 0);
                    if (n * ((points[i - 3] - x) * (points[i - 0] - y) - (points[i - 2] - y) * (points[i - 1] - x)) > 0) {
                        wn += n;
                    }
                }
            }
            return wn;
        }
    }]);
    return Polygon;
}();

/**
 * Math classes and utilities mixed into PIXI namespace.
 *
 * @lends PIXI
 */

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/**
 * Helper class to create a webGL Context
 *
 * @class
 * @memberof PIXI.glCore
 * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
 * @param options {Object} An options object that gets passed in to the canvas element containing the context attributes,
 *                         see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext for the options available
 * @return {WebGLRenderingContext} the WebGL context
 */
var createContext = function(canvas, options)
{
    var gl = canvas.getContext('webgl', options) || 
         canvas.getContext('experimental-webgl', options);

    if (!gl)
    {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    return gl;
};

var createContext_1 = createContext;

// var GL_MAP = {};

/**
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param attribs {*}
 * @param state {*}
 */
var setVertexAttribArrays = function (gl, attribs, state)
{
    var i;
    if(state)
    {
        var tempAttribState = state.tempAttribState,
            attribState = state.attribState;

        for (i = 0; i < tempAttribState.length; i++)
        {
            tempAttribState[i] = false;
        }

        // set the new attribs
        for (i = 0; i < attribs.length; i++)
        {
            tempAttribState[attribs[i].attribute.location] = true;
        }

        for (i = 0; i < attribState.length; i++)
        {
            if (attribState[i] !== tempAttribState[i])
            {
                attribState[i] = tempAttribState[i];

                if (state.attribState[i])
                {
                    gl.enableVertexAttribArray(i);
                }
                else
                {
                    gl.disableVertexAttribArray(i);
                }
            }
        }

    }
    else
    {
        for (i = 0; i < attribs.length; i++)
        {
            var attrib = attribs[i];
            gl.enableVertexAttribArray(attrib.attribute.location);
        }
    }
};

var setVertexAttribArrays_1 = setVertexAttribArrays;

var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);

/**
 * Helper class to create a webGL buffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param type {gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER} @mat
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 * @param drawType {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
 */
var Buffer = function(gl, type, data, drawType)
{

	/**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
	this.gl = gl;

	/**
     * The WebGL buffer, created upon instantiation
     *
     * @member {WebGLBuffer}
     */
	this.buffer = gl.createBuffer();

	/**
     * The type of the buffer
     *
     * @member {gl.ARRAY_BUFFER|gl.ELEMENT_ARRAY_BUFFER}
     */
	this.type = type || gl.ARRAY_BUFFER;

	/**
     * The draw type of the buffer
     *
     * @member {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
     */
	this.drawType = drawType || gl.STATIC_DRAW;

	/**
     * The data in the buffer, as a typed array
     *
     * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
     */
	this.data = EMPTY_ARRAY_BUFFER;

	if(data)
	{
		this.upload(data);
	}

	this._updateID = 0;
};

/**
 * Uploads the buffer to the GPU
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data to upload
 * @param offset {Number} if only a subset of the data should be uploaded, this is the amount of data to subtract
 * @param dontBind {Boolean} whether to bind the buffer before uploading it
 */
Buffer.prototype.upload = function(data, offset, dontBind)
{
	// todo - needed?
	if(!dontBind) this.bind();

	var gl = this.gl;

	data = data || this.data;
	offset = offset || 0;

	if(this.data.byteLength >= data.byteLength)
	{
		gl.bufferSubData(this.type, offset, data);
	}
	else
	{
		gl.bufferData(this.type, data, this.drawType);
	}

	this.data = data;
};
/**
 * Binds the buffer
 *
 */
Buffer.prototype.bind = function()
{
	var gl = this.gl;
	gl.bindBuffer(this.type, this.buffer);
};

Buffer.createVertexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType);
};

Buffer.createIndexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType);
};

Buffer.create = function(gl, type, data, drawType)
{
	return new Buffer(gl, type, data, drawType);
};

/**
 * Destroys the buffer
 *
 */
Buffer.prototype.destroy = function(){
	this.gl.deleteBuffer(this.buffer);
};

var GLBuffer = Buffer;

/**
 * Helper class to create a WebGL Texture
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param width {number} the width of the texture
 * @param height {number} the height of the texture
 * @param format {number} the pixel format of the texture. defaults to gl.RGBA
 * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE
 */
var Texture = function(gl, width, height, format, type)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;


	/**
	 * The WebGL texture
	 *
	 * @member {WebGLTexture}
	 */
	this.texture = gl.createTexture();

	/**
	 * If mipmapping was used for this texture, enable and disable with enableMipmap()
	 *
	 * @member {Boolean}
	 */
	// some settings..
	this.mipmap = false;


	/**
	 * Set to true to enable pre-multiplied alpha
	 *
	 * @member {Boolean}
	 */
	this.premultiplyAlpha = false;

	/**
	 * The width of texture
	 *
	 * @member {Number}
	 */
	this.width = width || -1;
	/**
	 * The height of texture
	 *
	 * @member {Number}
	 */
	this.height = height || -1;

	/**
	 * The pixel format of the texture. defaults to gl.RGBA
	 *
	 * @member {Number}
	 */
	this.format = format || gl.RGBA;

	/**
	 * The gl type of the texture. defaults to gl.UNSIGNED_BYTE
	 *
	 * @member {Number}
	 */
	this.type = type || gl.UNSIGNED_BYTE;


};

/**
 * Uploads this texture to the GPU
 * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture
 */
Texture.prototype.upload = function(source)
{
	this.bind();

	var gl = this.gl;


	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

	var newWidth = source.videoWidth || source.width;
	var newHeight = source.videoHeight || source.height;

	if(newHeight !== this.height || newWidth !== this.width)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);
	}
	else
	{
    	gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);
	}

	// if the source is a video, we need to use the videoWidth / videoHeight properties as width / height will be incorrect.
	this.width = newWidth;
	this.height = newHeight;

};

var FLOATING_POINT_AVAILABLE = false;

/**
 * Use a data source and uploads this texture to the GPU
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.prototype.uploadData = function(data, width, height)
{
	this.bind();

	var gl = this.gl;


	if(data instanceof Float32Array)
	{
		if(!FLOATING_POINT_AVAILABLE)
		{
			var ext = gl.getExtension("OES_texture_float");

			if(ext)
			{
				FLOATING_POINT_AVAILABLE = true;
			}
			else
			{
				throw new Error('floating point textures not available');
			}
		}

		this.type = gl.FLOAT;
	}
	else
	{
		// TODO support for other types
		this.type = this.type || gl.UNSIGNED_BYTE;
	}

	// what type of data?
	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);


	if(width !== this.width || height !== this.height)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format,  width, height, 0, this.format, this.type, data || null);
	}
	else
	{
		gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);
	}

	this.width = width;
	this.height = height;


//	texSubImage2D
};

/**
 * Binds the texture
 * @param  location
 */
Texture.prototype.bind = function(location)
{
	var gl = this.gl;

	if(location !== undefined)
	{
		gl.activeTexture(gl.TEXTURE0 + location);
	}

	gl.bindTexture(gl.TEXTURE_2D, this.texture);
};

/**
 * Unbinds the texture
 */
Texture.prototype.unbind = function()
{
	var gl = this.gl;
	gl.bindTexture(gl.TEXTURE_2D, null);
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.minFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	if(this.mipmap)
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
	}
	else
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);
	}
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.magFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);
};

/**
 * Enables mipmapping
 */
Texture.prototype.enableMipmap = function()
{
	var gl = this.gl;

	this.bind();

	this.mipmap = true;

	gl.generateMipmap(gl.TEXTURE_2D);
};

/**
 * Enables linear filtering
 */
Texture.prototype.enableLinearScaling = function()
{
	this.minFilter(true);
	this.magFilter(true);
};

/**
 * Enables nearest neighbour interpolation
 */
Texture.prototype.enableNearestScaling = function()
{
	this.minFilter(false);
	this.magFilter(false);
};

/**
 * Enables clamping on the texture so WebGL will not repeat it
 */
Texture.prototype.enableWrapClamp = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
};

/**
 * Enable tiling on the texture
 */
Texture.prototype.enableWrapRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
};

Texture.prototype.enableWrapMirrorRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
};


/**
 * Destroys this texture
 */
Texture.prototype.destroy = function()
{
	var gl = this.gl;
	//TODO
	gl.deleteTexture(this.texture);
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param source {HTMLImageElement|ImageData} the source image of the texture
 * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha
 */
Texture.fromSource = function(gl, source, premultiplyAlpha)
{
	var texture = new Texture(gl);
	texture.premultiplyAlpha = premultiplyAlpha || false;
	texture.upload(source);

	return texture;
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.fromData = function(gl, data, width, height)
{
	//console.log(data, width, height);
	var texture = new Texture(gl);
	texture.uploadData(data, width, height);

	return texture;
};


var GLTexture = Texture;

/**
 * Helper class to create a webGL Framebuffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 */
var Framebuffer = function(gl, width, height)
{
    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * The frame buffer
     *
     * @member {WebGLFramebuffer}
     */
    this.framebuffer = gl.createFramebuffer();

    /**
     * The stencil buffer
     *
     * @member {WebGLRenderbuffer}
     */
    this.stencil = null;

    /**
     * The stencil buffer
     *
     * @member {PIXI.glCore.GLTexture}
     */
    this.texture = null;

    /**
     * The width of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.width = width || 100;
    /**
     * The height of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.height = height || 100;
};

/**
 * Adds a texture to the frame buffer
 * @param texture {PIXI.glCore.GLTexture}
 */
Framebuffer.prototype.enableTexture = function(texture)
{
    var gl = this.gl;

    this.texture = texture || new GLTexture(gl);

    this.texture.bind();

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    this.bind();

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
};

/**
 * Initialises the stencil buffer
 */
Framebuffer.prototype.enableStencil = function()
{
    if(this.stencil)return;

    var gl = this.gl;

    this.stencil = gl.createRenderbuffer();

    gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);

    // TODO.. this is depth AND stencil?
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.width  , this.height );


};

/**
 * Erases the drawing area and fills it with a colour
 * @param  r {Number} the red value of the clearing colour
 * @param  g {Number} the green value of the clearing colour
 * @param  b {Number} the blue value of the clearing colour
 * @param  a {Number} the alpha value of the clearing colour
 */
Framebuffer.prototype.clear = function( r, g, b, a )
{
    this.bind();

    var gl = this.gl;

    gl.clearColor(r, g, b, a);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};

/**
 * Binds the frame buffer to the WebGL context
 */
Framebuffer.prototype.bind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );
};

/**
 * Unbinds the frame buffer to the WebGL context
 */
Framebuffer.prototype.unbind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null );
};
/**
 * Resizes the drawing area of the buffer to the given width and height
 * @param  width  {Number} the new width
 * @param  height {Number} the new height
 */
Framebuffer.prototype.resize = function(width, height)
{
    var gl = this.gl;

    this.width = width;
    this.height = height;

    if ( this.texture )
    {
        this.texture.uploadData(null, width, height);
    }

    if ( this.stencil )
    {
        // update the stencil buffer width and height
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    }
};

/**
 * Destroys this buffer
 */
Framebuffer.prototype.destroy = function()
{
    var gl = this.gl;

    //TODO
    if(this.texture)
    {
        this.texture.destroy();
    }

    gl.deleteFramebuffer(this.framebuffer);

    this.gl = null;

    this.stencil = null;
    this.texture = null;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createRGBA = function(gl, width, height, data)
{
    var texture = GLTexture.fromData(gl, null, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);

    //fbo.enableStencil(); // get this back on soon!

    fbo.unbind();

    return fbo;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createFloat32 = function(gl, width, height, data)
{
    // create a new texture..
    var texture = new GLTexture.fromData(gl, data, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);

    fbo.unbind();

    return fbo;
};

var GLFramebuffer$1 = Framebuffer;

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
var compileProgram = function(gl, vertexSrc, fragmentSrc, attributeLocations)
{
    var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
    var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);

    // optionally, set the attributes manually for the program rather than letting WebGL decide..
    if(attributeLocations)
    {
        for(var i in attributeLocations)
        {
            gl.bindAttribLocation(program, attributeLocations[i], i);
        }
    }


    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return program;
};

/**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
var compileShader = function (gl, type, src)
{
    var shader = gl.createShader(type);

    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

var compileProgram_1 = compileProgram;

var mapSize = function(gl, type) 
{
    if(!GL_TABLE) 
    {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);

        GL_TABLE = {};

        for(var i = 0; i < typeNames.length; ++i) 
        {
            var tn = typeNames[i];
            GL_TABLE[ gl[tn] ] = GL_TO_GLSL_TYPES[tn];
        }
    }

  return GL_TABLE[type];
};

var GL_TABLE = null;

var GL_TO_GLSL_TYPES = {
  'FLOAT':       'float',
  'FLOAT_VEC2':  'vec2',
  'FLOAT_VEC3':  'vec3',
  'FLOAT_VEC4':  'vec4',

  'INT':         'int',
  'INT_VEC2':    'ivec2',
  'INT_VEC3':    'ivec3',
  'INT_VEC4':    'ivec4',
  
  'BOOL':        'bool',
  'BOOL_VEC2':   'bvec2',
  'BOOL_VEC3':   'bvec3',
  'BOOL_VEC4':   'bvec4',
  
  'FLOAT_MAT2':  'mat2',
  'FLOAT_MAT3':  'mat3',
  'FLOAT_MAT4':  'mat4',
  
  'SAMPLER_2D':  'sampler2D'  
};

var mapType = mapSize;

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String}
 * @return {Number}
 */
var mapSize$1 = function(type) 
{ 
    return GLSL_TO_SIZE[type];
};


var GLSL_TO_SIZE = {
    'float':    1,
    'vec2':     2,
    'vec3':     3,
    'vec4':     4,

    'int':      1,
    'ivec2':    2,
    'ivec3':    3,
    'ivec4':    4,

    'bool':     1,
    'bvec2':    2,
    'bvec3':    3,
    'bvec4':    4,

    'mat2':     4,
    'mat3':     9,
    'mat4':     16,

    'sampler2D':  1
};

var mapSize_1 = mapSize$1;

/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the attributes from
 * @return attributes {Object}
 */
var extractAttributes = function(gl, program)
{
    var attributes = {};

    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

    for (var i = 0; i < totalAttributes; i++)
    {
        var attribData = gl.getActiveAttrib(program, i);
        var type = mapType(gl, attribData.type);

        attributes[attribData.name] = {
            type:type,
            size:mapSize_1(type),
            location:gl.getAttribLocation(program, attribData.name),
            //TODO - make an attribute object
            pointer: pointer
        };
    }

    return attributes;
};

var pointer = function(type, normalized, stride, start){
    // console.log(this.location)
    gl.vertexAttribPointer(this.location,this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0);
};

var extractAttributes_1 = extractAttributes;

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String} Type of value
 * @param size {Number}
 */
var defaultValue = function(type, size) 
{
    switch (type)
    {
        case 'float':
            return 0;

        case 'vec2': 
            return new Float32Array(2 * size);

        case 'vec3':
            return new Float32Array(3 * size);

        case 'vec4':     
            return new Float32Array(4 * size);
            
        case 'int':
        case 'sampler2D':
            return 0;

        case 'ivec2':   
            return new Int32Array(2 * size);

        case 'ivec3':
            return new Int32Array(3 * size);

        case 'ivec4': 
            return new Int32Array(4 * size);

        case 'bool':     
            return false;

        case 'bvec2':

            return booleanArray( 2 * size);

        case 'bvec3':
            return booleanArray(3 * size);

        case 'bvec4':
            return booleanArray(4 * size);

        case 'mat2':
            return new Float32Array([1, 0,
                                     0, 1]);

        case 'mat3': 
            return new Float32Array([1, 0, 0,
                                     0, 1, 0,
                                     0, 0, 1]);

        case 'mat4':
            return new Float32Array([1, 0, 0, 0,
                                     0, 1, 0, 0,
                                     0, 0, 1, 0,
                                     0, 0, 0, 1]);
    }
};

var booleanArray = function(size)
{
    var array = new Array(size);

    for (var i = 0; i < array.length; i++) 
    {
        array[i] = false;
    }

    return array;
};

var defaultValue_1 = defaultValue;

/**
 * Extracts the uniforms
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the uniforms from
 * @return uniforms {Object}
 */
var extractUniforms = function(gl, program)
{
	var uniforms = {};

    var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var i = 0; i < totalUniforms; i++)
    {
    	var uniformData = gl.getActiveUniform(program, i);
    	var name = uniformData.name.replace(/\[.*?\]/, "");
        var type = mapType(gl, uniformData.type );

    	uniforms[name] = {
    		type:type,
    		size:uniformData.size,
    		location:gl.getUniformLocation(program, name),
    		value:defaultValue_1(type, uniformData.size)
    	};
    }

	return uniforms;
};

var extractUniforms_1 = extractUniforms;

/**
 * Sets the float precision on the shader. If the precision is already present this function will do nothing
 * @param {string} src       the shader source
 * @param {string} precision The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 *
 * @return {string} modified shader source
 */
var setPrecision = function(src, precision)
{
    if(src.substring(0, 9) !== 'precision')
    {
        return 'precision ' + precision + ' float;\n' + src;
    }

    return src;
};

var setPrecision_1 = setPrecision;

/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param uniforms {Array} @mat ?
 * @return attributes {Object}
 */
var generateUniformAccessObject = function(gl, uniformData)
{
    // this is the object we will be sending back.
    // an object hierachy will be created for structs
    var uniforms = {data:{}};

    uniforms.gl = gl;

    var uniformKeys= Object.keys(uniformData);

    for (var i = 0; i < uniformKeys.length; i++)
    {
        var fullName = uniformKeys[i];

        var nameTokens = fullName.split('.');
        var name = nameTokens[nameTokens.length - 1];


        var uniformGroup = getUniformGroup(nameTokens, uniforms);

        var uniform =  uniformData[fullName];
        uniformGroup.data[name] = uniform;

        uniformGroup.gl = gl;

        Object.defineProperty(uniformGroup, name, {
            get: generateGetter(name),
            set: generateSetter(name, uniform)
        });
    }

    return uniforms;
};

var generateGetter = function(name)
{
	var template = getterTemplate.replace('%%', name);
	return new Function(template); // jshint ignore:line
};

var generateSetter = function(name, uniform)
{
    var template = setterTemplate.replace(/%%/g, name);
    var setTemplate;

    if(uniform.size === 1)
    {
        setTemplate = GLSL_TO_SINGLE_SETTERS[uniform.type];
    }
    else
    {
        setTemplate = GLSL_TO_ARRAY_SETTERS[uniform.type];
    }

    if(setTemplate)
    {
        template += "\nthis.gl." + setTemplate + ";";
    }

  	return new Function('value', template); // jshint ignore:line
};

var getUniformGroup = function(nameTokens, uniform)
{
    var cur = uniform;

    for (var i = 0; i < nameTokens.length - 1; i++)
    {
        var o = cur[nameTokens[i]] || {data:{}};
        cur[nameTokens[i]] = o;
        cur = o;
    }

    return cur;
};

var getterTemplate = [
    'return this.data.%%.value;',
].join('\n');

var setterTemplate = [
    'this.data.%%.value = value;',
    'var location = this.data.%%.location;'
].join('\n');


var GLSL_TO_SINGLE_SETTERS = {

    'float':    'uniform1f(location, value)',

    'vec2':     'uniform2f(location, value[0], value[1])',
    'vec3':     'uniform3f(location, value[0], value[1], value[2])',
    'vec4':     'uniform4f(location, value[0], value[1], value[2], value[3])',

    'int':      'uniform1i(location, value)',
    'ivec2':    'uniform2i(location, value[0], value[1])',
    'ivec3':    'uniform3i(location, value[0], value[1], value[2])',
    'ivec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',

    'bool':     'uniform1i(location, value)',
    'bvec2':    'uniform2i(location, value[0], value[1])',
    'bvec3':    'uniform3i(location, value[0], value[1], value[2])',
    'bvec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',

    'mat2':     'uniformMatrix2fv(location, false, value)',
    'mat3':     'uniformMatrix3fv(location, false, value)',
    'mat4':     'uniformMatrix4fv(location, false, value)',

    'sampler2D':'uniform1i(location, value)'
};

var GLSL_TO_ARRAY_SETTERS = {

    'float':    'uniform1fv(location, value)',

    'vec2':     'uniform2fv(location, value)',
    'vec3':     'uniform3fv(location, value)',
    'vec4':     'uniform4fv(location, value)',

    'int':      'uniform1iv(location, value)',
    'ivec2':    'uniform2iv(location, value)',
    'ivec3':    'uniform3iv(location, value)',
    'ivec4':    'uniform4iv(location, value)',

    'bool':     'uniform1iv(location, value)',
    'bvec2':    'uniform2iv(location, value)',
    'bvec3':    'uniform3iv(location, value)',
    'bvec4':    'uniform4iv(location, value)',

    'sampler2D':'uniform1iv(location, value)'
};

var generateUniformAccessObject_1 = generateUniformAccessObject;

/**
 * Helper class to create a webGL Shader
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param precision {precision]} The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 * @param attributeLocations {object} A key value pair showing which location eact attribute should sit eg {position:0, uvs:1}
 */
var Shader = function(gl, vertexSrc, fragmentSrc, precision, attributeLocations)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;

	if(precision)
	{
		vertexSrc = setPrecision_1(vertexSrc, precision);
		fragmentSrc = setPrecision_1(fragmentSrc, precision);
	}

	/**
	 * The shader program
	 *
	 * @member {WebGLProgram}
	 */
	// First compile the program..
	this.program = compileProgram_1(gl, vertexSrc, fragmentSrc, attributeLocations);

	/**
	 * The attributes of the shader as an object containing the following properties
	 * {
	 * 	type,
	 * 	size,
	 * 	location,
	 * 	pointer
	 * }
	 * @member {Object}
	 */
	// next extract the attributes
	this.attributes = extractAttributes_1(gl, this.program);

    this.uniformData = extractUniforms_1(gl, this.program);

	/**
	 * The uniforms of the shader as an object containing the following properties
	 * {
	 * 	gl,
	 * 	data
	 * }
	 * @member {Object}
	 */
	this.uniforms = generateUniformAccessObject_1( gl, this.uniformData );

};
/**
 * Uses this shader
 */
Shader.prototype.bind = function()
{
	this.gl.useProgram(this.program);
};

/**
 * Destroys this shader
 * TODO
 */
Shader.prototype.destroy = function()
{
	this.attributes = null;
	this.uniformData = null;
	this.uniforms = null;

	var gl = this.gl;
	gl.deleteProgram(this.program);
};


var GLShader = Shader;

// state object//


/**
 * Helper class to work with WebGL VertexArrayObjects (vaos)
 * Only works if WebGL extensions are enabled (they usually are)
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 */
function VertexArrayObject(gl, state)
{
    this.nativeVaoExtension = null;

    if(!VertexArrayObject.FORCE_NATIVE)
    {
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') ||
                                  gl.getExtension('MOZ_OES_vertex_array_object') ||
                                  gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    this.nativeState = state;

    if(this.nativeVaoExtension)
    {
        this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();

        var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        // VAO - overwrite the state..
        this.nativeState = {
            tempAttribState: new Array(maxAttribs),
            attribState: new Array(maxAttribs)
        };
    }

    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * An array of attributes
     *
     * @member {Array}
     */
    this.attributes = [];

    /**
     * @member {PIXI.glCore.GLBuffer}
     */
    this.indexBuffer = null;

    /**
     * A boolean flag
     *
     * @member {Boolean}
     */
    this.dirty = false;
}

VertexArrayObject.prototype.constructor = VertexArrayObject;
var VertexArrayObject_1 = VertexArrayObject;

/**
* Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
* If you find on older devices that things have gone a bit weird then set this to true.
*/
/**
 * Lets the VAO know if you should use the WebGL extension or the native methods.
 * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
 * If you find on older devices that things have gone a bit weird then set this to true.
 * @static
 * @property {Boolean} FORCE_NATIVE
 */
VertexArrayObject.FORCE_NATIVE = false;

/**
 * Binds the buffer
 */
VertexArrayObject.prototype.bind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);

        if(this.dirty)
        {
            this.dirty = false;
            this.activate();
        }
    }
    else
    {

        this.activate();
    }

    return this;
};

/**
 * Unbinds the buffer
 */
VertexArrayObject.prototype.unbind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(null);
    }

    return this;
};

/**
 * Uses this vao
 */
VertexArrayObject.prototype.activate = function()
{

    var gl = this.gl;
    var lastBuffer = null;

    for (var i = 0; i < this.attributes.length; i++)
    {
        var attrib = this.attributes[i];

        if(lastBuffer !== attrib.buffer)
        {
            attrib.buffer.bind();
            lastBuffer = attrib.buffer;
        }

        gl.vertexAttribPointer(attrib.attribute.location,
                               attrib.attribute.size,
                               attrib.type || gl.FLOAT,
                               attrib.normalized || false,
                               attrib.stride || 0,
                               attrib.start || 0);
    }

    setVertexAttribArrays_1(gl, this.attributes, this.nativeState);

    if(this.indexBuffer)
    {
        this.indexBuffer.bind();
    }

    return this;
};

/**
 *
 * @param buffer     {PIXI.gl.GLBuffer}
 * @param attribute  {*}
 * @param type       {String}
 * @param normalized {Boolean}
 * @param stride     {Number}
 * @param start      {Number}
 */
VertexArrayObject.prototype.addAttribute = function(buffer, attribute, type, normalized, stride, start)
{
    this.attributes.push({
        buffer:     buffer,
        attribute:  attribute,

        location:   attribute.location,
        type:       type || this.gl.FLOAT,
        normalized: normalized || false,
        stride:     stride || 0,
        start:      start || 0
    });

    this.dirty = true;

    return this;
};

/**
 *
 * @param buffer   {PIXI.gl.GLBuffer}
 */
VertexArrayObject.prototype.addIndex = function(buffer/*, options*/)
{
    this.indexBuffer = buffer;

    this.dirty = true;

    return this;
};

/**
 * Unbinds this vao and disables it
 */
VertexArrayObject.prototype.clear = function()
{
    // var gl = this.gl;

    // TODO - should this function unbind after clear?
    // for now, no but lets see what happens in the real world!
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
    }

    this.attributes.length = 0;
    this.indexBuffer = null;

    return this;
};

/**
 * @param type  {Number}
 * @param size  {Number}
 * @param start {Number}
 */
VertexArrayObject.prototype.draw = function(type, size, start)
{
    var gl = this.gl;

    if(this.indexBuffer)
    {
        gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2 );
    }
    else
    {
        // TODO need a better way to calculate size..
        gl.drawArrays(type, start, size || this.getSize());
    }

    return this;
};

/**
 * Destroy this vao
 */
VertexArrayObject.prototype.destroy = function()
{
    // lose references
    this.gl = null;
    this.indexBuffer = null;
    this.attributes = null;
    this.nativeState = null;

    if(this.nativeVao)
    {
        this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);
    }

    this.nativeVaoExtension = null;
    this.nativeVao = null;
};

VertexArrayObject.prototype.getSize = function()
{
    var attrib = this.attributes[0];
    return attrib.buffer.data.length / (( attrib.stride/4 ) || attrib.attribute.size);
};

var index$1 = {
    compileProgram: compileProgram_1,
    defaultValue: defaultValue_1,
    extractAttributes: extractAttributes_1,
    extractUniforms: extractUniforms_1,
    generateUniformAccessObject: generateUniformAccessObject_1,
    setPrecision: setPrecision_1,
    mapSize: mapSize_1,
    mapType: mapType
};

var index = createCommonjsModule(function (module) {
var gl = {
    createContext:          createContext_1,
    setVertexAttribArrays:  setVertexAttribArrays_1,
    GLBuffer:               GLBuffer,
    GLFramebuffer:          GLFramebuffer$1,
    GLShader:               GLShader,
    GLTexture:              GLTexture,
    VertexArrayObject:      VertexArrayObject_1,
    shader:                 index$1
};

// Export for Node-compatible environments
if ('object' !== 'undefined' && module.exports)
{
    // Export the module
    module.exports = gl;
}

// Add to the browser window pixi.gl
if (typeof window !== 'undefined')
{
    // add the window object
    window.PIXI = window.PIXI || {};
    window.PIXI.glCore = gl;
}
});

var GLFramebuffer = index.GLFramebuffer;

var RenderTarget = function () {
    function RenderTarget(gl, width, height, resolution, root) {
        classCallCheck(this, RenderTarget);


        this.gl = gl;

        // framebuffer 是WebGL渲染的终点。当你看屏幕时，其他就是在看 framebuffer 中的内容。
        this.frameBuffer = null;

        this.clearColor = [0, 0, 0, 0];

        this.size = new Rectangle(0, 0, 1, 1);

        /**
         * 设备分辨率
         */
        this.resolution = resolution || settings.RESOLUTION;

        //投影矩阵，把所有的顶点投射到webgl的[-1,1]的坐标系内
        this.projectionMatrix = new Matrix();

        this.frame = null;

        this.defaultFrame = new Rectangle();
        this.destinationFrame = null;
        this.sourceFrame = null;

        this.root = root;

        this.frameBuffer = new GLFramebuffer(gl, 100, 100);
        this.frameBuffer.framebuffer = null;

        this.setFrame();

        this.resize(width, height);
    }

    createClass(RenderTarget, [{
        key: 'clear',
        value: function clear(clearColor) {
            var cc = clearColor || this.clearColor;

            this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);
        }
    }, {
        key: 'setFrame',
        value: function setFrame(destinationFrame, sourceFrame) {
            this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
            this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        }

        //在WebGLRenderer中被调用

    }, {
        key: 'activate',
        value: function activate() {
            var gl = this.gl;

            this.frameBuffer.bind();

            this.calculateProjection(this.destinationFrame, this.sourceFrame);

            if (this.destinationFrame !== this.sourceFrame) {
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
            } else {
                gl.disable(gl.SCISSOR_TEST);
            }

            gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
        }

        //计算投影矩阵，把所有的顶点数据投射到 webgl 的 [-1,1] 坐标系内来

    }, {
        key: 'calculateProjection',
        value: function calculateProjection(destinationFrame, sourceFrame) {
            var pm = this.projectionMatrix;

            sourceFrame = sourceFrame || destinationFrame;

            pm.identity();

            pm.a = 1 / destinationFrame.width * 2;
            pm.d = -1 / destinationFrame.height * 2;

            pm.tx = -1 - sourceFrame.x * pm.a;
            pm.ty = 1 - sourceFrame.y * pm.d;
        }

        //stage 的 size发生变化，需要重新初始化这些对象的size，尤其是 projectionMatrix 投影举证

    }, {
        key: 'resize',
        value: function resize(width, height) {
            width = width | 0;
            height = height | 0;

            if (this.size.width === width && this.size.height === height) {
                return;
            }

            this.size.width = width;
            this.size.height = height;

            this.defaultFrame.width = width;
            this.defaultFrame.height = height;

            this.frameBuffer.resize(width * this.resolution, height * this.resolution);

            var projectionFrame = this.frame || this.size;

            this.calculateProjection(projectionFrame);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.frameBuffer.destroy();
            this.frameBuffer = null;
        }
    }]);
    return RenderTarget;
}();

var ObjectRenderer = function () {
    function ObjectRenderer(renderer) {
        classCallCheck(this, ObjectRenderer);

        this.renderer = renderer;
    }

    createClass(ObjectRenderer, [{
        key: 'start',
        value: function start() {}
    }, {
        key: 'stop',
        value: function stop() {
            this.flush();
        }
    }, {
        key: 'flush',
        value: function flush() {}
    }, {
        key: 'destroy',
        value: function destroy() {
            this.renderer.off('context', this.onContextChange, this);

            this.renderer = null;
        }
    }, {
        key: 'render',
        value: function render(object) {}
    }]);
    return ObjectRenderer;
}();

var DEPTH_TEST = 1;
var FRONT_FACE = 2;
var CULL_FACE = 3;

/**
 * A WebGL state machines
 *
 * @memberof PIXI
 * @class
 */

var WebGLState = function () {
    /**
     * @param {WebGLRenderingContext} gl - The current WebGL rendering context
     */
    function WebGLState(gl) {
        classCallCheck(this, WebGLState);

        /**
         * The current active state
         *
         * @member {Uint8Array}
         */
        this.activeState = new Uint8Array(16);

        /**
         * The default state
         *
         * @member {Uint8Array}
         */
        this.defaultState = new Uint8Array(16);

        // default blend mode..
        this.defaultState[0] = 1;

        /**
         * The current state index in the stack
         *
         * @member {number}
         * @private
         */
        this.stackIndex = 0;

        /**
         * The stack holding all the different states
         *
         * @member {Array<*>}
         * @private
         */
        this.stack = [];

        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;

        this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        this.attribState = {
            tempAttribState: new Array(this.maxAttribs),
            attribState: new Array(this.maxAttribs)
        };

        // check we have vao..
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    /**
     * Pushes a new active state
     */


    createClass(WebGLState, [{
        key: 'push',
        value: function push() {
            // next state..
            var state = this.stack[++this.stackIndex];

            if (!state) {
                state = this.stack[this.stackIndex] = new Uint8Array(16);
            }

            // copy state..
            // set active state so we can force overrides of gl state
            for (var i = 0; i < this.activeState.length; i++) {
                this.activeState[i] = state[i];
            }
        }

        /**
         * Pops a state out
         */

    }, {
        key: 'pop',
        value: function pop() {
            var state = this.stack[--this.stackIndex];

            this.setState(state);
        }

        /**
         * Sets the current state
         *
         * @param {*} state - The state to set.
         */

    }, {
        key: 'setState',
        value: function setState(state) {
            this.setDepthTest(state[DEPTH_TEST]);
            this.setFrontFace(state[FRONT_FACE]);
            this.setCullFace(state[CULL_FACE]);
        }

        /**
         * Sets whether to enable or disable depth test.
         *
         * @param {boolean} value - Turn on or off webgl depth testing.
         */

    }, {
        key: 'setDepthTest',
        value: function setDepthTest(value) {
            value = value ? 1 : 0;

            if (this.activeState[DEPTH_TEST] === value) {
                return;
            }

            this.activeState[DEPTH_TEST] = value;
            this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
        }

        /**
         * Sets whether to enable or disable cull face.
         *
         * @param {boolean} value - Turn on or off webgl cull face.
         */

    }, {
        key: 'setCullFace',
        value: function setCullFace(value) {
            value = value ? 1 : 0;

            if (this.activeState[CULL_FACE] === value) {
                return;
            }

            this.activeState[CULL_FACE] = value;
            this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
        }

        /**
         * Sets the gl front face.
         *
         * @param {boolean} value - true is clockwise and false is counter-clockwise
         */

    }, {
        key: 'setFrontFace',
        value: function setFrontFace(value) {
            value = value ? 1 : 0;

            if (this.activeState[FRONT_FACE] === value) {
                return;
            }

            this.activeState[FRONT_FACE] = value;
            this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
        }

        /**
         * Disables all the vaos in use
         *
         */

    }, {
        key: 'resetAttributes',
        value: function resetAttributes() {
            for (var i = 0; i < this.attribState.tempAttribState.length; i++) {
                this.attribState.tempAttribState[i] = 0;
            }

            for (var _i = 0; _i < this.attribState.attribState.length; _i++) {
                this.attribState.attribState[_i] = 0;
            }

            // im going to assume one is always active for performance reasons.
            for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) {
                this.gl.disableVertexAttribArray(_i2);
            }
        }

        // used
        /**
         * Resets all the logic and disables the vaos
         */

    }, {
        key: 'resetToDefault',
        value: function resetToDefault() {
            // unbind any VAO if they exist..
            if (this.nativeVaoExtension) {
                this.nativeVaoExtension.bindVertexArrayOES(null);
            }

            // reset all attributes..
            this.resetAttributes();

            // set active state so we can force overrides of gl state
            for (var i = 0; i < this.activeState.length; ++i) {
                this.activeState[i] = 32;
            }

            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);

            this.setState(this.defaultState);
        }
    }]);
    return WebGLState;
}();

function hex2rgb(hex, out) {
    out = out || [];

    out[0] = (hex >> 16 & 0xFF) / 255;
    out[1] = (hex >> 8 & 0xFF) / 255;
    out[2] = (hex & 0xFF) / 255;

    return out;
}

/**
 * An object containing WebGL specific properties to be used by the WebGL renderer
 *
 * @class
 * @private
 * @memberof PIXI
 */

var WebGLGraphicsData = function () {
  /**
   * @param {WebGLRenderingContext} gl - The current WebGL drawing context
   * @param {PIXI.Shader} shader - The shader
   * @param {object} attribsState - The state for the VAO
   */
  function WebGLGraphicsData(gl, shader, attribsState) {
    classCallCheck(this, WebGLGraphicsData);

    /**
     * The current WebGL drawing context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    // TODO does this need to be split before uploading??
    /**
     * An array of color components (r,g,b)
     * @member {number[]}
     */
    this.color = [0, 0, 0]; // color split!

    /**
     * An array of points to draw
     * @member {PIXI.Point[]}
     */
    this.points = [];

    /**
     * The indices of the vertices
     * @member {number[]}
     */
    this.indices = [];
    /**
     * The main buffer
     * @member {WebGLBuffer}
     */
    this.buffer = index.GLBuffer.createVertexBuffer(gl);

    /**
     * The index buffer
     * @member {WebGLBuffer}
     */
    this.indexBuffer = index.GLBuffer.createIndexBuffer(gl);

    /**
     * Whether this graphics is dirty or not
     * @member {boolean}
     */
    this.dirty = true;

    this.glPoints = null;
    this.glIndices = null;

    /**
     *
     * @member {PIXI.Shader}
     */
    this.shader = shader;

    this.vao = new index.VertexArrayObject(gl, attribsState).addIndex(this.indexBuffer).addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4);
  }

  /**
   * Resets the vertices and the indices
   */


  createClass(WebGLGraphicsData, [{
    key: 'reset',
    value: function reset() {
      this.points.length = 0;
      this.indices.length = 0;
    }

    /**
     * Binds the buffers and uploads the data
     */

  }, {
    key: 'upload',
    value: function upload() {
      this.glPoints = new Float32Array(this.points);
      this.buffer.upload(this.glPoints);

      this.glIndices = new Uint16Array(this.indices);
      this.indexBuffer.upload(this.glIndices);

      this.dirty = false;
    }

    /**
     * Empties all the data
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.color = null;
      this.points = null;
      this.indices = null;

      this.vao.destroy();
      this.buffer.destroy();
      this.indexBuffer.destroy();

      this.gl = null;

      this.buffer = null;
      this.indexBuffer = null;

      this.glPoints = null;
      this.glIndices = null;
    }
  }]);
  return WebGLGraphicsData;
}();

var PRECISION = settings.PRECISION;

var GLShader$2 = index.GLShader;

function checkPrecision(src) {
    if (src instanceof Array) {
        if (src[0].substring(0, 9) !== 'precision') {
            var copy = src.slice(0);

            copy.unshift('precision ' + PRECISION + ' float;');

            return copy;
        }
    } else if (src.substring(0, 9) !== 'precision') {
        return 'precision ' + PRECISION + ' float;\n' + src;
    }

    return src;
}

/**
 * Wrapper class, webGL Shader for Pixi.
 * Adds precision string if vertexSrc or fragmentSrc have no mention of it.
 *
 * @class
 * @extends GLShader
 * @memberof PIXI
 */

var Shader$1 = function (_GLShader) {
    inherits(Shader, _GLShader);

    /**
     *
     * @param {WebGLRenderingContext} gl - The current WebGL rendering context
     * @param {string|string[]} vertexSrc - The vertex shader source as an array of strings.
     * @param {string|string[]} fragmentSrc - The fragment shader source as an array of strings.
     */
    function Shader(gl, vertexSrc, fragmentSrc) {
        classCallCheck(this, Shader);
        return possibleConstructorReturn(this, (Shader.__proto__ || Object.getPrototypeOf(Shader)).call(this, gl, checkPrecision(vertexSrc), checkPrecision(fragmentSrc)));
    }

    return Shader;
}(GLShader$2);

/**
 * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
 *
 * @class
 * @memberof PIXI
 * @extends PIXI.Shader
 */

var PrimitiveShader = function (_Shader) {
    inherits(PrimitiveShader, _Shader);

    /**
     * @param {WebGLRenderingContext} gl - The webgl shader manager this shader works for.
     */
    function PrimitiveShader(gl) {
        classCallCheck(this, PrimitiveShader);
        return possibleConstructorReturn(this, (PrimitiveShader.__proto__ || Object.getPrototypeOf(PrimitiveShader)).call(this, gl,
        // vertex shader
        ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'),
        // fragment shader
        ['varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n')));
    }

    return PrimitiveShader;
}(Shader$1);

/**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildLine(graphicsData, webGLData) {
    // TODO OPTIMISE!
    var points = graphicsData.points;

    if (points.length === 0) {
        return;
    }
    // if the line width is an odd number add 0.5 to align to a whole pixel
    // commenting this out fixes #711 and #1620
    // if (graphicsData.lineWidth%2)
    // {
    //     for (i = 0; i < points.length; i++)
    //     {
    //         points[i] += 0.5;
    //     }
    // }

    // get first and last point.. figure out the middle!
    var firstPoint = new Point$2(points[0], points[1]);
    var lastPoint = new Point$2(points[points.length - 2], points[points.length - 1]);

    // if the first point is the last point - gonna have issues :)
    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
        // need to clone as we are going to slightly modify the shape..
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new Point$2(points[points.length - 2], points[points.length - 1]);

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length / 6;

    // DRAW the Line
    var width = graphicsData.lineWidth / 2;

    // sort color
    var color = hex2rgb(graphicsData.strokeStyle);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var p1x = points[0];
    var p1y = points[1];
    var p2x = points[2];
    var p2y = points[3];
    var p3x = 0;
    var p3y = 0;

    var perpx = -(p1y - p2y);
    var perpy = p1x - p2x;
    var perp2x = 0;
    var perp2y = 0;
    var perp3x = 0;
    var perp3y = 0;

    var dist = Math.sqrt(perpx * perpx + perpy * perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);

    verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);

    for (var i = 1; i < length - 1; ++i) {
        p1x = points[(i - 1) * 2];
        p1y = points[(i - 1) * 2 + 1];

        p2x = points[i * 2];
        p2y = points[i * 2 + 1];

        p3x = points[(i + 1) * 2];
        p3y = points[(i + 1) * 2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        var a1 = -perpy + p1y - (-perpy + p2y);
        var b1 = -perpx + p2x - (-perpx + p1x);
        var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        var a2 = -perp2y + p3y - (-perp2y + p2y);
        var b2 = -perp2x + p2x - (-perp2x + p3x);
        var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        var denom = a1 * b2 - a2 * b1;

        if (Math.abs(denom) < 0.1) {
            denom += 10.1;
            verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);

            verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);

            continue;
        }

        var px = (b1 * c2 - b2 * c1) / denom;
        var py = (a2 * c1 - a1 * c2) / denom;
        var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);

        if (pdist > 196 * width * width) {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y + perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        } else {
            verts.push(px, py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px - p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length - 2) * 2];
    p1y = points[(length - 2) * 2 + 1];

    p2x = points[(length - 1) * 2];
    p2y = points[(length - 1) * 2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx, p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx, p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (var _i = 0; _i < indexCount; ++_i) {
        indices.push(indexStart++);
    }

    indices.push(indexStart - 1);
}

var earcut_1 = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

/**
 * Builds a polygon to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildPoly(graphicsData, webGLData) {
    graphicsData.points = graphicsData.shape.points.slice();

    var points = graphicsData.points;

    if (graphicsData.fill && points.length >= 6) {
        var holeArray = [];
        // Process holes..
        var holes = graphicsData.holes;

        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];

            holeArray.push(points.length / 2);

            points = points.concat(hole.points);
        }

        // get first and last point.. figure out the middle!
        var verts = webGLData.points;
        var indices = webGLData.indices;

        var length = points.length / 2;

        // sort color
        var color = hex2rgb(graphicsData.fillStyle);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var triangles = earcut_1(points, holeArray, 2);

        if (!triangles) {
            return;
        }

        var vertPos = verts.length / 6;

        for (var _i = 0; _i < triangles.length; _i += 3) {
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i + 1] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
        }

        for (var _i2 = 0; _i2 < length; _i2++) {
            verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth > 0) {
        buildLine(graphicsData, webGLData);
    }
}

/**
 * Builds a rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildRectangle(graphicsData, webGLData) {
    // --- //
    // need to convert points to a nice regular data
    //
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;

    if (graphicsData.fill) {
        var color = hex2rgb(graphicsData.fillStyle);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length / 6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x, y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];

        buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}

/**
 * Builds a rounded rectangle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildRoundedRectangle(graphicsData, webGLData) {
    var rrectData = graphicsData.shape;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;

    var radius = rrectData.radius;

    var recPoints = [];

    recPoints.push(x, y + radius);
    quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
    quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
    quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
    quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);

    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
    // TODO - fix this properly, this is not very elegant.. but it works for now.

    if (graphicsData.fill) {
        var color = hex2rgb(graphicsData.fillStyle);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length / 6;

        var triangles = earcut_1(recPoints, null, 2);

        for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }

        for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {
            verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);
        }
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = recPoints;

        buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}

/**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {
    var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];

    var n = 20;
    var points = out;

    var xa = 0;
    var ya = 0;
    var xb = 0;
    var yb = 0;
    var x = 0;
    var y = 0;

    function getPt(n1, n2, perc) {
        var diff = n2 - n1;

        return n1 + diff * perc;
    }

    for (var i = 0, j = 0; i <= n; ++i) {
        j = i / n;

        // The Green Line
        xa = getPt(fromX, cpX, j);
        ya = getPt(fromY, cpY, j);
        xb = getPt(cpX, toX, j);
        yb = getPt(cpY, toY, j);

        // The Black Dot
        x = getPt(xa, xb, j);
        y = getPt(ya, yb, j);

        points.push(x, y);
    }

    return points;
}

/**
 * Builds a circle to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
 * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
 */
function buildCircle(graphicsData, webGLData) {

    // need to convert points to a nice regular data
    var circleData = graphicsData.shape;
    var x = circleData.x;
    var y = circleData.y;
    var width = void 0;
    var height = void 0;

    // TODO - bit hacky??
    if (graphicsData.type === SHAPES.CIRC) {
        width = circleData.radius;
        height = circleData.radius;
    } else {
        width = circleData.width;
        height = circleData.height;
    }

    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));

    var seg = Math.PI * 2 / totalSegs;

    if (graphicsData.fill) {
        var color = hex2rgb(graphicsData.fillStyle);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length / 6;

        indices.push(vecPos);

        for (var i = 0; i < totalSegs + 1; i++) {
            verts.push(x, y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos - 1);
    }

    if (graphicsData.lineWidth) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (var _i = 0; _i < totalSegs + 1; _i++) {
            graphicsData.points.push(x + Math.sin(seg * _i) * width, y + Math.cos(seg * _i) * height);
        }

        buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}

var GraphicsRenderer = function (_ObjectRenderer) {
    inherits(GraphicsRenderer, _ObjectRenderer);

    /**
     * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.
     */
    function GraphicsRenderer(renderer) {
        classCallCheck(this, GraphicsRenderer);

        var _this = possibleConstructorReturn(this, (GraphicsRenderer.__proto__ || Object.getPrototypeOf(GraphicsRenderer)).call(this, renderer));

        _this.graphicsDataPool = [];

        _this.primitiveShader = null;

        _this.gl = renderer.gl;

        // easy access!
        _this.CONTEXT_UID = 0;
        return _this;
    }

    /**
     * Called when there is a WebGL context change
     *
     * @private
     *
     */


    createClass(GraphicsRenderer, [{
        key: 'onContextChange',
        value: function onContextChange() {
            this.gl = this.renderer.gl;
            this.CONTEXT_UID = this.renderer.CONTEXT_UID;
            this.primitiveShader = new PrimitiveShader(this.gl);
        }

        /**
         * Destroys this renderer.
         *
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            ObjectRenderer.prototype.destroy.call(this);

            for (var i = 0; i < this.graphicsDataPool.length; ++i) {
                this.graphicsDataPool[i].destroy();
            }

            this.graphicsDataPool = null;
        }

        /**
         * Renders a graphics object.
         *
         * @param {PIXI.Graphics} graphics - The graphics object to render.
         */

    }, {
        key: 'render',
        value: function render(displayObject) {
            var graphics = displayObject.graphics;
            var renderer = this.renderer;
            var gl = renderer.gl;

            var webGLData = void 0;
            var webGL = graphics._webGL[this.CONTEXT_UID];

            if (!webGL || graphics.dirty !== webGL.dirty) {
                this.updateGraphics(graphics);

                webGL = graphics._webGL[this.CONTEXT_UID];
            }

            // This  could be speeded up for sure!
            var shader = this.primitiveShader;

            renderer.bindShader(shader);

            for (var i = 0, n = webGL.data.length; i < n; i++) {
                webGLData = webGL.data[i];
                var shaderTemp = webGLData.shader;

                renderer.bindShader(shaderTemp);

                var globalMatrix = displayObject.getConcatenatedMatrix().toArray(true);
                shaderTemp.uniforms.translationMatrix = globalMatrix;
                shaderTemp.uniforms.tint = hex2rgb(graphics.tint);
                shaderTemp.uniforms.alpha = graphics.worldAlpha;

                renderer.bindVao(webGLData.vao);
                webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);
            }
        }

        /**
         * Updates the graphics object
         *
         * @private
         * @param {PIXI.Graphics} graphics - The graphics object to update
         */

    }, {
        key: 'updateGraphics',
        value: function updateGraphics(graphics) {
            var gl = this.renderer.gl;

            // get the contexts graphics object
            var webGL = graphics._webGL[this.CONTEXT_UID];

            // if the graphics object does not exist in the webGL context time to create it!
            if (!webGL) {
                webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 };
            }

            // flag the graphics as not dirty as we are about to update it...
            webGL.dirty = graphics.dirty;

            // if the user cleared the graphics object we will need to clear every object
            if (graphics.clearDirty !== webGL.clearDirty) {
                webGL.clearDirty = graphics.clearDirty;

                // loop through and return all the webGLDatas to the object pool so than can be reused later on
                for (var i = 0; i < webGL.data.length; i++) {
                    this.graphicsDataPool.push(webGL.data[i]);
                }

                // clear the array and reset the index..
                webGL.data.length = 0;
                webGL.lastIndex = 0;
            }

            var webGLData = void 0;

            // loop through the graphics datas and construct each one..
            // if the object is a complex fill then the new stencil buffer technique will be used
            // other wise graphics objects will be pushed into a batch..
            for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {
                var data = graphics.graphicsData[_i];

                // TODO - this can be simplified
                webGLData = this.getWebGLData(webGL, 0);

                if (data.type === SHAPES.POLY) {
                    buildPoly(data, webGLData);
                }
                if (data.type === SHAPES.RECT) {
                    buildRectangle(data, webGLData);
                } else if (data.type === SHAPES.CIRC || data.type === SHAPES.ELIP) {
                    buildCircle(data, webGLData);
                } else if (data.type === SHAPES.RREC) {
                    buildRoundedRectangle(data, webGLData);
                }

                webGL.lastIndex++;
            }

            this.renderer.bindVao(null);

            // upload all the dirty data...
            for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {
                webGLData = webGL.data[_i2];

                if (webGLData.dirty) {
                    webGLData.upload();
                }
            }
        }

        /**
         *
         * @private
         * @param {WebGLRenderingContext} gl - the current WebGL drawing context
         * @param {number} type - TODO @Alvin
         * @return {*} TODO
         */

    }, {
        key: 'getWebGLData',
        value: function getWebGLData(gl, type) {
            var webGLData = gl.data[gl.data.length - 1];

            if (!webGLData || webGLData.points.length > 320000) {
                webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);

                webGLData.reset(type);
                gl.data.push(webGLData);
            }

            webGLData.dirty = true;

            return webGLData;
        }
    }]);
    return GraphicsRenderer;
}(ObjectRenderer);

var CONTEXT_UID = 0;

var WebGLStageRenderer = function () {
    function WebGLStageRenderer(stage, app) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck(this, WebGLStageRenderer);

        this.type = RENDERER_TYPE.WEBGL;
        this.width = app.width;
        this.height = app.height;
        this.canvas = stage.canvas;

        /*
        * 处理上下文丢失和恢复
        * 你的WebGL程序必须有一个用于处理上下文丢失（Lost Context）的机制
        * 导致上下文丢失的原因：
        * 移动设备电力不足
        * 其他外因导致GPU重置
        * 当浏览器标签页处于后台时，浏览器抛弃了上下文
        * 耗费资源过多，浏览器抛弃了上下文
        */
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        this.canvas.addEventListener('webglcontextlost', this.handleContextLost, false);
        this.canvas.addEventListener('webglcontextrestored', this.handleContextRestored, false);

        this._backgroundColor = 0x000000;
        this._backgroundColorRgba = [0, 0, 0, 0];
        this._backgroundColorString = '#000000';
        this.backgroundColor = options.backgroundColor || this._backgroundColor;

        this._contextOptions = {
            alpha: options.transparent,
            antialias: options.antialias,
            premultipliedAlpha: options.transparent && options.transparent !== 'notMultiplied',
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer
        };

        this.emptyRenderer = new ObjectRenderer(this);

        this.currentRenderer = this.emptyRenderer;

        this.gl = options.context || index.createContext(this.canvas, this._contextOptions);

        this.CONTEXT_UID = CONTEXT_UID++;

        this.state = new WebGLState(this.gl);

        this._activeShader = null;

        this._activeVao = null;

        this._activeRenderTarget = null;

        // map some webGL blend and drawmodes..
        this.drawModes = this.mapWebGLDrawModes();

        this.webglGR = new GraphicsRenderer(this);

        this._initContext();
    }

    /**
     * Creates the WebGL context
     *
     * @private
     */


    createClass(WebGLStageRenderer, [{
        key: '_initContext',
        value: function _initContext() {
            var gl = this.gl;

            // restore a context if it was previously lost
            if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
                gl.getExtension('WEBGL_lose_context').restoreContext();
            }

            this.state.resetToDefault();

            this.rootRenderTarget = new RenderTarget(gl, this.width, this.height, settings.RESOLUTION, true);
            this.rootRenderTarget.clearColor = this._backgroundColorRgba;

            this.bindRenderTarget(this.rootRenderTarget);

            this.webglGR.onContextChange();
        }
    }, {
        key: 'render',
        value: function render(displayObject) {

            if (!this.gl || this.gl.isContextLost()) {
                return;
            }

            this.currentRenderer.start();

            this._activeRenderTarget.clear();

            this.webglGR.render(displayObject);
            //displayObject.renderWebGL(this);

            // apply transform..
            this.currentRenderer.flush();
        }

        /**
         * Changes the current renderer to the one given in parameter
         *
         * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
         */

    }, {
        key: 'setObjectRenderer',
        value: function setObjectRenderer(objectRenderer) {
            if (this.currentRenderer === objectRenderer) {
                return;
            }

            this.currentRenderer.stop();
            this.currentRenderer = objectRenderer;
            this.currentRenderer.start();
        }

        /**
         * This should be called if you wish to do some custom rendering
         * It will basically render anything that may be batched up such as sprites
         *
         */

    }, {
        key: 'flush',
        value: function flush() {
            this.setObjectRenderer(this.emptyRenderer);
        }

        /**
         * Resizes the webGL view to the specified width and height.
         *
         * @param {number} width - the new width of the webGL view
         * @param {number} height - the new height of the webGL view
         */

    }, {
        key: 'resize',
        value: function resize(width, height) {
            //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;

            this.rootRenderTarget.resize(width, height);

            if (this._activeRenderTarget === this.rootRenderTarget) {
                this.rootRenderTarget.activate();

                if (this._activeShader) {
                    this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);
                }
            }
        }

        /**
         * Erases the active render target and fills the drawing area with a colour
         *
         * @param {number} [clearColor] - The colour
         */

    }, {
        key: 'clear',
        value: function clear(clearColor) {
            this._activeRenderTarget.clear(clearColor);
        }

        /**
         * Changes the current render target to the one given in parameter
         *
         * @param {PIXI.RenderTarget} renderTarget - the new render target
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

    }, {
        key: 'bindRenderTarget',
        value: function bindRenderTarget(renderTarget) {
            if (renderTarget !== this._activeRenderTarget) {
                this._activeRenderTarget = renderTarget;
                renderTarget.activate();

                if (this._activeShader) {
                    this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);
                }
            }
            return this;
        }

        /**
         * Changes the current shader to the one given in parameter
         *
         * @param {PIXI.Shader} shader - the new shader
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

    }, {
        key: 'bindShader',
        value: function bindShader(shader) {
            // TODO cache
            if (this._activeShader !== shader) {
                this._activeShader = shader;
                shader.bind();
                // automatically set the projection matrix
                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);
            }

            return this;
        }

        /**
         * Creates a new VAO from this renderer's context and state.
         *
         * @return {VertexArrayObject} The new VAO.
         */

    }, {
        key: 'createVao',
        value: function createVao() {
            return new index.VertexArrayObject(this.gl, this.state.attribState);
        }

        /**
         * Changes the current Vao to the one given in parameter
         *
         * @param {PIXI.VertexArrayObject} vao - the new Vao
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

    }, {
        key: 'bindVao',
        value: function bindVao(vao) {
            if (this._activeVao === vao) {
                return this;
            }

            if (vao) {
                vao.bind();
            } else if (this._activeVao) {
                // TODO this should always be true i think?
                this._activeVao.unbind();
            }

            this._activeVao = vao;

            return this;
        }

        /**
         * Resets the WebGL state so you can render things however you fancy!
         *
         * @return {PIXI.WebGLRenderer} Returns itself.
         */

    }, {
        key: 'reset',
        value: function reset() {
            this.setObjectRenderer(this.emptyRenderer);

            this._activeShader = null;
            this._activeRenderTarget = this.rootRenderTarget;

            // bind the main frame buffer (the screen);
            this.rootRenderTarget.activate();

            this.state.resetToDefault();

            return this;
        }

        /**
         * Handles a lost webgl context
         *
         * @private
         * @param {WebGLContextEvent} event - The context lost event.
         */

    }, {
        key: 'handleContextLost',
        value: function handleContextLost(event) {
            event.preventDefault();
        }

        /**
         * Handles a restored webgl context
         *
         * @private
         */

    }, {
        key: 'handleContextRestored',
        value: function handleContextRestored() {
            this._initContext();
            this.textureManager.removeAll();
        }
    }, {
        key: 'mapWebGLDrawModes',
        value: function mapWebGLDrawModes() {
            var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            object[DRAW_MODES.POINTS] = this.gl.POINTS;
            object[DRAW_MODES.LINES] = this.gl.LINES;
            object[DRAW_MODES.LINE_LOOP] = this.gl.LINE_LOOP;
            object[DRAW_MODES.LINE_STRIP] = this.gl.LINE_STRIP;
            object[DRAW_MODES.TRIANGLES] = this.gl.TRIANGLES;
            object[DRAW_MODES.TRIANGLE_STRIP] = this.gl.TRIANGLE_STRIP;
            object[DRAW_MODES.TRIANGLE_FAN] = this.gl.TRIANGLE_FAN;

            return object;
        }

        /**
         * Removes everything from the renderer (event listeners, spritebatch, etc...)
         *
         * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
         *  See: https://github.com/pixijs/pixi.js/issues/2233
         */

    }, {
        key: 'destroy',
        value: function destroy(removeView) {
            this.destroyPlugins();

            // remove listeners
            this.view.removeEventListener('webglcontextlost', this.handleContextLost);
            this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);

            // call base destroy
            get(WebGLStageRenderer.prototype.__proto__ || Object.getPrototypeOf(WebGLStageRenderer.prototype), 'destroy', this).call(this, removeView);

            this.uid = 0;

            this.currentRenderer = null;

            this.handleContextLost = null;
            this.handleContextRestored = null;

            this._contextOptions = null;
            this.gl.useProgram(null);

            if (this.gl.getExtension('WEBGL_lose_context')) {
                this.gl.getExtension('WEBGL_lose_context').loseContext();
            }

            this.gl = null;
        }
    }]);
    return WebGLStageRenderer;
}();

var WebGLRenderer = function (_SystemRenderer) {
    inherits(WebGLRenderer, _SystemRenderer);

    function WebGLRenderer(app) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        classCallCheck(this, WebGLRenderer);
        return possibleConstructorReturn(this, (WebGLRenderer.__proto__ || Object.getPrototypeOf(WebGLRenderer)).call(this, RENDERER_TYPE.CANVAS, app, options));
    }

    createClass(WebGLRenderer, [{
        key: 'render',
        value: function render(app) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var me = this;

            me.app = app;
            _$1.extend(this.options, options);

            _$1.each(_$1.values(app.convertStages), function (convertStage) {
                me.renderStage(convertStage.stage);
            });

            app.convertStages = {};
        }
    }, {
        key: 'renderStage',
        value: function renderStage(stage) {
            if (!stage.webGLStageRenderer) {
                stage.webGLStageRenderer = new WebGLStageRenderer(stage, app, this.options);
            }
            stage.stageRending = true;
            this._clear(stage);
            this._render(stage);
            stage.stageRending = false;
        }
    }, {
        key: '_render',
        value: function _render(stage, displayObject) {
            if (!displayObject) {
                displayObject = stage;
            }

            if (!displayObject.context.visible || displayObject.context.globalAlpha <= 0) {
                return;
            }

            if (displayObject.graphics) {
                stage.webGLStageRenderer.render(displayObject);
            }

            if (displayObject.children) {
                for (var i = 0, len = displayObject.children.length; i < len; i++) {
                    this._render(stage, displayObject.children[i]);
                }
            }
        }
    }, {
        key: '_clear',
        value: function _clear(stage) {
            stage.webGLStageRenderer.clear();
        }
    }]);
    return WebGLRenderer;
}(SystemRenderer);

function autoRenderer(app, options) {
    if (!app.noWebGL && Utils.isWebGLSupported()) {
        return new WebGLRenderer(app, options);
    }

    return new CanvasRenderer(app, options);
}

/**
 * Application {{PKG_VERSION}}
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 主引擎 类
 *
 * 负责所有canvas的层级管理，和心跳机制的实现,捕获到心跳包后 
 * 分发到对应的stage(canvas)来绘制对应的改动
 * 然后 默认有实现了shape的 mouseover  mouseout  drag 事件
 *
 **/

//utils
var Application = function Application(opt) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this.type = "canvax";
    this._cid = new Date().getTime() + "_" + Math.floor(Math.random() * 100);

    this.el = $.query(opt.el);

    this.width = parseInt("width" in opt || this.el.offsetWidth, 10);
    this.height = parseInt("height" in opt || this.el.offsetHeight, 10);

    var viewObj = $.createView(this.width, this.height, this._cid);
    this.view = viewObj.view;
    this.stage_c = viewObj.stage_c;
    this.dom_c = viewObj.dom_c;

    this.el.innerHTML = "";
    this.el.appendChild(this.view);

    this.viewOffset = $.offset(this.view);
    this.lastGetRO = 0; //最后一次获取 viewOffset 的时间

    this.noWebGL = opt.noWebGL;
    this.renderer = autoRenderer(this, options);

    this.event = null;

    this._bufferStage = null;

    //是否阻止浏览器默认事件的执行
    this.preventDefault = true;
    if (opt.preventDefault === false) {
        this.preventDefault = false;
    }

    //该属性在systenRender里面操作，每帧由心跳上报的 需要重绘的stages 列表
    this.convertStages = {};

    Application.superclass.constructor.apply(this, arguments);
};

Utils.creatClass(Application, DisplayObjectContainer, {
    init: function init() {
        this.context.width = this.width;
        this.context.height = this.height;

        //然后创建一个用于绘制激活 shape 的 stage 到activation
        this._creatHoverStage();

        //创建一个如果要用像素检测的时候的容器
        this._createPixelContext();
    },
    registEvent: function registEvent(opt) {
        //初始化事件委托到root元素上面
        this.event = new EventHandler(this, opt);
        this.event.init();
        return this.event;
    },
    resize: function resize(opt) {
        //重新设置坐标系统 高宽 等。
        this.width = parseInt(opt && "width" in opt || this.el.offsetWidth, 10);
        this.height = parseInt(opt && "height" in opt || this.el.offsetHeight, 10);

        this.view.style.width = this.width + "px";
        this.view.style.height = this.height + "px";

        this.viewOffset = $.offset(this.view);
        this._notWatch = true;
        this.context.width = this.width;
        this.context.height = this.height;
        this._notWatch = false;

        var me = this;
        var reSizeCanvas = function reSizeCanvas(ctx) {
            var canvas = ctx.canvas;
            canvas.style.width = me.width + "px";
            canvas.style.height = me.height + "px";
            canvas.setAttribute("width", me.width * Utils._devicePixelRatio);
            canvas.setAttribute("height", me.height * Utils._devicePixelRatio);

            //如果是swf的话就还要调用这个方法。
            if (ctx.resize) {
                ctx.resize(me.width, me.height);
            }
        };
        _$1.each(this.children, function (s, i) {
            s._notWatch = true;
            s.context.width = me.width;
            s.context.height = me.height;
            reSizeCanvas(s.canvas);
            s._notWatch = false;
        });

        this.dom_c.style.width = this.width + "px";
        this.dom_c.style.height = this.height + "px";

        this.heartBeat();
    },
    getHoverStage: function getHoverStage() {
        return this._bufferStage;
    },
    _creatHoverStage: function _creatHoverStage() {
        //TODO:创建stage的时候一定要传入width height  两个参数
        this._bufferStage = new Stage({
            id: "activCanvas" + new Date().getTime(),
            context: {
                width: this.context.width,
                height: this.context.height
            }
        });
        //该stage不参与事件检测
        this._bufferStage._eventEnabled = false;
        this.addChild(this._bufferStage);
    },
    /**
     * 用来检测文本width height 
     * @return {Object} 上下文
    */
    _createPixelContext: function _createPixelContext() {
        var _pixelCanvas = $.query("_pixelCanvas");
        if (!_pixelCanvas) {
            _pixelCanvas = $.createCanvas(0, 0, "_pixelCanvas");
        } else {
            //如果又的话 就不需要在创建了
            return;
        }
        document.body.appendChild(_pixelCanvas);
        Utils.initElement(_pixelCanvas);
        if (Utils.canvasSupport()) {
            //canvas的话，哪怕是display:none的页可以用来左像素检测和measureText文本width检测
            _pixelCanvas.style.display = "none";
        } else {
            //flashCanvas 的话，swf如果display:none了。就做不了measureText 文本宽度 检测了
            _pixelCanvas.style.zIndex = -1;
            _pixelCanvas.style.position = "absolute";
            _pixelCanvas.style.left = -this.context.width + "px";
            _pixelCanvas.style.top = -this.context.height + "px";
            _pixelCanvas.style.visibility = "hidden";
        }
        Utils._pixelCtx = _pixelCanvas.getContext('2d');
    },

    updateViewOffset: function updateViewOffset() {
        var now = new Date().getTime();
        if (now - this.lastGetRO > 1000) {
            this.viewOffset = $.offset(this.view);
            this.lastGetRO = now;
        }
    },

    _afterAddChild: function _afterAddChild(stage, index) {
        var canvas;

        if (!stage.canvas) {
            canvas = $.createCanvas(this.context.width, this.context.height, stage.id);
        } else {
            canvas = stage.canvas;
        }

        if (this.children.length == 1) {
            this.stage_c.appendChild(canvas);
        } else if (this.children.length > 1) {
            if (index == undefined) {
                //如果没有指定位置，那么就放到_bufferStage的下面。
                this.stage_c.insertBefore(canvas, this._bufferStage.canvas);
            } else {
                //如果有指定的位置，那么就指定的位置来
                if (index >= this.children.length - 1) {
                    this.stage_c.appendChild(canvas);
                } else {
                    this.stage_c.insertBefore(canvas, this.children[index].canvas);
                }
            }
        }

        Utils.initElement(canvas);
        stage.initStage(canvas, this.context.width, this.context.height);
    },
    _afterDelChild: function _afterDelChild(stage) {
        this.stage_c.removeChild(stage.canvas);
    },

    heartBeat: function heartBeat(opt) {
        this.renderer.heartBeat(opt);
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3 中 的sprite类，目前还只是个简单的容易。
 */
var Sprite = function Sprite() {
    this.type = "sprite";
    Sprite.superclass.constructor.apply(this, arguments);
};

Utils.creatClass(Sprite, DisplayObjectContainer, {
    init: function init() {}
});

var GraphicsData = function () {
    function GraphicsData(lineWidth, strokeStyle, lineAlpha, fillStyle, fillAlpha, shape) {
        classCallCheck(this, GraphicsData);

        this.lineWidth = lineWidth;
        this.strokeStyle = strokeStyle;
        this.lineAlpha = lineAlpha;

        this.fillStyle = fillStyle;
        this.fillAlpha = fillAlpha;

        this.shape = shape;
        this.type = shape.type;

        this.holes = [];

        //这两个可以被后续修改， 具有一票否决权
        //比如polygon的 虚线描边。必须在fill的poly上面设置line为false
        this.fill = true;
        this.line = true;
    }

    createClass(GraphicsData, [{
        key: "clone",
        value: function clone() {
            return new GraphicsData(this.lineWidth, this.strokeStyle, this.lineAlpha, this.fillStyle, this.fillAlpha, this.shape);
        }
    }, {
        key: "addHole",
        value: function addHole(shape) {
            this.holes.push(shape);
        }

        //从宿主graphics中同步最新的style属性

    }, {
        key: "synsStyle",
        value: function synsStyle(graphics) {
            //从shape中把绘图需要的style属性同步过来
            this.lineWidth = graphics.lineWidth;
            this.strokeStyle = graphics.strokeStyle;
            this.lineAlpha = graphics.lineAlpha;

            this.fillStyle = graphics.fillStyle;
            this.fillAlpha = graphics.fillAlpha;
        }
    }, {
        key: "hasFill",
        value: function hasFill() {
            return this.fillStyle && this.fill && this.shape.closed !== undefined && this.shape.closed && this.fillAlpha;
        }
    }, {
        key: "hasLine",
        value: function hasLine() {
            return this.strokeStyle && this.lineWidth && this.lineAlpha && this.line;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.shape = null;
            this.holes = null;
        }
    }]);
    return GraphicsData;
}();

/**
 * Calculate the points for a bezier curve and then draws it.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @param {number} fromX - Starting point x
 * @param {number} fromY - Starting point y
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} cpX2 - Second Control point x
 * @param {number} cpY2 - Second Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [path=[]] - Path array to push points into
 * @return {number[]} Array of points of the curve
 */
function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    var path = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];

    var n = 20;
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;

    path.push(fromX, fromY);

    for (var i = 1, j = 0; i <= n; ++i) {
        j = i / n;

        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }

    return path;
}

/**
 * 线段包含判断
 * @points [0,0,0,0]
 */
var _isInsideLine = function _isInsideLine(points, x, y, lineWidth) {
    var x0 = points[0];
    var y0 = points[1];
    var x1 = points[2];
    var y1 = points[3];
    var _l = Math.max(lineWidth, 3);
    var _a = 0;
    var _b = x0;

    if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
        return false;
    }

    if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    } else {
        return Math.abs(x - x0) <= _l / 2;
    }

    var _s = (_a * x - y + _b) * (_a * x - y + _b) / (_a * _a + 1);
    return _s <= _l / 2 * _l / 2;
};

function insideLine(data, x, y, line) {
    var points = data.shape.points;
    var lineWidth = data.lineWidth;
    var insideCatch = false;
    for (var i = 0; i < points.length; ++i) {
        insideCatch = _isInsideLine(points.slice(i, i + 4), x, y, lineWidth);
        if (insideCatch) {
            break;
        }
        i += 1;
    }
    return insideCatch;
}

/*
* Graphics绘图法则
* 单个grahics实例里的fill line 样式属性，都从对应shape.context中获取
* 
*/

var Graphics = function () {
    function Graphics(shape) {
        classCallCheck(this, Graphics);

        this.shape = shape;

        this.lineWidth = 1;
        this.strokeStyle = null;
        this.lineAlpha = 1;
        this.fillStyle = null;
        this.fillAlpha = 1;

        this.graphicsData = [];
        this.currentPath = null;

        this.synsStyle();

        this.dirty = 0; //脏数据
        this._webGL = {};
        this.worldAlpha = 1;
        this.tint = 0xFFFFFF; //目标对象附加颜色
    }

    createClass(Graphics, [{
        key: 'synsStyle',
        value: function synsStyle() {
            //从shape中把绘图需要的style属性同步过来
            var sctx = this.shape.context;
            this.lineWidth = sctx.lineWidth;
            this.strokeStyle = sctx.strokeStyle;
            this.lineAlpha = sctx.lineAlpha * sctx.globalAlpha;

            this.fillStyle = sctx.fillStyle;
            this.fillAlpha = sctx.fillAlpha * sctx.globalAlpha;

            //如果graphicsData有多分组的情况下，如果以为shape的 style 属性改变调用的synsStyle
            //则会覆盖全部的 graphicsData 元素
            for (var i = 0; i < this.graphicsData.length; ++i) {
                this.graphicsData[i].synsStyle(this);
            }
        }
    }, {
        key: 'clone',
        value: function clone() {
            var clone = new Graphics();

            clone.dirty = 0;

            // copy graphics data
            for (var i = 0; i < this.graphicsData.length; ++i) {
                clone.graphicsData.push(this.graphicsData[i].clone());
            }

            clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];
            return clone;
        }
    }, {
        key: 'moveTo',
        value: function moveTo(x, y) {
            var shape = new Polygon([x, y]);

            shape.closed = false;
            this.drawShape(shape);

            return this;
        }
    }, {
        key: 'lineTo',
        value: function lineTo(x, y) {
            if (this.currentPath) {
                this.currentPath.shape.points.push(x, y);
                this.dirty++;
            } else {
                this.moveTo(0, 0);
            }
            return this;
        }
    }, {
        key: 'quadraticCurveTo',
        value: function quadraticCurveTo(cpX, cpY, toX, toY) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points = [0, 0];
                }
            } else {
                this.moveTo(0, 0);
            }

            var n = 20;
            var points = this.currentPath.shape.points;
            var xa = 0;
            var ya = 0;

            if (points.length === 0) {
                this.moveTo(0, 0);
            }

            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];

            for (var i = 1; i <= n; ++i) {
                var j = i / n;

                xa = fromX + (cpX - fromX) * j;
                ya = fromY + (cpY - fromY) * j;

                points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
            }

            this.dirty++;

            return this;
        }
    }, {
        key: 'bezierCurveTo',
        value: function bezierCurveTo$$1(cpX, cpY, cpX2, cpY2, toX, toY) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points = [0, 0];
                }
            } else {
                this.moveTo(0, 0);
            }

            var points = this.currentPath.shape.points;

            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];

            points.length -= 2;

            bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);

            this.dirty++;

            return this;
        }
    }, {
        key: 'arcTo',
        value: function arcTo(x1, y1, x2, y2, radius) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points.push(x1, y1);
                }
            } else {
                this.moveTo(x1, y1);
            }

            var points = this.currentPath.shape.points;
            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];
            var a1 = fromY - y1;
            var b1 = fromX - x1;
            var a2 = y2 - y1;
            var b2 = x2 - x1;
            var mm = Math.abs(a1 * b2 - b1 * a2);

            if (mm < 1.0e-8 || radius === 0) {
                if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                    points.push(x1, y1);
                }
            } else {
                var dd = a1 * a1 + b1 * b1;
                var cc = a2 * a2 + b2 * b2;
                var tt = a1 * a2 + b1 * b2;
                var k1 = radius * Math.sqrt(dd) / mm;
                var k2 = radius * Math.sqrt(cc) / mm;
                var j1 = k1 * tt / dd;
                var j2 = k2 * tt / cc;
                var cx = k1 * b2 + k2 * b1;
                var cy = k1 * a2 + k2 * a1;
                var px = b1 * (k2 + j1);
                var py = a1 * (k2 + j1);
                var qx = b2 * (k1 + j2);
                var qy = a2 * (k1 + j2);
                var startAngle = Math.atan2(py - cy, px - cx);
                var endAngle = Math.atan2(qy - cy, qx - cx);

                this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
            }

            this.dirty++;

            return this;
        }
    }, {
        key: 'arc',
        value: function arc(cx, cy, radius, startAngle, endAngle) {
            var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

            if (startAngle === endAngle) {
                return this;
            }

            if (!anticlockwise && endAngle <= startAngle) {
                endAngle += Math.PI * 2;
            } else if (anticlockwise && startAngle <= endAngle) {
                startAngle += Math.PI * 2;
            }

            var sweep = endAngle - startAngle;
            var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;

            if (sweep === 0) {
                return this;
            }

            var startX = cx + Math.cos(startAngle) * radius;
            var startY = cy + Math.sin(startAngle) * radius;

            // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
            var points = this.currentPath ? this.currentPath.shape.points : null;

            if (points) {
                if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
                    points.push(startX, startY);
                }
            } else {
                this.moveTo(startX, startY);
                points = this.currentPath.shape.points;
            }

            var theta = sweep / (segs * 2);
            var theta2 = theta * 2;

            var cTheta = Math.cos(theta);
            var sTheta = Math.sin(theta);

            var segMinus = segs - 1;

            var remainder = segMinus % 1 / segMinus;

            for (var i = 0; i <= segMinus; ++i) {
                var real = i + remainder * i;

                var angle = theta + startAngle + theta2 * real;

                var c = Math.cos(angle);
                var s = -Math.sin(angle);

                points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
            }

            this.dirty++;

            return this;
        }
    }, {
        key: 'drawRect',
        value: function drawRect(x, y, width, height) {
            this.drawShape(new Rectangle(x, y, width, height));
            return this;
        }
    }, {
        key: 'drawCircle',
        value: function drawCircle(x, y, radius) {
            this.drawShape(new Circle(x, y, radius));

            return this;
        }
    }, {
        key: 'drawEllipse',
        value: function drawEllipse(x, y, width, height) {
            this.drawShape(new Ellipse(x, y, width, height));

            return this;
        }
    }, {
        key: 'drawPolygon',
        value: function drawPolygon(path) {
            // prevents an argument assignment deopt
            // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            var points = path;

            var closed = true;

            if (points instanceof Polygon) {
                closed = points.closed;
                points = points.points;
            }

            if (!Array.isArray(points)) {
                // prevents an argument leak deopt
                // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
                points = new Array(arguments.length);

                for (var i = 0; i < points.length; ++i) {
                    points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
                }
            }

            var shape = new Polygon(points);

            shape.closed = closed;

            this.drawShape(shape);

            return this;
        }
    }, {
        key: 'clear',
        value: function clear() {
            if (this.graphicsData.length > 0) {
                this.dirty++;
                this.graphicsData.length = 0;
            }

            this.currentPath = null;

            return this;
        }
    }, {
        key: 'drawShape',
        value: function drawShape(shape) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length <= 2) {
                    this.graphicsData.pop();
                }
            }

            this.currentPath = null;

            var data = new GraphicsData(this.lineWidth, this.strokeStyle, this.lineAlpha, this.fillStyle, this.fillAlpha, shape);

            this.graphicsData.push(data);

            if (data.type === SHAPES.POLY) {
                data.shape.closed = data.shape.closed;
                this.currentPath = data;
            }

            this.dirty++;

            return data;
        }
    }, {
        key: 'closePath',
        value: function closePath() {
            var currentPath = this.currentPath;

            if (currentPath && currentPath.shape) {
                currentPath.shape.close();
            }

            return this;
        }

        /**
         * Tests if a point is inside this graphics object
         *
         * @param {PIXI.Point} point - the point to test
         * @return {boolean} the result of the test
         */

    }, {
        key: 'containsPoint',
        value: function containsPoint(point) {
            var graphicsData = this.graphicsData;
            var inside = false;
            for (var i = 0; i < graphicsData.length; ++i) {
                var data = graphicsData[i];
                if (data.shape) {
                    //先检测fill， fill的检测概率大些。
                    //像circle,ellipse这样的shape 就直接把lineWidth算在fill里面计算就好了，所以他们是没有insideLine的
                    if (data.hasFill() && data.shape.contains(point.x, point.y)) {
                        inside = true;
                        if (inside) {
                            break;
                        }
                    }

                    //circle,ellipse等就没有points
                    if (data.hasLine() && data.shape.points) {
                        //然后检测是否和描边碰撞
                        inside = insideLine(data, point.x, point.y);
                        if (inside) {
                            break;
                        }
                    }
                }
            }

            return inside;
        }

        /**
        * Update the bounds of the object
        *
        */

    }, {
        key: 'updateLocalBounds',
        value: function updateLocalBounds() {
            var minX = Infinity;
            var maxX = -Infinity;

            var minY = Infinity;
            var maxY = -Infinity;

            if (this.graphicsData.length) {
                var shape = 0;
                var x = 0;
                var y = 0;
                var w = 0;
                var h = 0;

                for (var i = 0; i < this.graphicsData.length; i++) {
                    var data = this.graphicsData[i];
                    var type = data.type;
                    var lineWidth = data.lineWidth;

                    shape = data.shape;

                    if (type === SHAPES.RECT || type === SHAPES.RREC) {
                        x = shape.x - lineWidth / 2;
                        y = shape.y - lineWidth / 2;
                        w = shape.width + lineWidth;
                        h = shape.height + lineWidth;

                        minX = x < minX ? x : minX;
                        maxX = x + w > maxX ? x + w : maxX;

                        minY = y < minY ? y : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else if (type === SHAPES.CIRC) {
                        x = shape.x;
                        y = shape.y;
                        w = shape.radius + lineWidth / 2;
                        h = shape.radius + lineWidth / 2;

                        minX = x - w < minX ? x - w : minX;
                        maxX = x + w > maxX ? x + w : maxX;

                        minY = y - h < minY ? y - h : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else if (type === SHAPES.ELIP) {
                        x = shape.x;
                        y = shape.y;
                        w = shape.width + lineWidth / 2;
                        h = shape.height + lineWidth / 2;

                        minX = x - w < minX ? x - w : minX;
                        maxX = x + w > maxX ? x + w : maxX;

                        minY = y - h < minY ? y - h : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else {
                        // POLY
                        var points = shape.points;
                        var x2 = 0;
                        var y2 = 0;
                        var dx = 0;
                        var dy = 0;
                        var rw = 0;
                        var rh = 0;
                        var cx = 0;
                        var cy = 0;

                        for (var j = 0; j + 2 < points.length; j += 2) {
                            x = points[j];
                            y = points[j + 1];
                            x2 = points[j + 2];
                            y2 = points[j + 3];
                            dx = Math.abs(x2 - x);
                            dy = Math.abs(y2 - y);
                            h = lineWidth;
                            w = Math.sqrt(dx * dx + dy * dy);

                            if (w < 1e-9) {
                                continue;
                            }

                            rw = (h / w * dy + dx) / 2;
                            rh = (h / w * dx + dy) / 2;
                            cx = (x2 + x) / 2;
                            cy = (y2 + y) / 2;

                            minX = cx - rw < minX ? cx - rw : minX;
                            maxX = cx + rw > maxX ? cx + rw : maxX;

                            minY = cy - rh < minY ? cy - rh : minY;
                            maxY = cy + rh > maxY ? cy + rh : maxY;
                        }
                    }
                }
            } else {
                minX = 0;
                maxX = 0;
                minY = 0;
                maxY = 0;
            }

            this.Bound.minX = minX;
            this.Bound.maxX = maxX;

            this.Bound.minY = minY;
            this.Bound.maxY = maxY;
        }
    }, {
        key: 'destroy',
        value: function destroy(options) {
            get(Graphics.prototype.__proto__ || Object.getPrototypeOf(Graphics.prototype), 'destroy', this).call(this, options);

            for (var i = 0; i < this.graphicsData.length; ++i) {
                this.graphicsData[i].destroy();
            }
            for (var id in this._webgl) {
                for (var j = 0; j < this._webgl[id].data.length; ++j) {
                    this._webgl[id].data[j].destroy();
                }
            }

            this.graphicsData = null;
            this.currentPath = null;
            this._webgl = null;
        }
    }]);
    return Graphics;
}();

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3 DisplayList 中的shape 类
 */
var Shape = function (_DisplayObject) {
    inherits(Shape, _DisplayObject);

    function Shape(opt) {
        classCallCheck(this, Shape);


        opt = Utils.checkOpt(opt);
        var _context = _$1.extend(_$1.clone(SHAPE_CONTEXT_DEFAULT), opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this, opt));

        _this.graphics = new Graphics(_this);

        //元素是否有hover事件 和 chick事件，由addEvenetLister和remiveEventLister来触发修改
        _this._hoverable = false;
        _this._clickable = false;

        //over的时候如果有修改样式，就为true
        _this._hoverClass = false;
        _this.hoverClone = true; //是否开启在hover的时候clone一份到active stage 中 
        _this.pointChkPriority = true; //在鼠标mouseover到该节点，然后mousemove的时候，是否优先检测该节点

        //拖拽drag的时候显示在activShape的副本
        _this._dragDuplicate = null;

        //元素是否 开启 drag 拖动，这个有用户设置传入
        //self.draggable = opt.draggable || false;

        _this.type = _this.type || "shape";
        opt.draw && (_this.draw = opt.draw);

        //处理所有的图形一些共有的属性配置,把除开id,context之外的所有属性，全部挂载到this上面
        _this.initCompProperty(opt);

        _this._rect = null;
        return _this;
    }

    createClass(Shape, [{
        key: "init",
        value: function init() {}
    }, {
        key: "draw",
        value: function draw() {}
    }, {
        key: "initCompProperty",
        value: function initCompProperty(opt) {
            for (var i in opt) {
                if (i != "id" && i != "context") {
                    this[i] = opt[i];
                }
            }
        }

        /*
         * 画虚线
         */

    }, {
        key: "dashedLineTo",
        value: function dashedLineTo(x1, y1, x2, y2, dashLength) {
            dashLength = typeof dashLength == 'undefined' ? 3 : dashLength;
            dashLength = Math.max(dashLength, this.context.lineWidth);
            var deltaX = x2 - x1;
            var deltaY = y2 - y1;
            var numDashes = Math.floor(Math.sqrt(deltaX * deltaX + deltaY * deltaY) / dashLength);
            for (var i = 0; i < numDashes; ++i) {
                var x = parseInt(x1 + deltaX / numDashes * i);
                var y = parseInt(y1 + deltaY / numDashes * i);
                this.graphics[i % 2 === 0 ? 'moveTo' : 'lineTo'](x, y);
                if (i == numDashes - 1 && i % 2 === 0) {
                    this.graphics.lineTo(x2, y2);
                }
            }
        }

        /*
         *从cpl节点中获取到4个方向的边界节点
         *@param  context 
         *
         **/

    }, {
        key: "getRectFormPointList",
        value: function getRectFormPointList(context) {
            var minX = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var minY = Number.MAX_VALUE;
            var maxY = Number.MIN_VALUE;

            var cpl = context.pointList; //this.getcpl();
            for (var i = 0, l = cpl.length; i < l; i++) {
                if (cpl[i][0] < minX) {
                    minX = cpl[i][0];
                }
                if (cpl[i][0] > maxX) {
                    maxX = cpl[i][0];
                }
                if (cpl[i][1] < minY) {
                    minY = cpl[i][1];
                }
                if (cpl[i][1] > maxY) {
                    maxY = cpl[i][1];
                }
            }

            var lineWidth;
            if (context.strokeStyle || context.fillStyle) {
                lineWidth = context.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            return {
                x: Math.round(minX - lineWidth / 2),
                y: Math.round(minY - lineWidth / 2),
                width: maxX - minX + lineWidth,
                height: maxY - minY + lineWidth
            };
        }
    }]);
    return Shape;
}(DisplayObject);

/**
 * Canvax--Text
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 文本 类
 **/
var Text = function Text(text, opt) {
    var self = this;
    self.type = "text";
    self._reNewline = /\r?\n/;
    self.fontProperts = ["fontStyle", "fontVariant", "fontWeight", "fontSize", "fontFamily"];

    //做一次简单的opt参数校验，保证在用户不传opt的时候 或者传了opt但是里面没有context的时候报错
    opt = Utils.checkOpt(opt);

    self._context = _$1.extend({
        fontSize: 13, //字体大小默认13
        fontWeight: "normal",
        fontFamily: "微软雅黑,sans-serif",
        textDecoration: null,
        fillStyle: 'blank',
        strokeStyle: null,
        lineWidth: 0,
        lineHeight: 1.2,
        backgroundColor: null,
        textBackgroundColor: null
    }, opt.context);

    self._context.font = self._getFontDeclaration();

    self.text = text.toString();

    Text.superclass.constructor.apply(this, [opt]);
};

Utils.creatClass(Text, DisplayObject, {
    $watch: function $watch(name, value, preValue) {
        //context属性有变化的监听函数
        if (_$1.indexOf(this.fontProperts, name) >= 0) {
            this._context[name] = value;
            //如果修改的是font的某个内容，就重新组装一遍font的值，
            //然后通知引擎这次对context的修改不需要上报心跳
            this._notWatch = false;
            this.context.font = this._getFontDeclaration();
            this.context.width = this.getTextWidth();
            this.context.height = this.getTextHeight();
        }
    },
    init: function init(text, opt) {
        var self = this;
        var c = this.context;
        c.width = this.getTextWidth();
        c.height = this.getTextHeight();
    },
    render: function render(ctx) {
        for (var p in this.context.$model) {
            if (p in ctx) {
                if (p != "textBaseline" && this.context.$model[p]) {
                    ctx[p] = this.context.$model[p];
                }
            }
        }
        this._renderText(ctx, this._getTextLines());
    },
    resetText: function resetText(text) {
        this.text = text.toString();
        this.heartBeat();
    },
    getTextWidth: function getTextWidth() {
        var width = 0;
        Utils._pixelCtx.save();
        Utils._pixelCtx.font = this.context.font;
        width = this._getTextWidth(Utils._pixelCtx, this._getTextLines());
        Utils._pixelCtx.restore();
        return width;
    },
    getTextHeight: function getTextHeight() {
        return this._getTextHeight(Utils._pixelCtx, this._getTextLines());
    },
    _getTextLines: function _getTextLines() {
        return this.text.split(this._reNewline);
    },
    _renderText: function _renderText(ctx, textLines) {
        ctx.save();
        this._renderTextStroke(ctx, textLines);
        this._renderTextFill(ctx, textLines);
        ctx.restore();
    },
    _getFontDeclaration: function _getFontDeclaration() {
        var self = this;
        var fontArr = [];

        _$1.each(this.fontProperts, function (p) {
            var fontP = self._context[p];
            if (p == "fontSize") {
                fontP = parseFloat(fontP) + "px";
            }
            fontP && fontArr.push(fontP);
        });

        return fontArr.join(' ');
    },
    _renderTextFill: function _renderTextFill(ctx, textLines) {
        if (!this.context.fillStyle) return;

        this._boundaries = [];
        var lineHeights = 0;

        for (var i = 0, len = textLines.length; i < len; i++) {
            var heightOfLine = this._getHeightOfLine(ctx, i, textLines);
            lineHeights += heightOfLine;

            this._renderTextLine('fillText', ctx, textLines[i], 0, //this._getLeftOffset(),
            this._getTopOffset() + lineHeights, i);
        }
    },
    _renderTextStroke: function _renderTextStroke(ctx, textLines) {
        if (!this.context.strokeStyle || !this.context.lineWidth) return;

        var lineHeights = 0;

        ctx.save();
        if (this.strokeDashArray) {
            if (1 & this.strokeDashArray.length) {
                this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);
            }
            supportsLineDash && ctx.setLineDash(this.strokeDashArray);
        }

        ctx.beginPath();
        for (var i = 0, len = textLines.length; i < len; i++) {
            var heightOfLine = this._getHeightOfLine(ctx, i, textLines);
            lineHeights += heightOfLine;

            this._renderTextLine('strokeText', ctx, textLines[i], 0, //this._getLeftOffset(),
            this._getTopOffset() + lineHeights, i);
        }
        ctx.closePath();
        ctx.restore();
    },
    _renderTextLine: function _renderTextLine(method, ctx, line, left, top, lineIndex) {
        top -= this._getHeightOfLine() / 4;
        if (this.context.textAlign !== 'justify') {
            this._renderChars(method, ctx, line, left, top, lineIndex);
            return;
        }
        var lineWidth = ctx.measureText(line).width;
        var totalWidth = this.context.width;

        if (totalWidth > lineWidth) {
            var words = line.split(/\s+/);
            var wordsWidth = ctx.measureText(line.replace(/\s+/g, '')).width;
            var widthDiff = totalWidth - wordsWidth;
            var numSpaces = words.length - 1;
            var spaceWidth = widthDiff / numSpaces;

            var leftOffset = 0;
            for (var i = 0, len = words.length; i < len; i++) {
                this._renderChars(method, ctx, words[i], left + leftOffset, top, lineIndex);
                leftOffset += ctx.measureText(words[i]).width + spaceWidth;
            }
        } else {
            this._renderChars(method, ctx, line, left, top, lineIndex);
        }
    },
    _renderChars: function _renderChars(method, ctx, chars, left, top) {
        ctx[method](chars, 0, top);
    },
    _getHeightOfLine: function _getHeightOfLine() {
        return this.context.fontSize * this.context.lineHeight;
    },
    _getTextWidth: function _getTextWidth(ctx, textLines) {
        var maxWidth = ctx.measureText(textLines[0] || '|').width;
        for (var i = 1, len = textLines.length; i < len; i++) {
            var currentLineWidth = ctx.measureText(textLines[i]).width;
            if (currentLineWidth > maxWidth) {
                maxWidth = currentLineWidth;
            }
        }
        return maxWidth;
    },
    _getTextHeight: function _getTextHeight(ctx, textLines) {
        return this.context.fontSize * textLines.length * this.context.lineHeight;
    },

    /**
     * @private
     * @return {Number} Top offset
     */
    _getTopOffset: function _getTopOffset() {
        var t = 0;
        switch (this.context.textBaseline) {
            case "top":
                t = 0;
                break;
            case "middle":
                t = -this.context.height / 2;
                break;
            case "bottom":
                t = -this.context.height;
                break;
        }
        return t;
    },
    getRect: function getRect() {
        var c = this.context;
        var x = 0;
        var y = 0;
        //更具textAlign 和 textBaseline 重新矫正 xy
        if (c.textAlign == "center") {
            x = -c.width / 2;
        }
        if (c.textAlign == "right") {
            x = -c.width;
        }
        if (c.textBaseline == "middle") {
            y = -c.height / 2;
        }
        if (c.textBaseline == "bottom") {
            y = -c.height;
        }

        return {
            x: x,
            y: y,
            width: c.width,
            height: c.height
        };
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 向量操作类
 * */
function Vector(x, y) {
    var vx = 0,
        vy = 0;
    if (arguments.length == 1 && _$1.isObject(x)) {
        var arg = arguments[0];
        if (_$1.isArray(arg)) {
            vx = arg[0];
            vy = arg[1];
        } else if (arg.hasOwnProperty("x") && arg.hasOwnProperty("y")) {
            vx = arg.x;
            vy = arg.y;
        }
    }
    this._axes = [vx, vy];
}
Vector.prototype = {
    distance: function distance(v) {
        var x = this._axes[0] - v._axes[0];
        var y = this._axes[1] - v._axes[1];

        return Math.sqrt(x * x + y * y);
    }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 处理为平滑线条
 */
/**
 * @inner
 */
function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.25;
    var v1 = (p3 - p1) * 0.25;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}
/**
 * 多线段平滑曲线 
 * opt ==> points , isLoop
 */
var SmoothSpline = function (opt) {
    var points = opt.points;
    var isLoop = opt.isLoop;
    var smoothFilter = opt.smoothFilter;

    var len = points.length;
    if (len == 1) {
        return points;
    }
    var ret = [];
    var distance = 0;
    var preVertor = new Vector(points[0]);
    var iVtor = null;
    for (var i = 1; i < len; i++) {
        iVtor = new Vector(points[i]);
        distance += preVertor.distance(iVtor);
        preVertor = iVtor;
    }

    preVertor = null;
    iVtor = null;

    //基本上等于曲率
    var segs = distance / 6;

    segs = segs < len ? len : segs;
    for (var i = 0; i < segs; i++) {
        var pos = i / (segs - 1) * (isLoop ? len : len - 1);
        var idx = Math.floor(pos);

        var w = pos - idx;

        var p0;
        var p1 = points[idx % len];
        var p2;
        var p3;
        if (!isLoop) {
            p0 = points[idx === 0 ? idx : idx - 1];
            p2 = points[idx > len - 2 ? len - 1 : idx + 1];
            p3 = points[idx > len - 3 ? len - 1 : idx + 2];
        } else {
            p0 = points[(idx - 1 + len) % len];
            p2 = points[(idx + 1) % len];
            p3 = points[(idx + 2) % len];
        }

        var w2 = w * w;
        var w3 = w * w2;

        var rp = [interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)];

        _$1.isFunction(smoothFilter) && smoothFilter(rp);

        ret.push(rp);
    }
    return ret;
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 数学 类
 *
 **/

var _cache = {
    sin: {}, //sin缓存
    cos: {} //cos缓存
};
var _radians = Math.PI / 180;

/**
 * @param angle 弧度（角度）参数
 * @param isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
 */
function sin(angle, isDegrees) {
    angle = (isDegrees ? angle * _radians : angle).toFixed(4);
    if (typeof _cache.sin[angle] == 'undefined') {
        _cache.sin[angle] = Math.sin(angle);
    }
    return _cache.sin[angle];
}

/**
 * @param radians 弧度参数
 */
function cos(angle, isDegrees) {
    angle = (isDegrees ? angle * _radians : angle).toFixed(4);
    if (typeof _cache.cos[angle] == 'undefined') {
        _cache.cos[angle] = Math.cos(angle);
    }
    return _cache.cos[angle];
}

/**
 * 角度转弧度
 * @param {Object} angle
 */
function degreeToRadian(angle) {
    return angle * _radians;
}

/**
 * 弧度转角度
 * @param {Object} angle
 */
function radianToDegree(angle) {
    return angle / _radians;
}

/*
 * 校验角度到360度内
 * @param {angle} number
 */
function degreeTo360(angle) {
    var reAng = (360 + angle % 360) % 360; //Math.abs(360 + Math.ceil( angle ) % 360) % 360;
    if (reAng == 0 && angle !== 0) {
        reAng = 360;
    }
    return reAng;
}

function getIsgonPointList(n, r) {
    var pointList = [];
    var dStep = 2 * Math.PI / n;
    var beginDeg = -Math.PI / 2;
    var deg = beginDeg;
    for (var i = 0, end = n; i < end; i++) {
        pointList.push([r * Math.cos(deg), r * Math.sin(deg)]);
        deg += dStep;
    }
    return pointList;
}

function getSmoothPointList(pList, smoothFilter) {
    //smoothFilter -- 比如在折线图中。会传一个smoothFilter过来做point的纠正。
    //让y不能超过底部的原点
    var obj = {
        points: pList
    };
    if (_.isFunction(smoothFilter)) {
        obj.smoothFilter = smoothFilter;
    }

    var currL = SmoothSpline(obj);
    if (pList && pList.length > 0) {
        currL.push(pList[pList.length - 1]);
    }

    return currL;
}

var myMath = {
    PI: Math.PI,
    sin: sin,
    cos: cos,
    degreeToRadian: degreeToRadian,
    radianToDegree: radianToDegree,
    degreeTo360: degreeTo360,
    getIsgonPointList: getIsgonPointList,
    getSmoothPointList: getSmoothPointList
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 折线 类
 *
 * 对应context的属性有
 * @pointList 各个顶角坐标
 **/
var BrokenLine = function (_Shape) {
    inherits(BrokenLine, _Shape);

    function BrokenLine(opt, atype) {
        classCallCheck(this, BrokenLine);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            lineType: null,
            smooth: false,
            pointList: [], //{Array}  // 必须，各个顶角坐标
            smoothFilter: Utils.__emptyFunc
        }, opt.context);

        if (atype !== "clone" && _context.smooth) {
            _context.pointList = myMath.getSmoothPointList(_context.pointList);
        }

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (BrokenLine.__proto__ || Object.getPrototypeOf(BrokenLine)).call(this, opt));

        _this.type = "brokenline";
        _this.id = Utils.createId(_this.type);

        _this.setGraphics();
        return _this;
    }

    createClass(BrokenLine, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "pointList" || name == "smooth" || name == "lineType") {
                this.setGraphics();
            }
        }
    }, {
        key: "setGraphics",
        value: function setGraphics() {
            this.graphics.clear();

            var context = this.context;
            var pointList = context.pointList;
            if (pointList.length < 2) {
                //少于2个点就不画了~
                return this;
            }
            if (!context.lineType || context.lineType == 'solid') {
                //默认为实线
                //TODO:目前如果 有设置smooth 的情况下是不支持虚线的
                this.graphics.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 1, l = pointList.length; i < l; i++) {
                    this.graphics.lineTo(pointList[i][0], pointList[i][1]);
                }
            } else if (context.lineType == 'dashed' || context.lineType == 'dotted') {
                if (context.smooth) {
                    for (var si = 0, sl = pointList.length; si < sl; si++) {
                        if (si == sl - 1) {
                            break;
                        }
                        this.graphics.moveTo(pointList[si][0], pointList[si][1]);
                        this.graphics.lineTo(pointList[si + 1][0], pointList[si + 1][1]);
                        si += 1;
                    }
                } else {
                    //画虚线的方法  
                    this.graphics.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        var fromX = pointList[i - 1][0];
                        var toX = pointList[i][0];
                        var fromY = pointList[i - 1][1];
                        var toY = pointList[i][1];
                        this.dashedLineTo(fromX, fromY, toX, toY, 5);
                    }
                }
            }
            return this;
        }
    }]);
    return BrokenLine;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 圆形 类
 *
 * 坐标原点再圆心
 *
 * 对应context的属性有
 * @r 圆半径
 **/
var Circle$2 = function (_Shape) {
    inherits(Circle, _Shape);

    function Circle(opt) {
        classCallCheck(this, Circle);

        opt = Utils.checkOpt(opt);
        //默认情况下面，circle不需要把xy进行parentInt转换
        "xyToInt" in opt || (opt.xyToInt = false);
        var _context = _$1.extend({
            r: 0 //{number},  // 必须，圆半径
        }, opt.context);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, opt));

        _this.type = "circle";
        _this.id = Utils.createId(_this.type);

        _this.setGraphics();
        return _this;
    }

    createClass(Circle, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "r") {
                this.setGraphics();
            }
        }
    }, {
        key: "setGraphics",
        value: function setGraphics() {
            this.graphics.clear();
            //this.graphics.arc(0 , 0, this.context.r, 0, Math.PI * 2, true);
            this.graphics.drawCircle(0, 0, this.context.r);
        }
    }]);
    return Circle;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * Path 类，Path主要用于把svgpath 字符串转换为pointList，然后构建graphicsData
 *
 * 对应context的属性有
 * @path path串
 **/
var Path = function (_Shape) {
    inherits(Path, _Shape);

    function Path(opt) {
        classCallCheck(this, Path);


        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            pointList: [], //从下面的path中计算得到的边界点的集合
            path: "" //字符串 必须，路径。例如:M 0 0 L 0 10 L 10 10 Z (一个三角形)
            //M = moveto
            //L = lineto
            //H = horizontal lineto
            //V = vertical lineto
            //C = curveto
            //S = smooth curveto
            //Q = quadratic Belzier curve
            //T = smooth quadratic Belzier curveto
            //Z = closepath
        }, opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Path.__proto__ || Object.getPrototypeOf(Path)).call(this, opt));

        if ("drawTypeOnly" in opt) {
            _this.drawTypeOnly = opt.drawTypeOnly;
        }

        _this.__parsePathData = null;

        _this.type = "path";
        _this.id = Utils.createId(_this.type);

        _this.setGraphics();

        return _this;
    }

    createClass(Path, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "path") {
                //如果path有变动，需要自动计算新的pointList
                this.setGraphics();
            }
        }
    }, {
        key: "_parsePathData",
        value: function _parsePathData(data) {
            if (this.__parsePathData) {
                return this.__parsePathData;
            }
            if (!data) {
                return [];
            }
            //分拆子分组
            this.__parsePathData = [];
            var paths = _$1.compact(data.replace(/[Mm]/g, "\\r$&").split('\\r'));
            var me = this;
            _$1.each(paths, function (pathStr) {
                me.__parsePathData.push(me._parseChildPathData(pathStr));
            });
            return this.__parsePathData;
        }
    }, {
        key: "_parseChildPathData",
        value: function _parseChildPathData(data) {
            // command string
            var cs = data;
            // command chars
            var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
            cs = cs.replace(/  /g, ' ');
            cs = cs.replace(/ /g, ',');
            //cs = cs.replace(/(.)-/g, "$1,-");
            cs = cs.replace(/(\d)-/g, '$1,-');
            cs = cs.replace(/,,/g, ',');
            var n;
            // create pipes so that we can split the data
            for (n = 0; n < cc.length; n++) {
                cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
            }
            // create array
            var arr = cs.split('|');
            var ca = [];
            // init context point
            var cpx = 0;
            var cpy = 0;
            for (n = 1; n < arr.length; n++) {
                var str = arr[n];
                var c = str.charAt(0);
                str = str.slice(1);
                str = str.replace(new RegExp('e,-', 'g'), 'e-');

                //有的时候，比如“22，-22” 数据可能会经常的被写成22-22，那么需要手动修改
                //str = str.replace(new RegExp('-', 'g'), ',-');
                //str = str.replace(/(.)-/g, "$1,-")
                var p = str.split(',');

                if (p.length > 0 && p[0] === '') {
                    p.shift();
                }

                for (var i = 0; i < p.length; i++) {
                    p[i] = parseFloat(p[i]);
                }
                while (p.length > 0) {
                    if (isNaN(p[0])) {
                        break;
                    }
                    var cmd = null;
                    var points = [];

                    var ctlPtx;
                    var ctlPty;
                    var prevCmd;

                    var rx;
                    var ry;
                    var psi;
                    var fa;
                    var fs;

                    var x1 = cpx;
                    var y1 = cpy;

                    // convert l, H, h, V, and v to L
                    switch (c) {
                        case 'l':
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'L':
                            cpx = p.shift();
                            cpy = p.shift();
                            points.push(cpx, cpy);
                            break;
                        case 'm':
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'M';
                            points.push(cpx, cpy);
                            c = 'l';
                            break;
                        case 'M':
                            cpx = p.shift();
                            cpy = p.shift();
                            cmd = 'M';
                            points.push(cpx, cpy);
                            c = 'L';
                            break;

                        case 'h':
                            cpx += p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'H':
                            cpx = p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'v':
                            cpy += p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'V':
                            cpy = p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'C':
                            points.push(p.shift(), p.shift(), p.shift(), p.shift());
                            cpx = p.shift();
                            cpy = p.shift();
                            points.push(cpx, cpy);
                            break;
                        case 'c':
                            points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'C';
                            points.push(cpx, cpy);
                            break;
                        case 'S':
                            ctlPtx = cpx;
                            ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'C') {
                                ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                ctlPty = cpy + (cpy - prevCmd.points[3]);
                            }
                            points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                            cpx = p.shift();
                            cpy = p.shift();
                            cmd = 'C';
                            points.push(cpx, cpy);
                            break;
                        case 's':
                            ctlPtx = cpx, ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'C') {
                                ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                ctlPty = cpy + (cpy - prevCmd.points[3]);
                            }
                            points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'C';
                            points.push(cpx, cpy);
                            break;
                        case 'Q':
                            points.push(p.shift(), p.shift());
                            cpx = p.shift();
                            cpy = p.shift();
                            points.push(cpx, cpy);
                            break;
                        case 'q':
                            points.push(cpx + p.shift(), cpy + p.shift());
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'Q';
                            points.push(cpx, cpy);
                            break;
                        case 'T':
                            ctlPtx = cpx, ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'Q') {
                                ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                ctlPty = cpy + (cpy - prevCmd.points[1]);
                            }
                            cpx = p.shift();
                            cpy = p.shift();
                            cmd = 'Q';
                            points.push(ctlPtx, ctlPty, cpx, cpy);
                            break;
                        case 't':
                            ctlPtx = cpx, ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'Q') {
                                ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                ctlPty = cpy + (cpy - prevCmd.points[1]);
                            }
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'Q';
                            points.push(ctlPtx, ctlPty, cpx, cpy);
                            break;
                        case 'A':
                            rx = p.shift(); //x半径
                            ry = p.shift(); //y半径
                            psi = p.shift(); //旋转角度
                            fa = p.shift(); //角度大小 
                            fs = p.shift(); //时针方向

                            x1 = cpx, y1 = cpy;
                            cpx = p.shift(), cpy = p.shift();
                            cmd = 'A';
                            points = [rx, ry, psi, fa, fs, cpx, cpy, x1, y1];
                            break;
                        case 'a':
                            rx = p.shift();
                            ry = p.shift();
                            psi = p.shift();
                            fa = p.shift();
                            fs = p.shift();

                            x1 = cpx, y1 = cpy;
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'A';
                            points = [rx, ry, psi, fa, fs, cpx, cpy, x1, y1];
                            break;

                    }

                    ca.push({
                        command: cmd || c,
                        points: points
                    });
                }

                if (c === 'z' || c === 'Z') {
                    ca.push({
                        command: 'z',
                        points: []
                    });
                }
            }
            return ca;
        }

        //重新根的path绘制graphics

    }, {
        key: "setGraphics",
        value: function setGraphics() {

            this.graphics.clear();
            this.__parsePathData = null;
            this.context.pointList = [];

            var pathArray = this._parsePathData(this.context.path);

            for (var g = 0, gl = pathArray.length; g < gl; g++) {
                for (var i = 0, l = pathArray[g].length; i < l; i++) {
                    var c = pathArray[g][i].command,
                        p = pathArray[g][i].points;
                    switch (c) {
                        case 'L':
                            this.graphics.lineTo(p[0], p[1]);
                            break;
                        case 'M':
                            this.graphics.moveTo(p[0], p[1]);
                            break;
                        case 'C':
                            this.graphics.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                            break;
                        case 'Q':
                            this.graphics.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                            break;
                        case 'A':
                            //前面6个元素用来放path的A 6个参数，path A命令详见
                            Arc.drawArc(this.graphics, p[7], p[8], p);
                            break;
                        case 'z':
                            this.graphics.closePath();
                            break;
                    }
                }
            }
            return this;
        }
    }]);
    return Path;
}(Shape);

/**
 * Canvax
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 水滴形 类
 * 派生自Path类
 *
 * 对应context的属性有
 * @hr 水滴横宽（中心到水平边缘最宽处距离）
 * @vr 水滴纵高（中心到尖端距离）
 **/
var Droplet = function (_Path) {
    inherits(Droplet, _Path);

    function Droplet(opt) {
        var _this;

        classCallCheck(this, Droplet);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            hr: 0, //{number},  // 必须，水滴横宽（中心到水平边缘最宽处距离）
            vr: 0 //{number},  // 必须，水滴纵高（中心到尖端距离）
        }, opt.context);

        opt.context = _context;

        var my = (_this = possibleConstructorReturn(this, (Droplet.__proto__ || Object.getPrototypeOf(Droplet)).call(this, opt)), _this);

        _this.type = "droplet";
        _this.id = Utils.createId(_this.type);

        _this.context.path = _this._createPath();
        return _this;
    }

    createClass(Droplet, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "hr" || name == "vr") {
                this.context.path = this._createPath();
            }

            if (name == "path") {
                this.setGraphics();
            }
        }
    }, {
        key: "_createPath",
        value: function _createPath() {
            var context = this.context;
            var ps = "M 0 " + context.hr + " C " + context.hr + " " + context.hr + " " + context.hr * 3 / 2 + " " + -context.hr / 3 + " 0 " + -context.vr;
            ps += " C " + -context.hr * 3 / 2 + " " + -context.hr / 3 + " " + -context.hr + " " + context.hr + " 0 " + context.hr + "z";
            return ps;
        }
    }]);
    return Droplet;
}(Path);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 椭圆形 类
 *
 * 对应context的属性有 
 *
 * @hr 椭圆横轴半径
 * @vr 椭圆纵轴半径
 */
var Ellipse$2 = function (_Shape) {
    inherits(Ellipse, _Shape);

    function Ellipse(opt) {
        classCallCheck(this, Ellipse);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            //x             : 0 , //{number},  // 丢弃
            //y             : 0 , //{number},  // 丢弃，原因同circle
            hr: 0, //{number},  // 必须，椭圆横轴半径
            vr: 0 //{number},  // 必须，椭圆纵轴半径
        }, opt.context);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Ellipse.__proto__ || Object.getPrototypeOf(Ellipse)).call(this, opt));

        _this.type = "ellipse";
        _this.id = Utils.createId(_this.type);

        _this.setGraphics();
        return _this;
    }

    createClass(Ellipse, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "hr" || name == "vr") {
                this.setGraphics();
            }
        }
    }, {
        key: "setGraphics",
        value: function setGraphics() {
            this.graphics.clear();
            this.graphics.drawEllipse(0, 0, this.context.hr * 2, this.context.vr * 2);
        }
    }]);
    return Ellipse;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 多边形 类  （不规则）
 *
 * 对应context的属性有
 * @pointList 多边形各个顶角坐标
 **/
var Polygon$2 = function (_Shape) {
    inherits(Polygon, _Shape);

    function Polygon(opt, atype) {
        classCallCheck(this, Polygon);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            lineType: null,
            smooth: false,
            pointList: [], //{Array}  // 必须，各个顶角坐标
            smoothFilter: Utils.__emptyFunc
        }, opt.context);

        if (atype !== "clone") {
            var start = _context.pointList[0];
            var end = _context.pointList.slice(-1)[0];
            if (_context.smooth) {
                _context.pointList.unshift(end);
                _context.pointList = myMath.getSmoothPointList(_context.pointList);
            }
            //else {
            //    _context.pointList.push( start );
            //}
        }

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, opt, atype));

        _this._drawTypeOnly = null;
        _this.type = "polygon";
        _this.id = Utils.createId(_this.type);

        _this.setGraphics();
        return _this;
    }

    createClass(Polygon, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            //调用parent的setGraphics
            if (name == "pointList" || name == "smooth" || name == "lineType") {
                this.setGraphics();
            }
        }
    }, {
        key: "setGraphics",
        value: function setGraphics() {
            this.graphics.clear();

            var context = this.context;
            var pointList = context.pointList;
            if (pointList.length < 2) {
                //少于2个点就不画了~
                return;
            }

            this.graphics.moveTo(pointList[0][0], pointList[0][1]);
            for (var i = 1, l = pointList.length; i < l; i++) {
                this.graphics.lineTo(pointList[i][0], pointList[i][1]);
            }
            this.graphics.closePath();

            //如果为虚线
            if (context.lineType == 'dashed' || context.lineType == 'dotted') {
                //首先把前面的draphicsData设置为fill only
                //也就是把line强制设置为false，这点很重要，否则你虚线画不出来，会和这个实现重叠了
                this.graphics.currentPath.line = false;

                if (context.smooth) {
                    //如果是smooth，本身已经被用曲率打散过了，不需要采用间隔法
                    for (var si = 0, sl = pointList.length; si < sl; si++) {
                        if (si == sl - 1) {
                            break;
                        }
                        this.graphics.moveTo(pointList[si][0], pointList[si][1]);
                        this.graphics.lineTo(pointList[si + 1][0], pointList[si + 1][1]);
                        si += 1;
                    }
                } else {
                    //画虚线的方法  
                    this.graphics.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        var fromX = pointList[i - 1][0];
                        var toX = pointList[i][0];
                        var fromY = pointList[i - 1][1];
                        var toY = pointList[i][1];
                        this.dashedLineTo(fromX, fromY, toX, toY, 5);
                    }
                }
            }
            return;
        }
    }]);
    return Polygon;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 正n边形（n>=3）
 *
 * 对应context的属性有 
 *
 * @r 正n边形外接圆半径
 * @r 指明正几边形
 *
 * @pointList 私有，从上面的r和n计算得到的边界值的集合
 */
var Isogon = function (_Polygon) {
    inherits(Isogon, _Polygon);

    function Isogon(opt) {
        classCallCheck(this, Isogon);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            pointList: [], //从下面的r和n计算得到的边界值的集合
            r: 0, //{number},  // 必须，正n边形外接圆半径
            n: 0 //{number},  // 必须，指明正几边形
        }, opt.context);
        _context.pointList = myMath.getIsgonPointList(_context.n, _context.r);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Isogon.__proto__ || Object.getPrototypeOf(Isogon)).call(this, opt));

        _this.type = "isogon";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Isogon, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "r" || name == "n") {
                //如果path有变动，需要自动计算新的pointList
                this.context.pointList = myMath.getIsgonPointList(style.n, style.r);
            }

            if (name == "pointList" || name == "smooth" || name == "lineType") {
                this.setGraphics();
                this.graphics.closePath();
            }
        }
    }]);
    return Isogon;
}(Polygon$2);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 线条 类
 *
 *
 * 对应context的属性有
 * @lineType  可选 虚线 实现 的 类型
 * @xStart    必须，起点横坐标
 * @yStart    必须，起点纵坐标
 * @xEnd      必须，终点横坐标
 * @yEnd      必须，终点纵坐标
 **/
var Line = function (_Shape) {
    inherits(Line, _Shape);

    function Line(opt) {
        classCallCheck(this, Line);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            lineType: null, //可选 虚线 实现 的 类型
            start: {
                x: 0, // 必须，起点横坐标
                y: 0 // 必须，起点纵坐标
            },
            end: {
                x: 0, // 必须，终点横坐标
                y: 0 // 必须，终点纵坐标
            },
            dashLength: 3 // 虚线间隔
        }, opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this, opt));

        _this.setGraphics();

        _this.type = "line";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Line, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            //并不清楚是start.x 还是end.x， 当然，这并不重要
            if (name == "x" || name == "y") {
                this.setGraphics();
            }
        }
    }, {
        key: "setGraphics",
        value: function setGraphics() {
            this.graphics.clear();
            var context = this.context;
            if (!context.lineType || context.lineType == 'solid') {
                this.graphics.moveTo(context.start.x, context.start.y);
                this.graphics.lineTo(context.end.x, context.end.y);
            } else if (context.lineType == 'dashed' || context.lineType == 'dotted') {
                this.dashedLineTo(context.start.x, context.start.y, context.end.x, context.end.y, this.context.dashLength);
            }
            return this;
        }
    }]);
    return Line;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 矩现 类  （不规则）
 *
 *
 * 对应context的属性有
 * @width 宽度
 * @height 高度
 * @radius 如果是圆角的，则为【上右下左】顺序的圆角半径数组
 **/
var Rect = function (_Shape) {
    inherits(Rect, _Shape);

    function Rect(opt) {
        classCallCheck(this, Rect);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            width: 0,
            height: 0,
            radius: []
        }, opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this, opt));

        _this.type = "rect";
        _this.id = Utils.createId(_this.type);

        _this.setGraphics();
        return _this;
    }

    createClass(Rect, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "width" || name == "height" || name == "radius") {
                this.setGraphics();
            }
        }

        /**
         * 绘制圆角矩形
         */

    }, {
        key: "_buildRadiusPath",
        value: function _buildRadiusPath() {
            var context = this.context;
            //左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
            //r缩写为1         相当于 [1, 1, 1, 1]
            //r缩写为[1]       相当于 [1, 1, 1, 1]
            //r缩写为[1, 2]    相当于 [1, 2, 1, 2]
            //r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
            var x = 0;
            var y = 0;
            var width = this.context.width;
            var height = this.context.height;

            var r = Utils.getCssOrderArr(context.radius);
            var G = this.graphics;

            G.moveTo(parseInt(x + r[0]), parseInt(y));
            G.lineTo(parseInt(x + width - r[1]), parseInt(y));
            r[1] !== 0 && G.quadraticCurveTo(x + width, y, x + width, y + r[1]);
            G.lineTo(parseInt(x + width), parseInt(y + height - r[2]));
            r[2] !== 0 && G.quadraticCurveTo(x + width, y + height, x + width - r[2], y + height);
            G.lineTo(parseInt(x + r[3]), parseInt(y + height));
            r[3] !== 0 && G.quadraticCurveTo(x, y + height, x, y + height - r[3]);
            G.lineTo(parseInt(x), parseInt(y + r[0]));
            r[0] !== 0 && G.quadraticCurveTo(x, y, x + r[0], y);
        }
        /**
         * 创建矩形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} context 样式
         */

    }, {
        key: "setGraphics",
        value: function setGraphics() {
            this.graphics.clear();
            if (!this.context.radius.length) {
                this.graphics.drawRect(0, 0, this.context.width, this.context.height);
            } else {
                this._buildRadiusPath();
            }
            this.graphics.closePath();
            return;
        }
    }]);
    return Rect;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 扇形 类
 *
 * 坐标原点再圆心
 *
 * 对应context的属性有
 * @r0 默认为0，内圆半径指定后将出现内弧，同时扇边长度 = r - r0
 * @r  必须，外圆半径
 * @startAngle 起始角度(0, 360)
 * @endAngle   结束角度(0, 360)
 **/
var Sector = function (_Shape) {
    inherits(Sector, _Shape);

    function Sector(opt) {
        classCallCheck(this, Sector);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            pointList: [], //边界点的集合,私有，从下面的属性计算的来
            r0: 0, // 默认为0，内圆半径指定后将出现内弧，同时扇边长度 = r - r0
            r: 0, //{number},  // 必须，外圆半径
            startAngle: 0, //{number},  // 必须，起始角度[0, 360)
            endAngle: 0, //{number},  // 必须，结束角度(0, 360]
            clockwise: false //是否顺时针，默认为false(顺时针)
        }, opt.context);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Sector.__proto__ || Object.getPrototypeOf(Sector)).call(this, opt));

        _this.regAngle = [];
        _this.isRing = false; //是否为一个圆环
        _this.type = "sector";
        _this.id = Utils.createId(_this.type);

        _this.setGraphics();
        return _this;
    }

    createClass(Sector, [{
        key: "$watch",
        value: function $watch(name, value, preValue) {
            if (name == "r0" || name == "r" || name == "startAngle" || name == "endAngle" || name == "clockwise") {
                this.setGraphics();
            }
        }
    }, {
        key: "setGraphics",
        value: function setGraphics() {
            var context = this.context;
            // 形内半径[0,r)
            var r0 = typeof context.r0 == 'undefined' ? 0 : context.r0;
            var r = context.r; // 扇形外半径(0,r]
            var startAngle = myMath.degreeTo360(context.startAngle); // 起始角度[0,360)
            var endAngle = myMath.degreeTo360(context.endAngle); // 结束角度(0,360]

            //var isRing     = false;                       //是否为圆环

            //if( startAngle != endAngle && Math.abs(startAngle - endAngle) % 360 == 0 ) {
            if (startAngle == endAngle && context.startAngle != context.endAngle) {
                //如果两个角度相等，那么就认为是个圆环了
                this.isRing = true;
                startAngle = 0;
                endAngle = 360;
            }

            startAngle = myMath.degreeToRadian(startAngle);
            endAngle = myMath.degreeToRadian(endAngle);

            //处理下极小夹角的情况
            if (endAngle - startAngle < 0.025) {
                startAngle -= 0.003;
            }

            var G = this.graphics;

            G.arc(0, 0, r, startAngle, endAngle, this.context.clockwise);
            if (r0 !== 0) {
                if (this.isRing) {
                    //加上这个isRing的逻辑是为了兼容flashcanvas下绘制圆环的的问题
                    //不加这个逻辑flashcanvas会绘制一个大圆 ， 而不是圆环
                    G.moveTo(r0, 0);
                    G.arc(0, 0, r0, startAngle, endAngle, !this.context.clockwise);
                } else {
                    G.arc(0, 0, r0, endAngle, startAngle, !this.context.clockwise);
                }
            } else {
                //TODO:在r0为0的时候，如果不加lineTo(0,0)来把路径闭合，会出现有搞笑的一个bug
                //整个圆会出现一个以每个扇形两端为节点的镂空，我可能描述不清楚，反正这个加上就好了
                G.lineTo(0, 0);
            }

            G.closePath();
        }
    }, {
        key: "getRegAngle",
        value: function getRegAngle() {
            this.regIn = true; //如果在start和end的数值中，end大于start而且是顺时针则regIn为true
            var c = this.context;
            var startAngle = myMath.degreeTo360(c.startAngle); // 起始角度[0,360)
            var endAngle = myMath.degreeTo360(c.endAngle); // 结束角度(0,360]

            if (startAngle > endAngle && !c.clockwise || startAngle < endAngle && c.clockwise) {
                this.regIn = false; //out
            }
            //度的范围，从小到大
            this.regAngle = [Math.min(startAngle, endAngle), Math.max(startAngle, endAngle)];
        }
    }, {
        key: "getRect",
        value: function getRect(context) {
            var context = context ? context : this.context;
            var r0 = typeof context.r0 == 'undefined' // 形内半径[0,r)
            ? 0 : context.r0;
            var r = context.r; // 扇形外半径(0,r]

            this.getRegAngle();

            var startAngle = myMath.degreeTo360(context.startAngle); // 起始角度[0,360)
            var endAngle = myMath.degreeTo360(context.endAngle); // 结束角度(0,360]

            var pointList = [];

            var p4Direction = {
                "90": [0, r],
                "180": [-r, 0],
                "270": [0, -r],
                "360": [r, 0]
            };

            for (var d in p4Direction) {
                var inAngleReg = parseInt(d) > this.regAngle[0] && parseInt(d) < this.regAngle[1];
                if (this.isRing || inAngleReg && this.regIn || !inAngleReg && !this.regIn) {
                    pointList.push(p4Direction[d]);
                }
            }

            if (!this.isRing) {
                startAngle = myMath.degreeToRadian(startAngle);
                endAngle = myMath.degreeToRadian(endAngle);

                pointList.push([myMath.cos(startAngle) * r0, myMath.sin(startAngle) * r0]);

                pointList.push([myMath.cos(startAngle) * r, myMath.sin(startAngle) * r]);

                pointList.push([myMath.cos(endAngle) * r, myMath.sin(endAngle) * r]);

                pointList.push([myMath.cos(endAngle) * r0, myMath.sin(endAngle) * r0]);
            }

            context.pointList = pointList;
            return this.getRectFormPointList(context);
        }
    }]);
    return Sector;
}(Shape);

//shapes
var Canvax = {
    App: Application
};

Canvax.Display = {
    DisplayObject: DisplayObject,
    DisplayObjectContainer: DisplayObjectContainer,
    Stage: Stage,
    Sprite: Sprite,
    Shape: Shape,
    Point: Point,
    Text: Text
};

Canvax.Shapes = {
    BrokenLine: BrokenLine,
    Circle: Circle$2,
    Droplet: Droplet,
    Ellipse: Ellipse$2,
    Isogon: Isogon,
    Line: Line,
    Path: Path,
    Polygon: Polygon$2,
    Rect: Rect,
    Sector: Sector
};

Canvax.Event = {
    EventDispatcher: EventDispatcher,
    EventManager: EventManager
};

return Canvax;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmF4LmpzIiwic291cmNlcyI6WyIuLi8uLi9jYW52YXgvdXRpbHMvdW5kZXJzY29yZS5qcyIsIi4uLy4uL2NhbnZheC91dGlscy9pbmRleC5qcyIsIi4uLy4uL2NhbnZheC9kaXNwbGF5L1BvaW50LmpzIiwiLi4vLi4vY2FudmF4L2V2ZW50L0NhbnZheEV2ZW50LmpzIiwiLi4vLi4vY2FudmF4L3NldHRpbmdzLmpzIiwiLi4vLi4vY2FudmF4L3V0aWxzL2RvbS5qcyIsIi4uLy4uL2NhbnZheC9ldmVudC9FdmVudEhhbmRsZXIuanMiLCIuLi8uLi9jYW52YXgvZXZlbnQvRXZlbnRNYW5hZ2VyLmpzIiwiLi4vLi4vY2FudmF4L2V2ZW50L0V2ZW50RGlzcGF0Y2hlci5qcyIsIi4uLy4uL2NhbnZheC9nZW9tL01hdHJpeC5qcyIsIi4uLy4uL2NhbnZheC9hbmltYXRpb24vVHdlZW4uanMiLCIuLi8uLi9jYW52YXgvYW5pbWF0aW9uL0FuaW1hdGlvbkZyYW1lLmpzIiwiLi4vLi4vY2FudmF4L3V0aWxzL29ic2VydmUuanMiLCIuLi8uLi9jYW52YXgvY29uc3QuanMiLCIuLi8uLi9jYW52YXgvZGlzcGxheS9EaXNwbGF5T2JqZWN0LmpzIiwiLi4vLi4vY2FudmF4L2Rpc3BsYXkvRGlzcGxheU9iamVjdENvbnRhaW5lci5qcyIsIi4uLy4uL2NhbnZheC9kaXNwbGF5L1N0YWdlLmpzIiwiLi4vLi4vY2FudmF4L3JlbmRlcmVycy9TeXN0ZW1SZW5kZXJlci5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy9jYW52YXMvR3JhcGhpY3NSZW5kZXJlci5qcyIsIi4uLy4uL2NhbnZheC9yZW5kZXJlcnMvY2FudmFzL0NhbnZhc1JlbmRlcmVyLmpzIiwiLi4vLi4vY2FudmF4L21hdGgvUG9pbnQuanMiLCIuLi8uLi9jYW52YXgvbWF0aC9BcmMuanMiLCIuLi8uLi9jYW52YXgvbWF0aC9zaGFwZXMvUmVjdGFuZ2xlLmpzIiwiLi4vLi4vY2FudmF4L21hdGgvc2hhcGVzL0NpcmNsZS5qcyIsIi4uLy4uL2NhbnZheC9tYXRoL3NoYXBlcy9FbGxpcHNlLmpzIiwiLi4vLi4vY2FudmF4L21hdGgvc2hhcGVzL1BvbHlnb24uanMiLCIuLi8uLi9jYW52YXgvbWF0aC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL2NyZWF0ZUNvbnRleHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zZXRWZXJ0ZXhBdHRyaWJBcnJheXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9HTEJ1ZmZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL0dMVGV4dHVyZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL0dMRnJhbWVidWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvY29tcGlsZVByb2dyYW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvbWFwVHlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9tYXBTaXplLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2V4dHJhY3RBdHRyaWJ1dGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2RlZmF1bHRWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9leHRyYWN0VW5pZm9ybXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvc2V0UHJlY2lzaW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2dlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL0dMU2hhZGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvVmVydGV4QXJyYXlPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9pbmRleC5qcyIsIi4uLy4uL2NhbnZheC9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvUmVuZGVyVGFyZ2V0LmpzIiwiLi4vLi4vY2FudmF4L3JlbmRlcmVycy93ZWJnbC91dGlscy9PYmplY3RSZW5kZXJlci5qcyIsIi4uLy4uL2NhbnZheC9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qcyIsIi4uLy4uL2NhbnZheC91dGlscy9jb2xvci5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy93ZWJnbC9XZWJHTEdyYXBoaWNzRGF0YS5qcyIsIi4uLy4uL2NhbnZheC9TaGFkZXIuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3Mvd2ViZ2wvc2hhZGVycy9QcmltaXRpdmVTaGFkZXIuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3Mvd2ViZ2wvdXRpbHMvYnVpbGRMaW5lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzIiwiLi4vLi4vY2FudmF4L2dyYXBoaWNzL3dlYmdsL3V0aWxzL2J1aWxkUG9seS5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZFJlY3RhbmdsZS5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZFJvdW5kZWRSZWN0YW5nbGUuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3Mvd2ViZ2wvdXRpbHMvYnVpbGRDaXJjbGUuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3Mvd2ViZ2wvR3JhcGhpY3NSZW5kZXJlci5qcyIsIi4uLy4uL2NhbnZheC9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGFnZVJlbmRlcmVyLmpzIiwiLi4vLi4vY2FudmF4L3JlbmRlcmVycy93ZWJnbC9XZWJHTFJlbmRlcmVyLmpzIiwiLi4vLi4vY2FudmF4L3JlbmRlcmVycy9hdXRvUmVuZGVyZXIuanMiLCIuLi8uLi9jYW52YXgvQXBwbGljYXRpb24uanMiLCIuLi8uLi9jYW52YXgvZGlzcGxheS9TcHJpdGUuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3MvR3JhcGhpY3NEYXRhLmpzIiwiLi4vLi4vY2FudmF4L2dyYXBoaWNzL3V0aWxzL2JlemllckN1cnZlVG8uanMiLCIuLi8uLi9jYW52YXgvZ2VvbS9JbnNpZGVMaW5lLmpzIiwiLi4vLi4vY2FudmF4L2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwiLi4vLi4vY2FudmF4L2Rpc3BsYXkvU2hhcGUuanMiLCIuLi8uLi9jYW52YXgvZGlzcGxheS9UZXh0LmpzIiwiLi4vLi4vY2FudmF4L2dlb20vVmVjdG9yLmpzIiwiLi4vLi4vY2FudmF4L2dlb20vU21vb3RoU3BsaW5lLmpzIiwiLi4vLi4vY2FudmF4L2dlb20vTWF0aC5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9Ccm9rZW5MaW5lLmpzIiwiLi4vLi4vY2FudmF4L3NoYXBlL0NpcmNsZS5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9QYXRoLmpzIiwiLi4vLi4vY2FudmF4L3NoYXBlL0Ryb3BsZXQuanMiLCIuLi8uLi9jYW52YXgvc2hhcGUvRWxsaXBzZS5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9Qb2x5Z29uLmpzIiwiLi4vLi4vY2FudmF4L3NoYXBlL0lzb2dvbi5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9MaW5lLmpzIiwiLi4vLi4vY2FudmF4L3NoYXBlL1JlY3QuanMiLCIuLi8uLi9jYW52YXgvc2hhcGUvU2VjdG9yLmpzIiwiLi4vLi4vY2FudmF4L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfID0ge31cbnZhciBicmVha2VyID0ge307XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXJcbnRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbmhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxudmFyXG5uYXRpdmVGb3JFYWNoICAgICAgPSBBcnJheVByb3RvLmZvckVhY2gsXG5uYXRpdmVGaWx0ZXIgICAgICAgPSBBcnJheVByb3RvLmZpbHRlcixcbm5hdGl2ZUluZGV4T2YgICAgICA9IEFycmF5UHJvdG8uaW5kZXhPZixcbm5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG5uYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cztcblxuXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbl8ua2V5cyA9IG5hdGl2ZUtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmogIT09IE9iamVjdChvYmopKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9iamVjdCcpO1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG5cbl8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcblxudmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICB9XG4gIH1cbn07XG5cbl8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG59O1xuXG5fLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikgcmV0dXJuIG9iai5maWx0ZXIoaXRlcmF0b3IsIGNvbnRleHQpO1xuICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICB9O1xufSk7XG5cbmlmICh0eXBlb2YgKC8uLykgIT09ICdmdW5jdGlvbicpIHtcbiAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gIH07XG59O1xuXG5fLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xufTtcblxuXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPSArb2JqO1xufTtcblxuXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG59O1xuXG5fLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBudWxsO1xufTtcblxuXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGlmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5fLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG59O1xuXG5fLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5fLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xufTtcblxuXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbl8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgaWYgKGlzU29ydGVkKSB7XG4gICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgaSA9IChpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICB9XG4gIH1cbiAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgYXJyYXkuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSwgaXNTb3J0ZWQpO1xuICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbn07XG5cbl8uaXNXaW5kb3cgPSBmdW5jdGlvbiggb2JqICkgeyBcbiAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdztcbn07XG5fLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiggb2JqICkge1xuICAgIC8vIEJlY2F1c2Ugb2YgSUUsIHdlIGFsc28gaGF2ZSB0byBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5LlxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IERPTSBub2RlcyBhbmQgd2luZG93IG9iamVjdHMgZG9uJ3QgcGFzcyB0aHJvdWdoLCBhcyB3ZWxsXG4gICAgaWYgKCAhb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IF8uaXNXaW5kb3coIG9iaiApICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3RcbiAgICAgICAgaWYgKCBvYmouY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICFoYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcbiAgICAgICAgICAgICFoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgLy8gSUU4LDkgV2lsbCB0aHJvdyBleGNlcHRpb25zIG9uIGNlcnRhaW4gaG9zdCBvYmplY3RzICM5ODk3XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG4gICAgLy8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG4gICAgdmFyIGtleTtcbiAgICBmb3IgKCBrZXkgaW4gb2JqICkge31cblxuICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcbn07XG5cbi8qKlxuKlxuKuWmguaenOaYr+a3seW6pmV4dGVuZO+8jOesrOS4gOS4quWPguaVsOWwseiuvue9ruS4unRydWVcbiovXG5fLmV4dGVuZCA9IGZ1bmN0aW9uKCkgeyAgXG4gIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSwgIFxuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LCAgXG4gICAgICBpID0gMSwgIFxuICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwgIFxuICAgICAgZGVlcCA9IGZhbHNlOyAgXG4gIGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7ICBcbiAgICAgIGRlZXAgPSB0YXJnZXQ7ICBcbiAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTsgIFxuICAgICAgaSA9IDI7ICBcbiAgfTsgIFxuICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIV8uaXNGdW5jdGlvbih0YXJnZXQpICkgeyAgXG4gICAgICB0YXJnZXQgPSB7fTsgIFxuICB9OyAgXG4gIGlmICggbGVuZ3RoID09PSBpICkgeyAgXG4gICAgICB0YXJnZXQgPSB0aGlzOyAgXG4gICAgICAtLWk7ICBcbiAgfTsgIFxuICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHsgIFxuICAgICAgaWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkgeyAgXG4gICAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkgeyAgXG4gICAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdOyAgXG4gICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zWyBuYW1lIF07ICBcbiAgICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7ICBcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAgXG4gICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgICBpZiAoIGRlZXAgJiYgY29weSAmJiAoIF8uaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBfLmlzQXJyYXkoY29weSkpICkgKSB7ICBcbiAgICAgICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7ICBcbiAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlOyAgXG4gICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgXy5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTsgIFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgIFxuICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIF8uaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307ICBcbiAgICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBfLmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTsgIFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7ICBcbiAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gY29weTsgIFxuICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICB9ICBcbiAgICAgIH0gIFxuICB9ICBcbiAgcmV0dXJuIHRhcmdldDsgIFxufTsgXG5fLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHRydWUsIHt9LCBvYmopO1xufTtcbmV4cG9ydCBkZWZhdWx0IF87IiwiLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20gXG4qL1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxudmFyIFV0aWxzID0ge1xuICAgIG1haW5GcmFtZVJhdGUgICA6IDYwLC8v6buY6K6k5Li75bin546HXG4gICAgbm93IDogMCxcbiAgICAvKuWDj+e0oOajgOa1i+S4k+eUqCovXG4gICAgX3BpeGVsQ3R4ICAgOiBudWxsLFxuICAgIF9fZW1wdHlGdW5jIDogZnVuY3Rpb24oKXt9LFxuICAgIC8vcmV0aW5hIOWxj+W5leS8mOWMllxuICAgIF9kZXZpY2VQaXhlbFJhdGlvIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICBfVUlEICA6IDAsIC8v6K+l5YC85Li65ZCR5LiK55qE6Ieq5aKe6ZW/5pW05pWw5YC8XG4gICAgZ2V0VUlEOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9VSUQrKztcbiAgICB9LFxuICAgIGNyZWF0ZUlkIDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZighbmFtZSl7XG4gICAgICAgICAgICBkZWJ1Z2dlclxuICAgICAgICB9XG4gICAgICAgIC8vaWYgZW5kIHdpdGggYSBkaWdpdCwgdGhlbiBhcHBlbmQgYW4gdW5kZXJzQmFzZSBiZWZvcmUgYXBwZW5kaW5nXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IG5hbWUuY2hhckNvZGVBdChuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIG5hbWUgKz0gXCJfXCI7XG4gICAgICAgIHJldHVybiBuYW1lICsgVXRpbHMuZ2V0VUlEKCk7XG4gICAgfSxcbiAgICBjYW52YXNTdXBwb3J0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XG4gICAgfSxcbiAgICBjcmVhdGVPYmplY3QgOiBmdW5jdGlvbiggcHJvdG8gLCBjb25zdHJ1Y3RvciApIHtcbiAgICAgICAgdmFyIG5ld1Byb3RvO1xuICAgICAgICB2YXIgT2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbiAgICAgICAgaWYgKE9iamVjdENyZWF0ZSkge1xuICAgICAgICAgICAgbmV3UHJvdG8gPSBPYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVXRpbHMuX19lbXB0eUZ1bmMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICBuZXdQcm90byA9IG5ldyBVdGlscy5fX2VtcHR5RnVuYygpO1xuICAgICAgICB9XG4gICAgICAgIG5ld1Byb3RvLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXdQcm90bztcbiAgICB9LFxuICAgIGNyZWF0Q2xhc3MgOiBmdW5jdGlvbihyLCBzLCBweCl7XG4gICAgICAgIGlmICghcyB8fCAhcikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwID0gcy5wcm90b3R5cGUsIHJwO1xuICAgICAgICAvLyBhZGQgcHJvdG90eXBlIGNoYWluXG4gICAgICAgIHJwID0gVXRpbHMuY3JlYXRlT2JqZWN0KHNwLCByKTtcbiAgICAgICAgci5wcm90b3R5cGUgPSBfLmV4dGVuZChycCwgci5wcm90b3R5cGUpO1xuICAgICAgICByLnN1cGVyY2xhc3MgPSBVdGlscy5jcmVhdGVPYmplY3Qoc3AsIHMpO1xuICAgICAgICAvLyBhZGQgcHJvdG90eXBlIG92ZXJyaWRlc1xuICAgICAgICBpZiAocHgpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKHJwLCBweCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICBpbml0RWxlbWVudCA6IGZ1bmN0aW9uKCBjYW52YXMgKXtcbiAgICAgICAgaWYoIHdpbmRvdy5GbGFzaENhbnZhcyAmJiBGbGFzaENhbnZhcy5pbml0RWxlbWVudCl7XG4gICAgICAgICAgICBGbGFzaENhbnZhcy5pbml0RWxlbWVudCggY2FudmFzICk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8v5YGa5LiA5qyh566A5Y2V55qEb3B05Y+C5pWw5qCh6aqM77yM5L+d6K+B5Zyo55So5oi35LiN5Lygb3B055qE5pe25YCZIOaIluiAheS8oOS6hm9wdOS9huaYr+mHjOmdouayoeaciWNvbnRleHTnmoTml7blgJnmiqXplJlcbiAgICBjaGVja09wdCAgICA6IGZ1bmN0aW9uKG9wdCl7XG4gICAgICAgIGlmKCAhb3B0ICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQgOiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ICAgXG4gICAgICAgIH0gZWxzZSBpZiggb3B0ICYmICFvcHQuY29udGV4dCApIHtcbiAgICAgICAgICBvcHQuY29udGV4dCA9IHt9XG4gICAgICAgICAgcmV0dXJuIG9wdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3B0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiDmjInnhadjc3PnmoTpobrluo/vvIzov5Tlm57kuIDkuKpb5LiKLOWPsyzkuIss5bemXVxuICAgICAqL1xuICAgIGdldENzc09yZGVyQXJyIDogZnVuY3Rpb24oIHIgKXtcbiAgICAgICAgdmFyIHIxOyBcbiAgICAgICAgdmFyIHIyOyBcbiAgICAgICAgdmFyIHIzOyBcbiAgICAgICAgdmFyIHI0O1xuXG4gICAgICAgIGlmKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgIHIyID0gcjQgPSByWzFdO1xuICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgIHIyID0gclsxXTtcbiAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgcjQgPSByWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcjEscjIscjMscjRdO1xuICAgIH0sXG5cbiAgICBpc1dlYkdMU3VwcG9ydGVkIDogZnVuY3Rpb24gKCl7XG4gICAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHsgc3RlbmNpbDogdHJ1ZSB9O1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0KSAvL+S4jeWtmOWcqOebtOaOpXJldHVyblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSwgXG4gICAgICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBjb250ZXh0T3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiAhIShnbCAmJiBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLnN0ZW5jaWwpOyAvL+i/mOimgeehruWunuajgOa1i+aYr+WQpuaUr+aMgXdlYkdM5qih5byPXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxzOyIsIi8qKlxuICogUG9pbnRcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50XG57XG4gICAgY29uc3RydWN0b3IoIHg9MCAsIHk9MCApXG4gICAge1xuICAgICAgICBpZiggYXJndW1lbnRzLmxlbmd0aD09MSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09ICdvYmplY3QnICl7XG4gICAgICAgICAgICB2YXIgYXJnPWFyZ3VtZW50c1swXVxuICAgICAgICAgICAgaWYoIFwieFwiIGluIGFyZyAmJiBcInlcIiBpbiBhcmcgKXtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSBhcmcueCoxO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IGFyZy55KjE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpPTA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBhcmcpe1xuICAgICAgICAgICAgICAgICAgICBpZihpPT0wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IGFyZ1twXSoxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gYXJnW3BdKjE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54ID0geCoxO1xuICAgICAgICAgICAgdGhpcy55ID0geSoxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9BcnJheSgpXG4gICAge1xuICAgICAgICByZXR1cm4gW3RoaXMueCAsIHRoaXMueV0gIFxuICAgIH1cbn07XG5cbiIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIGNhbnZhcyDkuIrlp5TmiZjnmoTkuovku7bnrqHnkIZcbiAqL1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcblxudmFyIENhbnZheEV2ZW50ID0gZnVuY3Rpb24oIGV2dCAsIHBhcmFtcyApIHtcblx0XG5cdHZhciBldmVudFR5cGUgPSBcIkNhbnZheEV2ZW50XCI7IFxuICAgIGlmKCBfLmlzU3RyaW5nKCBldnQgKSApe1xuICAgIFx0ZXZlbnRUeXBlID0gZXZ0O1xuICAgIH07XG4gICAgaWYoIF8uaXNPYmplY3QoIGV2dCApICYmIGV2dC50eXBlICl7XG4gICAgXHRldmVudFR5cGUgPSBldnQudHlwZTtcbiAgICB9O1xuXG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XHRcbiAgICB0aGlzLnR5cGUgICA9IGV2ZW50VHlwZTtcbiAgICB0aGlzLnBvaW50ICA9IG51bGw7XG5cbiAgICB0aGlzLl9zdG9wUHJvcGFnYXRpb24gPSBmYWxzZSA7IC8v6buY6K6k5LiN6Zi75q2i5LqL5Lu25YaS5rOhXG59XG5DYW52YXhFdmVudC5wcm90b3R5cGUgPSB7XG4gICAgc3RvcFByb3BhZ2F0aW9uIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3N0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgQ2FudmF4RXZlbnQ7IiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIC8v6K6+5aSH5YiG6L6o546HXG4gICAgUkVTT0xVVElPTjogd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcblxuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGZyYW1lcyBwZXIgbWlsbGlzZWNvbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMDZcbiAgICAgKi9cbiAgICBUQVJHRVRfRlBNUzogMC4wNixcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlIFdlYkdMIHdpbGwgYXR0ZW1wdCBtYWtlIHRleHR1cmVzIG1pbXBhcGVkIGJ5IGRlZmF1bHQuXG4gICAgICogTWlwbWFwcGluZyB3aWxsIG9ubHkgc3VjY2VlZCBpZiB0aGUgYmFzZSB0ZXh0dXJlIHVwbG9hZGVkIGhhcyBwb3dlciBvZiB0d28gZGltZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBNSVBNQVBfVEVYVFVSRVM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGZpbHRlciByZXNvbHV0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgRklMVEVSX1JFU09MVVRJT046IDEsXG5cblxuICAgIC8vIFRPRE86IG1heWJlIGNoYW5nZSB0byBTUFJJVEUuQkFUQ0hfU0laRTogMjAwMFxuICAgIC8vIFRPRE86IG1heWJlIGFkZCBQQVJUSUNMRS5CQVRDSF9TSVpFOiAxNTAwMFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgc3ByaXRlIGJhdGNoIHNpemUuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBhaW1zIHRvIGJhbGFuY2UgZGVza3RvcCBhbmQgbW9iaWxlIGRldmljZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDQwOTZcbiAgICAgKi9cbiAgICBTUFJJVEVfQkFUQ0hfU0laRTogNDA5NixcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmaXggdGhhdCBkZW5vdGVzIGEgVVJMIGlzIGZvciBhIHJldGluYSBhc3NldC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtSZWdFeHB8c3RyaW5nfVxuICAgICAqIEBleGFtcGxlIGBAMnhgXG4gICAgICogQGRlZmF1bHQgL0AoLispeC9cbiAgICAgKi9cbiAgICBSRVRJTkFfUFJFRklYOiAvQCguKyl4LyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHJlbmRlciBvcHRpb25zIGlmIG5vbmUgYXJlIHN1cHBsaWVkIHRvIHtAbGluayBQSVhJLldlYkdMUmVuZGVyZXJ9XG4gICAgICogb3Ige0BsaW5rIFBJWEkuQ2FudmFzUmVuZGVyZXJ9LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0hUTUxDYW52YXNFbGVtZW50fSB2aWV3PW51bGxcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVzb2x1dGlvbj0xXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBhbnRpYWxpYXM9ZmFsc2VcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZvcmNlRlhBQT1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXV0b1Jlc2l6ZT1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJhbnNwYXJlbnQ9ZmFsc2VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmFja2dyb3VuZENvbG9yPTB4MDAwMDAwXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBjbGVhckJlZm9yZVJlbmRlcj10cnVlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2VcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHJvdW5kUGl4ZWxzPWZhbHNlXG4gICAgICovXG4gICAgUkVOREVSX09QVElPTlM6IHtcbiAgICAgICAgdmlldzogbnVsbCxcbiAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICBmb3JjZUZYQUE6IGZhbHNlLFxuICAgICAgICBhdXRvUmVzaXplOiBmYWxzZSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogMHgwMDAwMDAsXG4gICAgICAgIGNsZWFyQmVmb3JlUmVuZGVyOiB0cnVlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgICByb3VuZFBpeGVsczogZmFsc2UsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdHJhbnNmb3JtIHR5cGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7UElYSS5UUkFOU0ZPUk1fTU9ERX1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLlRSQU5TRk9STV9NT0RFLlNUQVRJQ1xuICAgICAqL1xuICAgIFRSQU5TRk9STV9NT0RFOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtQSVhJLkdDX01PREVTfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuR0NfTU9ERVMuQVVUT1xuICAgICAqL1xuICAgIEdDX01PREU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtYXggaWRsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMzYwMFxuICAgICAqL1xuICAgIEdDX01BWF9JRExFOiA2MCAqIDYwLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbWF4aW11bSBjaGVjayBjb3VudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNjAwXG4gICAgICovXG4gICAgR0NfTUFYX0NIRUNLX0NPVU5UOiA2MCAqIDEwLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB3cmFwIG1vZGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBwaXhpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge1BJWEkuV1JBUF9NT0RFU31cbiAgICAgKiBAZGVmYXVsdCBQSVhJLldSQVBfTU9ERVMuQ0xBTVBcbiAgICAgKi9cbiAgICBXUkFQX01PREU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7UElYSS5TQ0FMRV9NT0RFU31cbiAgICAgKiBAZGVmYXVsdCBQSVhJLlNDQUxFX01PREVTLkxJTkVBUlxuICAgICAqL1xuICAgIFNDQUxFX01PREU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHNwZWNpZnkgZmxvYXQgcHJlY2lzaW9uIGluIHNoYWRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7UElYSS5QUkVDSVNJT059XG4gICAgICogQGRlZmF1bHQgUElYSS5QUkVDSVNJT04uTUVESVVNXG4gICAgICovXG4gICAgUFJFQ0lTSU9OOiAnbWVkaXVtcCcsXG5cbn07XG4iLCJpbXBvcnQgXyBmcm9tIFwiLi91bmRlcnNjb3JlXCI7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSBcIi4uL3NldHRpbmdzXCJcblxudmFyIGFkZE9yUm1vdmVFdmVudEhhbmQgPSBmdW5jdGlvbiggZG9tSGFuZCAsIGllSGFuZCApe1xuICAgIGlmKCBkb2N1bWVudFsgZG9tSGFuZCBdICl7XG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50RG9tRm4oIGVsICwgdHlwZSAsIGZuICl7XG4gICAgICAgICAgICBpZiggZWwubGVuZ3RoICl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTAgOyBpIDwgZWwubGVuZ3RoIDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREb21GbiggZWxbaV0gLCB0eXBlICwgZm4gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsWyBkb21IYW5kIF0oIHR5cGUgLCBmbiAsIGZhbHNlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBldmVudERvbUZuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRGbiggZWwgLCB0eXBlICwgZm4gKXtcbiAgICAgICAgICAgIGlmKCBlbC5sZW5ndGggKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MCA7IGkgPCBlbC5sZW5ndGggOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBldmVudEZuKCBlbFtpXSx0eXBlLGZuICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbFsgaWVIYW5kIF0oIFwib25cIit0eXBlICwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoIGVsICwgd2luZG93LmV2ZW50ICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBldmVudEZuXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIC8vIGRvbeaTjeS9nOebuOWFs+S7o+eggVxuICAgIHF1ZXJ5IDogZnVuY3Rpb24oZWwpe1xuICAgICAgICBpZihfLmlzU3RyaW5nKGVsKSl7XG4gICAgICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbClcbiAgICAgICAgfVxuICAgICAgICBpZihlbC5ub2RlVHlwZSA9PSAxKXtcbiAgICAgICAgICAgLy/liJnkuLrkuIDkuKplbGVtZW505pys6LqrXG4gICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICB9XG4gICAgICAgIGlmKGVsLmxlbmd0aCl7XG4gICAgICAgICAgIHJldHVybiBlbFswXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgb2Zmc2V0IDogZnVuY3Rpb24oZWwpe1xuICAgICAgICB2YXIgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIFxuICAgICAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50LCBcbiAgICAgICAgYm9keSA9IGRvYy5ib2R5LCBcbiAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQsIFxuXG4gICAgICAgIC8vIGZvciBpZSAgXG4gICAgICAgIGNsaWVudFRvcCA9IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDAsIFxuICAgICAgICBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwLCBcblxuICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciA3IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIHBoeXNpY2FsLCBcbiAgICAgICAgLy8gd2hpbGUgb3RoZXJzIGFyZSBsb2dpY2FsLiBNYWtlIGFsbCBsb2dpY2FsLCBsaWtlIGluIElFOC4gXG4gICAgICAgIHpvb20gPSAxOyBcbiAgICAgICAgaWYgKGJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7IFxuICAgICAgICAgICAgdmFyIGJvdW5kID0gYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgXG4gICAgICAgICAgICB6b29tID0gKGJvdW5kLnJpZ2h0IC0gYm91bmQubGVmdCkvYm9keS5jbGllbnRXaWR0aDsgXG4gICAgICAgIH0gXG4gICAgICAgIGlmICh6b29tID4gMSl7IFxuICAgICAgICAgICAgY2xpZW50VG9wID0gMDsgXG4gICAgICAgICAgICBjbGllbnRMZWZ0ID0gMDsgXG4gICAgICAgIH0gXG4gICAgICAgIHZhciB0b3AgPSBib3gudG9wL3pvb20gKyAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5zY3JvbGxUb3Avem9vbSB8fCBib2R5LnNjcm9sbFRvcC96b29tKSAtIGNsaWVudFRvcCwgXG4gICAgICAgICAgICBsZWZ0ID0gYm94LmxlZnQvem9vbSArICh3aW5kb3cucGFnZVhPZmZzZXR8fCBkb2NFbGVtICYmIGRvY0VsZW0uc2Nyb2xsTGVmdC96b29tIHx8IGJvZHkuc2Nyb2xsTGVmdC96b29tKSAtIGNsaWVudExlZnQ7IFxuXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgdG9wOiB0b3AsIFxuICAgICAgICAgICAgbGVmdDogbGVmdCBcbiAgICAgICAgfTsgXG4gICAgfSxcbiAgICBhZGRFdmVudCA6IGFkZE9yUm1vdmVFdmVudEhhbmQoIFwiYWRkRXZlbnRMaXN0ZW5lclwiICwgXCJhdHRhY2hFdmVudFwiICksXG4gICAgcmVtb3ZlRXZlbnQgOiBhZGRPclJtb3ZlRXZlbnRIYW5kKCBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiAsIFwiZGV0YWNoRXZlbnRcIiApLFxuICAgIHBhZ2VYOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnBhZ2VYKSByZXR1cm4gZS5wYWdlWDtcbiAgICAgICAgZWxzZSBpZiAoZS5jbGllbnRYKVxuICAgICAgICAgICAgcmV0dXJuIGUuY2xpZW50WCArIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA/XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KTtcbiAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHBhZ2VZOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnBhZ2VZKSByZXR1cm4gZS5wYWdlWTtcbiAgICAgICAgZWxzZSBpZiAoZS5jbGllbnRZKVxuICAgICAgICAgICAgcmV0dXJuIGUuY2xpZW50WSArIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID9cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKTtcbiAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWIm+W7umRvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgOiBkb20gdHlwZe+8jCBzdWNoIGFzIGNhbnZhcywgZGl2IGV0Yy5cbiAgICAgKi9cbiAgICBjcmVhdGVDYW52YXMgOiBmdW5jdGlvbiggX3dpZHRoICwgX2hlaWdodCAsIGlkKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggID0gX3dpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IF9oZWlnaHQgKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCAgID0gMDtcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCAgICA9IDA7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgX3dpZHRoICogc2V0dGluZ3MuUkVTT0xVVElPTik7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIF9oZWlnaHQgKiBzZXR0aW5ncy5SRVNPTFVUSU9OKTtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcbiAgICBjcmVhdGVWaWV3OiBmdW5jdGlvbihfd2lkdGggLCBfaGVpZ2h0LCBpZCl7XG4gICAgICAgIHZhciB2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmlldy5jbGFzc05hbWUgPSBcImNhbnZheC12aWV3XCI7XG4gICAgICAgIHZpZXcuc3R5bGUuY3NzVGV4dCArPSBcInBvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOlwiICsgX3dpZHRoICsgXCJweDtoZWlnaHQ6XCIgKyBfaGVpZ2h0ICtcInB4O1wiXG5cbiAgICAgICAgdmFyIHN0YWdlX2MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2aWV3LnN0eWxlLmNzc1RleHQgKz0gXCJwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDpcIiArIF93aWR0aCArIFwicHg7aGVpZ2h0OlwiICsgX2hlaWdodCArXCJweDtcIlxuXG4gICAgICAgIC8v55So5p2l5a2Y5pS+5LiA5LqbZG9t5YWD57SgXG4gICAgICAgIHZhciBkb21fYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZpZXcuc3R5bGUuY3NzVGV4dCArPSBcInBvc2l0aW9uOmFic29sdXRlO3dpZHRoOlwiICsgX3dpZHRoICsgXCJweDtoZWlnaHQ6XCIgKyBfaGVpZ2h0ICtcInB4O1wiXG5cbiAgICAgICAgdmlldy5hcHBlbmRDaGlsZChzdGFnZV9jKTtcbiAgICAgICAgdmlldy5hcHBlbmRDaGlsZChkb21fYyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlldyA6IHZpZXcsXG4gICAgICAgICAgICBzdGFnZV9jOiBzdGFnZV9jLFxuICAgICAgICAgICAgZG9tX2M6IGRvbV9jXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9kb23nm7jlhbPku6PnoIHnu5PmnZ9cbn07IiwiLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICovXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL2Rpc3BsYXkvUG9pbnRcIjtcbmltcG9ydCBDYW52YXhFdmVudCBmcm9tIFwiLi9DYW52YXhFdmVudFwiO1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcbmltcG9ydCAkIGZyb20gXCIuLi91dGlscy9kb21cIjtcblxudmFyIF9tb3VzZUV2ZW50VHlwZXMgPSBbXCJjbGlja1wiLFwiZGJsY2xpY2tcIixcIm1vdXNlZG93blwiLFwibW91c2Vtb3ZlXCIsXCJtb3VzZXVwXCIsXCJtb3VzZW91dFwiXTtcbnZhciBfaGFtbWVyRXZlbnRUeXBlcyA9IFsgXG4gICAgXCJwYW5cIixcInBhbnN0YXJ0XCIsXCJwYW5tb3ZlXCIsXCJwYW5lbmRcIixcInBhbmNhbmNlbFwiLFwicGFubGVmdFwiLFwicGFucmlnaHRcIixcInBhbnVwXCIsXCJwYW5kb3duXCIsXG4gICAgXCJwcmVzc1wiICwgXCJwcmVzc3VwXCIsXG4gICAgXCJzd2lwZVwiICwgXCJzd2lwZWxlZnRcIiAsIFwic3dpcGVyaWdodFwiICwgXCJzd2lwZXVwXCIgLCBcInN3aXBlZG93blwiLFxuICAgIFwidGFwXCJcbl07XG5cbnZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbihjYW52YXggLCBvcHQpIHtcbiAgICB0aGlzLmNhbnZheCA9IGNhbnZheDtcblxuICAgIHRoaXMuY3VyUG9pbnRzID0gW25ldyBQb2ludCgwLCAwKV0gLy9YLFkg55qEIHBvaW50IOmbhuWQiCwg5ZyodG91Y2jkuIvpnaLliJnkuLogdG91Y2jnmoTpm4blkIjvvIzlj6rmmK/ov5nkuKp0b3VjaOiiq+a3u+WKoOS6huWvueW6lOeahHjvvIx5XG4gICAgLy/lvZPliY3mv4DmtLvnmoTngrnlr7nlupTnmoRvYmrvvIzlnKh0b3VjaOS4i+WPr+S7peaYr+S4quaVsOe7hCzlkozkuIrpnaLnmoQgY3VyUG9pbnRzIOWvueW6lFxuICAgIHRoaXMuY3VyUG9pbnRzVGFyZ2V0ID0gW107XG5cbiAgICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuICAgIC8v5q2j5Zyo5ouW5Yqo77yM5YmN5o+Q5pivX3RvdWNoaW5nPXRydWVcbiAgICB0aGlzLl9kcmFnaW5nID0gZmFsc2U7XG5cbiAgICAvL+W9k+WJjeeahOm8oOagh+eKtuaAgVxuICAgIHRoaXMuX2N1cnNvciA9IFwiZGVmYXVsdFwiO1xuXG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLmNhbnZheC52aWV3O1xuICAgIHRoaXMudHlwZXMgPSBbXTtcblxuICAgIC8vbW91c2XkvZPnu5/kuK3kuI3pnIDopoHphY3nva5kcmFnLHRvdWNo5Lit5Lya55So5Yiw56ys5LiJ5pa555qEdG91Y2jlupPvvIzmr4/kuKrlupPnmoTkuovku7blkI3np7Dlj6/og73kuI3kuIDmoLfvvIxcbiAgICAvL+Wwseimgei/memHjOmFjee9ru+8jOm7mOiupOWunueOsOeahOaYr2hhbW1lcmpz55qELOaJgOS7pem7mOiupOWPr+S7peWcqOmhueebrumHjOW8leWFpWhhbW1lcmpzIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vXG4gICAgdGhpcy5kcmFnID0ge1xuICAgICAgICBzdGFydCA6IFwicGFuc3RhcnRcIixcbiAgICAgICAgbW92ZSA6IFwicGFubW92ZVwiLFxuICAgICAgICBlbmQgOiBcInBhbmVuZFwiXG4gICAgfTtcblxuICAgIF8uZXh0ZW5kKCB0cnVlICwgdGhpcyAsIG9wdCApO1xuXG59O1xuXG4vL+i/meagt+eahOWlveWkhOaYr2RvY3VtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9u5Y+q5Lya5Zyo5a6a5LmJ55qE5pe25YCZ5omn6KGM5LiA5qyh44CCXG52YXIgY29udGFpbnMgPSBkb2N1bWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYoICFjaGlsZCApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhIShwYXJlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oY2hpbGQpICYgMTYpO1xufSA6IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYoICFjaGlsZCApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZCAhPT0gY2hpbGQgJiYgKHBhcmVudC5jb250YWlucyA/IHBhcmVudC5jb250YWlucyhjaGlsZCkgOiB0cnVlKTtcbn07XG5cbkV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICAvL+S+neasoea3u+WKoOS4iua1j+iniOWZqOeahOiHquW4puS6i+S7tuS+puWQrFxuICAgICAgICB2YXIgbWUgICA9IHRoaXM7XG4gICAgICAgIGlmKCBtZS50YXJnZXQubm9kZVR5cGUgPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAvL+WmguaenHRhcmdldC5ub2RlVHlwZeayoeacieeahOivne+8jCDor7TmmI7or6V0YXJnZXTkuLrkuIDkuKpqUXVlcnnlr7nosaEgb3Iga2lzc3kg5a+56LGhb3IgaGFtbWVy5a+56LGhXG4gICAgICAgICAgICAvL+WNs+S4uuesrOS4ieaWueW6k++8jOmCo+S5iOWwseimgeWvueaOpeesrOS4ieaWueW6k+eahOS6i+S7tuezu+e7n+OAgum7mOiupOWunueOsGhhbW1lcueahOWkp+mDqOWIhuS6i+S7tuezu+e7n1xuICAgICAgICAgICAgaWYoICFtZS50eXBlcyB8fCBtZS50eXBlcy5sZW5ndGggPT0gMCAgKXtcbiAgICAgICAgICAgICAgICBtZS50eXBlcyA9IF9oYW1tZXJFdmVudFR5cGVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCBtZS50YXJnZXQubm9kZVR5cGUgPT0gMSApe1xuICAgICAgICAgICAgbWUudHlwZXMgPSBfbW91c2VFdmVudFR5cGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIF8uZWFjaCggbWUudHlwZXMgLCBmdW5jdGlvbiggdHlwZSApe1xuICAgICAgICAgICAgLy/kuI3lho3lhbPlv4PmtY/op4jlmajnjq/looPmmK/lkKYgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IFxuICAgICAgICAgICAgLy/ogIzmmK/nm7TmjqXlj6rnrqHkvKDnu5nkuovku7bmqKHlnZfnmoTmmK/kuIDkuKrljp/nlJ9kb23ov5jmmK8ganHlr7nosaEgb3IgaGFtbWVy5a+56LGh562JXG4gICAgICAgICAgICBpZiggbWUudGFyZ2V0Lm5vZGVUeXBlID09IDEgKXtcbiAgICAgICAgICAgICAgICAkLmFkZEV2ZW50KCBtZS50YXJnZXQgLCB0eXBlICwgZnVuY3Rpb24oIGUgKXtcbiAgICAgICAgICAgICAgICAgICAgbWUuX19tb3VzZUhhbmRsZXIoIGUgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lLnRhcmdldC5vbiggdHlwZSAsIGZ1bmN0aW9uKCBlICl7XG4gICAgICAgICAgICAgICAgICAgIG1lLl9fbGliSGFuZGxlciggZSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApO1xuICAgIH0sXG4gICAgLypcbiAgICAqIOWOn+eUn+S6i+S7tuezu+e7ny0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLWJlZ2luXG4gICAgKiDpvKDmoIfkuovku7blpITnkIblh73mlbBcbiAgICAqKi9cbiAgICBfX21vdXNlSGFuZGxlciA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgPSBtZS5jYW52YXg7XG5cbiAgICAgICAgcm9vdC51cGRhdGVWaWV3T2Zmc2V0KCk7XG4gICAgXG4gICAgICAgIG1lLmN1clBvaW50cyA9IFsgbmV3IFBvaW50KCBcbiAgICAgICAgICAgICQucGFnZVgoIGUgKSAtIHJvb3Qudmlld09mZnNldC5sZWZ0ICwgXG4gICAgICAgICAgICAkLnBhZ2VZKCBlICkgLSByb290LnZpZXdPZmZzZXQudG9wXG4gICAgICAgICldO1xuXG4gICAgICAgIC8v55CG6K665LiK5p2l6K+077yM6L+Z6YeM5ou/5YiwcG9pbnTkuoblkI7vvIzlsLHopoHorqHnrpfov5nkuKpwb2ludOWvueW6lOeahHRhcmdldOadpXB1c2jliLBjdXJQb2ludHNUYXJnZXTph4zvvIxcbiAgICAgICAgLy/kvYbmmK/lm6DkuLrlnKhkcmFn55qE5pe25YCZ5YW25a6e5piv5Y+v5Lul5LiN55So6K6h566X5a+55bqUdGFyZ2V055qE44CCXG4gICAgICAgIC8v5omA5Lul5pS+5Zyo5LqG5LiL6Z2i55qEbWUuX19nZXRjdXJQb2ludHNUYXJnZXQoIGUgLCBjdXJNb3VzZVBvaW50ICk75bi46KeEbW91c2Vtb3Zl5Lit5omn6KGMXG5cbiAgICAgICAgdmFyIGN1ck1vdXNlUG9pbnQgID0gbWUuY3VyUG9pbnRzWzBdOyBcbiAgICAgICAgdmFyIGN1ck1vdXNlVGFyZ2V0ID0gbWUuY3VyUG9pbnRzVGFyZ2V0WzBdO1xuXG4gICAgICAgIC8v5qih5oufZHJhZyxtb3VzZW92ZXIsbW91c2VvdXQg6YOo5YiG5Luj56CBIGJlZ2luLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIC8vbW91c2Vkb3du55qE5pe25YCZIOWmguaenCBjdXJNb3VzZVRhcmdldC5kcmFnRW5hYmxlZCDkuLp0cnVl44CC5bCx6KaB5byA5aeL5YeG5aSHZHJhZ+S6hlxuICAgICAgICBpZiggZS50eXBlID09IFwibW91c2Vkb3duXCIgKXtcbiAgICAgICAgICAgLy/lpoLmnpxjdXJUYXJnZXQg55qE5pWw57uE5Li656m65oiW6ICF56ys5LiA5Liq5Li6ZmFsc2Ug77yM77yM77yMXG4gICAgICAgICAgIGlmKCAhY3VyTW91c2VUYXJnZXQgKXtcbiAgICAgICAgICAgICB2YXIgb2JqID0gcm9vdC5nZXRPYmplY3RzVW5kZXJQb2ludCggY3VyTW91c2VQb2ludCAsIDEpWzBdO1xuICAgICAgICAgICAgIGlmKG9iail7XG4gICAgICAgICAgICAgICBtZS5jdXJQb2ludHNUYXJnZXQgPSBbIG9iaiBdO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfTtcbiAgICAgICAgICAgY3VyTW91c2VUYXJnZXQgPSBtZS5jdXJQb2ludHNUYXJnZXRbMF07XG4gICAgICAgICAgIGlmICggY3VyTW91c2VUYXJnZXQgJiYgY3VyTW91c2VUYXJnZXQuZHJhZ0VuYWJsZWQgKXtcbiAgICAgICAgICAgICAgIC8v6byg5qCH5LqL5Lu25bey57uP5pG45Yiw5LqG5LiA5LiqXG4gICAgICAgICAgICAgICBtZS5fdG91Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBlLnR5cGUgPT0gXCJtb3VzZXVwXCIgfHwgKGUudHlwZSA9PSBcIm1vdXNlb3V0XCIgJiYgIWNvbnRhaW5zKHJvb3QudmlldyAsIChlLnRvRWxlbWVudCB8fCBlLnJlbGF0ZWRUYXJnZXQpICkpICl7XG4gICAgICAgICAgICBpZihtZS5fZHJhZ2luZyA9PSB0cnVlKXtcbiAgICAgICAgICAgICAgICAvL+ivtOaYjuWImuWImuWcqOaLluWKqFxuICAgICAgICAgICAgICAgIG1lLl9kcmFnRW5kKCBlICwgY3VyTW91c2VUYXJnZXQgLCAwICk7XG4gICAgICAgICAgICAgICAgY3VyTW91c2VUYXJnZXQuZmlyZShcImRyYWdlbmRcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWUuX2RyYWdpbmcgID0gZmFsc2U7XG4gICAgICAgICAgICBtZS5fdG91Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggZS50eXBlID09IFwibW91c2VvdXRcIiApe1xuICAgICAgICAgICAgaWYoICFjb250YWlucyhyb290LnZpZXcgLCAoZS50b0VsZW1lbnQgfHwgZS5yZWxhdGVkVGFyZ2V0KSApICl7XG4gICAgICAgICAgICAgICAgbWUuX19nZXRjdXJQb2ludHNUYXJnZXQoZSAsIGN1ck1vdXNlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIGUudHlwZSA9PSBcIm1vdXNlbW92ZVwiICl7ICAvL3x8IGUudHlwZSA9PSBcIm1vdXNlZG93blwiICl7XG4gICAgICAgICAgICAvL+aLluWKqOi/h+eoi+S4reWwseS4jeWcqOWBmuWFtuS7lueahG1vdXNlb3ZlcuajgOa1i++8jGRyYWfkvJjlhYhcbiAgICAgICAgICAgIGlmKG1lLl90b3VjaGluZyAmJiBlLnR5cGUgPT0gXCJtb3VzZW1vdmVcIiAmJiBjdXJNb3VzZVRhcmdldCl7XG4gICAgICAgICAgICAgICAgLy/or7TmmI7mraPlnKjmi5bliqjllYpcbiAgICAgICAgICAgICAgICBpZighbWUuX2RyYWdpbmcpe1xuICAgICAgICAgICAgICAgICAgICAvL2JlZ2luIGRyYWdcbiAgICAgICAgICAgICAgICAgICAgY3VyTW91c2VUYXJnZXQuZmlyZShcImRyYWdzdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy/lhYjmiormnKzlsIrnu5npmpDol4/kuoZcbiAgICAgICAgICAgICAgICAgICAgY3VyTW91c2VUYXJnZXQuY29udGV4dC5nbG9iYWxBbHBoYSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8v54S25ZCO5YWL6ZqG5LiA5Liq5Ymv5pys5YiwYWN0aXZlU3RhZ2VcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZU9iamVjdCA9IG1lLl9jbG9uZTJob3ZlclN0YWdlKCBjdXJNb3VzZVRhcmdldCAsIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVPYmplY3QuY29udGV4dC5nbG9iYWxBbHBoYSA9IGN1ck1vdXNlVGFyZ2V0Ll9nbG9iYWxBbHBoYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2RyYWcgbW92ZSBpbmdcbiAgICAgICAgICAgICAgICAgICAgbWUuX2RyYWdNb3ZlSGFuZGVyKCBlICwgY3VyTW91c2VUYXJnZXQgLCAwICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZS5fZHJhZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8v5bi46KeEbW91c2Vtb3Zl5qOA5rWLXG4gICAgICAgICAgICAgICAgLy9tb3Zl5LqL5Lu25Lit77yM6ZyA6KaB5LiN5YGc55qE5pCc57SidGFyZ2V077yM6L+Z5Liq5byA6ZSA5oy65aSn77yMXG4gICAgICAgICAgICAgICAgLy/lkI7nu63lj6/ku6XkvJjljJbvvIzliqDkuIrlkozluKfnjofnm7jlvZPnmoTlu7bov5/lpITnkIZcbiAgICAgICAgICAgICAgICBtZS5fX2dldGN1clBvaW50c1RhcmdldCggZSAsIGN1ck1vdXNlUG9pbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy/lhbbku5bnmoTkuovku7blsLHnm7TmjqXlnKh0YXJnZXTkuIrpnaLmtL7lj5Hkuovku7ZcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGN1ck1vdXNlVGFyZ2V0O1xuICAgICAgICAgICAgaWYoICFjaGlsZCApe1xuICAgICAgICAgICAgICAgIGNoaWxkID0gcm9vdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZS5fX2Rpc3BhdGNoRXZlbnRJbkNoaWxkcyggZSAsIFsgY2hpbGQgXSApO1xuICAgICAgICAgICAgbWUuX2N1cnNvckhhbmRlciggY2hpbGQgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggcm9vdC5wcmV2ZW50RGVmYXVsdCApIHtcbiAgICAgICAgICAgIC8v6Zi75q2i6buY6K6k5rWP6KeI5Zmo5Yqo5L2cKFczQykgXG4gICAgICAgICAgICBpZiAoIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCApIHtcbiAgICAgICAgICAgICAgIMKgZS5wcmV2ZW50RGVmYXVsdCgpOyBcbiAgICAgICAgICAgIH3CoGVsc2Uge1xuICAgICAgICAgICAgwqDCoMKgwqB3aW5kb3cuZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTsgXG4gICAgfSxcbiAgICBfX2dldGN1clBvaW50c1RhcmdldCA6IGZ1bmN0aW9uKGUgLCBwb2ludCApIHtcbiAgICAgICAgdmFyIG1lICAgICA9IHRoaXM7XG4gICAgICAgIHZhciByb290ICAgPSBtZS5jYW52YXg7XG4gICAgICAgIHZhciBvbGRPYmogPSBtZS5jdXJQb2ludHNUYXJnZXRbMF07XG5cbiAgICAgICAgaWYoIG9sZE9iaiAmJiAhb2xkT2JqLmNvbnRleHQgKXtcbiAgICAgICAgICAgIG9sZE9iaiA9IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGUgPSBuZXcgQ2FudmF4RXZlbnQoIGUgKTtcblxuICAgICAgICBpZiggZS50eXBlPT1cIm1vdXNlbW92ZVwiXG4gICAgICAgICAgICAmJiBvbGRPYmogJiYgb2xkT2JqLl9ob3ZlckNsYXNzICYmIG9sZE9iai5wb2ludENoa1ByaW9yaXR5XG4gICAgICAgICAgICAmJiBvbGRPYmouZ2V0Q2hpbGRJblBvaW50KCBwb2ludCApICl7XG4gICAgICAgICAgICAvL+Wwj+S8mOWMlizpvKDmoIdtb3Zl55qE5pe25YCZ44CC6K6h566X6aKR546H5aSq5aSn77yM5omA5Lul44CC5YGa5q2k5LyY5YyWXG4gICAgICAgICAgICAvL+WmguaenOaciXRhcmdldOWtmOWcqO+8jOiAjOS4lOW9k+WJjeWFg+e0oOato+WcqGhvdmVyU3RhZ2XkuK3vvIzogIzkuJTlvZPliY3pvKDmoIfov5jlnKh0YXJnZXTlhoUs5bCx5rKh5b+F6KaB5Y+W5qOA5rWL5pW05LiqZGlzcGxheUxpc3TkuoZcbiAgICAgICAgICAgIC8v5byA5Y+R5rS+5Y+R5bi46KeEbW91c2Vtb3Zl5LqL5Lu2XG4gICAgICAgICAgICBlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldCA9IG9sZE9iajtcbiAgICAgICAgICAgIGUucG9pbnQgID0gb2xkT2JqLmdsb2JhbFRvTG9jYWwoIHBvaW50ICk7XG4gICAgICAgICAgICBvbGRPYmouZGlzcGF0Y2hFdmVudCggZSApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb2JqID0gcm9vdC5nZXRPYmplY3RzVW5kZXJQb2ludCggcG9pbnQgLCAxKVswXTtcblxuICAgICAgICBpZihvbGRPYmogJiYgb2xkT2JqICE9IG9iaiB8fCBlLnR5cGU9PVwibW91c2VvdXRcIikge1xuICAgICAgICAgICAgaWYoIG9sZE9iaiAmJiBvbGRPYmouY29udGV4dCApe1xuICAgICAgICAgICAgICAgIG1lLmN1clBvaW50c1RhcmdldFswXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZS50eXBlICAgICA9IFwibW91c2VvdXRcIjtcbiAgICAgICAgICAgICAgICBlLnRvVGFyZ2V0ID0gb2JqOyBcbiAgICAgICAgICAgICAgICBlLnRhcmdldCAgID0gZS5jdXJyZW50VGFyZ2V0ID0gb2xkT2JqO1xuICAgICAgICAgICAgICAgIGUucG9pbnQgICAgPSBvbGRPYmouZ2xvYmFsVG9Mb2NhbCggcG9pbnQgKTtcbiAgICAgICAgICAgICAgICBvbGRPYmouZGlzcGF0Y2hFdmVudCggZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBvYmogJiYgb2xkT2JqICE9IG9iaiApeyAvLyYmIG9iai5faG92ZXJhYmxlIOW3sue7jyDlubLmjonkuoZcbiAgICAgICAgICAgIG1lLmN1clBvaW50c1RhcmdldFswXSA9IG9iajtcbiAgICAgICAgICAgIGUudHlwZSAgICAgICA9IFwibW91c2VvdmVyXCI7XG4gICAgICAgICAgICBlLmZyb21UYXJnZXQgPSBvbGRPYmo7XG4gICAgICAgICAgICBlLnRhcmdldCAgICAgPSBlLmN1cnJlbnRUYXJnZXQgPSBvYmo7XG4gICAgICAgICAgICBlLnBvaW50ICAgICAgPSBvYmouZ2xvYmFsVG9Mb2NhbCggcG9pbnQgKTtcbiAgICAgICAgICAgIG9iai5kaXNwYXRjaEV2ZW50KCBlICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGUudHlwZSA9PSBcIm1vdXNlbW92ZVwiICYmIG9iaiApe1xuICAgICAgICAgICAgZS50YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQgPSBvbGRPYmo7XG4gICAgICAgICAgICBlLnBvaW50ICA9IG9sZE9iai5nbG9iYWxUb0xvY2FsKCBwb2ludCApO1xuICAgICAgICAgICAgb2xkT2JqLmRpc3BhdGNoRXZlbnQoIGUgKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWUuX2N1cnNvckhhbmRlciggb2JqICwgb2xkT2JqICk7XG4gICAgfSxcbiAgICBfY3Vyc29ySGFuZGVyICAgIDogZnVuY3Rpb24oIG9iaiAsIG9sZE9iaiApe1xuICAgICAgICBpZighb2JqICYmICFvbGRPYmogKXtcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnNvcihcImRlZmF1bHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYob2JqICYmIG9sZE9iaiAhPSBvYmogJiYgb2JqLmNvbnRleHQpe1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKG9iai5jb250ZXh0LmN1cnNvcik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9zZXRDdXJzb3IgOiBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgICAgaWYodGhpcy5fY3Vyc29yID09IGN1cnNvcil7XG4gICAgICAgICAgLy/lpoLmnpzkuKTmrKHopoHorr7nva7nmoTpvKDmoIfnirbmgIHmmK/kuIDmoLfnmoRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FudmF4LnZpZXcuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICB0aGlzLl9jdXJzb3IgPSBjdXJzb3I7XG4gICAgfSxcbiAgICAvKlxuICAgICog5Y6f55Sf5LqL5Lu257O757ufLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tZW5kXG4gICAgKi9cblxuICAgIC8qXG4gICAgICrnrKzkuInmlrnlupPnmoTkuovku7bns7vnu58tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1iZWdpblxuICAgICAq6Kem5bGP5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICogKi9cbiAgICBfX2xpYkhhbmRsZXIgOiBmdW5jdGlvbiggZSApIHtcbiAgICAgICAgdmFyIG1lICAgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdCA9IG1lLmNhbnZheDtcbiAgICAgICAgcm9vdC51cGRhdGVWaWV3T2Zmc2V0KCk7XG4gICAgICAgIC8vIHRvdWNoIOS4i+eahCBjdXJQb2ludHNUYXJnZXQg5LuOdG91Y2hlc+S4readpVxuICAgICAgICAvL+iOt+WPlmNhbnZheOWdkOagh+ezu+e7n+mHjOmdoueahOWdkOagh1xuICAgICAgICBtZS5jdXJQb2ludHMgPSBtZS5fX2dldENhbnZheFBvaW50SW5Ub3VjaHMoIGUgKTtcbiAgICAgICAgaWYoICFtZS5fZHJhZ2luZyApe1xuICAgICAgICAgICAgLy/lpoLmnpzlnKhkcmFnaW5n55qE6K+d77yMdGFyZ2V05bey57uP5piv6YCJ5Lit5LqG55qE77yM5Y+v5Lul5LiN55SoIOajgOa1i+S6hlxuICAgICAgICAgICAgbWUuY3VyUG9pbnRzVGFyZ2V0ID0gbWUuX19nZXRDaGlsZEluVG91Y2hzKCBtZS5jdXJQb2ludHMgKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYoIG1lLmN1clBvaW50c1RhcmdldC5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICAvL2RyYWflvIDlp4tcbiAgICAgICAgICAgIGlmKCBlLnR5cGUgPT0gbWUuZHJhZy5zdGFydCl7XG4gICAgICAgICAgICAgICAgLy9kcmFnc3RhcnTnmoTml7blgJl0b3VjaOW3sue7j+WHhuWkh+WlveS6hnRhcmdldO+8jCBjdXJQb2ludHNUYXJnZXQg6YeM6Z2i5Y+q6KaB5pyJ5LiA5Liq5piv5pyJ5pWI55qEXG4gICAgICAgICAgICAgICAgLy/lsLHorqTkuLpkcmFnc+W8gOWni1xuICAgICAgICAgICAgICAgIF8uZWFjaCggbWUuY3VyUG9pbnRzVGFyZ2V0ICwgZnVuY3Rpb24oIGNoaWxkICwgaSApe1xuICAgICAgICAgICAgICAgICAgICBpZiggY2hpbGQgJiYgY2hpbGQuZHJhZ0VuYWJsZWQgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgLy/lj6ropoHmnInkuIDkuKrlhYPntKDlsLHorqTkuLrmraPlnKjlh4blpIdkcmFn5LqGXG4gICAgICAgICAgICAgICAgICAgICAgIG1lLl9kcmFnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgLy/nhLblkI7lhYvpmobkuIDkuKrlia/mnKzliLBhY3RpdmVTdGFnZVxuICAgICAgICAgICAgICAgICAgICAgICBtZS5fY2xvbmUyaG92ZXJTdGFnZSggY2hpbGQgLCBpICk7XG4gICAgICAgICAgICAgICAgICAgICAgIC8v5YWI5oqK5pys5bCK57uZ6ZqQ6JeP5LqGXG4gICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmZpcmUoXCJkcmFnc3RhcnRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApIFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy9kcmFnSW5nXG4gICAgICAgICAgICBpZiggZS50eXBlID09IG1lLmRyYWcubW92ZSl7XG4gICAgICAgICAgICAgICAgaWYoIG1lLl9kcmFnaW5nICl7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaCggbWUuY3VyUG9pbnRzVGFyZ2V0ICwgZnVuY3Rpb24oIGNoaWxkICwgaSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGNoaWxkICYmIGNoaWxkLmRyYWdFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5fZHJhZ01vdmVIYW5kZXIoIGUgLCBjaGlsZCAsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL2RyYWfnu5PmnZ9cbiAgICAgICAgICAgIGlmKCBlLnR5cGUgPT0gbWUuZHJhZy5lbmQpe1xuICAgICAgICAgICAgICAgIGlmKCBtZS5fZHJhZ2luZyApe1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2goIG1lLmN1clBvaW50c1RhcmdldCAsIGZ1bmN0aW9uKCBjaGlsZCAsIGkgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBjaGlsZCAmJiBjaGlsZC5kcmFnRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9kcmFnRW5kKCBlICwgY2hpbGQgLCAwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZmlyZShcImRyYWdlbmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuX2RyYWdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWUuX19kaXNwYXRjaEV2ZW50SW5DaGlsZHMoIGUgLCBtZS5jdXJQb2ludHNUYXJnZXQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8v5aaC5p6c5b2T5YmN5rKh5pyJ5LiA5LiqdGFyZ2V077yM5bCx5oqK5LqL5Lu25rS+5Y+R5YiwY2FudmF45LiK6Z2iXG4gICAgICAgICAgICBtZS5fX2Rpc3BhdGNoRXZlbnRJbkNoaWxkcyggZSAsIFsgcm9vdCBdICk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvL+S7jnRvdWNoc+S4reiOt+WPluWIsOWvueW6lHRvdWNoICwg5Zyo5LiK6Z2i5re75Yqg5LiKY2FudmF45Z2Q5qCH57O757uf55qEeO+8jHlcbiAgICBfX2dldENhbnZheFBvaW50SW5Ub3VjaHMgOiBmdW5jdGlvbiggZSApe1xuICAgICAgICB2YXIgbWUgICAgICAgID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgICAgICA9IG1lLmNhbnZheDtcbiAgICAgICAgdmFyIGN1clRvdWNocyA9IFtdO1xuICAgICAgICBfLmVhY2goIGUucG9pbnQgLCBmdW5jdGlvbiggdG91Y2ggKXtcbiAgICAgICAgICAgY3VyVG91Y2hzLnB1c2goIHtcbiAgICAgICAgICAgICAgIHggOiBDYW52YXhFdmVudC5wYWdlWCggdG91Y2ggKSAtIHJvb3Qudmlld09mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgeSA6IENhbnZheEV2ZW50LnBhZ2VZKCB0b3VjaCApIC0gcm9vdC52aWV3T2Zmc2V0LnRvcFxuICAgICAgICAgICB9ICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VyVG91Y2hzO1xuICAgIH0sXG4gICAgX19nZXRDaGlsZEluVG91Y2hzIDogZnVuY3Rpb24oIHRvdWNocyApe1xuICAgICAgICB2YXIgbWUgICA9IHRoaXM7XG4gICAgICAgIHZhciByb290ID0gbWUuY2FudmF4O1xuICAgICAgICB2YXIgdG91Y2hlc1RhcmdldCA9IFtdO1xuICAgICAgICBfLmVhY2goIHRvdWNocyAsIGZ1bmN0aW9uKHRvdWNoKXtcbiAgICAgICAgICAgIHRvdWNoZXNUYXJnZXQucHVzaCggcm9vdC5nZXRPYmplY3RzVW5kZXJQb2ludCggdG91Y2ggLCAxKVswXSApO1xuICAgICAgICB9ICk7XG4gICAgICAgIHJldHVybiB0b3VjaGVzVGFyZ2V0O1xuICAgIH0sXG4gICAgLypcbiAgICAq56ys5LiJ5pa55bqT55qE5LqL5Lu257O757ufLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tYmVnaW5cbiAgICAqL1xuXG5cbiAgICAvKlxuICAgICAqQHBhcmFtIHthcnJheX0gY2hpbGRzIFxuICAgICAqICovXG4gICAgX19kaXNwYXRjaEV2ZW50SW5DaGlsZHM6IGZ1bmN0aW9uKGUsIGNoaWxkcykge1xuICAgICAgICBpZiAoIWNoaWxkcyAmJiAhKFwibGVuZ3RoXCIgaW4gY2hpbGRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBoYXNDaGlsZCA9IGZhbHNlO1xuICAgICAgICBfLmVhY2goY2hpbGRzLCBmdW5jdGlvbihjaGlsZCwgaSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaGFzQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBjZSA9IG5ldyBDYW52YXhFdmVudChlKTtcbiAgICAgICAgICAgICAgICBjZS50YXJnZXQgPSBjZS5jdXJyZW50VGFyZ2V0ID0gY2hpbGQgfHwgdGhpcztcbiAgICAgICAgICAgICAgICBjZS5zdGFnZVBvaW50ID0gbWUuY3VyUG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGNlLnBvaW50ID0gY2UudGFyZ2V0Lmdsb2JhbFRvTG9jYWwoY2Uuc3RhZ2VQb2ludCk7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudChjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFzQ2hpbGQ7XG4gICAgfSxcbiAgICAvL+WFi+mahuS4gOS4quWFg+e0oOWIsGhvdmVyIHN0YWdl5Lit5Y67XG4gICAgX2Nsb25lMmhvdmVyU3RhZ2U6IGZ1bmN0aW9uKHRhcmdldCwgaSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdCA9IG1lLmNhbnZheDtcbiAgICAgICAgdmFyIF9kcmFnRHVwbGljYXRlID0gcm9vdC5fYnVmZmVyU3RhZ2UuZ2V0Q2hpbGRCeUlkKHRhcmdldC5pZCk7XG4gICAgICAgIGlmICghX2RyYWdEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIF9kcmFnRHVwbGljYXRlID0gdGFyZ2V0LmNsb25lKHRydWUpO1xuICAgICAgICAgICAgX2RyYWdEdXBsaWNhdGUuX3RyYW5zZm9ybSA9IHRhcmdldC5nZXRDb25jYXRlbmF0ZWRNYXRyaXgoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlRPRE86IOWboOS4uuWQjue7reWPr+iDveS8muacieaJi+WKqOa3u+WKoOeahCDlhYPntKDliLBfYnVmZmVyU3RhZ2Ug6YeM6Z2i5p2lXG4gICAgICAgICAgICAgKuavlOWmgnRpcHNcbiAgICAgICAgICAgICAq6L+Z57G75omL5Yqo5re75Yqg6L+b5p2l55qE6IKv5a6a5piv5Zug5Li66ZyA6KaB5pi+56S65Zyo5pyA5aSW5bGC55qE44CC5ZyoaG92ZXLlhYPntKDkuYvkuIrjgIJcbiAgICAgICAgICAgICAq5omA5pyJ6Ieq5Yqo5re75Yqg55qEaG92ZXLlhYPntKDpg73pu5jorqTmt7vliqDlnKhfYnVmZmVyU3RhZ2XnmoTmnIDlupXlsYJcbiAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIHJvb3QuX2J1ZmZlclN0YWdlLmFkZENoaWxkQXQoX2RyYWdEdXBsaWNhdGUsIDApO1xuICAgICAgICB9XG4gICAgICAgIF9kcmFnRHVwbGljYXRlLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0YXJnZXQuX2dsb2JhbEFscGhhO1xuICAgICAgICB0YXJnZXQuX2RyYWdQb2ludCA9IHRhcmdldC5nbG9iYWxUb0xvY2FsKG1lLmN1clBvaW50c1tpXSk7XG4gICAgICAgIHJldHVybiBfZHJhZ0R1cGxpY2F0ZTtcbiAgICB9LFxuICAgIC8vZHJhZyDkuK0g55qE5aSE55CG5Ye95pWwXG4gICAgX2RyYWdNb3ZlSGFuZGVyOiBmdW5jdGlvbihlLCB0YXJnZXQsIGkpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgPSBtZS5jYW52YXg7XG4gICAgICAgIHZhciBfcG9pbnQgPSB0YXJnZXQuZ2xvYmFsVG9Mb2NhbCggbWUuY3VyUG9pbnRzW2ldICk7XG5cbiAgICAgICAgLy/opoHlr7nlupTnmoTkv67mlLnmnKzlsIrnmoTkvY3nva7vvIzkvYbmmK/opoHlkYror4nlvJXmk47kuI3opoF3YXRjaOi/meS4quaXtuWAmeeahOWPmOWMllxuICAgICAgICB0YXJnZXQuX25vdFdhdGNoID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9tb3ZlU3RhZ2UgPSB0YXJnZXQubW92ZWluZztcbiAgICAgICAgdGFyZ2V0Lm1vdmVpbmcgPSB0cnVlO1xuICAgICAgICB0YXJnZXQuY29udGV4dC54ICs9IChfcG9pbnQueCAtIHRhcmdldC5fZHJhZ1BvaW50LngpO1xuICAgICAgICB0YXJnZXQuY29udGV4dC55ICs9IChfcG9pbnQueSAtIHRhcmdldC5fZHJhZ1BvaW50LnkpO1xuICAgICAgICB0YXJnZXQuZmlyZShcImRyYWdtb3ZlXCIpO1xuICAgICAgICB0YXJnZXQubW92ZWluZyA9IF9tb3ZlU3RhZ2U7XG4gICAgICAgIHRhcmdldC5fbm90V2F0Y2ggPSBmYWxzZTtcbiAgICAgICAgLy/lkIzmraXlrozmr5XmnKzlsIrnmoTkvY3nva5cblxuICAgICAgICAvL+i/memHjOWPquiDveebtOaOpeS/ruaUuV90cmFuc2Zvcm0g44CCIOS4jeiDveeUqOS4i+mdoueahOS/ruaUuXjvvIx555qE5pa55byP44CCXG4gICAgICAgIHZhciBfZHJhZ0R1cGxpY2F0ZSA9IHJvb3QuX2J1ZmZlclN0YWdlLmdldENoaWxkQnlJZCh0YXJnZXQuaWQpO1xuICAgICAgICBfZHJhZ0R1cGxpY2F0ZS5fdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbmNhdGVuYXRlZE1hdHJpeCgpO1xuICAgICAgICAvL+S7peS4uuebtOaOpeS/ruaUueeahF90cmFuc2Zvcm3kuI3kvJrlh7rlj5Hlv4Pot7PkuIrmiqXvvIwg5riy5p+T5byV5pOO5LiN5Yi25Yqo6L+Z5Liqc3RhZ2XpnIDopoHnu5jliLbjgIJcbiAgICAgICAgLy/miYDku6XopoHmiYvliqjlh7rlj5Hlv4Pot7PljIVcbiAgICAgICAgX2RyYWdEdXBsaWNhdGUuaGVhcnRCZWF0KCk7XG4gICAgfSxcbiAgICAvL2RyYWfnu5PmnZ/nmoTlpITnkIblh73mlbBcbiAgICBfZHJhZ0VuZDogZnVuY3Rpb24oZSwgdGFyZ2V0LCBpKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciByb290ID0gbWUuY2FudmF4O1xuXG4gICAgICAgIC8vX2RyYWdEdXBsaWNhdGUg5aSN5Yi25ZyoX2J1ZmZlclN0YWdlIOS4reeahOWJr+acrFxuICAgICAgICB2YXIgX2RyYWdEdXBsaWNhdGUgPSByb290Ll9idWZmZXJTdGFnZS5nZXRDaGlsZEJ5SWQodGFyZ2V0LmlkKTtcbiAgICAgICAgX2RyYWdEdXBsaWNhdGUuZGVzdHJveSgpO1xuXG4gICAgICAgIHRhcmdldC5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGFyZ2V0Ll9nbG9iYWxBbHBoYTtcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgRXZlbnRIYW5kbGVyOyIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOS6i+S7tueuoeeQhuexu1xuICovXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuXG4vKipcbiAqIOaehOmAoOWHveaVsC5cbiAqIEBuYW1lIEV2ZW50RGlzcGF0Y2hlclxuICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlcuexu+aYr+WPr+iwg+W6puS6i+S7tueahOexu+eahOWfuuexu++8jOWug+WFgeiuuOaYvuekuuWIl+ihqOS4iueahOS7u+S9leWvueixoemDveaYr+S4gOS4quS6i+S7tuebruagh+OAglxuICovXG52YXIgRXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgLy/kuovku7bmmKDlsITooajvvIzmoLzlvI/kuLrvvJp7dHlwZTE6W2xpc3RlbmVyMSwgbGlzdGVuZXIyXSwgdHlwZTI6W2xpc3RlbmVyMywgbGlzdGVuZXI0XX1cbiAgICB0aGlzLl9ldmVudE1hcCA9IHt9O1xufTtcblxuRXZlbnRNYW5hZ2VyLnByb3RvdHlwZSA9IHsgXG4gICAgLypcbiAgICAgKiDms6jlhozkuovku7bkvqblkKzlmajlr7nosaHvvIzku6Xkvb/kvqblkKzlmajog73lpJ/mjqXmlLbkuovku7bpgJrnn6XjgIJcbiAgICAgKi9cbiAgICBfYWRkRXZlbnRMaXN0ZW5lciA6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG5cbiAgICAgICAgaWYoIHR5cGVvZiBsaXN0ZW5lciAhPSBcImZ1bmN0aW9uXCIgKXtcbiAgICAgICAgICAvL2xpc3RlbmVy5b+F6aG75piv5LiqZnVuY3Rpb27lkZDkurJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZFJlc3VsdCA9IHRydWU7XG4gICAgICAgIHZhciBzZWxmICAgICAgPSB0aGlzO1xuICAgICAgICBfLmVhY2goIHR5cGUuc3BsaXQoXCIgXCIpICwgZnVuY3Rpb24odHlwZSl7XG4gICAgICAgICAgICB2YXIgbWFwID0gc2VsZi5fZXZlbnRNYXBbdHlwZV07XG4gICAgICAgICAgICBpZighbWFwKXtcbiAgICAgICAgICAgICAgICBtYXAgPSBzZWxmLl9ldmVudE1hcFt0eXBlXSA9IFtdO1xuICAgICAgICAgICAgICAgIG1hcC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9ldmVudEVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihfLmluZGV4T2YobWFwICxsaXN0ZW5lcikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtYXAucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgc2VsZi5fZXZlbnRFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWRkUmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yig6Zmk5LqL5Lu25L6m5ZCs5Zmo44CCXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIgOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJCeVR5cGUodHlwZSk7XG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX2V2ZW50TWFwW3R5cGVdO1xuICAgICAgICBpZighbWFwKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaSA9IG1hcFtpXTtcbiAgICAgICAgICAgIGlmKGxpID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIG1hcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaWYobWFwLmxlbmd0aCAgICA9PSAwKSB7IFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXBbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c6L+Z5Liq5aaC5p6c6L+Z5Liq5pe25YCZY2hpbGTmsqHmnInku7vkvZXkuovku7bkvqblkKxcbiAgICAgICAgICAgICAgICAgICAgaWYoXy5pc0VtcHR5KHRoaXMuX2V2ZW50TWFwKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL+mCo+S5iOivpeWFg+e0oOS4jeWGjeaOpeWPl+S6i+S7tueahOajgOa1i1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOWIoOmZpOaMh+Wumuexu+Wei+eahOaJgOacieS6i+S7tuS+puWQrOWZqOOAglxuICAgICAqL1xuICAgIF9yZW1vdmVFdmVudExpc3RlbmVyQnlUeXBlIDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fZXZlbnRNYXBbdHlwZV07XG4gICAgICAgIGlmKCFtYXApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFt0eXBlXTtcblxuICAgICAgICAgICAgLy/lpoLmnpzov5nkuKrlpoLmnpzov5nkuKrml7blgJljaGlsZOayoeacieS7u+S9leS6i+S7tuS+puWQrFxuICAgICAgICAgICAgaWYoXy5pc0VtcHR5KHRoaXMuX2V2ZW50TWFwKSl7XG4gICAgICAgICAgICAgICAgLy/pgqPkuYjor6XlhYPntKDkuI3lho3mjqXlj5fkuovku7bnmoTmo4DmtYtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yig6Zmk5omA5pyJ5LqL5Lu25L6m5ZCs5Zmo44CCXG4gICAgICovXG4gICAgX3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzIDogZnVuY3Rpb24oKSB7XHRcbiAgICAgICAgdGhpcy5fZXZlbnRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5fZXZlbnRFbmFibGVkID0gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAqIOa0vuWPkeS6i+S7tu+8jOiwg+eUqOS6i+S7tuS+puWQrOWZqOOAglxuICAgICovXG4gICAgX2Rpc3BhdGNoRXZlbnQgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9ldmVudE1hcFtlLnR5cGVdO1xuICAgICAgICBcbiAgICAgICAgaWYoIG1hcCApe1xuICAgICAgICAgICAgaWYoIWUudGFyZ2V0KSBlLnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBtYXAgPSBtYXAuc2xpY2UoKTtcblxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IG1hcFtpXTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YobGlzdGVuZXIpID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhZS5fc3RvcFByb3BhZ2F0aW9uICkge1xuICAgICAgICAgICAgLy/lkJHkuIrlhpLms6FcbiAgICAgICAgICAgIGlmKCB0aGlzLnBhcmVudCApe1xuICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Ll9kaXNwYXRjaEV2ZW50KCBlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgKiDmo4Dmn6XmmK/lkKbkuLrmjIflrprkuovku7bnsbvlnovms6jlhozkuobku7vkvZXkvqblkKzlmajjgIJcbiAgICAgICAqL1xuICAgIF9oYXNFdmVudExpc3RlbmVyIDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fZXZlbnRNYXBbdHlwZV07XG4gICAgICAgIHJldHVybiBtYXAgIT0gbnVsbCAmJiBtYXAubGVuZ3RoID4gMDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50TWFuYWdlcjtcbiIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOS6i+S7tua0vuWPkeexu1xuICovXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gXCIuL0V2ZW50TWFuYWdlclwiO1xuaW1wb3J0IENhbnZheEV2ZW50IGZyb20gXCIuL0NhbnZheEV2ZW50XCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuXG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbigpe1xuICAgIEV2ZW50RGlzcGF0Y2hlci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbmFtZSk7XG59O1xuXG5VdGlscy5jcmVhdENsYXNzKEV2ZW50RGlzcGF0Y2hlciAsIEV2ZW50TWFuYWdlciAsIHtcbiAgICBvbiA6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKXtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdW4gOiBmdW5jdGlvbih0eXBlLGxpc3RlbmVyKXtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24odHlwZSxsaXN0ZW5lcil7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyQnlUeXBlOmZ1bmN0aW9uKHR5cGUpe1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyQnlUeXBlKCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVBbGxFdmVudExpc3RlbmVyczpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy9wYXJhbXMg6KaB5Lyg57uZZXZ055qEZXZlbnRoYW5kbGVy5aSE55CG5Ye95pWw55qE5Y+C5pWw77yM5Lya6KKrbWVyZ2XliLBDYW52YXggZXZlbnTkuK1cbiAgICBmaXJlIDogZnVuY3Rpb24oZXZlbnRUeXBlICwgcGFyYW1zKXtcbiAgICAgICAgdmFyIGUgPSBuZXcgQ2FudmF4RXZlbnQoIGV2ZW50VHlwZSApO1xuXG4gICAgICAgIGlmKCBwYXJhbXMgKXtcbiAgICAgICAgICAgIGZvciggdmFyIHAgaW4gcGFyYW1zICl7XG4gICAgICAgICAgICAgICAgaWYoIHAgaW4gZSApe1xuICAgICAgICAgICAgICAgICAgICAvL3BhcmFtc+S4reeahOaVsOaNruS4jeiDveimhueblmV2ZW505bGe5oCnXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBwICsgXCLlsZ7mgKfkuI3og73opobnm5ZDYW52YXhFdmVudOWxnuaAp1wiIClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlW3BdID0gcGFyYW1zW3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBfLmVhY2goIGV2ZW50VHlwZS5zcGxpdChcIiBcIikgLCBmdW5jdGlvbihlVHlwZSl7XG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBtZTtcbiAgICAgICAgICAgIG1lLmRpc3BhdGNoRXZlbnQoIGUgKTtcbiAgICAgICAgfSApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRpc3BhdGNoRXZlbnQ6ZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAvL3RoaXMgaW5zdGFuY2VvZiBEaXNwbGF5T2JqZWN0Q29udGFpbmVyID09PiB0aGlzLmNoaWxkcmVuXG4gICAgICAgIC8vVE9ETzog6L+Z6YeMaW1wb3J0IERpc3BsYXlPYmplY3RDb250YWluZXIg55qE6K+d77yM5ZyoZGlzcGxheU9iamVjdOmHjOmdoueahGltcG9ydCBFdmVudERpc3BhdGNoZXIgZnJvbSBcIi4uL2V2ZW50L0V2ZW50RGlzcGF0Y2hlclwiO1xuICAgICAgICAvL+S8muW+l+WIsOS4gOS4qnVuZGVmaW5lZO+8jOaEn+inieaYr+aIkOS6huS4gOS4quW+queOr+S+nei1lueahOmXrumimO+8jOaJgOS7pei/memHjOaNoueUqOeugOWNleeahOWIpOaWreadpeWIpOaWreiHquW3seaYr+S4gOS4quWuueaYk++8jOaLpeaciWNoaWxkcmVuXG4gICAgICAgIGlmKCB0aGlzLmNoaWxkcmVuICAmJiBldmVudC5wb2ludCApe1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0T2JqZWN0c1VuZGVyUG9pbnQoIGV2ZW50LnBvaW50ICwgMSlbMF07XG4gICAgICAgICAgICBpZiggdGFyZ2V0ICl7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmNvbnRleHQgJiYgZXZlbnQudHlwZSA9PSBcIm1vdXNlb3ZlclwiKXtcbiAgICAgICAgICAgIC8v6K6w5b2VZGlzcGF0Y2hFdmVudOS5i+WJjeeahOW/g+i3s1xuICAgICAgICAgICAgdmFyIHByZUhlYXJ0QmVhdCA9IHRoaXMuX2hlYXJ0QmVhdE51bTtcbiAgICAgICAgICAgIHZhciBwcmVnQWxwaGEgICAgPSB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KCBldmVudCApO1xuICAgICAgICAgICAgaWYoIHByZUhlYXJ0QmVhdCAhPSB0aGlzLl9oZWFydEJlYXROdW0gKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlckNsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5ob3ZlckNsb25lICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXggPSB0aGlzLmdldFN0YWdlKCkucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAvL+eEtuWQjmNsb25l5LiA5Lu9b2Jq77yM5re75Yqg5YiwX2J1ZmZlclN0YWdlIOS4rVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aXZTaGFwZSA9IHRoaXMuY2xvbmUodHJ1ZSk7ICBcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZTaGFwZS5fdHJhbnNmb3JtID0gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmF4Ll9idWZmZXJTdGFnZS5hZGRDaGlsZEF0KCBhY3RpdlNoYXBlICwgMCApOyBcbiAgICAgICAgICAgICAgICAgICAgLy/nhLblkI7mioroh6rlt7HpmpDol4/kuoZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsQWxwaGEgPSBwcmVnQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG5cbiAgICAgICAgaWYoIHRoaXMuY29udGV4dCAmJiBldmVudC50eXBlID09IFwibW91c2VvdXRcIil7XG4gICAgICAgICAgICBpZih0aGlzLl9ob3ZlckNsYXNzKXtcbiAgICAgICAgICAgICAgICAvL+ivtOaYjuWImuWImm92ZXLnmoTml7blgJnmnInmt7vliqDmoLflvI9cbiAgICAgICAgICAgICAgICB2YXIgY2FudmF4ID0gdGhpcy5nZXRTdGFnZSgpLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlckNsYXNzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjYW52YXguX2J1ZmZlclN0YWdlLnJlbW92ZUNoaWxkQnlJZCh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggdGhpcy5fZ2xvYmFsQWxwaGEgKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy5fZ2xvYmFsQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9nbG9iYWxBbHBoYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGhhc0V2ZW50OmZ1bmN0aW9uKHR5cGUpe1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzRXZlbnRMaXN0ZW5lcih0eXBlKTtcbiAgICB9LFxuICAgIGhhc0V2ZW50TGlzdGVuZXI6ZnVuY3Rpb24odHlwZSl7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNFdmVudExpc3RlbmVyKHR5cGUpO1xuICAgIH0sXG4gICAgaG92ZXIgOiBmdW5jdGlvbiggb3ZlckZ1biAsIG91dEZ1biApe1xuICAgICAgICB0aGlzLm9uKFwibW91c2VvdmVyXCIgLCBvdmVyRnVuKTtcbiAgICAgICAgdGhpcy5vbihcIm1vdXNlb3V0XCIgICwgb3V0RnVuICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jZSA6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKXtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIG9uY2VIYW5kbGUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkobWUgLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy51bih0eXBlICwgb25jZUhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24odHlwZSAsIG9uY2VIYW5kbGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnREaXNwYXRjaGVyO1xuIiwiXG4vKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiB8IGEgfCBjIHwgdHh8XG4gKiB8IGIgfCBkIHwgdHl8XG4gKiB8IDAgfCAwIHwgMSB8XG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICpcbiAqXG4gKiBNYXRyaXgg55+p6Zi15bqTIOeUqOS6juaVtOS4quezu+e7n+eahOWHoOS9leWPmOaNouiuoeeul1xuICovXG5cbnZhciBNYXRyaXggPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpe1xuICAgIHRoaXMuYSA9IGEgIT0gdW5kZWZpbmVkID8gYSA6IDE7XG4gICAgdGhpcy5iID0gYiAhPSB1bmRlZmluZWQgPyBiIDogMDtcbiAgICB0aGlzLmMgPSBjICE9IHVuZGVmaW5lZCA/IGMgOiAwO1xuICAgIHRoaXMuZCA9IGQgIT0gdW5kZWZpbmVkID8gZCA6IDE7XG4gICAgdGhpcy50eCA9IHR4ICE9IHVuZGVmaW5lZCA/IHR4IDogMDtcbiAgICB0aGlzLnR5ID0gdHkgIT0gdW5kZWZpbmVkID8gdHkgOiAwO1xuICAgIHRoaXMuYXJyYXkgPSBudWxsO1xufTtcblxuTWF0cml4LnByb3RvdHlwZSA9IHtcbiAgICBjb25jYXQgOiBmdW5jdGlvbihtdHgpe1xuICAgICAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmM7XG4gICAgICAgIHZhciB0eCA9IHRoaXMudHg7XG5cbiAgICAgICAgdGhpcy5hID0gYSAqIG10eC5hICsgdGhpcy5iICogbXR4LmM7XG4gICAgICAgIHRoaXMuYiA9IGEgKiBtdHguYiArIHRoaXMuYiAqIG10eC5kO1xuICAgICAgICB0aGlzLmMgPSBjICogbXR4LmEgKyB0aGlzLmQgKiBtdHguYztcbiAgICAgICAgdGhpcy5kID0gYyAqIG10eC5iICsgdGhpcy5kICogbXR4LmQ7XG4gICAgICAgIHRoaXMudHggPSB0eCAqIG10eC5hICsgdGhpcy50eSAqIG10eC5jICsgbXR4LnR4O1xuICAgICAgICB0aGlzLnR5ID0gdHggKiBtdHguYiArIHRoaXMudHkgKiBtdHguZCArIG10eC50eTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb25jYXRUcmFuc2Zvcm0gOiBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24pe1xuICAgICAgICB2YXIgY29zID0gMTtcbiAgICAgICAgdmFyIHNpbiA9IDA7XG4gICAgICAgIGlmKHJvdGF0aW9uJTM2MCl7XG4gICAgICAgICAgICB2YXIgciA9IHJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHIpO1xuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4ocik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbmNhdChuZXcgTWF0cml4KGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCB4LCB5KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcm90YXRlIDogZnVuY3Rpb24oYW5nbGUpe1xuICAgICAgICAvL+ebruWJjeW3sue7j+aPkOS+m+WvuemhuuaXtumSiOmAhuaXtumSiOS4pOS4quaWueWQkeaXi+i9rOeahOaUr+aMgVxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgICB2YXIgYyA9IHRoaXMuYztcbiAgICAgICAgdmFyIHR4ID0gdGhpcy50eDtcblxuICAgICAgICBpZiAoYW5nbGU+MCl7XG4gICAgICAgICAgICB0aGlzLmEgPSBhICogY29zIC0gdGhpcy5iICogc2luO1xuICAgICAgICAgICAgdGhpcy5iID0gYSAqIHNpbiArIHRoaXMuYiAqIGNvcztcbiAgICAgICAgICAgIHRoaXMuYyA9IGMgKiBjb3MgLSB0aGlzLmQgKiBzaW47XG4gICAgICAgICAgICB0aGlzLmQgPSBjICogc2luICsgdGhpcy5kICogY29zO1xuICAgICAgICAgICAgdGhpcy50eCA9IHR4ICogY29zIC0gdGhpcy50eSAqIHNpbjtcbiAgICAgICAgICAgIHRoaXMudHkgPSB0eCAqIHNpbiArIHRoaXMudHkgKiBjb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3QgPSBNYXRoLnNpbihNYXRoLmFicyhhbmdsZSkpO1xuICAgICAgICAgICAgdmFyIGN0ID0gTWF0aC5jb3MoTWF0aC5hYnMoYW5nbGUpKTtcblxuICAgICAgICAgICAgdGhpcy5hID0gYSpjdCArIHRoaXMuYipzdDtcbiAgICAgICAgICAgIHRoaXMuYiA9IC1hKnN0ICsgdGhpcy5iKmN0O1xuICAgICAgICAgICAgdGhpcy5jID0gYypjdCArIHRoaXMuZCpzdDtcbiAgICAgICAgICAgIHRoaXMuZCA9IC1jKnN0ICsgY3QqdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy50eCA9IGN0KnR4ICsgc3QqdGhpcy50eTtcbiAgICAgICAgICAgIHRoaXMudHkgPSBjdCp0aGlzLnR5IC0gc3QqdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzY2FsZSA6IGZ1bmN0aW9uKHN4LCBzeSl7XG4gICAgICAgIHRoaXMuYSAqPSBzeDtcbiAgICAgICAgdGhpcy5kICo9IHN5O1xuICAgICAgICB0aGlzLnR4ICo9IHN4O1xuICAgICAgICB0aGlzLnR5ICo9IHN5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHRyYW5zbGF0ZSA6IGZ1bmN0aW9uKGR4LCBkeSl7XG4gICAgICAgIHRoaXMudHggKz0gZHg7XG4gICAgICAgIHRoaXMudHkgKz0gZHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaWRlbnRpdHkgOiBmdW5jdGlvbigpe1xuICAgICAgICAvL+WIneWni+WMllxuICAgICAgICB0aGlzLmEgPSB0aGlzLmQgPSAxO1xuICAgICAgICB0aGlzLmIgPSB0aGlzLmMgPSB0aGlzLnR4ID0gdGhpcy50eSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaW52ZXJ0IDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy/pgIblkJHnn6npmLVcbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiID0gdGhpcy5iO1xuICAgICAgICB2YXIgYyA9IHRoaXMuYztcbiAgICAgICAgdmFyIGQgPSB0aGlzLmQ7XG4gICAgICAgIHZhciB0eCA9IHRoaXMudHg7XG4gICAgICAgIHZhciBpID0gYSAqIGQgLSBiICogYztcblxuICAgICAgICB0aGlzLmEgPSBkIC8gaTtcbiAgICAgICAgdGhpcy5iID0gLWIgLyBpO1xuICAgICAgICB0aGlzLmMgPSAtYyAvIGk7XG4gICAgICAgIHRoaXMuZCA9IGEgLyBpO1xuICAgICAgICB0aGlzLnR4ID0gKGMgKiB0aGlzLnR5IC0gZCAqIHR4KSAvIGk7XG4gICAgICAgIHRoaXMudHkgPSAtKGEgKiB0aGlzLnR5IC0gYiAqIHR4KSAvIGk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xvbmUgOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMudHgsIHRoaXMudHkpO1xuICAgIH0sXG4gICAgdG9BcnJheSA6IGZ1bmN0aW9uKHRyYW5zcG9zZSwgb3V0KXtcbiAgICAgICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT0gMCApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vY2FudmFzMmQg5Lit5LiN5Lya5pyJ5Lu75L2V55qE5Y+C5pWw5Lyg5YWlXG4gICAgICAgICAgICByZXR1cm4gWyB0aGlzLmEgLCB0aGlzLmIgLCB0aGlzLmMgLCB0aGlzLmQgLCB0aGlzLnR4ICwgdGhpcy50eSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy93ZWJnbOeahGdsc2zpnIDopoHnlKjnmoTml7blgJnvvIzpnIDopoHkvKDlhaV0cmFuc3Bvc2Ug5p2l6L2s5o2i5Li65LiA5LiqMyoz5a6M5pW055+p6Zi1XG4gICAgICAgIGlmICghdGhpcy5hcnJheSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJyYXkgPSBvdXQgfHwgdGhpcy5hcnJheTtcblxuICAgICAgICBpZiAodHJhbnNwb3NlKVxuICAgICAgICB7XG4gICAgICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgICAgIGFycmF5WzFdID0gdGhpcy5iO1xuICAgICAgICAgICAgYXJyYXlbMl0gPSAwO1xuICAgICAgICAgICAgYXJyYXlbM10gPSB0aGlzLmM7XG4gICAgICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgICAgICAgIGFycmF5WzVdID0gMDtcbiAgICAgICAgICAgIGFycmF5WzZdID0gdGhpcy50eDtcbiAgICAgICAgICAgIGFycmF5WzddID0gdGhpcy50eTtcbiAgICAgICAgICAgIGFycmF5WzhdID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XG4gICAgICAgICAgICBhcnJheVsyXSA9IHRoaXMudHg7XG4gICAgICAgICAgICBhcnJheVszXSA9IHRoaXMuYjtcbiAgICAgICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgICAgICAgYXJyYXlbNV0gPSB0aGlzLnR5O1xuICAgICAgICAgICAgYXJyYXlbNl0gPSAwO1xuICAgICAgICAgICAgYXJyYXlbN10gPSAwO1xuICAgICAgICAgICAgYXJyYXlbOF0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog55+p6Zi15bem5LmY5ZCR6YePXG4gICAgICovXG4gICAgbXVsVmVjdG9yIDogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgYWEgPSB0aGlzLmEsIGFjID0gdGhpcy5jLCBhdHggPSB0aGlzLnR4O1xuICAgICAgICB2YXIgYWIgPSB0aGlzLmIsIGFkID0gdGhpcy5kLCBhdHkgPSB0aGlzLnR5O1xuXG4gICAgICAgIHZhciBvdXQgPSBbMCwwXTtcbiAgICAgICAgb3V0WzBdID0gdlswXSAqIGFhICsgdlsxXSAqIGFjICsgYXR4O1xuICAgICAgICBvdXRbMV0gPSB2WzBdICogYWIgKyB2WzFdICogYWQgKyBhdHk7XG5cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9ICAgIFxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXRyaXg7XG4iLCJpbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuXG4vKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG5cbiB2YXIgVFdFRU4gPSBUV0VFTiB8fCAoZnVuY3Rpb24gKCkge1xuXG4gXHR2YXIgX3R3ZWVucyA9IFtdO1xuXG4gXHRyZXR1cm4ge1xuXG4gXHRcdGdldEFsbDogZnVuY3Rpb24gKCkge1xuXG4gXHRcdFx0cmV0dXJuIF90d2VlbnM7XG5cbiBcdFx0fSxcblxuIFx0XHRyZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcblxuIFx0XHRcdF90d2VlbnMgPSBbXTtcblxuIFx0XHR9LFxuXG4gXHRcdGFkZDogZnVuY3Rpb24gKHR3ZWVuKSB7XG5cbiBcdFx0XHRfdHdlZW5zLnB1c2godHdlZW4pO1xuXG4gXHRcdH0sXG5cbiBcdFx0cmVtb3ZlOiBmdW5jdGlvbiAodHdlZW4pIHtcblxuXHRcdFx0dmFyIGkgPSBfLmluZGV4T2YoIF90d2VlbnMgLCB0d2VlbiApOy8vX3R3ZWVucy5pbmRleE9mKHR3ZWVuKTtcblxuXHRcdFx0aWYgKGkgIT09IC0xKSB7XG5cdFx0XHRcdF90d2VlbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKHRpbWUsIHByZXNlcnZlKSB7XG5cblx0XHRcdGlmIChfdHdlZW5zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0dGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHRpbWUgOiBUV0VFTi5ub3coKTtcblxuXHRcdFx0d2hpbGUgKGkgPCBfdHdlZW5zLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgLyogb2xkIFxuXHRcdFx0XHRpZiAoX3R3ZWVuc1tpXS51cGRhdGUodGltZSkgfHwgcHJlc2VydmUpIHtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3R3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ki9cblxuICAgICAgICAgICAgICAgIC8vbmV3IGNvZGVcbiAgICAgICAgICAgICAgICAvL2luIHJlYWwgd29ybGQsIHR3ZWVuLnVwZGF0ZSBoYXMgY2hhbmNlIHRvIHJlbW92ZSBpdHNlbGYsIHNvIHdlIGhhdmUgdG8gaGFuZGxlIHRoaXMgc2l0dWF0aW9uLlxuICAgICAgICAgICAgICAgIC8vaW4gY2VydGFpbiBjYXNlcywgb25VcGRhdGVDYWxsYmFjayB3aWxsIHJlbW92ZSBpbnN0YW5jZXMgaW4gX3R3ZWVucywgd2hpY2ggbWFrZSBfdHdlZW5zLnNwbGljZShpLCAxKSBmYWlsXG4gICAgICAgICAgICAgICAgLy9AbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tXG4gICAgICAgICAgICAgICAgdmFyIF90ID0gX3R3ZWVuc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgX3VwZGF0ZVJlcyA9IF90LnVwZGF0ZSh0aW1lKTtcblxuICAgICAgICAgICAgICAgIGlmKCAhX3R3ZWVuc1tpXSApe1xuICAgICAgICAgICAgICAgIFx0YnJlYWs7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIF90ID09PSBfdHdlZW5zW2ldICkge1xuICAgICAgICAgICAgICAgIFx0aWYgKCBfdXBkYXRlUmVzIHx8IHByZXNlcnZlICkge1xuICAgICAgICAgICAgICAgIFx0XHRpKys7XG4gICAgICAgICAgICAgICAgXHR9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFx0XHRfdHdlZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBcdH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cblxuLy8gSW5jbHVkZSBhIHBlcmZvcm1hbmNlLm5vdyBwb2x5ZmlsbC5cbi8vIEluIG5vZGUuanMsIHVzZSBwcm9jZXNzLmhydGltZS5cbmlmICh0eXBlb2YgKHdpbmRvdykgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiAocHJvY2VzcykgIT09ICd1bmRlZmluZWQnKSB7XG5cdFRXRUVOLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG5cblx0XHQvLyBDb252ZXJ0IFtzZWNvbmRzLCBuYW5vc2Vjb25kc10gdG8gbWlsbGlzZWNvbmRzLlxuXHRcdHJldHVybiB0aW1lWzBdICogMTAwMCArIHRpbWVbMV0gLyAxMDAwMDAwO1xuXHR9O1xufVxuLy8gSW4gYSBicm93c2VyLCB1c2Ugd2luZG93LnBlcmZvcm1hbmNlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXG5lbHNlIGlmICh0eXBlb2YgKHdpbmRvdykgIT09ICd1bmRlZmluZWQnICYmXG5cdHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmXG5cdHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCkge1xuXHQvLyBUaGlzIG11c3QgYmUgYm91bmQsIGJlY2F1c2UgZGlyZWN0bHkgYXNzaWduaW5nIHRoaXMgZnVuY3Rpb25cblx0Ly8gbGVhZHMgdG8gYW4gaW52b2NhdGlvbiBleGNlcHRpb24gaW4gQ2hyb21lLlxuXHRUV0VFTi5ub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93LmJpbmQod2luZG93LnBlcmZvcm1hbmNlKTtcbn1cbi8vIFVzZSBEYXRlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXG5lbHNlIGlmIChEYXRlLm5vdyAhPT0gdW5kZWZpbmVkKSB7XG5cdFRXRUVOLm5vdyA9IERhdGUubm93O1xufVxuLy8gT3RoZXJ3aXNlLCB1c2UgJ25ldyBEYXRlKCkuZ2V0VGltZSgpJy5cbmVsc2Uge1xuXHRUV0VFTi5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9O1xufVxuXG5cblRXRUVOLlR3ZWVuID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXG5cdHZhciBfb2JqZWN0ID0gb2JqZWN0O1xuXHR2YXIgX3ZhbHVlc1N0YXJ0ID0ge307XG5cdHZhciBfdmFsdWVzRW5kID0ge307XG5cdHZhciBfdmFsdWVzU3RhcnRSZXBlYXQgPSB7fTtcblx0dmFyIF9kdXJhdGlvbiA9IDEwMDA7XG5cdHZhciBfcmVwZWF0ID0gMDtcblx0dmFyIF9yZXBlYXREZWxheVRpbWU7XG5cdHZhciBfeW95byA9IGZhbHNlO1xuXHR2YXIgX2lzUGxheWluZyA9IGZhbHNlO1xuXHR2YXIgX3JldmVyc2VkID0gZmFsc2U7XG5cdHZhciBfZGVsYXlUaW1lID0gMDtcblx0dmFyIF9zdGFydFRpbWUgPSBudWxsO1xuXHR2YXIgX2Vhc2luZ0Z1bmN0aW9uID0gVFdFRU4uRWFzaW5nLkxpbmVhci5Ob25lO1xuXHR2YXIgX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IFRXRUVOLkludGVycG9sYXRpb24uTGluZWFyO1xuXHR2YXIgX2NoYWluZWRUd2VlbnMgPSBbXTtcblx0dmFyIF9vblN0YXJ0Q2FsbGJhY2sgPSBudWxsO1xuXHR2YXIgX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG5cdHZhciBfb25VcGRhdGVDYWxsYmFjayA9IG51bGw7XG5cdHZhciBfb25Db21wbGV0ZUNhbGxiYWNrID0gbnVsbDtcblx0dmFyIF9vblN0b3BDYWxsYmFjayA9IG51bGw7XG5cblx0dGhpcy50byA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBkdXJhdGlvbikge1xuXG5cdFx0X3ZhbHVlc0VuZCA9IHByb3BlcnRpZXM7XG5cblx0XHRpZiAoZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0X2R1cmF0aW9uID0gZHVyYXRpb247XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuXHRcdFRXRUVOLmFkZCh0aGlzKTtcblxuXHRcdF9pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdFx0X29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG5cblx0XHRfc3RhcnRUaW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gdGltZSA6IFRXRUVOLm5vdygpO1xuXHRcdF9zdGFydFRpbWUgKz0gX2RlbGF5VGltZTtcblxuXHRcdGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXG5cdFx0XHRpZiAoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gaW5zdGFuY2VvZiBBcnJheSkge1xuXG5cdFx0XHRcdGlmIChfdmFsdWVzRW5kW3Byb3BlcnR5XS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIEFycmF5IHdpdGggdGhlIHN0YXJ0IHZhbHVlIGF0IHRoZSBmcm9udFxuXHRcdFx0XHRfdmFsdWVzRW5kW3Byb3BlcnR5XSA9IFtfb2JqZWN0W3Byb3BlcnR5XV0uY29uY2F0KF92YWx1ZXNFbmRbcHJvcGVydHldKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBgdG8oKWAgc3BlY2lmaWVzIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0LFxuXHRcdFx0Ly8gd2Ugc2hvdWxkIG5vdCBzZXQgdGhhdCBwcm9wZXJ0eSBpbiB0aGUgb2JqZWN0XG5cdFx0XHRpZiAoX29iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSB0aGUgc3RhcnRpbmcgdmFsdWUuXG5cdFx0XHRfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gX29iamVjdFtwcm9wZXJ0eV07XG5cblx0XHRcdGlmICgoX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSBpbnN0YW5jZW9mIEFycmF5KSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0X3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3Ncblx0XHRcdH1cblxuXHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCFfaXNQbGF5aW5nKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRUV0VFTi5yZW1vdmUodGhpcyk7XG5cdFx0X2lzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0aWYgKF9vblN0b3BDYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0X29uU3RvcENhbGxiYWNrLmNhbGwoX29iamVjdCwgX29iamVjdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wQ2hhaW5lZFR3ZWVucygpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5lbmQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnVwZGF0ZShfc3RhcnRUaW1lICsgX2R1cmF0aW9uKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuc3RvcENoYWluZWRUd2VlbnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IF9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuXHRcdFx0X2NoYWluZWRUd2VlbnNbaV0uc3RvcCgpO1xuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZGVsYXkgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG5cblx0XHRfZGVsYXlUaW1lID0gYW1vdW50O1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5yZXBlYXQgPSBmdW5jdGlvbiAodGltZXMpIHtcblxuXHRcdF9yZXBlYXQgPSB0aW1lcztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG5cblx0XHRfcmVwZWF0RGVsYXlUaW1lID0gYW1vdW50O1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy55b3lvID0gZnVuY3Rpb24gKHlveW8pIHtcblxuXHRcdF95b3lvID0geW95bztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cblx0dGhpcy5lYXNpbmcgPSBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cblx0XHRfZWFzaW5nRnVuY3Rpb24gPSBlYXNpbmc7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLmludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW50ZXJwb2xhdGlvbikge1xuXG5cdFx0X2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb247XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLmNoYWluID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0X2NoYWluZWRUd2VlbnMgPSBhcmd1bWVudHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uU3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuXHRcdF9vblN0YXJ0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25VcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuXHRcdF9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuXHRcdF9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25TdG9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cblx0XHRfb25TdG9wQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuXHRcdHZhciBwcm9wZXJ0eTtcblx0XHR2YXIgZWxhcHNlZDtcblx0XHR2YXIgdmFsdWU7XG5cblx0XHRpZiAodGltZSA8IF9zdGFydFRpbWUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChfb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG5cblx0XHRcdGlmIChfb25TdGFydENhbGxiYWNrICE9PSBudWxsKSB7XG5cdFx0XHRcdF9vblN0YXJ0Q2FsbGJhY2suY2FsbChfb2JqZWN0LCBfb2JqZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0X29uU3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRlbGFwc2VkID0gKHRpbWUgLSBfc3RhcnRUaW1lKSAvIF9kdXJhdGlvbjtcblx0XHRlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuXHRcdHZhbHVlID0gX2Vhc2luZ0Z1bmN0aW9uKGVsYXBzZWQpO1xuXG5cdFx0Zm9yIChwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kKSB7XG5cblx0XHRcdC8vIERvbid0IHVwZGF0ZSBwcm9wZXJ0aWVzIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0XG5cdFx0XHRpZiAoX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc3RhcnQgPSBfdmFsdWVzU3RhcnRbcHJvcGVydHldIHx8IDA7XG5cdFx0XHR2YXIgZW5kID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG5cblx0XHRcdGlmIChlbmQgaW5zdGFuY2VvZiBBcnJheSkge1xuXG5cdFx0XHRcdF9vYmplY3RbcHJvcGVydHldID0gX2ludGVycG9sYXRpb25GdW5jdGlvbihlbmQsIHZhbHVlKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBQYXJzZXMgcmVsYXRpdmUgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IGFzIGJhc2UgKGUuZy46ICsxMCwgLTMpXG5cdFx0XHRcdGlmICh0eXBlb2YgKGVuZCkgPT09ICdzdHJpbmcnKSB7XG5cblx0XHRcdFx0XHRpZiAoZW5kLmNoYXJBdCgwKSA9PT0gJysnIHx8IGVuZC5jaGFyQXQoMCkgPT09ICctJykge1xuXHRcdFx0XHRcdFx0ZW5kID0gc3RhcnQgKyBwYXJzZUZsb2F0KGVuZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVuZCA9IHBhcnNlRmxvYXQoZW5kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm90ZWN0IGFnYWluc3Qgbm9uIG51bWVyaWMgcHJvcGVydGllcy5cblx0XHRcdFx0aWYgKHR5cGVvZiAoZW5kKSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRfb2JqZWN0W3Byb3BlcnR5XSA9IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmIChfb25VcGRhdGVDYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0X29uVXBkYXRlQ2FsbGJhY2suY2FsbChfb2JqZWN0LCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGVsYXBzZWQgPT09IDEpIHtcblxuXHRcdFx0aWYgKF9yZXBlYXQgPiAwKSB7XG5cblx0XHRcdFx0aWYgKGlzRmluaXRlKF9yZXBlYXQpKSB7XG5cdFx0XHRcdFx0X3JlcGVhdC0tO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVhc3NpZ24gc3RhcnRpbmcgdmFsdWVzLCByZXN0YXJ0IGJ5IG1ha2luZyBzdGFydFRpbWUgPSBub3dcblx0XHRcdFx0Zm9yIChwcm9wZXJ0eSBpbiBfdmFsdWVzU3RhcnRSZXBlYXQpIHtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgKF92YWx1ZXNFbmRbcHJvcGVydHldKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdChfdmFsdWVzRW5kW3Byb3BlcnR5XSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKF95b3lvKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcblxuXHRcdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNFbmRbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0X3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChfeW95bykge1xuXHRcdFx0XHRcdF9yZXZlcnNlZCA9ICFfcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoX3JlcGVhdERlbGF5VGltZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0X3N0YXJ0VGltZSA9IHRpbWUgKyBfcmVwZWF0RGVsYXlUaW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9zdGFydFRpbWUgPSB0aW1lICsgX2RlbGF5VGltZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmIChfb25Db21wbGV0ZUNhbGxiYWNrICE9PSBudWxsKSB7XG5cblx0XHRcdFx0XHRfb25Db21wbGV0ZUNhbGxiYWNrLmNhbGwoX29iamVjdCwgX29iamVjdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IF9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuXHRcdFx0XHRcdC8vIE1ha2UgdGhlIGNoYWluZWQgdHdlZW5zIHN0YXJ0IGV4YWN0bHkgYXQgdGhlIHRpbWUgdGhleSBzaG91bGQsXG5cdFx0XHRcdFx0Ly8gZXZlbiBpZiB0aGUgYHVwZGF0ZSgpYCBtZXRob2Qgd2FzIGNhbGxlZCB3YXkgcGFzdCB0aGUgZHVyYXRpb24gb2YgdGhlIHR3ZWVuXG5cdFx0XHRcdFx0X2NoYWluZWRUd2VlbnNbaV0uc3RhcnQoX3N0YXJ0VGltZSArIF9kdXJhdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH07XG5cbn07XG5cblxuVFdFRU4uRWFzaW5nID0ge1xuXG5cdExpbmVhcjoge1xuXG5cdFx0Tm9uZTogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIGs7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWFkcmF0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqICgyIC0gayk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Q3ViaWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFF1YXJ0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAtIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVpbnRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG5cblx0XHR9XG5cblx0fSxcblxuXHRTaW51c29pZGFsOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRFeHBvbmVudGlhbDoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtIDEwICogayk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogKC0gTWF0aC5wb3coMiwgLSAxMCAqIChrIC0gMSkpICsgMik7XG5cblx0XHR9XG5cblx0fSxcblxuXHRDaXJjdWxhcjoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtIDAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0RWxhc3RpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIC1NYXRoLnBvdygyLCAxMCAqIChrIC0gMSkpICogTWF0aC5zaW4oKGsgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIDAuMSkgKiA1ICogTWF0aC5QSSkgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGsgKj0gMjtcblxuXHRcdFx0aWYgKGsgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtMC41ICogTWF0aC5wb3coMiwgMTAgKiAoayAtIDEpKSAqIE1hdGguc2luKChrIC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICogTWF0aC5zaW4oKGsgLSAxLjEpICogNSAqIE1hdGguUEkpICsgMTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEJhY2s6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cblx0XHRcdHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXG5cdFx0XHRyZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Qm91bmNlOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCgxIC0gayk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoayA8ICgxIC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoayA8IDAuNSkge1xuXHRcdFx0XHRyZXR1cm4gVFdFRU4uRWFzaW5nLkJvdW5jZS5JbihrICogMikgKiAwLjU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLk91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVFdFRU4uSW50ZXJwb2xhdGlvbiA9IHtcblxuXHRMaW5lYXI6IGZ1bmN0aW9uICh2LCBrKSB7XG5cblx0XHR2YXIgbSA9IHYubGVuZ3RoIC0gMTtcblx0XHR2YXIgZiA9IG0gKiBrO1xuXHRcdHZhciBpID0gTWF0aC5mbG9vcihmKTtcblx0XHR2YXIgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkxpbmVhcjtcblxuXHRcdGlmIChrIDwgMCkge1xuXHRcdFx0cmV0dXJuIGZuKHZbMF0sIHZbMV0sIGYpO1xuXHRcdH1cblxuXHRcdGlmIChrID4gMSkge1xuXHRcdFx0cmV0dXJuIGZuKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZuKHZbaV0sIHZbaSArIDEgPiBtID8gbSA6IGkgKyAxXSwgZiAtIGkpO1xuXG5cdH0sXG5cblx0QmV6aWVyOiBmdW5jdGlvbiAodiwgaykge1xuXG5cdFx0dmFyIGIgPSAwO1xuXHRcdHZhciBuID0gdi5sZW5ndGggLSAxO1xuXHRcdHZhciBwdyA9IE1hdGgucG93O1xuXHRcdHZhciBibiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG5cdFx0XHRiICs9IHB3KDEgLSBrLCBuIC0gaSkgKiBwdyhrLCBpKSAqIHZbaV0gKiBibihuLCBpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYjtcblxuXHR9LFxuXG5cdENhdG11bGxSb206IGZ1bmN0aW9uICh2LCBrKSB7XG5cblx0XHR2YXIgbSA9IHYubGVuZ3RoIC0gMTtcblx0XHR2YXIgZiA9IG0gKiBrO1xuXHRcdHZhciBpID0gTWF0aC5mbG9vcihmKTtcblx0XHR2YXIgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XG5cblx0XHRpZiAodlswXSA9PT0gdlttXSkge1xuXG5cdFx0XHRpZiAoayA8IDApIHtcblx0XHRcdFx0aSA9IE1hdGguZmxvb3IoZiA9IG0gKiAoMSArIGspKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoayA8IDApIHtcblx0XHRcdFx0cmV0dXJuIHZbMF0gLSAoZm4odlswXSwgdlswXSwgdlsxXSwgdlsxXSwgLWYpIC0gdlswXSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrID4gMSkge1xuXHRcdFx0XHRyZXR1cm4gdlttXSAtIChmbih2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm4odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFV0aWxzOiB7XG5cblx0XHRMaW5lYXI6IGZ1bmN0aW9uIChwMCwgcDEsIHQpIHtcblxuXHRcdFx0cmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcblxuXHRcdH0sXG5cblx0XHRCZXJuc3RlaW46IGZ1bmN0aW9uIChuLCBpKSB7XG5cblx0XHRcdHZhciBmYyA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuRmFjdG9yaWFsO1xuXG5cdFx0XHRyZXR1cm4gZmMobikgLyBmYyhpKSAvIGZjKG4gLSBpKTtcblxuXHRcdH0sXG5cblx0XHRGYWN0b3JpYWw6IChmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBhID0gWzFdO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG4pIHtcblxuXHRcdFx0XHR2YXIgcyA9IDE7XG5cblx0XHRcdFx0aWYgKGFbbl0pIHtcblx0XHRcdFx0XHRyZXR1cm4gYVtuXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSBuOyBpID4gMTsgaS0tKSB7XG5cdFx0XHRcdFx0cyAqPSBpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YVtuXSA9IHM7XG5cdFx0XHRcdHJldHVybiBzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSkoKSxcblxuXHRcdENhdG11bGxSb206IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgdCkge1xuXG5cdFx0XHR2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG5cdFx0XHR2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG5cdFx0XHR2YXIgdDIgPSB0ICogdDtcblx0XHRcdHZhciB0MyA9IHQgKiB0MjtcblxuXHRcdFx0cmV0dXJuICgyICogcDEgLSAyICogcDIgKyB2MCArIHYxKSAqIHQzICsgKC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRXRUVOO1xuIiwiaW1wb3J0IFR3ZWVuIGZyb20gXCIuL1R3ZWVuXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuXG4vKipcbiAqIOiuvue9riBBbmltYXRpb25GcmFtZSBiZWdpblxuICovXG52YXIgbGFzdFRpbWUgPSAwO1xudmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG59O1xuaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lVG9DYWxsKTtcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xufTtcbmlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xufTtcblxuLy/nrqHnkIbmiYDmnInlm77ooajnmoTmuLLmn5Pku7vliqFcbnZhciBfdGFza0xpc3QgPSBbXTsgLy9beyBpZCA6IHRhc2s6IH0uLi5dXG52YXIgX3JlcXVlc3RBaWQgPSBudWxsO1xuXG5mdW5jdGlvbiBlbmFibGVkQW5pbWF0aW9uRnJhbWUoKXtcbiAgICBpZiAoIV9yZXF1ZXN0QWlkKSB7XG4gICAgICAgIF9yZXF1ZXN0QWlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImZyYW1lX19cIiArIF90YXNrTGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgLy9pZiAoIFR3ZWVuLmdldEFsbCgpLmxlbmd0aCApIHtcbiAgICAgICAgICAgIFR3ZWVuLnVwZGF0ZSgpOyAvL3R3ZWVu6Ieq5bex5Lya5YGabGVuZ3Ro5Yik5patXG4gICAgICAgICAgICAvL307XG4gICAgICAgICAgICB2YXIgY3VyclRhc2tMaXN0ID0gX3Rhc2tMaXN0O1xuICAgICAgICAgICAgX3Rhc2tMaXN0ID0gW107XG4gICAgICAgICAgICBfcmVxdWVzdEFpZCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoY3VyclRhc2tMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyVGFza0xpc3Quc2hpZnQoKS50YXNrKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBfcmVxdWVzdEFpZDtcbn07IFxuXG4vKlxuICogQHBhcmFtIHRhc2sg6KaB5Yqg5YWl5Yiw5riy5p+T5bin6Zif5YiX5Lit55qE5Lu75YqhXG4gKiBAcmVzdWx0IGZyYW1laWRcbiAqL1xuZnVuY3Rpb24gcmVnaXN0RnJhbWUoICRmcmFtZSApIHtcbiAgICBpZiAoISRmcmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBfdGFza0xpc3QucHVzaCgkZnJhbWUpO1xuICAgIHJldHVybiBlbmFibGVkQW5pbWF0aW9uRnJhbWUoKTtcbn07XG5cbi8qXG4gKiAgQHBhcmFtIHRhc2sg6KaB5LuO5riy5p+T5bin6Zif5YiX5Lit5Yig6Zmk55qE5Lu75YqhXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3lGcmFtZSggJGZyYW1lICkge1xuICAgIHZhciBkX3Jlc3VsdCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gX3Rhc2tMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoX3Rhc2tMaXN0W2ldLmlkID09PSAkZnJhbWUuaWQpIHtcbiAgICAgICAgICAgIGRfcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIF90YXNrTGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBsLS07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoX3Rhc2tMaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF9yZXF1ZXN0QWlkKTtcbiAgICAgICAgX3JlcXVlc3RBaWQgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGRfcmVzdWx0O1xufTtcblxuXG4vKiBcbiAqIEBwYXJhbSBvcHQge2Zyb20gLCB0byAsIG9uVXBkYXRlICwgb25Db21wbGV0ZSAsIC4uLi4uLn1cbiAqIEByZXN1bHQgdHdlZW5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0VHdlZW4ob3B0aW9ucykge1xuICAgIHZhciBvcHQgPSBfLmV4dGVuZCh7XG4gICAgICAgIGZyb206IG51bGwsXG4gICAgICAgIHRvOiBudWxsLFxuICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbigpe30sXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBvblN0b3A6IGZ1bmN0aW9uKCl7fSxcbiAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgZWFzaW5nOiAnTGluZWFyLk5vbmUnLFxuICAgICAgICBkZXNjOiAnJyAvL+WKqOeUu+aPj+i/sO+8jOaWueS+v+afpeaJvmJ1Z1xuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIHR3ZWVuID0ge307XG4gICAgdmFyIHRpZCA9IFwidHdlZW5fXCIgKyBVdGlscy5nZXRVSUQoKTtcbiAgICBvcHQuaWQgJiYgKCB0aWQgPSB0aWQrXCJfXCIrb3B0LmlkICk7XG5cbiAgICBpZiAob3B0LmZyb20gJiYgb3B0LnRvKSB7XG4gICAgICAgIHR3ZWVuID0gbmV3IFR3ZWVuLlR3ZWVuKCBvcHQuZnJvbSApXG4gICAgICAgIC50byggb3B0LnRvLCBvcHQuZHVyYXRpb24gKVxuICAgICAgICAub25TdGFydChmdW5jdGlvbigpe1xuICAgICAgICAgICAgb3B0Lm9uU3RhcnQuYXBwbHkoIHRoaXMgKVxuICAgICAgICB9KVxuICAgICAgICAub25VcGRhdGUoIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvcHQub25VcGRhdGUuYXBwbHkoIHRoaXMgKTtcbiAgICAgICAgfSApXG4gICAgICAgIC5vbkNvbXBsZXRlKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lGcmFtZSh7XG4gICAgICAgICAgICAgICAgaWQ6IHRpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0d2Vlbi5faXNDb21wbGV0ZWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdC5vbkNvbXBsZXRlLmFwcGx5KCB0aGlzICwgW3RoaXNdICk7IC8v5omn6KGM55So5oi355qEY29uQ29tcGxldGVcbiAgICAgICAgfSApXG4gICAgICAgIC5vblN0b3AoIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBkZXN0cm95RnJhbWUoe1xuICAgICAgICAgICAgICAgIGlkOiB0aWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHdlZW4uX2lzU3RvcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdC5vblN0b3AuYXBwbHkoIHRoaXMgLCBbdGhpc10gKTtcbiAgICAgICAgfSApXG4gICAgICAgIC5yZXBlYXQoIG9wdC5yZXBlYXQgKVxuICAgICAgICAuZGVsYXkoIG9wdC5kZWxheSApXG4gICAgICAgIC5lYXNpbmcoIFR3ZWVuLkVhc2luZ1tvcHQuZWFzaW5nLnNwbGl0KFwiLlwiKVswXV1bb3B0LmVhc2luZy5zcGxpdChcIi5cIilbMV1dIClcbiAgICAgICAgXG4gICAgICAgIHR3ZWVuLmlkID0gdGlkO1xuICAgICAgICB0d2Vlbi5zdGFydCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG5cbiAgICAgICAgICAgIGlmICggdHdlZW4uX2lzQ29tcGxldGVlZCB8fCB0d2Vlbi5faXNTdG9wZWQgKSB7XG4gICAgICAgICAgICAgICAgdHdlZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWdpc3RGcmFtZSh7XG4gICAgICAgICAgICAgICAgaWQ6IHRpZCxcbiAgICAgICAgICAgICAgICB0YXNrOiBhbmltYXRlLFxuICAgICAgICAgICAgICAgIGRlc2M6IG9wdC5kZXNjLFxuICAgICAgICAgICAgICAgIHR3ZWVuOiB0d2VlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGUoKTtcblxuICAgIH07XG4gICAgcmV0dXJuIHR3ZWVuO1xufTtcbi8qXG4gKiBAcGFyYW0gdHdlZW5cbiAqIEByZXN1bHQgdm9pZCgwKVxuICovXG5mdW5jdGlvbiBkZXN0cm95VHdlZW4odHdlZW4gLCBtc2cpIHtcbiAgICB0d2Vlbi5zdG9wKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVnaXN0RnJhbWU6IHJlZ2lzdEZyYW1lLFxuICAgIGRlc3Ryb3lGcmFtZTogZGVzdHJveUZyYW1lLFxuICAgIHJlZ2lzdFR3ZWVuOiByZWdpc3RUd2VlbixcbiAgICBkZXN0cm95VHdlZW46IGRlc3Ryb3lUd2VlblxufTsiLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiDlsZ7mgKflt6XljoLvvIxpZeS4i+mdoueUqFZCU+aPkOS+m+aUr+aMgVxuICog5p2l57uZ5pW05Liq5byV5pOO5o+Q5L6b5b+D6Lez5YyF55qE6Kem5Y+R5py65Yi2XG4gKi9cbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbi8v5a6a5LmJ5bCB6KOF5aW955qE5YW85a655aSn6YOo5YiG5rWP6KeI5Zmo55qEZGVmaW5lUHJvcGVydGllcyDnmoQg5bGe5oCn5bel5Y6CXG52YXIgdW53YXRjaE9uZSA9IHtcbiAgICBcIiRza2lwQXJyYXlcIiA6IDAsXG4gICAgXCIkd2F0Y2hcIiAgICAgOiAxLFxuICAgIFwiJGZpcmVcIiAgICAgIDogMiwvL+S4u+imgeaYr2dldCBzZXQg5pi+5oCn6K6+572u55qEIOinpuWPkVxuICAgIFwiJG1vZGVsXCIgICAgIDogMyxcbiAgICBcIiRhY2Nlc3NvclwiICA6IDQsXG4gICAgXCIkb3duZXJcIiAgICAgOiA1LFxuICAgIC8vXCJwYXRoXCIgICAgICAgOiA2LCAvL+i/meS4quW6lOivpeaYr+WUr+S4gOS4gOS4quS4jeeUqHdhdGNo55qE5LiN5bimJOeahOaIkOWRmOS6huWQp++8jOWboOS4uuWcsOWbvuetieeahHBhdGjmmK/lnKjlpKrlpKdcbiAgICBcIiRwYXJlbnRcIiAgICA6IDcgIC8v55So5LqO5bu656uL5pWw5o2u55qE5YWz57O76ZO+XG59XG5cbmZ1bmN0aW9uIE9ic2VydmUoc2NvcGUsIG1vZGVsLCB3YXRjaE1vcmUpIHtcblxuICAgIHZhciBzdG9wUmVwZWF0QXNzaWduPXRydWU7XG5cbiAgICB2YXIgc2tpcEFycmF5ID0gc2NvcGUuJHNraXBBcnJheSwgLy/opoHlv73nlaXnm5HmjqfnmoTlsZ7mgKflkI3liJfooahcbiAgICAgICAgcG1vZGVsID0ge30sIC8v6KaB6L+U5Zue55qE5a+56LGhXG4gICAgICAgIGFjY2Vzc29yZXMgPSB7fSwgLy/lhoXpg6jnlKjkuo7ovazmjaLnmoTlr7nosaFcbiAgICAgICAgVkJQdWJsaWNzID0gXy5rZXlzKCB1bndhdGNoT25lICk7IC8v55So5LqOSUU2LThcblxuICAgICAgICBtb2RlbCA9IG1vZGVsIHx8IHt9Oy8v6L+Z5pivcG1vZGVs5LiK55qEJG1vZGVs5bGe5oCnXG4gICAgICAgIHdhdGNoTW9yZSA9IHdhdGNoTW9yZSB8fCB7fTsvL+S7pSTlvIDlpLTkvYbopoHlvLrliLbnm5HlkKznmoTlsZ7mgKdcbiAgICAgICAgc2tpcEFycmF5ID0gXy5pc0FycmF5KHNraXBBcnJheSkgPyBza2lwQXJyYXkuY29uY2F0KFZCUHVibGljcykgOiBWQlB1YmxpY3M7XG5cbiAgICBmdW5jdGlvbiBsb29wKG5hbWUsIHZhbCkge1xuICAgICAgICBpZiAoICF1bndhdGNoT25lW25hbWVdIHx8ICh1bndhdGNoT25lW25hbWVdICYmIG5hbWUuY2hhckF0KDApICE9PSBcIiRcIikgKSB7XG4gICAgICAgICAgICBtb2RlbFtuYW1lXSA9IHZhbFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbDtcbiAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZighdW53YXRjaE9uZVtuYW1lXSl7XG4gICAgICAgICAgICAgIFZCUHVibGljcy5wdXNoKG5hbWUpIC8v5Ye95pWw5peg6ZyA6KaB6L2s5o2iXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoXy5pbmRleE9mKHNraXBBcnJheSxuYW1lKSAhPT0gLTEgfHwgKG5hbWUuY2hhckF0KDApID09PSBcIiRcIiAmJiAhd2F0Y2hNb3JlW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWQlB1YmxpY3MucHVzaChuYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjY2Vzc29yID0gZnVuY3Rpb24obmVvKSB7IC8v5Yib5bu655uR5o6n5bGe5oCn5oiW5pWw57uE77yM6Ieq5Y+Y6YeP77yM55Sx55So5oi36Kem5Y+R5YW25pS55Y+YXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYWNjZXNzb3IudmFsdWUsIHByZVZhbHVlID0gdmFsdWUsIGNvbXBsZXhWYWx1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvL+WGmeaTjeS9nFxuICAgICAgICAgICAgICAgICAgICAvL3NldCDnmoQg5YC855qEIOexu+Wei1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVvVHlwZSA9IHR5cGVvZiBuZW87XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BSZXBlYXRBc3NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvL+mYu+atoumHjeWkjei1i+WAvFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbmVvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggbmVvICYmIG5lb1R5cGUgPT09IFwib2JqZWN0XCIgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShuZW8gaW5zdGFuY2VvZiBBcnJheSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbmVvLmFkZENvbG9yU3RvcCAvLyBuZW8gaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZW8uJG1vZGVsID8gbmVvIDogT2JzZXJ2ZShuZW8gLCBuZW8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXhWYWx1ZSA9IHZhbHVlLiRtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7Ly/lpoLmnpzmmK/lhbbku5bmlbDmja7nsbvlnotcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmKCBuZW9UeXBlID09PSBcImFycmF5XCIgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB2YWx1ZSA9IF8uY2xvbmUobmVvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmVvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3Nvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxbbmFtZV0gPSBjb21wbGV4VmFsdWUgPyBjb21wbGV4VmFsdWUgOiB2YWx1ZTsvL+abtOaWsCRtb2RlbOS4reeahOWAvFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGV4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbW9kZWwuJGZpcmUgJiYgcG1vZGVsLiRmaXJlKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlVHlwZSAhPSBuZW9UeXBlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WmguaenHNldOeahOWAvOexu+Wei+W3sue7j+aUueWPmO+8jFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v6YKj5LmI5Lmf6KaB5oqK5a+55bqU55qEdmFsdWVUeXBl5L+u5pS55Li65a+55bqU55qEbmVvVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IG5lb1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzV2F0Y2hNb2RlbCA9IHBtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5omA5pyJ55qE6LWL5YC86YO96KaB6Kem5Y+Rd2F0Y2jnmoTnm5HlkKzkuovku7ZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIXBtb2RlbC4kd2F0Y2ggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKCBoYXNXYXRjaE1vZGVsLiRwYXJlbnQgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzV2F0Y2hNb2RlbCA9IGhhc1dhdGNoTW9kZWwuJHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNXYXRjaE1vZGVsLiR3YXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzV2F0Y2hNb2RlbC4kd2F0Y2guY2FsbChoYXNXYXRjaE1vZGVsICwgbmFtZSwgdmFsdWUsIHByZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8v6K+75pON5L2cXG4gICAgICAgICAgICAgICAgICAgIC8v6K+755qE5pe25YCZ77yM5Y+R546wdmFsdWXmmK/kuKpvYmrvvIzogIzkuJTov5jmsqHmnIlkZWZpbmVQcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAvL+mCo+S5iOWwseS4tOaXtmRlZmluZVByb3BlcnR55LiA5qyhXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgJiYgKHZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIikgXG4gICAgICAgICAgICAgICAgICAgICAgICYmICEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgXG4gICAgICAgICAgICAgICAgICAgICAgICYmICF2YWx1ZS4kbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZhbHVlLmFkZENvbG9yU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy/lu7rnq4vlkozniLbmlbDmja7oioLngrnnmoTlhbPns7tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLiRwYXJlbnQgPSBwbW9kZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE9ic2VydmUodmFsdWUgLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWNjZXNzb3IudmFsdWUg6YeN5paw5aSN5Yi25Li6ZGVmaW5lUHJvcGVydHnov4flkI7nmoTlr7nosaFcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc29yLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2Nlc3Nvci52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWNjZXNzb3Jlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzZXQ6IGFjY2Vzc29yLFxuICAgICAgICAgICAgICAgIGdldDogYWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmb3IgKHZhciBpIGluIHNjb3BlKSB7XG4gICAgICAgIGxvb3AoaSwgc2NvcGVbaV0pXG4gICAgfTtcblxuICAgIHBtb2RlbCA9IGRlZmluZVByb3BlcnRpZXMocG1vZGVsLCBhY2Nlc3NvcmVzLCBWQlB1YmxpY3MpOy8v55Sf5oiQ5LiA5Liq56m655qEVmlld01vZGVsXG5cbiAgICBfLmZvckVhY2goVkJQdWJsaWNzLGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKHNjb3BlW25hbWVdKSB7Ly/lhYjkuLrlh73mlbDnrYnkuI3ooqvnm5HmjqfnmoTlsZ7mgKfotYvlgLxcbiAgICAgICAgICAgIGlmKHR5cGVvZiBzY29wZVtuYW1lXSA9PSBcImZ1bmN0aW9uXCIgKXtcbiAgICAgICAgICAgICAgIHBtb2RlbFtuYW1lXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICBzY29wZVtuYW1lXS5hcHBseSh0aGlzICwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBwbW9kZWxbbmFtZV0gPSBzY29wZVtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcG1vZGVsLiRtb2RlbCA9IG1vZGVsO1xuICAgIHBtb2RlbC4kYWNjZXNzb3IgPSBhY2Nlc3NvcmVzO1xuXG4gICAgcG1vZGVsLmhhc093blByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSBpbiBwbW9kZWwuJG1vZGVsXG4gICAgfTtcblxuICAgIHN0b3BSZXBlYXRBc3NpZ24gPSBmYWxzZTtcblxuICAgIHJldHVybiBwbW9kZWxcbn1cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAgIC8v5aaC5p6c5rWP6KeI5Zmo5LiN5pSv5oyBZWNtYTI2MnY155qET2JqZWN0LmRlZmluZVByb3BlcnRpZXPmiJbogIXlrZjlnKhCVUfvvIzmr5TlpoJJRThcbiAgICAvL+agh+WHhua1j+iniOWZqOS9v+eUqF9fZGVmaW5lR2V0dGVyX18sIF9fZGVmaW5lU2V0dGVyX1/lrp7njrBcbiAgICB0cnkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh7fSwgXCJfXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBcInhcIlxuICAgICAgICB9KVxuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoXCJfX2RlZmluZUdldHRlcl9fXCIgaW4gT2JqZWN0KSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcCwgZGVzYykge1xuICAgICAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gZGVzYy52YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ2dldCcgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBkZXNjLmdldClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdzZXQnIGluIGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgZGVzYy5zZXQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24ob2JqLCBkZXNjcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZGVzY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2NzW3Byb3BdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4vL0lFNi045L2/55SoVkJTY3JpcHTnsbvnmoRzZXQgZ2V06K+t5Y+l5a6e546wXG5pZiAoIWRlZmluZVByb3BlcnRpZXMgJiYgd2luZG93LlZCQXJyYXkpIHtcbiAgICB3aW5kb3cuZXhlY1NjcmlwdChbXG4gICAgICAgICAgICBcIkZ1bmN0aW9uIHBhcnNlVkIoY29kZSlcIixcbiAgICAgICAgICAgIFwiXFx0RXhlY3V0ZUdsb2JhbChjb2RlKVwiLFxuICAgICAgICAgICAgXCJFbmQgRnVuY3Rpb25cIlxuICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpLCBcIlZCU2NyaXB0XCIpO1xuXG4gICAgZnVuY3Rpb24gVkJNZWRpYXRvcihkZXNjcmlwdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZuID0gZGVzY3JpcHRpb25bbmFtZV0gJiYgZGVzY3JpcHRpb25bbmFtZV0uc2V0O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgZm4odmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbihwdWJsaWNzLCBkZXNjcmlwdGlvbiwgYXJyYXkpIHtcbiAgICAgICAgcHVibGljcyA9IGFycmF5LnNsaWNlKDApO1xuICAgICAgICBwdWJsaWNzLnB1c2goXCJoYXNPd25Qcm9wZXJ0eVwiKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFwiVkJDbGFzc1wiICsgc2V0VGltZW91dChcIjFcIiksIG93bmVyID0ge30sIGJ1ZmZlciA9IFtdO1xuICAgICAgICBidWZmZXIucHVzaChcbiAgICAgICAgICAgICAgICBcIkNsYXNzIFwiICsgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIFwiXFx0UHJpdmF0ZSBbX19kYXRhX19dLCBbX19wcm94eV9fXVwiLFxuICAgICAgICAgICAgICAgIFwiXFx0UHVibGljIERlZmF1bHQgRnVuY3Rpb24gW19fY29uc3RfX10oZCwgcClcIixcbiAgICAgICAgICAgICAgICBcIlxcdFxcdFNldCBbX19kYXRhX19dID0gZDogc2V0IFtfX3Byb3h5X19dID0gcFwiLFxuICAgICAgICAgICAgICAgIFwiXFx0XFx0U2V0IFtfX2NvbnN0X19dID0gTWVcIiwgLy/pk77lvI/osIPnlKhcbiAgICAgICAgICAgICAgICBcIlxcdEVuZCBGdW5jdGlvblwiKTtcbiAgICAgICAgXy5mb3JFYWNoKHB1YmxpY3MsZnVuY3Rpb24obmFtZSkgeyAvL+a3u+WKoOWFrOWFseWxnuaApyzlpoLmnpzmraTml7bkuI3liqDku6XlkI7lsLHmsqHmnLrkvJrkuoZcbiAgICAgICAgICAgIGlmIChvd25lcltuYW1lXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG93bmVyW25hbWVdID0gdHJ1ZSAvL+WboOS4ulZCU2NyaXB05a+56LGh5LiN6IO95YOPSlPpgqPmoLfpmo/mhI/lop7liKDlsZ7mgKdcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiXFx0UHVibGljIFtcIiArIG5hbWUgKyBcIl1cIikgLy/kvaDlj6/ku6XpooTlhYjmlL7liLBza2lwQXJyYXnkuK1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIG93bmVyW25hbWVdID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy/nlLHkuo7kuI3nn6Xlr7nmlrnkvJrkvKDlhaXku4DkuYgs5Zug5q2kc2V0LCBsZXTpg73nlKjkuIpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0UHVibGljIFByb3BlcnR5IExldCBbXCIgKyBuYW1lICsgXCJdKHZhbClcIiwgLy9zZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0XFx0Q2FsbCBbX19wcm94eV9fXShbX19kYXRhX19dLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCB2YWwpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEVuZCBQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRQdWJsaWMgUHJvcGVydHkgU2V0IFtcIiArIG5hbWUgKyBcIl0odmFsKVwiLCAvL3NldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRcXHRDYWxsIFtfX3Byb3h5X19dKFtfX2RhdGFfX10sIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHZhbClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0RW5kIFByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFB1YmxpYyBQcm9wZXJ0eSBHZXQgW1wiICsgbmFtZSArIFwiXVwiLCAvL2dldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRPbiBFcnJvciBSZXN1bWUgTmV4dFwiLCAvL+W/hemhu+S8mOWFiOS9v+eUqHNldOivreWPpSzlkKbliJnlroPkvJror6/lsIbmlbDnu4TlvZPlrZfnrKbkuLLov5Tlm55cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0XFx0U2V0W1wiICsgbmFtZSArIFwiXSA9IFtfX3Byb3h5X19dKFtfX2RhdGFfX10sXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0SWYgRXJyLk51bWJlciA8PiAwIFRoZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0XFx0W1wiICsgbmFtZSArIFwiXSA9IFtfX3Byb3h5X19dKFtfX2RhdGFfX10sXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0RW5kIElmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdE9uIEVycm9yIEdvdG8gMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRFbmQgUHJvcGVydHlcIilcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChcIkVuZCBDbGFzc1wiKTsgLy/nsbvlrprkuYnlrozmr5VcbiAgICAgICAgYnVmZmVyLnB1c2goXG4gICAgICAgICAgICAgICAgXCJGdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiRmFjdG9yeShhLCBiKVwiLCAvL+WIm+W7uuWunuS+i+W5tuS8oOWFpeS4pOS4quWFs+mUrueahOWPguaVsFxuICAgICAgICAgICAgICAgIFwiXFx0RGltIG9cIixcbiAgICAgICAgICAgICAgICBcIlxcdFNldCBvID0gKE5ldyBcIiArIGNsYXNzTmFtZSArIFwiKShhLCBiKVwiLFxuICAgICAgICAgICAgICAgIFwiXFx0U2V0IFwiICsgY2xhc3NOYW1lICsgXCJGYWN0b3J5ID0gb1wiLFxuICAgICAgICAgICAgICAgIFwiRW5kIEZ1bmN0aW9uXCIpO1xuICAgICAgICB3aW5kb3cucGFyc2VWQihidWZmZXIuam9pbihcIlxcclxcblwiKSk7Ly/lhYjliJvlu7rkuIDkuKpWQuexu+W3peWOglxuICAgICAgICByZXR1cm4gIHdpbmRvd1tjbGFzc05hbWUgKyBcIkZhY3RvcnlcIl0oZGVzY3JpcHRpb24sIFZCTWVkaWF0b3IpOy8v5b6X5Yiw5YW25Lqn5ZOBXG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgT2JzZXJ2ZTtcblxuIiwiXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IF9fVkVSU0lPTl9fO1xuXG5leHBvcnQgY29uc3QgUElfMiA9IE1hdGguUEkgKiAyO1xuXG5leHBvcnQgY29uc3QgUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5cbmV4cG9ydCBjb25zdCBERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcblxuZXhwb3J0IGNvbnN0IFJFTkRFUkVSX1RZUEUgPSB7XG4gICAgVU5LTk9XTjogICAgMCxcbiAgICBXRUJHTDogICAgICAxLFxuICAgIENBTlZBUzogICAgIDIsXG59O1xuXG5leHBvcnQgY29uc3QgRFJBV19NT0RFUyA9IHtcbiAgICBQT0lOVFM6ICAgICAgICAgMCxcbiAgICBMSU5FUzogICAgICAgICAgMSxcbiAgICBMSU5FX0xPT1A6ICAgICAgMixcbiAgICBMSU5FX1NUUklQOiAgICAgMyxcbiAgICBUUklBTkdMRVM6ICAgICAgNCxcbiAgICBUUklBTkdMRV9TVFJJUDogNSxcbiAgICBUUklBTkdMRV9GQU46ICAgNixcbn07XG5cbmV4cG9ydCBjb25zdCBTSEFQRVMgPSB7XG4gICAgUE9MWTogMCxcbiAgICBSRUNUOiAxLFxuICAgIENJUkM6IDIsXG4gICAgRUxJUDogMyxcbiAgICBSUkVDOiA0LFxufTtcblxuZXhwb3J0IGNvbnN0IFNDQUxFX01PREVTID0ge1xuICAgIExJTkVBUjogICAgIDAsXG4gICAgTkVBUkVTVDogICAgMSxcbn07XG5cbmV4cG9ydCBjb25zdCBDT05URVhUX0RFRkFVTFQgPSB7XG4gICAgd2lkdGggICAgICAgICA6IDAsXG4gICAgaGVpZ2h0ICAgICAgICA6IDAsXG4gICAgeCAgICAgICAgICAgICA6IDAsXG4gICAgeSAgICAgICAgICAgICA6IDAsXG4gICAgc2NhbGVYICAgICAgICA6IDEsXG4gICAgc2NhbGVZICAgICAgICA6IDEsXG4gICAgc2NhbGVPcmlnaW4gICA6IHtcbiAgICAgICAgeCA6IDAsXG4gICAgICAgIHkgOiAwXG4gICAgfSxcbiAgICByb3RhdGlvbiAgICAgIDogMCxcbiAgICByb3RhdGVPcmlnaW4gIDogIHtcbiAgICAgICAgeCA6IDAsXG4gICAgICAgIHkgOiAwXG4gICAgfSxcbiAgICB2aXNpYmxlICAgICAgIDogdHJ1ZSxcbiAgICBnbG9iYWxBbHBoYSAgIDogMSxcblxuICAgIC8vc2hhcGUg5omN6ZyA6KaB55So5Yiw77yMIOW3sue7j+i/geenu+WIsHNoYXBl5Lit5Y675LqG77yM6L+Z6YeM5YWI5rOo6YeK5o6JXG4gICAgLypcbiAgICBjdXJzb3IgICAgICAgIDogXCJkZWZhdWx0XCIsXG5cbiAgICBmaWxsQWxwaGEgICAgIDogMSwvL2NvbnRleHQyZOmHjOayoeacie+8jOiHquWumuS5iVxuICAgIGZpbGxTdHlsZSAgICAgOiBudWxsLC8vXCIjMDAwMDAwXCIsXG5cbiAgICBsaW5lQ2FwICAgICAgIDogbnVsbCwvL+m7mOiupOmDveaYr+ebtOinklxuICAgIGxpbmVKb2luICAgICAgOiBudWxsLC8v6L+Z5Lik5Liq55uu5YmNd2ViZ2zph4zpnaLmsqHlrp7njrBcbiAgICBtaXRlckxpbWl0ICAgIDogbnVsbCwvL21pdGVyTGltaXQg5bGe5oCn6K6+572u5oiW6L+U5Zue5pyA5aSn5pac5o6l6ZW/5bqmLOWPquacieW9kyBsaW5lSm9pbiDlsZ7mgKfkuLogXCJtaXRlclwiIOaXtu+8jG1pdGVyTGltaXQg5omN5pyJ5pWI44CCXG5cbiAgICBsaW5lQWxwaGEgICAgIDogMSwvL2NvbnRleHQyZOmHjOayoeacie+8jOiHquWumuS5iVxuICAgIHN0cm9rZVN0eWxlICAgOiBudWxsLFxuICAgIGxpbmVUeXBlICAgICAgOiBcInNvbGlkXCIsIC8vY29udGV4dDJk6YeM5rKh5pyJ77yM6Ieq5a6a5LmJ57q/5p2h55qEdHlwZe+8jOm7mOiupOS4uuWunue6v1xuICAgIGxpbmVXaWR0aCAgICAgOiBudWxsLFxuICAgICovXG4gICAgXG4gICAgXG4gICAgLy/msqHnlKjliLDnmoTmmoLml7bkuI3nlKhcbiAgICAvL3NoYWRvd0JsdXIgICAgOiBudWxsLFxuICAgIC8vc2hhZG93Q29sb3IgICA6IG51bGwsXG4gICAgLy9zaGFkb3dPZmZzZXRYIDogbnVsbCxcbiAgICAvL3NoYWRvd09mZnNldFkgOiBudWxsLFxuICAgIFxuICAgIC8vZm9udCAgICAgICAgICA6IG51bGwsXG4gICAgLy90ZXh0QWxpZ24gICAgIDogXCJsZWZ0XCIsXG4gICAgLy90ZXh0QmFzZWxpbmUgIDogXCJ0b3BcIiwgXG4gICAgLy9hcmNTY2FsZVhfICAgIDogbnVsbCxcbiAgICAvL2FyY1NjYWxlWV8gICAgOiBudWxsLFxuICAgIC8vbGluZVNjYWxlXyAgICA6IG51bGwsXG4gICAgXG4gICAgLy9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gOiBudWxsXG5cbn07XG5leHBvcnQgY29uc3QgU0hBUEVfQ09OVEVYVF9ERUZBVUxUID0ge1xuICAgIGN1cnNvciAgICAgICAgOiBcImRlZmF1bHRcIixcblxuICAgIGZpbGxBbHBoYSAgICAgOiAxLC8vY29udGV4dDJk6YeM5rKh5pyJ77yM6Ieq5a6a5LmJXG4gICAgZmlsbFN0eWxlICAgICA6IG51bGwsLy9cIiMwMDAwMDBcIixcblxuICAgIGxpbmVDYXAgICAgICAgOiBudWxsLC8v6buY6K6k6YO95piv55u06KeSXG4gICAgbGluZUpvaW4gICAgICA6IG51bGwsLy/ov5nkuKTkuKrnm67liY13ZWJnbOmHjOmdouayoeWunueOsFxuICAgIG1pdGVyTGltaXQgICAgOiBudWxsLC8vbWl0ZXJMaW1pdCDlsZ7mgKforr7nva7miJbov5Tlm57mnIDlpKfmlpzmjqXplb/luqYs5Y+q5pyJ5b2TIGxpbmVKb2luIOWxnuaAp+S4uiBcIm1pdGVyXCIg5pe277yMbWl0ZXJMaW1pdCDmiY3mnInmlYjjgIJcblxuICAgIGxpbmVBbHBoYSAgICAgOiAxLC8vY29udGV4dDJk6YeM5rKh5pyJ77yM6Ieq5a6a5LmJXG4gICAgc3Ryb2tlU3R5bGUgICA6IG51bGwsXG4gICAgbGluZVR5cGUgICAgICA6IFwic29saWRcIiwgLy9jb250ZXh0MmTph4zmsqHmnInvvIzoh6rlrprkuYnnur/mnaHnmoR0eXBl77yM6buY6K6k5Li65a6e57q/XG4gICAgbGluZVdpZHRoICAgICA6IG51bGxcbn1cblxuXG5cbiIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOaooeaLn2FzMyBEaXNwbGF5TGlzdCDnmoQg546w5a6e5a+56LGh5Z+657G7XG4gKi9cbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5pbXBvcnQgRXZlbnREaXNwYXRjaGVyIGZyb20gXCIuLi9ldmVudC9FdmVudERpc3BhdGNoZXJcIjtcbmltcG9ydCBNYXRyaXggZnJvbSBcIi4uL2dlb20vTWF0cml4XCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4vUG9pbnRcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcbmltcG9ydCBBbmltYXRpb25GcmFtZSBmcm9tIFwiLi4vYW5pbWF0aW9uL0FuaW1hdGlvbkZyYW1lXCI7XG5pbXBvcnQgT2JzZXJ2ZSBmcm9tIFwiLi4vdXRpbHMvb2JzZXJ2ZVwiO1xuaW1wb3J0IHtDT05URVhUX0RFRkFVTFR9IGZyb20gXCIuLi9jb25zdFwiXG5cbnZhciBEaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24ob3B0KXtcbiAgICBEaXNwbGF5T2JqZWN0LnN1cGVyY2xhc3MuY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8v5aaC5p6c55So5oi35rKh5pyJ5Lyg5YWlY29udGV4dOiuvue9ru+8jOWwsem7mOiupOS4uuepuueahOWvueixoVxuICAgIG9wdCAgICAgID0gVXRpbHMuY2hlY2tPcHQoIG9wdCApO1xuXG4gICAgLy/nm7jlr7nniLbnuqflhYPntKDnmoTnn6npmLVcbiAgICB0aGlzLl90cmFuc2Zvcm0gICAgICA9IG51bGw7XG5cbiAgICAvL+W/g+i3s+asoeaVsFxuICAgIHRoaXMuX2hlYXJ0QmVhdE51bSAgID0gMDtcblxuICAgIC8v5YWD57Sg5a+55bqU55qEc3RhZ2XlhYPntKBcbiAgICB0aGlzLnN0YWdlICAgICAgICAgICA9IG51bGw7XG5cbiAgICAvL+WFg+e0oOeahOeItuWFg+e0oFxuICAgIHRoaXMucGFyZW50ICAgICAgICAgID0gbnVsbDtcblxuICAgIHRoaXMuX2V2ZW50RW5hYmxlZCAgID0gZmFsc2U7ICAgLy/mmK/lkKblk43lupTkuovku7bkuqTkupIs5Zyo5re75Yqg5LqG5LqL5Lu25L6m5ZCs5ZCO5Lya6Ieq5Yqo6K6+572u5Li6dHJ1ZVxuXG4gICAgdGhpcy5kcmFnRW5hYmxlZCAgICAgPSB0cnVlIDsvL1wiZHJhZ0VuYWJsZWRcIiBpbiBvcHQgPyBvcHQuZHJhZ0VuYWJsZWQgOiBmYWxzZTsgICAvL+aYr+WQpuWQr+eUqOWFg+e0oOeahOaLluaLvVxuXG4gICAgdGhpcy54eVRvSW50ICAgICAgICAgPSBcInh5VG9JbnRcIiBpbiBvcHQgPyBvcHQueHlUb0ludCA6IHRydWU7ICAgIC8v5piv5ZCm5a+5eHnlnZDmoIfnu5/kuIBpbnTlpITnkIbvvIzpu5jorqTkuLp0cnVl77yM5L2G5piv5pyJ55qE5pe25YCZ5Y+v5Lul55Sx5aSW55WM55So5oi35omL5Yqo5oyH5a6a5piv5ZCm6ZyA6KaB6K6h566X5Li6aW5077yM5Zug5Li65pyJ55qE5pe25YCZ5LiN6K6h566X5q+U6L6D5aW977yM5q+U5aaC77yM6L+b5bqm5Zu+6KGo5Lit77yM5YaNc2VjdG9y55qE5Lik56uv5re75Yqg5Lik5Liq5ZyG5p2l5YGa5ZyG6KeS55qE6L+b5bqm5p2h55qE5pe25YCZ77yM5ZyGY2lyY2xl5LiN5YGaaW506K6h566X77yM5omN6IO95ZKMc2VjdG9y5pu05aW955qE6KGU5o6lXG5cbiAgICB0aGlzLm1vdmVpbmcgICAgICAgICA9IGZhbHNlOyAvL+WmguaenOWFg+e0oOWcqOacgOi9qOmBk+i/kOWKqOS4reeahOaXtuWAme+8jOacgOWlveaKiui/meS4quiuvue9ruS4unRydWXvvIzov5nmoLfog73kv53or4Hovajov7nnmoTkuJ3mkKzpobrmu5HvvIzlkKbliJnlm6DkuLp4eVRvSW5055qE5Y6f5Zug77yM5Lya5pyJ6Lez6LeDXG5cbiAgICAvL+WIm+W7uuWlvWNvbnRleHRcbiAgICB0aGlzLl9jcmVhdGVDb250ZXh0KCBvcHQgKTtcblxuICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUgfHwgXCJkaXNwbGF5T2JqZWN0XCIpO1xuXG4gICAgdGhpcy5pbml0LmFwcGx5KHRoaXMgLCBhcmd1bWVudHMpO1xuXG4gICAgLy/miYDmnInlsZ7mgKflh4blpIflpb3kuoblkI7vvIzlhYjopoHorqHnrpfkuIDmrKF0aGlzLl91cGRhdGVUcmFuc2Zvcm0oKeW+l+WIsF90YW5zZm9ybVxuICAgIHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSgpO1xufTtcblxuVXRpbHMuY3JlYXRDbGFzcyggRGlzcGxheU9iamVjdCAsIEV2ZW50RGlzcGF0Y2hlciAsIHtcbiAgICBpbml0IDogZnVuY3Rpb24oKXt9LFxuICAgIF9jcmVhdGVDb250ZXh0IDogZnVuY3Rpb24oIG9wdCApe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8v5omA5pyJ5pi+56S65a+56LGh77yM6YO95pyJ5LiA5Liq57G75Ly8Y2FudmFzLmNvbnRleHTnsbvkvLznmoQgY29udGV4dOWxnuaAp1xuICAgICAgICAvL+eUqOadpeWtmOWPluaUueaYvuekuuWvueixoeaJgOacieWSjOaYvuekuuacieWFs+eahOWxnuaAp++8jOWdkOagh++8jOagt+W8j+etieOAglxuICAgICAgICAvL+ivpeWvueixoeS4ukNvZXIuT2JzZXJ2ZSgp5bel5Y6C5Ye95pWw55Sf5oiQXG4gICAgICAgIHNlbGYuY29udGV4dCA9IG51bGw7XG5cbiAgICAgICAgLy/mj5Dkvpvnu5lDb2VyLk9ic2VydmUoKSDmnaUg57uZIHNlbGYuY29udGV4dCDorr7nva4gcHJvcGVydHlzXG4gICAgICAgIC8v6L+Z6YeM5LiN6IO955SoXy5leHRlbmTvvIwg5Zug5Li66KaB5L+d6K+BX2NvbnRleHRBVFRSU+eahOe6r+eyue+8jOWPquimhuebluS4i+mdouW3suacieeahOWxnuaAp1xuICAgICAgICB2YXIgX2NvbnRleHRBVFRSUyA9IF8uZXh0ZW5kKCBfLmNsb25lKENPTlRFWFRfREVGQVVMVCksIG9wdC5jb250ZXh0ICwgdHJ1ZSk7XG5cbiAgICAgICAgLy/mnInkupvlvJXmk47lhoXpg6jorr7nva5jb250ZXh05bGe5oCn55qE5pe25YCZ5piv5LiN55So5LiK5oql5b+D6Lez55qE77yM5q+U5aaC5YGa54Ot54K55qOA5rWL55qE5pe25YCZXG4gICAgICAgIHNlbGYuX25vdFdhdGNoID0gZmFsc2U7XG5cbiAgICAgICAgX2NvbnRleHRBVFRSUy4kb3duZXIgPSBzZWxmO1xuICAgICAgICBfY29udGV4dEFUVFJTLiR3YXRjaCA9IGZ1bmN0aW9uKG5hbWUgLCB2YWx1ZSAsIHByZVZhbHVlKXtcblxuICAgICAgICAgICAgLy/kuIvpnaLnmoTov5nkupvlsZ7mgKflj5jljJbvvIzpg73kvJrpnIDopoHph43mlrDnu4Tnu4fnn6npmLXlsZ7mgKcgX3RyYW5zZm9ybSBcbiAgICAgICAgICAgIHZhciB0cmFuc0Zvcm1Qcm9wcyA9IFsgXCJ4XCIgLCBcInlcIiAsIFwic2NhbGVYXCIgLCBcInNjYWxlWVwiICwgXCJyb3RhdGlvblwiICwgXCJzY2FsZU9yaWdpblwiICwgXCJyb3RhdGVPcmlnaW4sIGxpbmVXaWR0aFwiIF07XG5cbiAgICAgICAgICAgIGlmKCBfLmluZGV4T2YoIHRyYW5zRm9ybVByb3BzICwgbmFtZSApID49IDAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3duZXIuX3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYoIHRoaXMuJG93bmVyLl9ub3RXYXRjaCApe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKCB0aGlzLiRvd25lci4kd2F0Y2ggKXtcbiAgICAgICAgICAgICAgICB0aGlzLiRvd25lci4kd2F0Y2goIG5hbWUgLCB2YWx1ZSAsIHByZVZhbHVlICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLiRvd25lci5oZWFydEJlYXQoIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0VHlwZTpcImNvbnRleHRcIixcbiAgICAgICAgICAgICAgICBzaGFwZSAgICAgIDogdGhpcy4kb3duZXIsXG4gICAgICAgICAgICAgICAgbmFtZSAgICAgICA6IG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHByZVZhbHVlICAgOiBwcmVWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcblxuICAgICAgICAvL+aJp+ihjGluaXTkuYvliY3vvIzlupTor6XlsLHmoLnmja7lj4LmlbDvvIzmiopjb250ZXh057uE57uH5aW957q/XG4gICAgICAgIHNlbGYuY29udGV4dCA9IE9ic2VydmUoIF9jb250ZXh0QVRUUlMgKTtcbiAgICB9LFxuICAgIC8qIEBteXNlbGYg5piv5ZCm55Sf5oiQ6Ieq5bex55qE6ZWc5YOPIFxuICAgICAqIOWFi+mahuWPiOS4pOenje+8jOS4gOenjeaYr+mVnOWDj++8jOWPpuWkluS4gOenjeaYr+e7neWvueaEj+S5ieS4iumdoueahOaWsOS4quS9k1xuICAgICAqIOm7mOiupOS4uue7neWvueaEj+S5ieS4iumdoueahOaWsOS4quS9k++8jOaWsOWvueixoWlk5LiN6IO955u45ZCMXG4gICAgICog6ZWc5YOP5Z+65pys5LiK5piv5qGG5p625YaF6YOo5Zyo5a6e546wICDplZzlg4/nmoRpZOebuOWQjCDkuLvopoHnlKjmnaXmioroh6rlt7HnlLvliLDlj6blpJbnmoRzdGFnZemHjOmdou+8jOavlOWmglxuICAgICAqIG1vdXNlb3ZlcuWSjG1vdXNlb3V055qE5pe25YCZ6LCD55SoKi9cbiAgICBjbG9uZSA6IGZ1bmN0aW9uKCBteXNlbGYgKXtcbiAgICAgICAgdmFyIGNvbmYgICA9IHtcbiAgICAgICAgICAgIGlkICAgICAgOiB0aGlzLmlkLFxuICAgICAgICAgICAgY29udGV4dCA6IF8uY2xvbmUodGhpcy5jb250ZXh0LiRtb2RlbClcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbmV3T2JqO1xuICAgICAgICBpZiggdGhpcy50eXBlID09ICd0ZXh0JyApe1xuICAgICAgICAgICAgbmV3T2JqID0gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMudGV4dCAsIGNvbmYgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld09iaiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCBjb25mICk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdPYmouaWQgPSBjb25mLmlkO1xuXG4gICAgICAgIGlmKCB0aGlzLmNoaWxkcmVuICl7XG4gICAgICAgICAgICBuZXdPYmouY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFteXNlbGYpe1xuICAgICAgICAgICAgbmV3T2JqLmlkID0gVXRpbHMuY3JlYXRlSWQobmV3T2JqLnR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sXG4gICAgaGVhcnRCZWF0IDogZnVuY3Rpb24ob3B0KXtcbiAgICAgICAgLy9zdGFnZeWtmOWcqO+8jOaJjeivtHNlbGbku6PooajnmoRkaXNwbGF55bey57uP6KKr5re75Yqg5Yiw5LqGZGlzcGxheUxpc3TkuK3vvIznu5jlm77lvJXmk47pnIDopoHnn6XpgZPlhbbmlLnlj5jlkI5cbiAgICAgICAgLy/nmoTlsZ7mgKfvvIzmiYDku6XvvIzpgJrnn6XliLBzdGFnZS5kaXNwbGF5QXR0ckhhc0NoYW5nZVxuICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGlmKCBzdGFnZSApe1xuICAgICAgICAgICAgdGhpcy5faGVhcnRCZWF0TnVtICsrO1xuICAgICAgICAgICAgc3RhZ2UuaGVhcnRCZWF0ICYmIHN0YWdlLmhlYXJ0QmVhdCggb3B0ICk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEN1cnJlbnRXaWR0aCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuY29udGV4dC53aWR0aCAqIHRoaXMuY29udGV4dC5zY2FsZVgpO1xuICAgIH0sXG4gICAgZ2V0Q3VycmVudEhlaWdodCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuY29udGV4dC5oZWlnaHQgKiB0aGlzLmNvbnRleHQuc2NhbGVZKTtcbiAgICB9LFxuICAgIGdldFN0YWdlIDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHRoaXMuc3RhZ2UgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFnZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICBpZiAocC50eXBlICE9IFwic3RhZ2VcIil7XG4gICAgICAgICAgd2hpbGUocC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT0gXCJzdGFnZVwiKXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocC50eXBlICE9PSBcInN0YWdlXCIpIHtcbiAgICAgICAgICAgIC8v5aaC5p6c5b6X5Yiw55qE6aG254K5ZGlzcGxheSDnmoR0eXBl5LiN5pivU3RhZ2Us5Lmf5bCx5piv6K+05LiN5pivc3RhZ2XlhYPntKBcbiAgICAgICAgICAgIC8v6YKj5LmI5Y+q6IO96K+05piO6L+Z5LiqcOaJgOS7o+ihqOeahOmhtuerr2Rpc3BsYXkg6L+Y5rKh5pyJ5re75Yqg5YiwZGlzcGxheUxpc3TkuK3vvIzkuZ/lsLHmmK/msqHmnInmsqHmt7vliqDliLBcbiAgICAgICAgICAgIC8vc3RhZ2XoiJ7lj7DnmoRjaGlsZGVu6Zif5YiX5Lit77yM5LiN5Zyo5byV5pOO5riy5p+T6IyD5Zu05YaFXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICAvL+S4gOebtOWbnua6r+WIsOmhtuWxgm9iamVjdO+8jCDljbPmmK9zdGFnZe+8jCBzdGFnZeeahHBhcmVudOS4um51bGxcbiAgICAgICAgdGhpcy5zdGFnZSA9IHA7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgbG9jYWxUb0dsb2JhbCA6IGZ1bmN0aW9uKCBwb2ludCAsIGNvbnRhaW5lciApe1xuICAgICAgICAhcG9pbnQgJiYgKCBwb2ludCA9IG5ldyBQb2ludCggMCAsIDAgKSApO1xuICAgICAgICB2YXIgY20gPSB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCggY29udGFpbmVyICk7XG5cbiAgICAgICAgaWYgKGNtID09IG51bGwpIHJldHVybiBQb2ludCggMCAsIDAgKTtcbiAgICAgICAgdmFyIG0gPSBuZXcgTWF0cml4KDEsIDAsIDAsIDEsIHBvaW50LnggLCBwb2ludC55KTtcbiAgICAgICAgbS5jb25jYXQoY20pO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCBtLnR4ICwgbS50eSApOyAvL3t4Om0udHgsIHk6bS50eX07XG4gICAgfSxcbiAgICBnbG9iYWxUb0xvY2FsIDogZnVuY3Rpb24oIHBvaW50ICwgY29udGFpbmVyKSB7XG4gICAgICAgICFwb2ludCAmJiAoIHBvaW50ID0gbmV3IFBvaW50KCAwICwgMCApICk7XG5cbiAgICAgICAgaWYoIHRoaXMudHlwZSA9PSBcInN0YWdlXCIgKXtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY20gPSB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCggY29udGFpbmVyICk7XG5cbiAgICAgICAgaWYgKGNtID09IG51bGwpIHJldHVybiBuZXcgUG9pbnQoIDAgLCAwICk7IC8ve3g6MCwgeTowfTtcbiAgICAgICAgY20uaW52ZXJ0KCk7XG4gICAgICAgIHZhciBtID0gbmV3IE1hdHJpeCgxLCAwLCAwLCAxLCBwb2ludC54ICwgcG9pbnQueSk7XG4gICAgICAgIG0uY29uY2F0KGNtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggbS50eCAsIG0udHkgKTsgLy97eDptLnR4LCB5Om0udHl9O1xuICAgIH0sXG4gICAgbG9jYWxUb1RhcmdldCA6IGZ1bmN0aW9uKCBwb2ludCAsIHRhcmdldCl7XG4gICAgICAgIHZhciBwID0gbG9jYWxUb0dsb2JhbCggcG9pbnQgKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5nbG9iYWxUb0xvY2FsKCBwICk7XG4gICAgfSxcbiAgICBnZXRDb25jYXRlbmF0ZWRNYXRyaXggOiBmdW5jdGlvbiggY29udGFpbmVyICl7XG4gICAgICAgIHZhciBjbSA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgZm9yICh2YXIgbyA9IHRoaXM7IG8gIT0gbnVsbDsgbyA9IG8ucGFyZW50KSB7XG4gICAgICAgICAgICBjbS5jb25jYXQoIG8uX3RyYW5zZm9ybSApO1xuICAgICAgICAgICAgaWYoICFvLnBhcmVudCB8fCAoIGNvbnRhaW5lciAmJiBvLnBhcmVudCAmJiBvLnBhcmVudCA9PSBjb250YWluZXIgKSB8fCAoIG8ucGFyZW50ICYmIG8ucGFyZW50LnR5cGU9PVwic3RhZ2VcIiApICkge1xuICAgICAgICAgICAgLy9pZiggby50eXBlID09IFwic3RhZ2VcIiB8fCAoby5wYXJlbnQgJiYgY29udGFpbmVyICYmIG8ucGFyZW50LnR5cGUgPT0gY29udGFpbmVyLnR5cGUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY207Ly9icmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY207XG4gICAgfSxcbiAgICAvKlxuICAgICAq6K6+572u5YWD57Sg55qE5piv5ZCm5ZON5bqU5LqL5Lu25qOA5rWLXG4gICAgICpAYm9vbCAgQm9vbGVhbiDnsbvlnotcbiAgICAgKi9cbiAgICBzZXRFdmVudEVuYWJsZSA6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICAgIGlmKF8uaXNCb29sZWFuKGJvb2wpKXtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50RW5hYmxlZCA9IGJvb2xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKlxuICAgICAq5p+l6K+i6Ieq5bex5ZyocGFyZW5055qE6Zif5YiX5Lit55qE5L2N572uXG4gICAgICovXG4gICAgZ2V0SW5kZXggICA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZih0aGlzLnBhcmVudC5jaGlsZHJlbiAsIHRoaXMpXG4gICAgfSxcbiAgICAvKlxuICAgICAq5YWD57Sg5Zyoeui9tOaWueWQkeWQkeS4i+enu+WKqFxuICAgICAqQG51bSDnp7vliqjnmoTlsYLnuqdcbiAgICAgKi9cbiAgICB0b0JhY2sgOiBmdW5jdGlvbiggbnVtICl7XG4gICAgICAgIGlmKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbUluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICB2YXIgdG9JbmRleCA9IDA7XG4gICAgICAgIFxuICAgICAgICBpZihfLmlzTnVtYmVyKCBudW0gKSl7XG4gICAgICAgICAgaWYoIG51bSA9PSAwICl7XG4gICAgICAgICAgICAgLy/ljp/lnLDkuI3liqhcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0b0luZGV4ID0gZnJvbUluZGV4IC0gbnVtO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSggZnJvbUluZGV4ICwgMSApWzBdO1xuICAgICAgICBpZiggdG9JbmRleCA8IDAgKXtcbiAgICAgICAgICAgIHRvSW5kZXggPSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhcmVudC5hZGRDaGlsZEF0KCBtZSAsIHRvSW5kZXggKTtcbiAgICB9LFxuICAgIC8qXG4gICAgICrlhYPntKDlnKh66L205pa55ZCR5ZCR5LiK56e75YqoXG4gICAgICpAbnVtIOenu+WKqOeahOWxguaVsOmHjyDpu5jorqTliLDpobbnq69cbiAgICAgKi9cbiAgICB0b0Zyb250IDogZnVuY3Rpb24oIG51bSApe1xuICAgICAgICBpZighdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcbiAgICAgICAgdmFyIHBjbCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIHRvSW5kZXggPSBwY2w7XG4gICAgICAgIFxuICAgICAgICBpZihfLmlzTnVtYmVyKCBudW0gKSl7XG4gICAgICAgICAgaWYoIG51bSA9PSAwICl7XG4gICAgICAgICAgICAgLy/ljp/lnLDkuI3liqhcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvSW5kZXggPSBmcm9tSW5kZXggKyBudW0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSggZnJvbUluZGV4ICwgMSApWzBdO1xuICAgICAgICBpZih0b0luZGV4ID4gcGNsKXtcbiAgICAgICAgICAgIHRvSW5kZXggPSBwY2w7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQuYWRkQ2hpbGRBdCggbWUgLCB0b0luZGV4LTEgKTtcbiAgICB9LFxuICAgIF91cGRhdGVUcmFuc2Zvcm0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90cmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIF90cmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIC8v5piv5ZCm6ZyA6KaBVHJhbnNmb3JtXG4gICAgICAgIGlmKGNvbnRleHQuc2NhbGVYICE9PSAxIHx8IGNvbnRleHQuc2NhbGVZICE9PTEgKXtcbiAgICAgICAgICAgIC8v5aaC5p6c5pyJ57yp5pS+XG4gICAgICAgICAgICAvL+e8qeaUvueahOWOn+eCueWdkOagh1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG5ldyBQb2ludChjb250ZXh0LnNjYWxlT3JpZ2luKTtcbiAgICAgICAgICAgIGlmKCBvcmlnaW4ueCB8fCBvcmlnaW4ueSApe1xuICAgICAgICAgICAgICAgIF90cmFuc2Zvcm0udHJhbnNsYXRlKCAtb3JpZ2luLnggLCAtb3JpZ2luLnkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90cmFuc2Zvcm0uc2NhbGUoIGNvbnRleHQuc2NhbGVYICwgY29udGV4dC5zY2FsZVkgKTtcbiAgICAgICAgICAgIGlmKCBvcmlnaW4ueCB8fCBvcmlnaW4ueSApe1xuICAgICAgICAgICAgICAgIF90cmFuc2Zvcm0udHJhbnNsYXRlKCBvcmlnaW4ueCAsIG9yaWdpbi55ICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByb3RhdGlvbiA9IGNvbnRleHQucm90YXRpb247XG4gICAgICAgIGlmKCByb3RhdGlvbiApe1xuICAgICAgICAgICAgLy/lpoLmnpzmnInml4vovaxcbiAgICAgICAgICAgIC8v5peL6L2s55qE5Y6f54K55Z2Q5qCHXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gbmV3IFBvaW50KGNvbnRleHQucm90YXRlT3JpZ2luKTtcbiAgICAgICAgICAgIGlmKCBvcmlnaW4ueCB8fCBvcmlnaW4ueSApe1xuICAgICAgICAgICAgICAgIF90cmFuc2Zvcm0udHJhbnNsYXRlKCAtb3JpZ2luLnggLCAtb3JpZ2luLnkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90cmFuc2Zvcm0ucm90YXRlKCByb3RhdGlvbiAlIDM2MCAqIE1hdGguUEkvMTgwICk7XG4gICAgICAgICAgICBpZiggb3JpZ2luLnggfHwgb3JpZ2luLnkgKXtcbiAgICAgICAgICAgICAgICBfdHJhbnNmb3JtLnRyYW5zbGF0ZSggb3JpZ2luLnggLCBvcmlnaW4ueSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8v5aaC5p6c5pyJ5L2N56e7XG4gICAgICAgIHZhciB4LHk7XG4gICAgICAgIGlmKCB0aGlzLnh5VG9JbnQgJiYgIXRoaXMubW92ZWluZyApe1xuICAgICAgICAgICAgLy/lvZPov5nkuKrlhYPntKDlnKjlgZrovajov7nov5DliqjnmoTml7blgJnvvIzmr5TlpoJkcmFn77yMYW5pbWF0aW9u5aaC5p6c5a6e5pe255qE6LCD5pW06L+Z5LiqeCDvvIwgeVxuICAgICAgICAgICAgLy/pgqPkuYjor6XlhYPntKDnmoTovajov7nkvJrmnInot7Pot4PnmoTmg4XlhrXlj5HnlJ/jgILmiYDku6XliqDkuKrmnaHku7bov4fmu6TvvIxcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQoIGNvbnRleHQueCApO1xuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludCggY29udGV4dC55ICk7XG5cbiAgICAgICAgICAgIGlmKCBwYXJzZUludChjb250ZXh0LmxpbmVXaWR0aCAsIDEwKSAlIDIgPT0gMSAmJiBjb250ZXh0LnN0cm9rZVN0eWxlICl7XG4gICAgICAgICAgICAgICAgeCArPSAwLjU7XG4gICAgICAgICAgICAgICAgeSArPSAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gY29udGV4dC54O1xuICAgICAgICAgICAgeSA9IGNvbnRleHQueTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggeCAhPSAwIHx8IHkgIT0gMCApe1xuICAgICAgICAgICAgX3RyYW5zZm9ybS50cmFuc2xhdGUoIHggLCB5ICk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IF90cmFuc2Zvcm07XG4gICAgICAgIHJldHVybiBfdHJhbnNmb3JtO1xuICAgIH0sXG4gICAgLy/mmL7npLrlr7nosaHnmoTpgInlj5bmo4DmtYvlpITnkIblh73mlbBcbiAgICBnZXRDaGlsZEluUG9pbnQgOiBmdW5jdGlvbiggcG9pbnQgKXtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7IC8v5qOA5rWL55qE57uT5p6cXG5cbiAgICAgICAgLy/nrKzkuIDmraXvvIzlkKdnbG9i55qEcG9pbnTovazmjaLliLDlr7nlupTnmoRvYmrnmoTlsYLnuqflhoXnmoTlnZDmoIfns7vnu59cbiAgICAgICAgaWYoIHRoaXMudHlwZSAhPSBcInN0YWdlXCIgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQudHlwZSAhPSBcInN0YWdlXCIgKSB7XG4gICAgICAgICAgICBwb2ludCA9IHRoaXMucGFyZW50Lmdsb2JhbFRvTG9jYWwoIHBvaW50ICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHggPSBwb2ludC54O1xuICAgICAgICB2YXIgeSA9IHBvaW50Lnk7XG4gICAgXG4gICAgICAgIC8v5a+56byg5qCH55qE5Z2Q5qCH5Lmf5YGa55u45ZCM55qE5Y+Y5o2iXG4gICAgICAgIGlmKCB0aGlzLl90cmFuc2Zvcm0gKXtcbiAgICAgICAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtLmNsb25lKCkuaW52ZXJ0KCk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luUG9zID0gW3gsIHldO1xuICAgICAgICAgICAgb3JpZ2luUG9zID0gaW52ZXJzZU1hdHJpeC5tdWxWZWN0b3IoIG9yaWdpblBvcyApO1xuXG4gICAgICAgICAgICB4ID0gb3JpZ2luUG9zWzBdO1xuICAgICAgICAgICAgeSA9IG9yaWdpblBvc1sxXTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggdGhpcy5ncmFwaGljcyApe1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5ncmFwaGljcy5jb250YWluc1BvaW50KCB7eDogeCAsIHk6IHl9ICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLypcbiAgICAqIGFuaW1hdGVcbiAgICAqIEBwYXJhbSB0b0NvbnRlbnQg6KaB5Yqo55S75Y+Y5b2i5Yiw55qE5bGe5oCn6ZuG5ZCIXG4gICAgKiBAcGFyYW0gb3B0aW9ucyB0d2VlbiDliqjnlLvlj4LmlbBcbiAgICAqL1xuICAgIGFuaW1hdGUgOiBmdW5jdGlvbiggdG9Db250ZW50ICwgb3B0aW9ucyApe1xuICAgICAgICB2YXIgdG8gPSB0b0NvbnRlbnQ7XG4gICAgICAgIHZhciBmcm9tID0ge307XG4gICAgICAgIGZvciggdmFyIHAgaW4gdG8gKXtcbiAgICAgICAgICAgIGZyb21bIHAgXSA9IHRoaXMuY29udGV4dFtwXTtcbiAgICAgICAgfTtcbiAgICAgICAgIW9wdGlvbnMgJiYgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgICAgIG9wdGlvbnMudG8gPSB0bztcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB1cEZ1biA9IGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgaWYoIG9wdGlvbnMub25VcGRhdGUgKXtcbiAgICAgICAgICAgIHVwRnVuID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHR3ZWVuO1xuICAgICAgICBvcHRpb25zLm9uVXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8v5aaC5p6cY29udGV4dOS4jeWtmOWcqOivtOaYjuivpW9iauW3sue7j+iiq2Rlc3Ryb3nkuobvvIzpgqPkuYjopoHmiorku5bnmoR0d2Vlbue7mWRlc3Ryb3lcbiAgICAgICAgICAgIGlmICghc2VsZi5jb250ZXh0ICYmIHR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uRnJhbWUuZGVzdHJveVR3ZWVuKHR3ZWVuKTtcbiAgICAgICAgICAgICAgICB0d2VlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciggdmFyIHAgaW4gdGhpcyApe1xuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dFtwXSA9IHRoaXNbcF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBGdW4uYXBwbHkoc2VsZiAsIFt0aGlzXSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wRnVuID0gZnVuY3Rpb24oKXt9O1xuICAgICAgICBpZiggb3B0aW9ucy5vbkNvbXBsZXRlICl7XG4gICAgICAgICAgICBjb21wRnVuID0gb3B0aW9ucy5vbkNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUgPSBmdW5jdGlvbiggb3B0ICl7XG4gICAgICAgICAgICBjb21wRnVuLmFwcGx5KHNlbGYgLCBhcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICAgIHR3ZWVuID0gQW5pbWF0aW9uRnJhbWUucmVnaXN0VHdlZW4oIG9wdGlvbnMgKTtcbiAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgIH0sXG5cblxuICAgIC8v5riy5p+T55u45YWz6YOo5YiG77yM6L+B56e75YiwcmVuZGVyZXJz5Lit5Y67XG4gICAgX3JlbmRlciA6IGZ1bmN0aW9uKCBjdHggKXtcdFxuICAgICAgICBpZiggIXRoaXMuY29udGV4dC52aXNpYmxlIHx8IHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA8PSAwICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgXG5cbiAgICAgICAgdmFyIHRyYW5zRm9ybSA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICAgICAgaWYoICF0cmFuc0Zvcm0gKSB7XG4gICAgICAgICAgICB0cmFuc0Zvcm0gPSB0aGlzLl91cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy/ov5DnlKjnn6npmLXlvIDlp4vlj5jlvaJcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseSggY3R4ICwgdHJhbnNGb3JtLnRvQXJyYXkoKSApO1xuXG4gICAgICAgIC8v6K6+572u5qC35byP77yM5paH5pys5pyJ6Ieq5bex55qE6K6+572u5qC35byP5pa55byPXG4gICAgICAgIGlmKCB0aGlzLnR5cGUgIT0gXCJ0ZXh0XCIgKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmNvbnRleHQuJG1vZGVsO1xuICAgICAgICAgICAgZm9yKHZhciBwIGluIHN0eWxlKXtcbiAgICAgICAgICAgICAgICBpZiggcCAhPSBcInRleHRCYXNlbGluZVwiICYmICggcCBpbiBjdHggKSApe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0eWxlW3BdIHx8IF8uaXNOdW1iZXIoIHN0eWxlW3BdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggcCA9PSBcImdsb2JhbEFscGhhXCIgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+mAj+aYjuW6puimgeS7jueItuiKgueCuee7p+aJv1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eFtwXSAqPSBzdHlsZVtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4W3BdID0gc3R5bGVbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIoIGN0eCApO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgcmVuZGVyIDogZnVuY3Rpb24oIGN0eCApIHtcbiAgICAgICAgLy/ln7rnsbvkuI3mj5DkvptyZW5kZXLnmoTlhbfkvZPlrp7njrDvvIznlLHlkI7nu63lhbfkvZPnmoTmtL7nlJ/nsbvlkIToh6rlrp7njrBcbiAgICB9LFxuICAgIC8v5LuO5qCR5Lit5Yig6ZmkXG4gICAgcmVtb3ZlIDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHRoaXMucGFyZW50ICl7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy/lhYPntKDnmoToh6rmiJHplIDmr4FcbiAgICBkZXN0cm95IDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5maXJlKFwiZGVzdHJveVwiKTtcbiAgICAgICAgLy/mioroh6rlt7Hku47niLboioLngrnkuK3liKDpmaTkuoblkI7lgZroh6rmiJHmuIXpmaTvvIzph4rmlL7lhoXlrZhcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dDtcbiAgICB9XG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IERpc3BsYXlPYmplY3Q7XG5cbiIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOaooeaLn2FzM+eahERpc3BsYXlMaXN0IOS4reeahOWuueWZqOexu1xuICovXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xuaW1wb3J0IERpc3BsYXlPYmplY3QgZnJvbSBcIi4vRGlzcGxheU9iamVjdFwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuL1BvaW50XCI7XG5cbnZhciBEaXNwbGF5T2JqZWN0Q29udGFpbmVyID0gZnVuY3Rpb24ob3B0KXtcbiAgIHZhciBzZWxmID0gdGhpcztcbiAgIHNlbGYuY2hpbGRyZW4gPSBbXTtcbiAgIHNlbGYubW91c2VDaGlsZHJlbiA9IFtdO1xuICAgRGlzcGxheU9iamVjdENvbnRhaW5lci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgIC8v5omA5pyJ55qE5a655Zmo6buY6K6k5pSv5oyBZXZlbnQg5qOA5rWL77yM5Zug5Li6IOWPr+iDveaciemHjOmdoueahHNoYXBl5pivZXZlbnRFbmFibGXmmK90cnVl55qEXG4gICAvL+WmguaenOeUqOaIt+acieW8uuWItueahOmcgOaxguiuqeWuueWZqOS4i+eahOaJgOacieWFg+e0oOmDvSDkuI3lj6/mo4DmtYvvvIzlj6/ku6XosIPnlKhcbiAgIC8vRGlzcGxheU9iamVjdENvbnRhaW5lcueahCBzZXRFdmVudEVuYWJsZSgpIOaWueazlVxuICAgc2VsZi5fZXZlbnRFbmFibGVkID0gdHJ1ZTtcbn07XG5cblV0aWxzLmNyZWF0Q2xhc3MoIERpc3BsYXlPYmplY3RDb250YWluZXIgLCBEaXNwbGF5T2JqZWN0ICwge1xuICAgIGFkZENoaWxkIDogZnVuY3Rpb24oY2hpbGQpe1xuICAgICAgICBpZiggIWNoaWxkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBpZih0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpICE9IC0xKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9O1xuICAgICAgICAvL+WmguaenOS7luWcqOWIq+eahOWtkOWFg+e0oOS4re+8jOmCo+S5iOWwseS7juWIq+S6uumCo+mHjOWIoOmZpOS6hlxuICAgICAgICBpZihjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYodGhpcy5oZWFydEJlYXQpe1xuICAgICAgICAgICB0aGlzLmhlYXJ0QmVhdCh7XG4gICAgICAgICAgICAgY29udmVydFR5cGUgOiBcImNoaWxkcmVuXCIsXG4gICAgICAgICAgICAgdGFyZ2V0ICAgICAgOiBjaGlsZCxcbiAgICAgICAgICAgICBzcmMgICAgICAgICA6IHRoaXNcbiAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYodGhpcy5fYWZ0ZXJBZGRDaGlsZCl7XG4gICAgICAgICAgIHRoaXMuX2FmdGVyQWRkQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuICAgIGFkZENoaWxkQXQgOiBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYodGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKSAhPSAtMSkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYoY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgLy/kuIrmiqVjaGlsZHJlbuW/g+i3s1xuICAgICAgICBpZih0aGlzLmhlYXJ0QmVhdCl7XG4gICAgICAgICAgIHRoaXMuaGVhcnRCZWF0KHtcbiAgICAgICAgICAgICBjb252ZXJ0VHlwZSA6IFwiY2hpbGRyZW5cIixcbiAgICAgICAgICAgICB0YXJnZXQgICAgICAgOiBjaGlsZCxcbiAgICAgICAgICAgICBzcmMgICAgICA6IHRoaXNcbiAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9hZnRlckFkZENoaWxkKXtcbiAgICAgICAgICAgdGhpcy5fYWZ0ZXJBZGRDaGlsZChjaGlsZCxpbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGQgOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZEF0KF8uaW5kZXhPZiggdGhpcy5jaGlsZHJlbiAsIGNoaWxkICkpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRBdCA6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmhlYXJ0QmVhdCl7XG4gICAgICAgICAgIHRoaXMuaGVhcnRCZWF0KHtcbiAgICAgICAgICAgICBjb252ZXJ0VHlwZSA6IFwiY2hpbGRyZW5cIixcbiAgICAgICAgICAgICB0YXJnZXQgICAgICAgOiBjaGlsZCxcbiAgICAgICAgICAgICBzcmMgICAgICA6IHRoaXNcbiAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9hZnRlckRlbENoaWxkKXtcbiAgICAgICAgICAgdGhpcy5fYWZ0ZXJEZWxDaGlsZChjaGlsZCAsIGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkQnlJZCA6IGZ1bmN0aW9uKCBpZCApIHtcdFxuICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNoaWxkcmVuW2ldLmlkID09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGRBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICByZW1vdmVBbGxDaGlsZHJlbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRBdCgwKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy/pm4blkIjnsbvnmoToh6rmiJHplIDmr4FcbiAgICBkZXN0cm95IDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHRoaXMucGFyZW50ICl7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maXJlKFwiZGVzdHJveVwiKTtcbiAgICAgICAgLy/kvp3mrKHplIDmr4HmiYDmnInlrZDlhYPntKBcbiAgICAgICAgZm9yICh2YXIgaT0wLGw9dGhpcy5jaGlsZHJlbi5sZW5ndGggOyBpPGwgOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5nZXRDaGlsZEF0KGkpLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGwtLTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8qXG4gICAgICpAaWQg5YWD57Sg55qEaWRcbiAgICAgKkBib29sZW4g5piv5ZCm5rex5bqm5p+l6K+i77yM6buY6K6k5bCx5Zyo56ys5LiA5bGC5a2Q5YWD57Sg5Lit5p+l6K+iXG4gICAgICoqL1xuICAgIGdldENoaWxkQnlJZCA6IGZ1bmN0aW9uKGlkICwgYm9vbGVuKXtcbiAgICAgICAgaWYoIWJvb2xlbikge1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jaGlsZHJlbltpXS5pZCA9PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL+a3seW6puafpeivolxuICAgICAgICAgICAgLy9UT0RPOuaaguaXtuacquWunueOsFxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldENoaWxkQXQgOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICAgIH0sXG4gICAgZ2V0Q2hpbGRJbmRleCA6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBfLmluZGV4T2YoIHRoaXMuY2hpbGRyZW4gLCBjaGlsZCApO1xuICAgIH0sXG4gICAgc2V0Q2hpbGRJbmRleCA6IGZ1bmN0aW9uKGNoaWxkLCBpbmRleCl7XG4gICAgICAgIGlmKGNoaWxkLnBhcmVudCAhPSB0aGlzKSByZXR1cm47XG4gICAgICAgIHZhciBvbGRJbmRleCA9IF8uaW5kZXhPZiggdGhpcy5jaGlsZHJlbiAsIGNoaWxkICk7XG4gICAgICAgIGlmKGluZGV4ID09IG9sZEluZGV4KSByZXR1cm47XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKG9sZEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICB9LFxuICAgIGdldE51bUNoaWxkcmVuIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICB9LFxuICAgIC8v6I635Y+WeCx554K55LiK55qE5omA5pyJb2JqZWN0ICBudW0g6ZyA6KaB6L+U5Zue55qEb2Jq5pWw6YePXG4gICAgZ2V0T2JqZWN0c1VuZGVyUG9pbnQgOiBmdW5jdGlvbiggcG9pbnQgLCBudW0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yKHZhciBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYoIGNoaWxkID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAoIWNoaWxkLl9ldmVudEVuYWJsZWQgJiYgIWNoaWxkLmRyYWdFbmFibGVkKSB8fCBcbiAgICAgICAgICAgICAgICAhY2hpbGQuY29udGV4dC52aXNpYmxlIFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggY2hpbGQgaW5zdGFuY2VvZiBEaXNwbGF5T2JqZWN0Q29udGFpbmVyICkge1xuICAgICAgICAgICAgICAgIC8v5piv6ZuG5ZCIXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1vdXNlQ2hpbGRyZW4gJiYgY2hpbGQuZ2V0TnVtQ2hpbGRyZW4oKSA+IDApe1xuICAgICAgICAgICAgICAgICAgIHZhciBvYmpzID0gY2hpbGQuZ2V0T2JqZWN0c1VuZGVyUG9pbnQoIHBvaW50ICk7XG4gICAgICAgICAgICAgICAgICAgaWYgKG9ianMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCggb2JqcyApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XHRcdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL+mdnumbhuWQiO+8jOWPr+S7peW8gOWni+WBmmdldENoaWxkSW5Qb2ludOS6hlxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5nZXRDaGlsZEluUG9pbnQoIHBvaW50ICkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtICE9IHVuZGVmaW5lZCAmJiAhaXNOYU4obnVtKSl7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5sZW5ndGggPT0gbnVtKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSk7XG5leHBvcnQgZGVmYXVsdCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyO1xuIiwiLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICogc3RhZ2Ug57G777yMIOWGjWFzM+S4re+8jHN0YWdl5YiZ5Luj6KGo5pW05Liq6Iie5Y+w44CC5piv5ZSv5LiA55qE5qC56IqC54K5XG4gKiDkvYbmmK/lho1jYW52YXjkuK3vvIzlm6DkuLrliIblsYLorr7orqHnmoTpnIDopoHjgIJzdGFnZSDoiJ7lj7Ag5ZCM5qC35Luj6KGo5LiA5LiqY2FudmFz5YWD57Sg77yM5L2G5piv5LiN5piv5YaN5pW05Liq5byV5pOO6K6+6K6hXG4gKiDph4zpnaLvvIwg5LiN5piv5ZSv5LiA55qE5qC56IqC54K544CC6ICM5piv5Lya5Lqk55SxY2FudmF457G75p2l57uf5LiA566h55CG5YW25bGC57qnXG4gKi9cbmltcG9ydCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIGZyb20gXCIuL0Rpc3BsYXlPYmplY3RDb250YWluZXJcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcblxudmFyIFN0YWdlID0gZnVuY3Rpb24oICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudHlwZSA9IFwic3RhZ2VcIjtcbiAgICBzZWxmLmNhbnZhcyA9IG51bGw7XG4gICAgc2VsZi5jdHggPSBudWxsOyAvL+a4suafk+eahOaXtuWAmeeUsXJlbmRlcmVy5Yaz5a6aLOi/memHjOS4jeWBmuWIneWni+WAvFxuICAgIC8vc3RhZ2XmraPlnKjmuLLmn5PkuK1cbiAgICBzZWxmLnN0YWdlUmVuZGluZyA9IGZhbHNlO1xuICAgIHNlbGYuX2lzUmVhZHkgPSBmYWxzZTtcbiAgICBTdGFnZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuVXRpbHMuY3JlYXRDbGFzcyggU3RhZ2UgLCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyICwge1xuICAgIGluaXQgOiBmdW5jdGlvbigpe30sXG4gICAgLy/nlLFjYW52YXjnmoRhZnRlckFkZENoaWxkIOWbnuiwg1xuICAgIGluaXRTdGFnZSA6IGZ1bmN0aW9uKCBjYW52YXMgLCB3aWR0aCAsIGhlaWdodCApe1xuICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICBzZWxmLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICBzZWxmLmNvbnRleHQud2lkdGggID0gd2lkdGg7XG4gICAgICAgc2VsZi5jb250ZXh0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICBzZWxmLmNvbnRleHQuc2NhbGVYID0gVXRpbHMuX2RldmljZVBpeGVsUmF0aW87XG4gICAgICAgc2VsZi5jb250ZXh0LnNjYWxlWSA9IFV0aWxzLl9kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgIHNlbGYuX2lzUmVhZHkgPSB0cnVlO1xuICAgIH0sXG4gICAgaGVhcnRCZWF0IDogZnVuY3Rpb24oIG9wdCApe1xuICAgICAgICAvL3NoYXBlICwgbmFtZSAsIHZhbHVlICwgcHJlVmFsdWUgXG4gICAgICAgIC8vZGlzcGxheUxpc3TkuK3mn5DkuKrlsZ7mgKfmlLnlj5jkuoZcbiAgICAgICAgaWYgKCF0aGlzLl9pc1JlYWR5KSB7XG4gICAgICAgICAgIC8v5Zyoc3RhZ2Xov5jmsqHliJ3lp4vljJblrozmr5XnmoTmg4XlhrXkuIvvvIzml6DpnIDlgZrku7vkvZXlpITnkIZcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBvcHQgfHwgKCBvcHQgPSB7fSApOyAvL+WmguaenG9wdOS4uuepuu+8jOivtOaYjuWwseaYr+aXoOadoeS7tuWIt+aWsFxuICAgICAgICBvcHQuc3RhZ2UgICA9IHRoaXM7XG5cbiAgICAgICAgLy9UT0RP5Li05pe25YWI6L+Z5LmI5aSE55CGXG4gICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmhlYXJ0QmVhdChvcHQpO1xuICAgIH1cbn0pO1xuZXhwb3J0IGRlZmF1bHQgU3RhZ2U7IiwiaW1wb3J0IHsgUkVOREVSRVJfVFlQRSB9IGZyb20gJy4uL2NvbnN0JztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi9zZXR0aW5ncyc7XG5pbXBvcnQgQW5pbWF0aW9uRnJhbWUgZnJvbSBcIi4uL2FuaW1hdGlvbi9BbmltYXRpb25GcmFtZVwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3lzdGVtUmVuZGVyZXIgXG57XG4gICAgY29uc3RydWN0b3IoIHR5cGU9UkVOREVSRVJfVFlQRS5VTktOT1dOICwgYXBwICwgb3B0aW9ucyApXG4gICAge1xuICAgIFx0dGhpcy50eXBlID0gdHlwZTsgLy8yY2FudmFzLDF3ZWJnbFxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcblxuICAgICAgICAvLyBwcmVwYXJlIG9wdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBzZXR0aW5ncy5SRU5ERVJfT1BUSU9OUylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbaV0gPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tpXSA9IHNldHRpbmdzLlJFTkRFUl9PUFRJT05TW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBzZXR0aW5ncy5SRU5ERVJfT1BUSU9OUztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblxuICAgICAgICB0aGlzLnJlcXVlc3RBaWQgPSBudWxsO1xuXG5cdFx0dGhpcy5faGVhcnRCZWF0ID0gZmFsc2U7Ly/lv4Pot7PvvIzpu5jorqTkuLpmYWxzZe+8jOWNs2ZhbHNl55qE5pe25YCZ5byV5pOO5aSE5LqO6Z2Z6buY54q25oCBIHRydWXliJnlkK/liqjmuLLmn5NcblxuXHRcdHRoaXMuX3ByZVJlbmRlclRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8v5aaC5p6c5byV5pOO5aSE5LqO6Z2Z6buY54q25oCB55qE6K+d77yM5bCx5Lya5ZCv5YqoXG4gICAgc3RhcnRFbnRlcigpXG4gICAge1xuICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICBpZiggIXNlbGYucmVxdWVzdEFpZCApe1xuICAgICAgICAgICBzZWxmLnJlcXVlc3RBaWQgPSBBbmltYXRpb25GcmFtZS5yZWdpc3RGcmFtZSgge1xuICAgICAgICAgICAgICAgaWQgOiBcImVudGVyRnJhbWVcIiwgLy/lkIzml7bogq/lrprlj6rmnInkuIDkuKplbnRlckZyYW1l55qEdGFza1xuICAgICAgICAgICAgICAgdGFzayA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW50ZXJGcmFtZS5hcHBseShzZWxmKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSApO1xuICAgICAgIH1cbiAgICB9XG5cbiAgICBlbnRlckZyYW1lKClcbiAgICB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLy/kuI3nrqHmgI7kuYjmoLfvvIxlbnRlckZyYW1l5omn6KGM5LqG5bCx6KaB5oqKXG4gICAgICAgIC8vcmVxdWVzdEFpZCBudWxsIOaOiVxuICAgICAgICBzZWxmLnJlcXVlc3RBaWQgPSBudWxsO1xuICAgICAgICBVdGlscy5ub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYoIHNlbGYuX2hlYXJ0QmVhdCApe1xuXG4gICAgICAgICAgICB2YXIgX2JlZ2luID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBzZWxmLnJlbmRlciggdGhpcy5hcHAgKTtcbiAgICAgICAgICAgIHZhciBfZW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyggX2VuZCAtIF9iZWdpbiApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYuX2hlYXJ0QmVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgLy/muLLmn5PlrozkuobvvIzmiZPkuIrmnIDmlrDml7bpl7TmjKtcbiAgICAgICAgICAgIHNlbGYuX3ByZVJlbmRlclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfY29udmVydENhbnZheChvcHQpXG4gICAge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBfLmVhY2goIG1lLmFwcC5jaGlsZHJlbiAsIGZ1bmN0aW9uKHN0YWdlKXtcbiAgICAgICAgICAgIHN0YWdlLmNvbnRleHRbb3B0Lm5hbWVdID0gb3B0LnZhbHVlOyBcbiAgICAgICAgfSApOyAgXG4gICAgfVxuXG4gICAgaGVhcnRCZWF0KCBvcHQgKVxuICAgIHtcbiAgICAgICAgLy9kaXNwbGF5TGlzdOS4reafkOS4quWxnuaAp+aUueWPmOS6hlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmKCBvcHQgKXtcbiAgICAgICAgICAgIC8v5b+D6Lez5YyF5pyJ5Lik56eN77yM5LiA56eN5piv5p+Q5YWD57Sg55qE5Y+v6KeG5bGe5oCn5pS55Y+Y5LqG44CC5LiA56eN5pivY2hpbGRyZW7mnInlj5jliqhcbiAgICAgICAgICAgIC8v5YiG5Yir5a+55bqUY29udmVydFR5cGUgIOS4uiBjb250ZXh0ICBhbmQgY2hpbGRyZW5cbiAgICAgICAgICAgIGlmIChvcHQuY29udmVydFR5cGUgPT0gXCJjb250ZXh0XCIpe1xuICAgICAgICAgICAgICAgIHZhciBzdGFnZSAgID0gb3B0LnN0YWdlO1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSAgID0gb3B0LnNoYXBlO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lICAgID0gb3B0Lm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlICAgPSBvcHQudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHByZVZhbHVlPSBvcHQucHJlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiggc2hhcGUudHlwZSA9PSBcImNhbnZheFwiICl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbnZlcnRDYW52YXgob3B0KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFzZWxmLmFwcC5jb252ZXJ0U3RhZ2VzW3N0YWdlLmlkXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcC5jb252ZXJ0U3RhZ2VzW3N0YWdlLmlkXT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2UgOiBzdGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0U2hhcGVzIDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYoc2hhcGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmFwcC5jb252ZXJ0U3RhZ2VzWyBzdGFnZS5pZCBdLmNvbnZlcnRTaGFwZXNbIHNoYXBlLmlkIF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwLmNvbnZlcnRTdGFnZXNbIHN0YWdlLmlkIF0uY29udmVydFNoYXBlc1sgc2hhcGUuaWQgXT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlIDogc2hhcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRUeXBlIDogb3B0LmNvbnZlcnRUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WmguaenOW3sue7j+S4iuaKpeS6huivpSBzaGFwZSDnmoTlv4Pot7PjgIJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG9wdC5jb252ZXJ0VHlwZSA9PSBcImNoaWxkcmVuXCIpe1xuICAgICAgICAgICAgICAgIC8v5YWD57Sg57uT5p6E5Y+Y5YyW77yM5q+U5aaCYWRkY2hpbGQgcmVtb3ZlQ2hpbGTnrYlcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gb3B0LnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhZ2UgPSBvcHQuc3JjLmdldFN0YWdlKCk7XG4gICAgICAgICAgICAgICAgaWYoIHN0YWdlIHx8ICh0YXJnZXQudHlwZT09XCJzdGFnZVwiKSApe1xuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOaTjeS9nOeahOebruagh+WFg+e0oOaYr1N0YWdlXG4gICAgICAgICAgICAgICAgICAgIHN0YWdlID0gc3RhZ2UgfHwgdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZighc2VsZi5hcHAuY29udmVydFN0YWdlc1tzdGFnZS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwLmNvbnZlcnRTdGFnZXNbc3RhZ2UuaWRdPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZSA6IHN0YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRTaGFwZXMgOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighb3B0LmNvbnZlcnRUeXBlKXtcbiAgICAgICAgICAgICAgICAvL+aXoOadoeS7tuimgeaxguWIt+aWsFxuICAgICAgICAgICAgICAgIHZhciBzdGFnZSA9IG9wdC5zdGFnZTtcbiAgICAgICAgICAgICAgICBpZighc2VsZi5hcHAuY29udmVydFN0YWdlc1tzdGFnZS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHAuY29udmVydFN0YWdlc1tzdGFnZS5pZF09e1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2UgOiBzdGFnZSAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0U2hhcGVzIDoge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8v5peg5p2h5Lu26KaB5rGC5YWo6YOo5Yi35paw77yM5LiA6Iis55So5ZyocmVzaXpl562J44CCXG4gICAgICAgICAgICBfLmVhY2goIHNlbGYuYXBwLmNoaWxkcmVuICwgZnVuY3Rpb24oIHN0YWdlICwgaSApe1xuICAgICAgICAgICAgICAgIHNlbGYuYXBwLmNvbnZlcnRTdGFnZXNbIHN0YWdlLmlkIF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlIDogc3RhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRTaGFwZXMgOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZWxmLl9oZWFydEJlYXQpe1xuICAgICAgICAgICAvL+WmguaenOWPkeeOsOW8leaTjuWcqOmdmem7mOeKtuaAge+8jOmCo+S5iOWwseWUpOmGkuW8leaTjlxuICAgICAgICAgICBzZWxmLl9oZWFydEJlYXQgPSB0cnVlO1xuICAgICAgICAgICBzZWxmLnN0YXJ0RW50ZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgLy/lkKbliJnmmbrmhafnu6fnu63noa7orqTlv4Pot7NcbiAgICAgICAgICAgc2VsZi5faGVhcnRCZWF0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uLy4uL2NvbnN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzR3JhcGhpY3NSZW5kZXJlclxue1xuICAgXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpXG4gICAge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIFxuICAgICAvKipcbiAgICAgKiBAcGFyYW0gZGlzcGxheU9iamVjdFxuICAgICAqIEBzdGFnZSDkuZ/lj6/ku6VkaXNwbGF5T2JqZWN0LmdldFN0YWdlKCnojrflj5bjgIJcbiAgICAgKi9cbiAgICByZW5kZXIoZGlzcGxheU9iamVjdCAsIHN0YWdlKVxuICAgIHtcblxuICAgICAgICBjb25zdCBncmFwaGljcyA9IGRpc3BsYXlPYmplY3QuZ3JhcGhpY3M7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgY29uc3QgY3R4ID0gc3RhZ2UuY3R4O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gZGlzcGxheU9iamVjdC5jb250ZXh0O1xuXG4gICAgICAgIGlmKCBkaXNwbGF5T2JqZWN0LnBhcmVudCApe1xuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSAqPSBkaXNwbGF5T2JqZWN0LnBhcmVudC5jb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZ3JhcGhpY3MuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBkYXRhLnNoYXBlO1xuXG4gICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBkYXRhLmZpbGxTdHlsZTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gZGF0YS5zdHJva2VTdHlsZTtcblxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGRhdGEubGluZVdpZHRoO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuUE9MWSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvbHlnb24oc2hhcGUucG9pbnRzLCBzaGFwZS5jbG9zZWQsIGN0eCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNGaWxsKCkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzTGluZSgpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuUkVDVClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIGRhdGEuaGFzRmlsbCgpIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3Qoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc0xpbmUoKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3Qoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuQ0lSQylcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBuZWVkIHRvIGJlIFVuZGVmaW5lZCFcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhzaGFwZS54LCBzaGFwZS55LCBzaGFwZS5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNGaWxsKCkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBkYXRhLmZpbGxBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzTGluZSgpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuRUxJUClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gc2hhcGUud2lkdGggKiAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBzaGFwZS5oZWlnaHQgKiAyO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHNoYXBlLnggLSAodyAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBzaGFwZS55IC0gKGggLyAyKTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGthcHBhID0gMC41NTIyODQ4O1xuICAgICAgICAgICAgICAgIGNvbnN0IG94ID0gKHcgLyAyKSAqIGthcHBhOyAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgY29uc3Qgb3kgPSAoaCAvIDIpICoga2FwcGE7IC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgY29uc3QgeGUgPSB4ICsgdzsgICAgICAgICAgIC8vIHgtZW5kXG4gICAgICAgICAgICAgICAgY29uc3QgeWUgPSB5ICsgaDsgICAgICAgICAgIC8vIHktZW5kXG4gICAgICAgICAgICAgICAgY29uc3QgeG0gPSB4ICsgKHcgLyAyKTsgICAgICAgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICBjb25zdCB5bSA9IHkgKyAoaCAvIDIpOyAgICAgICAvLyB5LW1pZGRsZVxuXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5bSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzRmlsbCgpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc0xpbmUoKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGRhdGEubGluZUFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlclBvbHlnb24ocG9pbnRzLCBjbG9zZSwgY3R4KVxuICAgIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwb2ludHMubGVuZ3RoIC8gMjsgKytqKVxuICAgICAgICB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1tqICogMl0sIHBvaW50c1soaiAqIDIpICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb3NlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgU3lzdGVtUmVuZGVyZXIgZnJvbSAnLi4vU3lzdGVtUmVuZGVyZXInO1xuaW1wb3J0IHsgUkVOREVSRVJfVFlQRSB9IGZyb20gJy4uLy4uL2NvbnN0JztcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgQ0dSIGZyb20gXCIuLi8uLi9ncmFwaGljcy9jYW52YXMvR3JhcGhpY3NSZW5kZXJlclwiO1xuaW1wb3J0IF8gZnJvbSBcIi4uLy4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBTeXN0ZW1SZW5kZXJlclxue1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgb3B0aW9ucz17fSlcbiAgICB7XG4gICAgICAgIHN1cGVyKFJFTkRFUkVSX1RZUEUuQ0FOVkFTLCBhcHAsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLkNHUiA9IG5ldyBDR1IodGhpcyk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCBhcHAgKVxuICAgIHtcbiAgICBcdHZhciBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmFwcCA9IGFwcDtcbiAgICBcdF8uZWFjaChfLnZhbHVlcyggYXBwLmNvbnZlcnRTdGFnZXMgKSAsIGZ1bmN0aW9uKGNvbnZlcnRTdGFnZSl7XG4gICAgICAgICAgICBtZS5yZW5kZXJTdGFnZSggY29udmVydFN0YWdlLnN0YWdlICk7XG4gICAgICAgIH0pO1xuICAgICAgICBhcHAuY29udmVydFN0YWdlcyA9IHt9O1xuICAgIH1cblxuICAgIHJlbmRlclN0YWdlKCBzdGFnZSApXG4gICAge1xuICAgICAgICBpZighc3RhZ2UuY3R4KXtcbiAgICAgICAgICAgIHN0YWdlLmN0eCA9IHN0YWdlLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhZ2Uuc3RhZ2VSZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2xlYXIoIHN0YWdlICk7XG4gICAgICAgIHRoaXMuX3JlbmRlciggc3RhZ2UgKTtcbiAgICAgICAgc3RhZ2Uuc3RhZ2VSZW5kaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3JlbmRlciggc3RhZ2UgLCBkaXNwbGF5T2JqZWN0IClcbiAgICB7XG4gICAgICAgIGlmKCAhZGlzcGxheU9iamVjdCApe1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdCA9IHN0YWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCAhZGlzcGxheU9iamVjdC5jb250ZXh0LnZpc2libGUgfHwgZGlzcGxheU9iamVjdC5jb250ZXh0Lmdsb2JhbEFscGhhIDw9IDAgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3R4ID0gc3RhZ2UuY3R4O1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgdHJhbnNGb3JtID0gZGlzcGxheU9iamVjdC5fdHJhbnNmb3JtO1xuICAgICAgICBpZiggIXRyYW5zRm9ybSApIHtcbiAgICAgICAgICAgIHRyYW5zRm9ybSA9IGRpc3BsYXlPYmplY3QuX3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9O1xuICAgICAgICAvL+i/kOeUqOefqemYteW8gOWni+WPmOW9olxuICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KCBjdHggLCB0cmFuc0Zvcm0udG9BcnJheSgpICk7XG5cblxuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5ncmFwaGljcyApe1xuICAgICAgICAgICAgdGhpcy5DR1IucmVuZGVyKCBkaXNwbGF5T2JqZWN0ICwgc3RhZ2UgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5jaGlsZHJlbiApe1xuXHQgICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICBcdHRoaXMuX3JlbmRlciggc3RhZ2UgLCBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuW2ldICk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIF9jbGVhciggc3RhZ2UgKVxuICAgIHtcbiAgICAgICAgLy9UT0RPOui/memHjOacieeCuSDlpYfmgKrvvIwg5LmL5YmN55qE54mI5pysY2xlYXJSZWN055qE5pe25YCZ77yM5LiN6ZyA6KaBICpSRVNPTFVUSU9O77yI5YiG6L6o546H77yJXG4gICAgICAgIHN0YWdlLmN0eC5jbGVhclJlY3QoIDAsIDAsIHRoaXMuYXBwLndpZHRoKlNldHRpbmdzLlJFU09MVVRJT04gLCB0aGlzLmFwcC5oZWlnaHQqU2V0dGluZ3MuUkVTT0xVVElPTiApO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKiBUaGUgUG9pbnQgb2JqZWN0IHJlcHJlc2VudHMgYSBsb2NhdGlvbiBpbiBhIHR3by1kaW1lbnNpb25hbCBjb29yZGluYXRlIHN5c3RlbSwgd2hlcmUgeCByZXByZXNlbnRzXG4gKiB0aGUgaG9yaXpvbnRhbCBheGlzIGFuZCB5IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsIGF4aXMuXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludFxue1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApXG4gICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IGEgY29weSBvZiB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBjbG9uZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgeCBhbmQgeSBmcm9tIHRoZSBnaXZlbiBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNvcHkuXG4gICAgICovXG4gICAgY29weShwKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXQocC54LCBwLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGVxdWFsIHRvIHRoaXMgcG9pbnRcbiAgICAgKi9cbiAgICBlcXVhbHMocClcbiAgICB7XG4gICAgICAgIHJldHVybiAocC54ID09PSB0aGlzLngpICYmIChwLnkgPT09IHRoaXMueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgeCBhbmQgeSBwb3NpdGlvbi5cbiAgICAgKiBJZiB5IGlzIG9taXR0ZWQsIGJvdGggeCBhbmQgeSB3aWxsIGJlIHNldCB0byB4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgICAqL1xuICAgIHNldCh4LCB5KVxuICAgIHtcbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB5IHx8ICgoeSAhPT0gMCkgPyB0aGlzLnggOiAwKTtcbiAgICB9XG5cbn1cbiIsIlxudmFyIGFyY1RvU2VnbWVudHNDYWNoZSA9IHsgfSxcbiAgICBzZWdtZW50VG9CZXppZXJDYWNoZSA9IHsgfSxcbiAgICBib3VuZHNPZkN1cnZlQ2FjaGUgPSB7IH0sXG4gICAgX2pvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbjtcblxuLyogQWRhcHRlZCBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9jb250ZW50L3N2Zy9jb250ZW50L3NyYy9uc1NWR1BhdGhEYXRhUGFyc2VyLmNwcFxuICogYnkgQW5kcmVhIEJvZ2F6emkgY29kZSBpcyB1bmRlciBNUEwuIGlmIHlvdSBkb24ndCBoYXZlIGEgY29weSBvZiB0aGUgbGljZW5zZSB5b3UgY2FuIHRha2UgaXQgaGVyZVxuICogaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvXG4gKi9cbmZ1bmN0aW9uIGFyY1RvU2VnbWVudHModG9YLCB0b1ksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYKSB7XG4gIHZhciBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgcmV0dXJuIGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyaW5nXTtcbiAgfVxuXG4gIHZhciBQSSA9IE1hdGguUEksIHRoID0gcm90YXRlWCAqIFBJIC8gMTgwLFxuICAgICAgc2luVGggPSBNYXRoLnNpbih0aCksXG4gICAgICBjb3NUaCA9IE1hdGguY29zKHRoKSxcbiAgICAgIGZyb21YID0gMCwgZnJvbVkgPSAwO1xuXG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICB2YXIgcHggPSAtY29zVGggKiB0b1ggKiAwLjUgLSBzaW5UaCAqIHRvWSAqIDAuNSxcbiAgICAgIHB5ID0gLWNvc1RoICogdG9ZICogMC41ICsgc2luVGggKiB0b1ggKiAwLjUsXG4gICAgICByeDIgPSByeCAqIHJ4LCByeTIgPSByeSAqIHJ5LCBweTIgPSBweSAqIHB5LCBweDIgPSBweCAqIHB4LFxuICAgICAgcGwgPSByeDIgKiByeTIgLSByeDIgKiBweTIgLSByeTIgKiBweDIsXG4gICAgICByb290ID0gMDtcblxuICBpZiAocGwgPCAwKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHBsIC8gKHJ4MiAqIHJ5MikpO1xuICAgIHJ4ICo9IHM7XG4gICAgcnkgKj0gcztcbiAgfVxuICBlbHNlIHtcbiAgICByb290ID0gKGxhcmdlID09PSBzd2VlcCA/IC0xLjAgOiAxLjApICpcbiAgICAgICAgICAgIE1hdGguc3FydCggcGwgLyAocngyICogcHkyICsgcnkyICogcHgyKSk7XG4gIH1cblxuICB2YXIgY3ggPSByb290ICogcnggKiBweSAvIHJ5LFxuICAgICAgY3kgPSAtcm9vdCAqIHJ5ICogcHggLyByeCxcbiAgICAgIGN4MSA9IGNvc1RoICogY3ggLSBzaW5UaCAqIGN5ICsgdG9YICogMC41LFxuICAgICAgY3kxID0gc2luVGggKiBjeCArIGNvc1RoICogY3kgKyB0b1kgKiAwLjUsXG4gICAgICBtVGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoMSwgMCwgKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5KSxcbiAgICAgIGR0aGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnksICgtcHggLSBjeCkgLyByeCwgKC1weSAtIGN5KSAvIHJ5KTtcblxuICBpZiAoc3dlZXAgPT09IDAgJiYgZHRoZXRhID4gMCkge1xuICAgIGR0aGV0YSAtPSAyICogUEk7XG4gIH1cbiAgZWxzZSBpZiAoc3dlZXAgPT09IDEgJiYgZHRoZXRhIDwgMCkge1xuICAgIGR0aGV0YSArPSAyICogUEk7XG4gIH1cblxuICAvLyBDb252ZXJ0IGludG8gY3ViaWMgYmV6aWVyIHNlZ21lbnRzIDw9IDkwZGVnXG4gIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhkdGhldGEgLyBQSSAqIDIpKSxcbiAgICAgIHJlc3VsdCA9IFtdLCBtRGVsdGEgPSBkdGhldGEgLyBzZWdtZW50cyxcbiAgICAgIG1UID0gOCAvIDMgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAqIE1hdGguc2luKG1EZWx0YSAvIDQpIC8gTWF0aC5zaW4obURlbHRhIC8gMiksXG4gICAgICB0aDMgPSBtVGhldGEgKyBtRGVsdGE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gc2VnbWVudFRvQmV6aWVyKG1UaGV0YSwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpO1xuICAgIGZyb21YID0gcmVzdWx0W2ldWzRdO1xuICAgIGZyb21ZID0gcmVzdWx0W2ldWzVdO1xuICAgIG1UaGV0YSA9IHRoMztcbiAgICB0aDMgKz0gbURlbHRhO1xuICB9XG4gIGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKHRoMiwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpIHtcbiAgdmFyIGFyZ3NTdHJpbmcyID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXTtcbiAgfVxuXG4gIHZhciBjb3N0aDIgPSBNYXRoLmNvcyh0aDIpLFxuICAgICAgc2ludGgyID0gTWF0aC5zaW4odGgyKSxcbiAgICAgIGNvc3RoMyA9IE1hdGguY29zKHRoMyksXG4gICAgICBzaW50aDMgPSBNYXRoLnNpbih0aDMpLFxuICAgICAgdG9YID0gY29zVGggKiByeCAqIGNvc3RoMyAtIHNpblRoICogcnkgKiBzaW50aDMgKyBjeDEsXG4gICAgICB0b1kgPSBzaW5UaCAqIHJ4ICogY29zdGgzICsgY29zVGggKiByeSAqIHNpbnRoMyArIGN5MSxcbiAgICAgIGNwMVggPSBmcm9tWCArIG1UICogKCAtY29zVGggKiByeCAqIHNpbnRoMiAtIHNpblRoICogcnkgKiBjb3N0aDIpLFxuICAgICAgY3AxWSA9IGZyb21ZICsgbVQgKiAoIC1zaW5UaCAqIHJ4ICogc2ludGgyICsgY29zVGggKiByeSAqIGNvc3RoMiksXG4gICAgICBjcDJYID0gdG9YICsgbVQgKiAoIGNvc1RoICogcnggKiBzaW50aDMgKyBzaW5UaCAqIHJ5ICogY29zdGgzKSxcbiAgICAgIGNwMlkgPSB0b1kgKyBtVCAqICggc2luVGggKiByeCAqIHNpbnRoMyAtIGNvc1RoICogcnkgKiBjb3N0aDMpO1xuXG4gIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXSA9IFtcbiAgICBjcDFYLCBjcDFZLFxuICAgIGNwMlgsIGNwMlksXG4gICAgdG9YLCB0b1lcbiAgXTtcbiAgcmV0dXJuIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJpbmcyXTtcbn1cblxuLypcbiAqIFByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsY1ZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gIHZhciB0YSA9IE1hdGguYXRhbjIodXksIHV4KSxcbiAgICAgIHRiID0gTWF0aC5hdGFuMih2eSwgdngpO1xuICBpZiAodGIgPj0gdGEpIHtcbiAgICByZXR1cm4gdGIgLSB0YTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gMiAqIE1hdGguUEkgLSAodGEgLSB0Yik7XG4gIH1cbn1cblxuLyoqXG4gKiBEcmF3cyBhcmNcbiAqIEBwYXJhbSB7Z3JhcGhpY3N9IGdyYXBoaWNzXG4gKiBAcGFyYW0ge051bWJlcn0gZnhcbiAqIEBwYXJhbSB7TnVtYmVyfSBmeVxuICogQHBhcmFtIHtBcnJheX0gY29vcmRzXG4gKi9cbnZhciBkcmF3QXJjID0gZnVuY3Rpb24oZ3JhcGhpY3MgLCBmeCwgZnksIGNvb3Jkcykge1xuICB2YXIgcnggPSBjb29yZHNbMF0sXG4gICAgICByeSA9IGNvb3Jkc1sxXSxcbiAgICAgIHJvdCA9IGNvb3Jkc1syXSxcbiAgICAgIGxhcmdlID0gY29vcmRzWzNdLFxuICAgICAgc3dlZXAgPSBjb29yZHNbNF0sXG4gICAgICB0eCA9IGNvb3Jkc1s1XSxcbiAgICAgIHR5ID0gY29vcmRzWzZdLFxuICAgICAgc2VncyA9IFtbXSwgW10sIFtdLCBbXV0sXG4gICAgICBzZWdzTm9ybSA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ3NOb3JtLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2Vnc1tpXVswXSA9IHNlZ3NOb3JtW2ldWzBdICsgZng7XG4gICAgc2Vnc1tpXVsxXSA9IHNlZ3NOb3JtW2ldWzFdICsgZnk7XG4gICAgc2Vnc1tpXVsyXSA9IHNlZ3NOb3JtW2ldWzJdICsgZng7XG4gICAgc2Vnc1tpXVszXSA9IHNlZ3NOb3JtW2ldWzNdICsgZnk7XG4gICAgc2Vnc1tpXVs0XSA9IHNlZ3NOb3JtW2ldWzRdICsgZng7XG4gICAgc2Vnc1tpXVs1XSA9IHNlZ3NOb3JtW2ldWzVdICsgZnk7XG4gICAgZ3JhcGhpY3MuYmV6aWVyQ3VydmVUby5hcHBseShncmFwaGljcywgc2Vnc1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhIGVsbGlwdGljLWFyY1xuICogQHBhcmFtIHtOdW1iZXJ9IGZ4IHN0YXJ0IHBvaW50IG9mIGFyY1xuICogQHBhcmFtIHtOdW1iZXJ9IGZ5XG4gKiBAcGFyYW0ge051bWJlcn0gcnggaG9yaXpvbnRhbCByYWRpdXNcbiAqIEBwYXJhbSB7TnVtYmVyfSByeSB2ZXJ0aWNhbCByYWRpdXNcbiAqIEBwYXJhbSB7TnVtYmVyfSByb3QgYW5nbGUgb2YgaG9yaXpvbnRhbCBheGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsYXJnZSAxIG9yIDAsIHdoYXRldmVyIHRoZSBhcmMgaXMgdGhlIGJpZyBvciB0aGUgc21hbGwgb24gdGhlIDIgcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gc3dlZXAgMSBvciAwLCAxIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IGVuZCBwb2ludCBvZiBhcmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eVxuICovXG52YXIgZ2V0Qm91bmRzT2ZBcmMgPSBmdW5jdGlvbihmeCwgZnksIHJ4LCByeSwgcm90LCBsYXJnZSwgc3dlZXAsIHR4LCB0eSkge1xuXG4gIHZhciBmcm9tWCA9IDAsIGZyb21ZID0gMCwgYm91bmQsIGJvdW5kcyA9IFtdLFxuICAgICAgc2VncyA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBib3VuZCA9IGdldEJvdW5kc09mQ3VydmUoZnJvbVgsIGZyb21ZLCBzZWdzW2ldWzBdLCBzZWdzW2ldWzFdLCBzZWdzW2ldWzJdLCBzZWdzW2ldWzNdLCBzZWdzW2ldWzRdLCBzZWdzW2ldWzVdKTtcbiAgICBib3VuZHMucHVzaCh7IHg6IGJvdW5kWzBdLnggKyBmeCwgeTogYm91bmRbMF0ueSArIGZ5IH0pO1xuICAgIGJvdW5kcy5wdXNoKHsgeDogYm91bmRbMV0ueCArIGZ4LCB5OiBib3VuZFsxXS55ICsgZnkgfSk7XG4gICAgZnJvbVggPSBzZWdzW2ldWzRdO1xuICAgIGZyb21ZID0gc2Vnc1tpXVs1XTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgYmV6aWVyY3VydmVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MCBzdGFydGluZyBwb2ludFxuICogQHBhcmFtIHtOdW1iZXJ9IHkwXG4gKiBAcGFyYW0ge051bWJlcn0geDEgZmlyc3QgY29udHJvbCBwb2ludFxuICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gKiBAcGFyYW0ge051bWJlcn0geDIgc2Vjb25kbyBjb250cm9sIHBvaW50XG4gKiBAcGFyYW0ge051bWJlcn0geTJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MyBlbmQgb2YgYmVpemVyXG4gKiBAcGFyYW0ge051bWJlcn0geTNcbiAqL1xuLy8gdGFrZW4gZnJvbSBodHRwOi8vanNiaW4uY29tL2l2b21pcS81Ni9lZGl0ICBubyBjcmVkaXRzIGF2YWlsYWJsZSBmb3IgdGhhdC5cbmZ1bmN0aW9uIGdldEJvdW5kc09mQ3VydmUoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgcmV0dXJuIGJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXTtcbiAgfVxuXG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgYWJzID0gTWF0aC5hYnMsIHR2YWx1ZXMgPSBbXSxcbiAgICAgIGJvdW5kcyA9IFtbXSwgW11dLFxuICAgICAgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcblxuICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gIGMgPSAzICogeDEgLSAzICogeDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgIH1cblxuICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdCA9IC1jIC8gYjtcbiAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNxcnRiMmFjID0gc3FydChiMmFjKTtcbiAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgfVxuICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLCBqbGVuID0gaiwgbXQ7XG4gIHdoaWxlIChqLS0pIHtcbiAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICBtdCA9IDEgLSB0O1xuICAgIHggPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgYm91bmRzWzBdW2pdID0geDtcblxuICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgYm91bmRzWzFdW2pdID0geTtcbiAgfVxuXG4gIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gIHZhciByZXN1bHQgPSBbXG4gICAge1xuICAgICAgeDogbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICB5OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgIH0sXG4gICAge1xuICAgICAgeDogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICB5OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgIH1cbiAgXTtcbiAgYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3QXJjOiBkcmF3QXJjLFxuICAgIGdldEJvdW5kc09mQ3VydmU6IGdldEJvdW5kc09mQ3VydmUsXG4gICAgZ2V0Qm91bmRzT2ZBcmM6IGdldEJvdW5kc09mQXJjXG59XG5cbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uLy4uL2NvbnN0JztcblxuLyoqXG4gKiBSZWN0YW5nbGUgb2JqZWN0IGlzIGFuIGFyZWEgZGVmaW5lZCBieSBpdHMgcG9zaXRpb24sIGFzIGluZGljYXRlZCBieSBpdHMgdG9wLWxlZnQgY29ybmVyXG4gKiBwb2ludCAoeCwgeSkgYW5kIGJ5IGl0cyB3aWR0aCBhbmQgaXRzIGhlaWdodC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3RhbmdsZVxue1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFRoZSBvdmVyYWxsIHdpZHRoIG9mIHRoaXMgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MF0gLSBUaGUgb3ZlcmFsbCBoZWlnaHQgb2YgdGhpcyByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMClcbiAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IHg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuUkVDVFxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBTSEFQRVMuUkVDVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZWZ0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdG9wKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBib3R0b20oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgY29uc3RhbnQgZW1wdHkgcmVjdGFuZ2xlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRU1QVFkoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gYSBjb3B5IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBjbG9uZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBhbm90aGVyIHJlY3RhbmdsZSB0byB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgY29weShyZWN0YW5nbGUpXG4gICAge1xuICAgICAgICB0aGlzLnggPSByZWN0YW5nbGUueDtcbiAgICAgICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgICAgIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcbiAgICAgKi9cbiAgICBjb250YWlucyh4LCB5KVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA+PSB0aGlzLnggJiYgeCA8IHRoaXMueCArIHRoaXMud2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdZIC0gVGhlIHZlcnRpY2FsIHBhZGRpbmcgYW1vdW50LlxuICAgICAqL1xuICAgIHBhZChwYWRkaW5nWCwgcGFkZGluZ1kpXG4gICAge1xuICAgICAgICBwYWRkaW5nWCA9IHBhZGRpbmdYIHx8IDA7XG4gICAgICAgIHBhZGRpbmdZID0gcGFkZGluZ1kgfHwgKChwYWRkaW5nWSAhPT0gMCkgPyBwYWRkaW5nWCA6IDApO1xuXG4gICAgICAgIHRoaXMueCAtPSBwYWRkaW5nWDtcbiAgICAgICAgdGhpcy55IC09IHBhZGRpbmdZO1xuXG4gICAgICAgIHRoaXMud2lkdGggKz0gcGFkZGluZ1ggKiAyO1xuICAgICAgICB0aGlzLmhlaWdodCArPSBwYWRkaW5nWSAqIDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRml0cyB0aGlzIHJlY3RhbmdsZSBhcm91bmQgdGhlIHBhc3NlZCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGZpdC5cbiAgICAgKi9cbiAgICBmaXQocmVjdGFuZ2xlKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMueCA8IHJlY3RhbmdsZS54KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLndpZHRoICs9IHRoaXMueDtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoIDwgMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy55IDwgcmVjdGFuZ2xlLnkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ICs9IHRoaXMueTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy54ICsgdGhpcy53aWR0aCA+IHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gcmVjdGFuZ2xlLndpZHRoIC0gdGhpcy54O1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPCAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueSArIHRoaXMuaGVpZ2h0ID4gcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQgLSB0aGlzLnk7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPCAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVubGFyZ2VzIHRoaXMgcmVjdGFuZ2xlIHRvIGluY2x1ZGUgdGhlIHBhc3NlZCByZWN0YW5nbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGluY2x1ZGUuXG4gICAgICovXG4gICAgZW5sYXJnZShyZWN0YW5nbGUpXG4gICAge1xuICAgICAgICBjb25zdCB4MSA9IE1hdGgubWluKHRoaXMueCwgcmVjdGFuZ2xlLngpO1xuICAgICAgICBjb25zdCB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICAgICAgY29uc3QgeTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3RhbmdsZS55KTtcbiAgICAgICAgY29uc3QgeTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLnggPSB4MTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHgyIC0geDE7XG4gICAgICAgIHRoaXMueSA9IHkxO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHkyIC0geTE7XG4gICAgfVxufVxuIiwiaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuL1JlY3RhbmdsZSc7XG5pbXBvcnQgeyBTSEFQRVMgfSBmcm9tICcuLi8uLi9jb25zdCc7XG5cbi8qKlxuICogVGhlIENpcmNsZSBvYmplY3QgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGhpdCBhcmVhIGZvciBkaXNwbGF5T2JqZWN0c1xuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY2xlXG57XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXM9MF0gLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHJhZGl1cyA9IDApXG4gICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuQ0lSQ1xuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBTSEFQRVMuQ0lSQztcblxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkNpcmNsZX0gYSBjb3B5IG9mIHRoZSBDaXJjbGVcbiAgICAgKi9cbiAgICBjbG9uZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgY2lyY2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIENpcmNsZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5yYWRpdXMgPD0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgICAgICBsZXQgZHggPSAodGhpcy54IC0geCk7XG4gICAgICAgIGxldCBkeSA9ICh0aGlzLnkgLSB5KTtcblxuICAgICAgICBkeCAqPSBkeDtcbiAgICAgICAgZHkgKj0gZHk7XG5cbiAgICAgICAgcmV0dXJuIChkeCArIGR5IDw9IHIyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBjaXJjbGUgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAgKlxuICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgICovXG4gICAgZ2V0Qm91bmRzKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICAgIH1cbn1cbiIsImltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi9SZWN0YW5nbGUnO1xuaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnLi4vLi4vY29uc3QnO1xuXG4vKipcbiAqIFRoZSBFbGxpcHNlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGxpcHNlXG57XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoaXMgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFRoZSBoYWxmIHdpZHRoIG9mIHRoaXMgZWxsaXBzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTBdIC0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoaXMgZWxsaXBzZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKVxuICAgIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5FTElQXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFNIQVBFUy5FTElQO1xuXG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkVsbGlwc2V9IGEgY29weSBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGNsb25lKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwXG4gICAgICAgIGxldCBub3JteCA9ICgoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoKTtcbiAgICAgICAgbGV0IG5vcm15ID0gKCh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICBub3JteCAqPSBub3JteDtcbiAgICAgICAgbm9ybXkgKj0gbm9ybXk7XG5cbiAgICAgICAgcmV0dXJuIChub3JteCArIG5vcm15IDw9IDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGdldEJvdW5kcygpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLndpZHRoLCB0aGlzLnkgLSB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbn1cbiIsImltcG9ydCBQb2ludCBmcm9tICcuLi9Qb2ludCc7XG5pbXBvcnQgeyBTSEFQRVMgfSBmcm9tICcuLi8uLi9jb25zdCc7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uXG57XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50W118bnVtYmVyW119IHBvaW50cyAtIFRoaXMgY2FuIGJlIGFuIGFycmF5IG9mIFBvaW50c1xuICAgICAqICB0aGF0IGZvcm0gdGhlIHBvbHlnb24sIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzIHRoYXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBbeCx5LCB4LHksIC4uLl0sIG9yXG4gICAgICogIHRoZSBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBhbGwgdGhlIHBvaW50cyBvZiB0aGUgcG9seWdvbiBlLmcuXG4gICAgICogIGBuZXcgUElYSS5Qb2x5Z29uKG5ldyBQSVhJLlBvaW50KCksIG5ldyBQSVhJLlBvaW50KCksIC4uLilgLCBvciB0aGUgYXJndW1lbnRzIHBhc3NlZCBjYW4gYmUgZmxhdFxuICAgICAqICB4LHkgdmFsdWVzIGUuZy4gYG5ldyBQb2x5Z29uKHgseSwgeCx5LCB4LHksIC4uLilgIHdoZXJlIGB4YCBhbmQgYHlgIGFyZSBOdW1iZXJzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLnBvaW50cylcbiAgICB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvaW50c1swXSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50c1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gYXJyYXkgb2YgcG9pbnRzLCBjb252ZXJ0IGl0IHRvIGEgZmxhdCBhcnJheSBvZiBudW1iZXJzXG4gICAgICAgIGlmIChwb2ludHNbMF0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwLnB1c2gocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9pbnRzID0gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgdGhlIHBvaW50cyBvZiB0aGlzIHBvbHlnb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5QT0xZXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFNIQVBFUy5QT0xZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9seWdvbn0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXG4gICAgICovXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uKHRoaXMucG9pbnRzLnNsaWNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgcG9seWdvbiwgYWRkaW5nIHBvaW50cyBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgaWYgKHBvaW50c1swXSAhPT0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSB8fCBwb2ludHNbMV0gIT09IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29udGFpbnMoeCwgeSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luc2lkZVBvbHlnb25fV2luZGluZ051bWJlcih4LHkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICog5aSa6L655b2i5YyF5ZCr5Yik5patIE5vbnplcm8gV2luZGluZyBOdW1iZXIgUnVsZVxuICAgICAqL1xuICAgIF9pc0luc2lkZVBvbHlnb25fV2luZGluZ051bWJlcih4LCB5KSBcbiAgICB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHduID0gMDtcbiAgICAgICAgZm9yICh2YXIgc2hpZnRQLCBzaGlmdCA9IHBvaW50c1sxXSA+IHksIGkgPSAzOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBzaGlmdFAgPSBzaGlmdDtcbiAgICAgICAgICAgIHNoaWZ0ID0gcG9pbnRzW2ldID4geTtcbiAgICAgICAgICAgIGlmIChzaGlmdFAgIT0gc2hpZnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IChzaGlmdFAgPyAxIDogMCkgLSAoc2hpZnQgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gKiAoKHBvaW50c1tpIC0gM10gLSB4KSAqIChwb2ludHNbaSAtIDBdIC0geSkgLSAocG9pbnRzW2kgLSAyXSAtIHkpICogKHBvaW50c1tpIC0gMV0gLSB4KSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHduICs9IG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHduXG4gICAgfVxufVxuIiwiLyoqXG4gKiBNYXRoIGNsYXNzZXMgYW5kIHV0aWxpdGllcyBtaXhlZCBpbnRvIFBJWEkgbmFtZXNwYWNlLlxuICpcbiAqIEBsZW5kcyBQSVhJXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9pbnQgfSBmcm9tICcuL1BvaW50JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXJjIH0gZnJvbSAnLi9BcmMnO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIENpcmNsZSB9IGZyb20gJy4vc2hhcGVzL0NpcmNsZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsbGlwc2UgfSBmcm9tICcuL3NoYXBlcy9FbGxpcHNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seWdvbiB9IGZyb20gJy4vc2hhcGVzL1BvbHlnb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWN0YW5nbGUgfSBmcm9tICcuL3NoYXBlcy9SZWN0YW5nbGUnO1xuXG5cbiIsIlxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgd2ViR0wgQ29udGV4dFxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgd2Ugd2lsbCBnZXQgdGhlIGNvbnRleHQgZnJvbVxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBnZXRzIHBhc3NlZCBpbiB0byB0aGUgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udGV4dCBhdHRyaWJ1dGVzLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0IGZvciB0aGUgb3B0aW9ucyBhdmFpbGFibGVcbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIFdlYkdMIGNvbnRleHRcbiAqL1xudmFyIGNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbihjYW52YXMsIG9wdGlvbnMpXG57XG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0aW9ucykgfHwgXG4gICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWdsKVxuICAgIHtcbiAgICAgICAgLy8gZmFpbCwgbm90IGFibGUgdG8gZ2V0IGEgY29udGV4dFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xuICAgIH1cblxuICAgIHJldHVybiBnbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ29udGV4dDtcbiIsIi8vIHZhciBHTF9NQVAgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dFxuICogQHBhcmFtIGF0dHJpYnMgeyp9XG4gKiBAcGFyYW0gc3RhdGUgeyp9XG4gKi9cbnZhciBzZXRWZXJ0ZXhBdHRyaWJBcnJheXMgPSBmdW5jdGlvbiAoZ2wsIGF0dHJpYnMsIHN0YXRlKVxue1xuICAgIHZhciBpO1xuICAgIGlmKHN0YXRlKVxuICAgIHtcbiAgICAgICAgdmFyIHRlbXBBdHRyaWJTdGF0ZSA9IHN0YXRlLnRlbXBBdHRyaWJTdGF0ZSxcbiAgICAgICAgICAgIGF0dHJpYlN0YXRlID0gc3RhdGUuYXR0cmliU3RhdGU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXBBdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGVtcEF0dHJpYlN0YXRlW2ldID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIG5ldyBhdHRyaWJzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZW1wQXR0cmliU3RhdGVbYXR0cmlic1tpXS5hdHRyaWJ1dGUubG9jYXRpb25dID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGF0dHJpYlN0YXRlW2ldICE9PSB0ZW1wQXR0cmliU3RhdGVbaV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXR0cmliU3RhdGVbaV0gPSB0ZW1wQXR0cmliU3RhdGVbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXR0cmliU3RhdGVbaV0pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYXR0cmliID0gYXR0cmlic1tpXTtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYi5hdHRyaWJ1dGUubG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRWZXJ0ZXhBdHRyaWJBcnJheXM7XG4iLCJ2YXIgRU1QVFlfQVJSQVlfQlVGRkVSID0gbmV3IEFycmF5QnVmZmVyKDApO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSB3ZWJHTCBidWZmZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gdHlwZSB7Z2wuQVJSQVlfQlVGRkVSIHwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJ9IEBtYXRcbiAqIEBwYXJhbSBkYXRhIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhbiBhcnJheSBvZiBkYXRhXG4gKiBAcGFyYW0gZHJhd1R5cGUge2dsLlNUQVRJQ19EUkFXfGdsLkRZTkFNSUNfRFJBV3xnbC5TVFJFQU1fRFJBV31cbiAqL1xudmFyIEJ1ZmZlciA9IGZ1bmN0aW9uKGdsLCB0eXBlLCBkYXRhLCBkcmF3VHlwZSlcbntcblxuXHQvKipcbiAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuXHR0aGlzLmdsID0gZ2w7XG5cblx0LyoqXG4gICAgICogVGhlIFdlYkdMIGJ1ZmZlciwgY3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb25cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMQnVmZmVyfVxuICAgICAqL1xuXHR0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2dsLkFSUkFZX0JVRkZFUnxnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUn1cbiAgICAgKi9cblx0dGhpcy50eXBlID0gdHlwZSB8fCBnbC5BUlJBWV9CVUZGRVI7XG5cblx0LyoqXG4gICAgICogVGhlIGRyYXcgdHlwZSBvZiB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtnbC5TVEFUSUNfRFJBV3xnbC5EWU5BTUlDX0RSQVd8Z2wuU1RSRUFNX0RSQVd9XG4gICAgICovXG5cdHRoaXMuZHJhd1R5cGUgPSBkcmF3VHlwZSB8fCBnbC5TVEFUSUNfRFJBVztcblxuXHQvKipcbiAgICAgKiBUaGUgZGF0YSBpbiB0aGUgYnVmZmVyLCBhcyBhIHR5cGVkIGFycmF5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fVxuICAgICAqL1xuXHR0aGlzLmRhdGEgPSBFTVBUWV9BUlJBWV9CVUZGRVI7XG5cblx0aWYoZGF0YSlcblx0e1xuXHRcdHRoaXMudXBsb2FkKGRhdGEpO1xuXHR9XG5cblx0dGhpcy5fdXBkYXRlSUQgPSAwO1xufTtcblxuLyoqXG4gKiBVcGxvYWRzIHRoZSBidWZmZXIgdG8gdGhlIEdQVVxuICogQHBhcmFtIGRhdGEge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGFuIGFycmF5IG9mIGRhdGEgdG8gdXBsb2FkXG4gKiBAcGFyYW0gb2Zmc2V0IHtOdW1iZXJ9IGlmIG9ubHkgYSBzdWJzZXQgb2YgdGhlIGRhdGEgc2hvdWxkIGJlIHVwbG9hZGVkLCB0aGlzIGlzIHRoZSBhbW91bnQgb2YgZGF0YSB0byBzdWJ0cmFjdFxuICogQHBhcmFtIGRvbnRCaW5kIHtCb29sZWFufSB3aGV0aGVyIHRvIGJpbmQgdGhlIGJ1ZmZlciBiZWZvcmUgdXBsb2FkaW5nIGl0XG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBkb250QmluZClcbntcblx0Ly8gdG9kbyAtIG5lZWRlZD9cblx0aWYoIWRvbnRCaW5kKSB0aGlzLmJpbmQoKTtcblxuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdGRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YTtcblx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cblx0aWYodGhpcy5kYXRhLmJ5dGVMZW5ndGggPj0gZGF0YS5ieXRlTGVuZ3RoKVxuXHR7XG5cdFx0Z2wuYnVmZmVyU3ViRGF0YSh0aGlzLnR5cGUsIG9mZnNldCwgZGF0YSk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0Z2wuYnVmZmVyRGF0YSh0aGlzLnR5cGUsIGRhdGEsIHRoaXMuZHJhd1R5cGUpO1xuXHR9XG5cblx0dGhpcy5kYXRhID0gZGF0YTtcbn07XG4vKipcbiAqIEJpbmRzIHRoZSBidWZmZXJcbiAqXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblx0Z2wuYmluZEJ1ZmZlcih0aGlzLnR5cGUsIHRoaXMuYnVmZmVyKTtcbn07XG5cbkJ1ZmZlci5jcmVhdGVWZXJ0ZXhCdWZmZXIgPSBmdW5jdGlvbihnbCwgZGF0YSwgZHJhd1R5cGUpXG57XG5cdHJldHVybiBuZXcgQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGRyYXdUeXBlKTtcbn07XG5cbkJ1ZmZlci5jcmVhdGVJbmRleEJ1ZmZlciA9IGZ1bmN0aW9uKGdsLCBkYXRhLCBkcmF3VHlwZSlcbntcblx0cmV0dXJuIG5ldyBCdWZmZXIoZ2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCBkcmF3VHlwZSk7XG59O1xuXG5CdWZmZXIuY3JlYXRlID0gZnVuY3Rpb24oZ2wsIHR5cGUsIGRhdGEsIGRyYXdUeXBlKVxue1xuXHRyZXR1cm4gbmV3IEJ1ZmZlcihnbCwgdHlwZSwgZGF0YSwgZHJhd1R5cGUpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgYnVmZmVyXG4gKlxuICovXG5CdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuXHR0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcjtcbiIsIlxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgV2ViR0wgVGV4dHVyZVxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dFxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gZm9ybWF0IHtudW1iZXJ9IHRoZSBwaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIGRlZmF1bHRzIHRvIGdsLlJHQkFcbiAqIEBwYXJhbSB0eXBlIHtudW1iZXJ9IHRoZSBnbCB0eXBlIG9mIHRoZSB0ZXh0dXJlLiBkZWZhdWx0cyB0byBnbC5VTlNJR05FRF9CWVRFXG4gKi9cbnZhciBUZXh0dXJlID0gZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSlcbntcblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqXG5cdCAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cblx0ICovXG5cdHRoaXMuZ2wgPSBnbDtcblxuXG5cdC8qKlxuXHQgKiBUaGUgV2ViR0wgdGV4dHVyZVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtXZWJHTFRleHR1cmV9XG5cdCAqL1xuXHR0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0LyoqXG5cdCAqIElmIG1pcG1hcHBpbmcgd2FzIHVzZWQgZm9yIHRoaXMgdGV4dHVyZSwgZW5hYmxlIGFuZCBkaXNhYmxlIHdpdGggZW5hYmxlTWlwbWFwKClcblx0ICpcblx0ICogQG1lbWJlciB7Qm9vbGVhbn1cblx0ICovXG5cdC8vIHNvbWUgc2V0dGluZ3MuLlxuXHR0aGlzLm1pcG1hcCA9IGZhbHNlO1xuXG5cblx0LyoqXG5cdCAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBwcmUtbXVsdGlwbGllZCBhbHBoYVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtCb29sZWFufVxuXHQgKi9cblx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSB3aWR0aCBvZiB0ZXh0dXJlXG5cdCAqXG5cdCAqIEBtZW1iZXIge051bWJlcn1cblx0ICovXG5cdHRoaXMud2lkdGggPSB3aWR0aCB8fCAtMTtcblx0LyoqXG5cdCAqIFRoZSBoZWlnaHQgb2YgdGV4dHVyZVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtOdW1iZXJ9XG5cdCAqL1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAtMTtcblxuXHQvKipcblx0ICogVGhlIHBpeGVsIGZvcm1hdCBvZiB0aGUgdGV4dHVyZS4gZGVmYXVsdHMgdG8gZ2wuUkdCQVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtOdW1iZXJ9XG5cdCAqL1xuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdCB8fCBnbC5SR0JBO1xuXG5cdC8qKlxuXHQgKiBUaGUgZ2wgdHlwZSBvZiB0aGUgdGV4dHVyZS4gZGVmYXVsdHMgdG8gZ2wuVU5TSUdORURfQllURVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtOdW1iZXJ9XG5cdCAqL1xuXHR0aGlzLnR5cGUgPSB0eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG5cblxufTtcblxuLyoqXG4gKiBVcGxvYWRzIHRoaXMgdGV4dHVyZSB0byB0aGUgR1BVXG4gKiBAcGFyYW0gc291cmNlIHtIVE1MSW1hZ2VFbGVtZW50fEltYWdlRGF0YXxIVE1MVmlkZW9FbGVtZW50fSB0aGUgc291cmNlIGltYWdlIG9mIHRoZSB0ZXh0dXJlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uKHNvdXJjZSlcbntcblx0dGhpcy5iaW5kKCk7XG5cblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXG5cdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVtdWx0aXBseUFscGhhKTtcblxuXHR2YXIgbmV3V2lkdGggPSBzb3VyY2UudmlkZW9XaWR0aCB8fCBzb3VyY2Uud2lkdGg7XG5cdHZhciBuZXdIZWlnaHQgPSBzb3VyY2UudmlkZW9IZWlnaHQgfHwgc291cmNlLmhlaWdodDtcblxuXHRpZihuZXdIZWlnaHQgIT09IHRoaXMuaGVpZ2h0IHx8IG5ld1dpZHRoICE9PSB0aGlzLndpZHRoKVxuXHR7XG5cdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgc291cmNlKTtcblx0fVxuXHRlbHNlXG5cdHtcbiAgICBcdGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgc291cmNlKTtcblx0fVxuXG5cdC8vIGlmIHRoZSBzb3VyY2UgaXMgYSB2aWRlbywgd2UgbmVlZCB0byB1c2UgdGhlIHZpZGVvV2lkdGggLyB2aWRlb0hlaWdodCBwcm9wZXJ0aWVzIGFzIHdpZHRoIC8gaGVpZ2h0IHdpbGwgYmUgaW5jb3JyZWN0LlxuXHR0aGlzLndpZHRoID0gbmV3V2lkdGg7XG5cdHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXG59O1xuXG52YXIgRkxPQVRJTkdfUE9JTlRfQVZBSUxBQkxFID0gZmFsc2U7XG5cbi8qKlxuICogVXNlIGEgZGF0YSBzb3VyY2UgYW5kIHVwbG9hZHMgdGhpcyB0ZXh0dXJlIHRvIHRoZSBHUFVcbiAqIEBwYXJhbSBkYXRhIHtUeXBlZEFycmF5fSB0aGUgZGF0YSB0byB1cGxvYWQgdG8gdGhlIHRleHR1cmVcbiAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnVwbG9hZERhdGEgPSBmdW5jdGlvbihkYXRhLCB3aWR0aCwgaGVpZ2h0KVxue1xuXHR0aGlzLmJpbmQoKTtcblxuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cblx0aWYoZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcblx0e1xuXHRcdGlmKCFGTE9BVElOR19QT0lOVF9BVkFJTEFCTEUpXG5cdFx0e1xuXHRcdFx0dmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0XCIpO1xuXG5cdFx0XHRpZihleHQpXG5cdFx0XHR7XG5cdFx0XHRcdEZMT0FUSU5HX1BPSU5UX0FWQUlMQUJMRSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignZmxvYXRpbmcgcG9pbnQgdGV4dHVyZXMgbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHlwZSA9IGdsLkZMT0FUO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdC8vIFRPRE8gc3VwcG9ydCBmb3Igb3RoZXIgdHlwZXNcblx0XHR0aGlzLnR5cGUgPSB0aGlzLnR5cGUgfHwgZ2wuVU5TSUdORURfQllURTtcblx0fVxuXG5cdC8vIHdoYXQgdHlwZSBvZiBkYXRhP1xuXHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMucHJlbXVsdGlwbHlBbHBoYSk7XG5cblxuXHRpZih3aWR0aCAhPT0gdGhpcy53aWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuaGVpZ2h0KVxuXHR7XG5cdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgIHdpZHRoLCBoZWlnaHQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGRhdGEgfHwgbnVsbCk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0Z2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBkYXRhIHx8IG51bGwpO1xuXHR9XG5cblx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXG4vL1x0dGV4U3ViSW1hZ2UyRFxufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgdGV4dHVyZVxuICogQHBhcmFtICBsb2NhdGlvblxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24obG9jYXRpb24pXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0aWYobG9jYXRpb24gIT09IHVuZGVmaW5lZClcblx0e1xuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBsb2NhdGlvbik7XG5cdH1cblxuXHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xufTtcblxuLyoqXG4gKiBVbmJpbmRzIHRoZSB0ZXh0dXJlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBsaW5lYXIge0Jvb2xlYW59IGlmIHdlIHdhbnQgdG8gdXNlIGxpbmVhciBmaWx0ZXJpbmcgb3IgbmVhcmVzdCBuZWlnaGJvdXIgaW50ZXJwb2xhdGlvblxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5taW5GaWx0ZXIgPSBmdW5jdGlvbiggbGluZWFyIClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHRpZih0aGlzLm1pcG1hcClcblx0e1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBsaW5lYXIgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBsaW5lYXIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcblx0fVxufTtcblxuLyoqXG4gKiBAcGFyYW0gbGluZWFyIHtCb29sZWFufSBpZiB3ZSB3YW50IHRvIHVzZSBsaW5lYXIgZmlsdGVyaW5nIG9yIG5lYXJlc3QgbmVpZ2hib3VyIGludGVycG9sYXRpb25cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUubWFnRmlsdGVyID0gZnVuY3Rpb24oIGxpbmVhciApXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGxpbmVhciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG1pcG1hcHBpbmdcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuZW5hYmxlTWlwbWFwID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdHRoaXMubWlwbWFwID0gdHJ1ZTtcblxuXHRnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbn07XG5cbi8qKlxuICogRW5hYmxlcyBsaW5lYXIgZmlsdGVyaW5nXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZUxpbmVhclNjYWxpbmcgPSBmdW5jdGlvbigpXG57XG5cdHRoaXMubWluRmlsdGVyKHRydWUpO1xuXHR0aGlzLm1hZ0ZpbHRlcih0cnVlKTtcbn07XG5cbi8qKlxuICogRW5hYmxlcyBuZWFyZXN0IG5laWdoYm91ciBpbnRlcnBvbGF0aW9uXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZU5lYXJlc3RTY2FsaW5nID0gZnVuY3Rpb24oKVxue1xuXHR0aGlzLm1pbkZpbHRlcihmYWxzZSk7XG5cdHRoaXMubWFnRmlsdGVyKGZhbHNlKTtcbn07XG5cbi8qKlxuICogRW5hYmxlcyBjbGFtcGluZyBvbiB0aGUgdGV4dHVyZSBzbyBXZWJHTCB3aWxsIG5vdCByZXBlYXQgaXRcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuZW5hYmxlV3JhcENsYW1wID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdGlsaW5nIG9uIHRoZSB0ZXh0dXJlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmVuYWJsZVdyYXBSZXBlYXQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5SRVBFQVQpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuZW5hYmxlV3JhcE1pcnJvclJlcGVhdCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5NSVJST1JFRF9SRVBFQVQpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLk1JUlJPUkVEX1JFUEVBVCk7XG59O1xuXG5cbi8qKlxuICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cdC8vVE9ET1xuXHRnbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0XG4gKiBAcGFyYW0gc291cmNlIHtIVE1MSW1hZ2VFbGVtZW50fEltYWdlRGF0YX0gdGhlIHNvdXJjZSBpbWFnZSBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIHByZW11bHRpcGx5QWxwaGEge0Jvb2xlYW59IElmIHdlIHdhbnQgdG8gdXNlIHByZS1tdWx0aXBsaWVkIGFscGhhXG4gKi9cblRleHR1cmUuZnJvbVNvdXJjZSA9IGZ1bmN0aW9uKGdsLCBzb3VyY2UsIHByZW11bHRpcGx5QWxwaGEpXG57XG5cdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoZ2wpO1xuXHR0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSBwcmVtdWx0aXBseUFscGhhIHx8IGZhbHNlO1xuXHR0ZXh0dXJlLnVwbG9hZChzb3VyY2UpO1xuXG5cdHJldHVybiB0ZXh0dXJlO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dFxuICogQHBhcmFtIGRhdGEge1R5cGVkQXJyYXl9IHRoZSBkYXRhIHRvIHVwbG9hZCB0byB0aGUgdGV4dHVyZVxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAqL1xuVGV4dHVyZS5mcm9tRGF0YSA9IGZ1bmN0aW9uKGdsLCBkYXRhLCB3aWR0aCwgaGVpZ2h0KVxue1xuXHQvL2NvbnNvbGUubG9nKGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuXHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsKTtcblx0dGV4dHVyZS51cGxvYWREYXRhKGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuXG5cdHJldHVybiB0ZXh0dXJlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmU7XG4iLCJcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9HTFRleHR1cmUnKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgd2ViR0wgRnJhbWVidWZmZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICovXG52YXIgRnJhbWVidWZmZXIgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodClcbntcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMRnJhbWVidWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RlbmNpbCBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyYnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RlbmNpbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RlbmNpbCBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuZ2xDb3JlLkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxMDA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxMDA7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB0ZXh0dXJlIHRvIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSB0ZXh0dXJlIHtQSVhJLmdsQ29yZS5HTFRleHR1cmV9XG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS5lbmFibGVUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSlcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZSB8fCBuZXcgVGV4dHVyZShnbCk7XG5cbiAgICB0aGlzLnRleHR1cmUuYmluZCgpO1xuXG4gICAgLy9nbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsICB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICB0aGlzLmJpbmQoKTtcblxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLnRleHR1cmUsIDApO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXNlcyB0aGUgc3RlbmNpbCBidWZmZXJcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLmVuYWJsZVN0ZW5jaWwgPSBmdW5jdGlvbigpXG57XG4gICAgaWYodGhpcy5zdGVuY2lsKXJldHVybjtcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLnN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWwpO1xuXG4gICAgLy8gVE9ETy4uIHRoaXMgaXMgZGVwdGggQU5EIHN0ZW5jaWw/XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWwpO1xuICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCAgdGhpcy53aWR0aCAgLCB0aGlzLmhlaWdodCApO1xuXG5cbn07XG5cbi8qKlxuICogRXJhc2VzIHRoZSBkcmF3aW5nIGFyZWEgYW5kIGZpbGxzIGl0IHdpdGggYSBjb2xvdXJcbiAqIEBwYXJhbSAgciB7TnVtYmVyfSB0aGUgcmVkIHZhbHVlIG9mIHRoZSBjbGVhcmluZyBjb2xvdXJcbiAqIEBwYXJhbSAgZyB7TnVtYmVyfSB0aGUgZ3JlZW4gdmFsdWUgb2YgdGhlIGNsZWFyaW5nIGNvbG91clxuICogQHBhcmFtICBiIHtOdW1iZXJ9IHRoZSBibHVlIHZhbHVlIG9mIHRoZSBjbGVhcmluZyBjb2xvdXJcbiAqIEBwYXJhbSAgYSB7TnVtYmVyfSB0aGUgYWxwaGEgdmFsdWUgb2YgdGhlIGNsZWFyaW5nIGNvbG91clxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiggciwgZywgYiwgYSApXG57XG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBmcmFtZSBidWZmZXIgdG8gdGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIgKTtcbn07XG5cbi8qKlxuICogVW5iaW5kcyB0aGUgZnJhbWUgYnVmZmVyIHRvIHRoZSBXZWJHTCBjb250ZXh0XG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcbn07XG4vKipcbiAqIFJlc2l6ZXMgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgYnVmZmVyIHRvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gKiBAcGFyYW0gIHdpZHRoICB7TnVtYmVyfSB0aGUgbmV3IHdpZHRoXG4gKiBAcGFyYW0gIGhlaWdodCB7TnVtYmVyfSB0aGUgbmV3IGhlaWdodFxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgaWYgKCB0aGlzLnRleHR1cmUgKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLnVwbG9hZERhdGEobnVsbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnN0ZW5jaWwgKVxuICAgIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGVuY2lsIGJ1ZmZlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnN0ZW5jaWwpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIGJ1ZmZlclxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy9UT0RPXG4gICAgaWYodGhpcy50ZXh0dXJlKVxuICAgIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKTtcblxuICAgIHRoaXMuZ2wgPSBudWxsO1xuXG4gICAgdGhpcy5zdGVuY2lsID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJhbWUgYnVmZmVyIHdpdGggYSB0ZXh0dXJlIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGRhdGFcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSBkYXRhIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhbiBhcnJheSBvZiBkYXRhXG4gKi9cbkZyYW1lYnVmZmVyLmNyZWF0ZVJHQkEgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgZGF0YSlcbntcbiAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmUuZnJvbURhdGEoZ2wsIG51bGwsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRleHR1cmUuZW5hYmxlTmVhcmVzdFNjYWxpbmcoKTtcbiAgICB0ZXh0dXJlLmVuYWJsZVdyYXBDbGFtcCgpO1xuXG4gICAgLy9ub3cgY3JlYXRlIHRoZSBmcmFtZWJ1ZmZlciBvYmplY3QgYW5kIGF0dGFjaCB0aGUgdGV4dHVyZSB0byBpdC5cbiAgICB2YXIgZmJvID0gbmV3IEZyYW1lYnVmZmVyKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmYm8uZW5hYmxlVGV4dHVyZSh0ZXh0dXJlKTtcblxuICAgIC8vZmJvLmVuYWJsZVN0ZW5jaWwoKTsgLy8gZ2V0IHRoaXMgYmFjayBvbiBzb29uIVxuXG4gICAgZmJvLnVuYmluZCgpO1xuXG4gICAgcmV0dXJuIGZibztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyYW1lIGJ1ZmZlciB3aXRoIGEgdGV4dHVyZSBjb250YWluaW5nIHRoZSBnaXZlbiBkYXRhXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXlCdWZmZXJ8IFNoYXJlZEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gYW4gYXJyYXkgb2YgZGF0YVxuICovXG5GcmFtZWJ1ZmZlci5jcmVhdGVGbG9hdDMyID0gZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIGRhdGEpXG57XG4gICAgLy8gY3JlYXRlIGEgbmV3IHRleHR1cmUuLlxuICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUuZnJvbURhdGEoZ2wsIGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRleHR1cmUuZW5hYmxlTmVhcmVzdFNjYWxpbmcoKTtcbiAgICB0ZXh0dXJlLmVuYWJsZVdyYXBDbGFtcCgpO1xuXG4gICAgLy9ub3cgY3JlYXRlIHRoZSBmcmFtZWJ1ZmZlciBvYmplY3QgYW5kIGF0dGFjaCB0aGUgdGV4dHVyZSB0byBpdC5cbiAgICB2YXIgZmJvID0gbmV3IEZyYW1lYnVmZmVyKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmYm8uZW5hYmxlVGV4dHVyZSh0ZXh0dXJlKTtcblxuICAgIGZiby51bmJpbmQoKTtcblxuICAgIHJldHVybiBmYm87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lYnVmZmVyO1xuIiwiXG4vKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlLnNoYWRlclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHQge1dlYkdMUHJvZ3JhbX1cbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gZnJhZ21lbnRTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVMb2NhdGlvbnMge09iamVjdH0gQW4gYXR0cmlidXRlIGxvY2F0aW9uIG1hcCB0aGF0IGxldHMgeW91IG1hbnVhbGx5IHNldCB0aGUgYXR0cmlidXRlIGxvY2F0aW9uc1xuICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSB0aGUgc2hhZGVyIHByb2dyYW1cbiAqL1xudmFyIGNvbXBpbGVQcm9ncmFtID0gZnVuY3Rpb24oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYnV0ZUxvY2F0aW9ucylcbntcbiAgICB2YXIgZ2xWZXJ0U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U3JjKTtcbiAgICB2YXIgZ2xGcmFnU2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNyYyk7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbFZlcnRTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbEZyYWdTaGFkZXIpO1xuXG4gICAgLy8gb3B0aW9uYWxseSwgc2V0IHRoZSBhdHRyaWJ1dGVzIG1hbnVhbGx5IGZvciB0aGUgcHJvZ3JhbSByYXRoZXIgdGhhbiBsZXR0aW5nIFdlYkdMIGRlY2lkZS4uXG4gICAgaWYoYXR0cmlidXRlTG9jYXRpb25zKVxuICAgIHtcbiAgICAgICAgZm9yKHZhciBpIGluIGF0dHJpYnV0ZUxvY2F0aW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZUxvY2F0aW9uc1tpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgLy8gaWYgbGlua2luZyBmYWlscywgdGhlbiBsb2cgYW5kIGNsZWFudXBcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUGl4aS5qcyBFcnJvcjogQ291bGQgbm90IGluaXRpYWxpemUgc2hhZGVyLicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnbC5nZXRFcnJvcigpJywgZ2wuZ2V0RXJyb3IoKSk7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBwcm9ncmFtIGluZm8gbG9nLCBsb2cgaXRcbiAgICAgICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSAnJylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQaXhpLmpzIFdhcm5pbmc6IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBwcm9ncmFtID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjbGVhbiB1cCBzb21lIHNoYWRlcnNcbiAgICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZ2xGcmFnU2hhZGVyKTtcblxuICAgIHJldHVybiBwcm9ncmFtO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHQge1dlYkdMUHJvZ3JhbX1cbiAqIEBwYXJhbSB0eXBlIHtOdW1iZXJ9IHRoZSB0eXBlLCBjYW4gYmUgZWl0aGVyIFZFUlRFWF9TSEFERVIgb3IgRlJBR01FTlRfU0hBREVSXG4gKiBAcGFyYW0gdmVydGV4U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSB2ZXJ0ZXggc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHJldHVybiB7V2ViR0xTaGFkZXJ9IHRoZSBzaGFkZXJcbiAqL1xudmFyIGNvbXBpbGVTaGFkZXIgPSBmdW5jdGlvbiAoZ2wsIHR5cGUsIHNyYylcbntcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVQcm9ncmFtO1xuIiwiXG5cbnZhciBtYXBTaXplID0gZnVuY3Rpb24oZ2wsIHR5cGUpIFxue1xuICAgIGlmKCFHTF9UQUJMRSkgXG4gICAge1xuICAgICAgICB2YXIgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG5cbiAgICAgICAgR0xfVEFCTEUgPSB7fTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdHlwZU5hbWVzLmxlbmd0aDsgKytpKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRuID0gdHlwZU5hbWVzW2ldO1xuICAgICAgICAgICAgR0xfVEFCTEVbIGdsW3RuXSBdID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIEdMX1RBQkxFW3R5cGVdO1xufTtcblxudmFyIEdMX1RBQkxFID0gbnVsbDtcblxudmFyIEdMX1RPX0dMU0xfVFlQRVMgPSB7XG4gICdGTE9BVCc6ICAgICAgICdmbG9hdCcsXG4gICdGTE9BVF9WRUMyJzogICd2ZWMyJyxcbiAgJ0ZMT0FUX1ZFQzMnOiAgJ3ZlYzMnLFxuICAnRkxPQVRfVkVDNCc6ICAndmVjNCcsXG5cbiAgJ0lOVCc6ICAgICAgICAgJ2ludCcsXG4gICdJTlRfVkVDMic6ICAgICdpdmVjMicsXG4gICdJTlRfVkVDMyc6ICAgICdpdmVjMycsXG4gICdJTlRfVkVDNCc6ICAgICdpdmVjNCcsXG4gIFxuICAnQk9PTCc6ICAgICAgICAnYm9vbCcsXG4gICdCT09MX1ZFQzInOiAgICdidmVjMicsXG4gICdCT09MX1ZFQzMnOiAgICdidmVjMycsXG4gICdCT09MX1ZFQzQnOiAgICdidmVjNCcsXG4gIFxuICAnRkxPQVRfTUFUMic6ICAnbWF0MicsXG4gICdGTE9BVF9NQVQzJzogICdtYXQzJyxcbiAgJ0ZMT0FUX01BVDQnOiAgJ21hdDQnLFxuICBcbiAgJ1NBTVBMRVJfMkQnOiAgJ3NhbXBsZXIyRCcgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXBTaXplO1xuIiwiLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBtYXBTaXplID0gZnVuY3Rpb24odHlwZSkgXG57IFxuICAgIHJldHVybiBHTFNMX1RPX1NJWkVbdHlwZV07XG59O1xuXG5cbnZhciBHTFNMX1RPX1NJWkUgPSB7XG4gICAgJ2Zsb2F0JzogICAgMSxcbiAgICAndmVjMic6ICAgICAyLFxuICAgICd2ZWMzJzogICAgIDMsXG4gICAgJ3ZlYzQnOiAgICAgNCxcblxuICAgICdpbnQnOiAgICAgIDEsXG4gICAgJ2l2ZWMyJzogICAgMixcbiAgICAnaXZlYzMnOiAgICAzLFxuICAgICdpdmVjNCc6ICAgIDQsXG5cbiAgICAnYm9vbCc6ICAgICAxLFxuICAgICdidmVjMic6ICAgIDIsXG4gICAgJ2J2ZWMzJzogICAgMyxcbiAgICAnYnZlYzQnOiAgICA0LFxuXG4gICAgJ21hdDInOiAgICAgNCxcbiAgICAnbWF0Myc6ICAgICA5LFxuICAgICdtYXQ0JzogICAgIDE2LFxuXG4gICAgJ3NhbXBsZXIyRCc6ICAxXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFNpemU7XG4iLCJcbnZhciBtYXBUeXBlID0gcmVxdWlyZSgnLi9tYXBUeXBlJyk7XG52YXIgbWFwU2l6ZSA9IHJlcXVpcmUoJy4vbWFwU2l6ZScpO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBhdHRyaWJ1dGVzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHByb2dyYW0ge1dlYkdMUHJvZ3JhbX0gVGhlIHNoYWRlciBwcm9ncmFtIHRvIGdldCB0aGUgYXR0cmlidXRlcyBmcm9tXG4gKiBAcmV0dXJuIGF0dHJpYnV0ZXMge09iamVjdH1cbiAqL1xudmFyIGV4dHJhY3RBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pXG57XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHZhciB0b3RhbEF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxBdHRyaWJ1dGVzOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgYXR0cmliRGF0YSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXBUeXBlKGdsLCBhdHRyaWJEYXRhLnR5cGUpO1xuXG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmliRGF0YS5uYW1lXSA9IHtcbiAgICAgICAgICAgIHR5cGU6dHlwZSxcbiAgICAgICAgICAgIHNpemU6bWFwU2l6ZSh0eXBlKSxcbiAgICAgICAgICAgIGxvY2F0aW9uOmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYkRhdGEubmFtZSksXG4gICAgICAgICAgICAvL1RPRE8gLSBtYWtlIGFuIGF0dHJpYnV0ZSBvYmplY3RcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cbnZhciBwb2ludGVyID0gZnVuY3Rpb24odHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBzdGFydCl7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5sb2NhdGlvbilcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMubG9jYXRpb24sdGhpcy5zaXplLCB0eXBlIHx8IGdsLkZMT0FULCBub3JtYWxpemVkIHx8IGZhbHNlLCBzdHJpZGUgfHwgMCwgc3RhcnQgfHwgMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dHJhY3RBdHRyaWJ1dGVzO1xuIiwiLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IFR5cGUgb2YgdmFsdWVcbiAqIEBwYXJhbSBzaXplIHtOdW1iZXJ9XG4gKi9cbnZhciBkZWZhdWx0VmFsdWUgPSBmdW5jdGlvbih0eXBlLCBzaXplKSBcbntcbiAgICBzd2l0Y2ggKHR5cGUpXG4gICAge1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBjYXNlICd2ZWMyJzogXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgyICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAndmVjMyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgzICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAndmVjNCc6ICAgICBcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDQgKiBzaXplKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdpbnQnOlxuICAgICAgICBjYXNlICdzYW1wbGVyMkQnOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgY2FzZSAnaXZlYzInOiAgIFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDIgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdpdmVjMyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMyAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ2l2ZWM0JzogXG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoNCAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2wnOiAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSAnYnZlYzInOlxuXG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbkFycmF5KCAyICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAnYnZlYzMnOlxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSgzICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAnYnZlYzQnOlxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSg0ICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAnbWF0Mic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAxXSk7XG5cbiAgICAgICAgY2FzZSAnbWF0Myc6IFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAxXSk7XG5cbiAgICAgICAgY2FzZSAnbWF0NCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgMV0pO1xuICAgIH1cbn07XG5cbnZhciBib29sZWFuQXJyYXkgPSBmdW5jdGlvbihzaXplKVxue1xuICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShzaXplKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIFxuICAgIHtcbiAgICAgICAgYXJyYXlbaV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRWYWx1ZTtcbiIsInZhciBtYXBUeXBlID0gcmVxdWlyZSgnLi9tYXBUeXBlJyk7XG52YXIgZGVmYXVsdFZhbHVlID0gcmVxdWlyZSgnLi9kZWZhdWx0VmFsdWUnKTtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdW5pZm9ybXNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlLnNoYWRlclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gcHJvZ3JhbSB7V2ViR0xQcm9ncmFtfSBUaGUgc2hhZGVyIHByb2dyYW0gdG8gZ2V0IHRoZSB1bmlmb3JtcyBmcm9tXG4gKiBAcmV0dXJuIHVuaWZvcm1zIHtPYmplY3R9XG4gKi9cbnZhciBleHRyYWN0VW5pZm9ybXMgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSlcbntcblx0dmFyIHVuaWZvcm1zID0ge307XG5cbiAgICB2YXIgdG90YWxVbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxVbmlmb3JtczsgaSsrKVxuICAgIHtcbiAgICBcdHZhciB1bmlmb3JtRGF0YSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XG4gICAgXHR2YXIgbmFtZSA9IHVuaWZvcm1EYXRhLm5hbWUucmVwbGFjZSgvXFxbLio/XFxdLywgXCJcIik7XG4gICAgICAgIHZhciB0eXBlID0gbWFwVHlwZShnbCwgdW5pZm9ybURhdGEudHlwZSApO1xuXG4gICAgXHR1bmlmb3Jtc1tuYW1lXSA9IHtcbiAgICBcdFx0dHlwZTp0eXBlLFxuICAgIFx0XHRzaXplOnVuaWZvcm1EYXRhLnNpemUsXG4gICAgXHRcdGxvY2F0aW9uOmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICBcdFx0dmFsdWU6ZGVmYXVsdFZhbHVlKHR5cGUsIHVuaWZvcm1EYXRhLnNpemUpXG4gICAgXHR9O1xuICAgIH1cblxuXHRyZXR1cm4gdW5pZm9ybXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dHJhY3RVbmlmb3JtcztcbiIsIi8qKlxuICogU2V0cyB0aGUgZmxvYXQgcHJlY2lzaW9uIG9uIHRoZSBzaGFkZXIuIElmIHRoZSBwcmVjaXNpb24gaXMgYWxyZWFkeSBwcmVzZW50IHRoaXMgZnVuY3Rpb24gd2lsbCBkbyBub3RoaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjICAgICAgIHRoZSBzaGFkZXIgc291cmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlY2lzaW9uIFRoZSBmbG9hdCBwcmVjaXNpb24gb2YgdGhlIHNoYWRlci4gT3B0aW9ucyBhcmUgJ2xvd3AnLCAnbWVkaXVtcCcgb3IgJ2hpZ2hwJy5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IG1vZGlmaWVkIHNoYWRlciBzb3VyY2VcbiAqL1xudmFyIHNldFByZWNpc2lvbiA9IGZ1bmN0aW9uKHNyYywgcHJlY2lzaW9uKVxue1xuICAgIGlmKHNyYy5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICdwcmVjaXNpb24gJyArIHByZWNpc2lvbiArICcgZmxvYXQ7XFxuJyArIHNyYztcbiAgICB9XG5cbiAgICByZXR1cm4gc3JjO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRQcmVjaXNpb247XG4iLCIvKipcbiAqIEV4dHJhY3RzIHRoZSBhdHRyaWJ1dGVzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHVuaWZvcm1zIHtBcnJheX0gQG1hdCA/XG4gKiBAcmV0dXJuIGF0dHJpYnV0ZXMge09iamVjdH1cbiAqL1xudmFyIGdlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdCA9IGZ1bmN0aW9uKGdsLCB1bmlmb3JtRGF0YSlcbntcbiAgICAvLyB0aGlzIGlzIHRoZSBvYmplY3Qgd2Ugd2lsbCBiZSBzZW5kaW5nIGJhY2suXG4gICAgLy8gYW4gb2JqZWN0IGhpZXJhY2h5IHdpbGwgYmUgY3JlYXRlZCBmb3Igc3RydWN0c1xuICAgIHZhciB1bmlmb3JtcyA9IHtkYXRhOnt9fTtcblxuICAgIHVuaWZvcm1zLmdsID0gZ2w7XG5cbiAgICB2YXIgdW5pZm9ybUtleXM9IE9iamVjdC5rZXlzKHVuaWZvcm1EYXRhKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pZm9ybUtleXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgZnVsbE5hbWUgPSB1bmlmb3JtS2V5c1tpXTtcblxuICAgICAgICB2YXIgbmFtZVRva2VucyA9IGZ1bGxOYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZVRva2Vuc1tuYW1lVG9rZW5zLmxlbmd0aCAtIDFdO1xuXG5cbiAgICAgICAgdmFyIHVuaWZvcm1Hcm91cCA9IGdldFVuaWZvcm1Hcm91cChuYW1lVG9rZW5zLCB1bmlmb3Jtcyk7XG5cbiAgICAgICAgdmFyIHVuaWZvcm0gPSAgdW5pZm9ybURhdGFbZnVsbE5hbWVdO1xuICAgICAgICB1bmlmb3JtR3JvdXAuZGF0YVtuYW1lXSA9IHVuaWZvcm07XG5cbiAgICAgICAgdW5pZm9ybUdyb3VwLmdsID0gZ2w7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHVuaWZvcm1Hcm91cCwgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBnZW5lcmF0ZUdldHRlcihuYW1lKSxcbiAgICAgICAgICAgIHNldDogZ2VuZXJhdGVTZXR0ZXIobmFtZSwgdW5pZm9ybSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xufTtcblxudmFyIGdlbmVyYXRlR2V0dGVyID0gZnVuY3Rpb24obmFtZSlcbntcblx0dmFyIHRlbXBsYXRlID0gZ2V0dGVyVGVtcGxhdGUucmVwbGFjZSgnJSUnLCBuYW1lKTtcblx0cmV0dXJuIG5ldyBGdW5jdGlvbih0ZW1wbGF0ZSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxufTtcblxudmFyIGdlbmVyYXRlU2V0dGVyID0gZnVuY3Rpb24obmFtZSwgdW5pZm9ybSlcbntcbiAgICB2YXIgdGVtcGxhdGUgPSBzZXR0ZXJUZW1wbGF0ZS5yZXBsYWNlKC8lJS9nLCBuYW1lKTtcbiAgICB2YXIgc2V0VGVtcGxhdGU7XG5cbiAgICBpZih1bmlmb3JtLnNpemUgPT09IDEpXG4gICAge1xuICAgICAgICBzZXRUZW1wbGF0ZSA9IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNbdW5pZm9ybS50eXBlXTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgc2V0VGVtcGxhdGUgPSBHTFNMX1RPX0FSUkFZX1NFVFRFUlNbdW5pZm9ybS50eXBlXTtcbiAgICB9XG5cbiAgICBpZihzZXRUZW1wbGF0ZSlcbiAgICB7XG4gICAgICAgIHRlbXBsYXRlICs9IFwiXFxudGhpcy5nbC5cIiArIHNldFRlbXBsYXRlICsgXCI7XCI7XG4gICAgfVxuXG4gIFx0cmV0dXJuIG5ldyBGdW5jdGlvbigndmFsdWUnLCB0ZW1wbGF0ZSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxufTtcblxudmFyIGdldFVuaWZvcm1Hcm91cCA9IGZ1bmN0aW9uKG5hbWVUb2tlbnMsIHVuaWZvcm0pXG57XG4gICAgdmFyIGN1ciA9IHVuaWZvcm07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVUb2tlbnMubGVuZ3RoIC0gMTsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIG8gPSBjdXJbbmFtZVRva2Vuc1tpXV0gfHwge2RhdGE6e319O1xuICAgICAgICBjdXJbbmFtZVRva2Vuc1tpXV0gPSBvO1xuICAgICAgICBjdXIgPSBvO1xuICAgIH1cblxuICAgIHJldHVybiBjdXI7XG59O1xuXG52YXIgZ2V0dGVyVGVtcGxhdGUgPSBbXG4gICAgJ3JldHVybiB0aGlzLmRhdGEuJSUudmFsdWU7Jyxcbl0uam9pbignXFxuJyk7XG5cbnZhciBzZXR0ZXJUZW1wbGF0ZSA9IFtcbiAgICAndGhpcy5kYXRhLiUlLnZhbHVlID0gdmFsdWU7JyxcbiAgICAndmFyIGxvY2F0aW9uID0gdGhpcy5kYXRhLiUlLmxvY2F0aW9uOydcbl0uam9pbignXFxuJyk7XG5cblxudmFyIEdMU0xfVE9fU0lOR0xFX1NFVFRFUlMgPSB7XG5cbiAgICAnZmxvYXQnOiAgICAndW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSknLFxuXG4gICAgJ3ZlYzInOiAgICAgJ3VuaWZvcm0yZihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdKScsXG4gICAgJ3ZlYzMnOiAgICAgJ3VuaWZvcm0zZihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSknLFxuICAgICd2ZWM0JzogICAgICd1bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzNdKScsXG5cbiAgICAnaW50JzogICAgICAndW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdpdmVjMic6ICAgICd1bmlmb3JtMmkobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSknLFxuICAgICdpdmVjMyc6ICAgICd1bmlmb3JtM2kobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0pJyxcbiAgICAnaXZlYzQnOiAgICAndW5pZm9ybTRpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSknLFxuXG4gICAgJ2Jvb2wnOiAgICAgJ3VuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnYnZlYzInOiAgICAndW5pZm9ybTJpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pJyxcbiAgICAnYnZlYzMnOiAgICAndW5pZm9ybTNpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdKScsXG4gICAgJ2J2ZWM0JzogICAgJ3VuaWZvcm00aShsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM10pJyxcblxuICAgICdtYXQyJzogICAgICd1bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpJyxcbiAgICAnbWF0Myc6ICAgICAndW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKScsXG4gICAgJ21hdDQnOiAgICAgJ3VuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSknLFxuXG4gICAgJ3NhbXBsZXIyRCc6J3VuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpJ1xufTtcblxudmFyIEdMU0xfVE9fQVJSQVlfU0VUVEVSUyA9IHtcblxuICAgICdmbG9hdCc6ICAgICd1bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSknLFxuXG4gICAgJ3ZlYzInOiAgICAgJ3VuaWZvcm0yZnYobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ3ZlYzMnOiAgICAgJ3VuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ3ZlYzQnOiAgICAgJ3VuaWZvcm00ZnYobG9jYXRpb24sIHZhbHVlKScsXG5cbiAgICAnaW50JzogICAgICAndW5pZm9ybTFpdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnaXZlYzInOiAgICAndW5pZm9ybTJpdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnaXZlYzMnOiAgICAndW5pZm9ybTNpdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAnaXZlYzQnOiAgICAndW5pZm9ybTRpdihsb2NhdGlvbiwgdmFsdWUpJyxcblxuICAgICdib29sJzogICAgICd1bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdidmVjMic6ICAgICd1bmlmb3JtMml2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdidmVjMyc6ICAgICd1bmlmb3JtM2l2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdidmVjNCc6ICAgICd1bmlmb3JtNGl2KGxvY2F0aW9uLCB2YWx1ZSknLFxuXG4gICAgJ3NhbXBsZXIyRCc6J3VuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlKSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0O1xuIiwiXG52YXIgY29tcGlsZVByb2dyYW0gPSByZXF1aXJlKCcuL3NoYWRlci9jb21waWxlUHJvZ3JhbScpLFxuXHRleHRyYWN0QXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vc2hhZGVyL2V4dHJhY3RBdHRyaWJ1dGVzJyksXG5cdGV4dHJhY3RVbmlmb3JtcyA9IHJlcXVpcmUoJy4vc2hhZGVyL2V4dHJhY3RVbmlmb3JtcycpLFxuXHRzZXRQcmVjaXNpb24gPSByZXF1aXJlKCcuL3NoYWRlci9zZXRQcmVjaXNpb24nKSxcblx0Z2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0ID0gcmVxdWlyZSgnLi9zaGFkZXIvZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0Jyk7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHdlYkdMIFNoYWRlclxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gZnJhZ21lbnRTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBwcmVjaXNpb24ge3ByZWNpc2lvbl19IFRoZSBmbG9hdCBwcmVjaXNpb24gb2YgdGhlIHNoYWRlci4gT3B0aW9ucyBhcmUgJ2xvd3AnLCAnbWVkaXVtcCcgb3IgJ2hpZ2hwJy5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVMb2NhdGlvbnMge29iamVjdH0gQSBrZXkgdmFsdWUgcGFpciBzaG93aW5nIHdoaWNoIGxvY2F0aW9uIGVhY3QgYXR0cmlidXRlIHNob3VsZCBzaXQgZWcge3Bvc2l0aW9uOjAsIHV2czoxfVxuICovXG52YXIgU2hhZGVyID0gZnVuY3Rpb24oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHByZWNpc2lvbiwgYXR0cmlidXRlTG9jYXRpb25zKVxue1xuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcblx0ICpcblx0ICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuXHQgKi9cblx0dGhpcy5nbCA9IGdsO1xuXG5cdGlmKHByZWNpc2lvbilcblx0e1xuXHRcdHZlcnRleFNyYyA9IHNldFByZWNpc2lvbih2ZXJ0ZXhTcmMsIHByZWNpc2lvbik7XG5cdFx0ZnJhZ21lbnRTcmMgPSBzZXRQcmVjaXNpb24oZnJhZ21lbnRTcmMsIHByZWNpc2lvbik7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHNoYWRlciBwcm9ncmFtXG5cdCAqXG5cdCAqIEBtZW1iZXIge1dlYkdMUHJvZ3JhbX1cblx0ICovXG5cdC8vIEZpcnN0IGNvbXBpbGUgdGhlIHByb2dyYW0uLlxuXHR0aGlzLnByb2dyYW0gPSBjb21waWxlUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmlidXRlTG9jYXRpb25zKTtcblxuXHQvKipcblx0ICogVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHNoYWRlciBhcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcblx0ICoge1xuXHQgKiBcdHR5cGUsXG5cdCAqIFx0c2l6ZSxcblx0ICogXHRsb2NhdGlvbixcblx0ICogXHRwb2ludGVyXG5cdCAqIH1cblx0ICogQG1lbWJlciB7T2JqZWN0fVxuXHQgKi9cblx0Ly8gbmV4dCBleHRyYWN0IHRoZSBhdHRyaWJ1dGVzXG5cdHRoaXMuYXR0cmlidXRlcyA9IGV4dHJhY3RBdHRyaWJ1dGVzKGdsLCB0aGlzLnByb2dyYW0pO1xuXG4gICAgdGhpcy51bmlmb3JtRGF0YSA9IGV4dHJhY3RVbmlmb3JtcyhnbCwgdGhpcy5wcm9ncmFtKTtcblxuXHQvKipcblx0ICogVGhlIHVuaWZvcm1zIG9mIHRoZSBzaGFkZXIgYXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzXG5cdCAqIHtcblx0ICogXHRnbCxcblx0ICogXHRkYXRhXG5cdCAqIH1cblx0ICogQG1lbWJlciB7T2JqZWN0fVxuXHQgKi9cblx0dGhpcy51bmlmb3JtcyA9IGdlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdCggZ2wsIHRoaXMudW5pZm9ybURhdGEgKTtcblxufTtcbi8qKlxuICogVXNlcyB0aGlzIHNoYWRlclxuICovXG5TaGFkZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbigpXG57XG5cdHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHNoYWRlclxuICogVE9ET1xuICovXG5TaGFkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG5cdHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG5cdHRoaXMudW5pZm9ybURhdGEgPSBudWxsO1xuXHR0aGlzLnVuaWZvcm1zID0gbnVsbDtcblxuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXHRnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyO1xuIiwiXG4vLyBzdGF0ZSBvYmplY3QvL1xudmFyIHNldFZlcnRleEF0dHJpYkFycmF5cyA9IHJlcXVpcmUoICcuL3NldFZlcnRleEF0dHJpYkFycmF5cycgKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gd29yayB3aXRoIFdlYkdMIFZlcnRleEFycmF5T2JqZWN0cyAodmFvcylcbiAqIE9ubHkgd29ya3MgaWYgV2ViR0wgZXh0ZW5zaW9ucyBhcmUgZW5hYmxlZCAodGhleSB1c3VhbGx5IGFyZSlcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZVxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIFZlcnRleEFycmF5T2JqZWN0KGdsLCBzdGF0ZSlcbntcbiAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbiA9IG51bGw7XG5cbiAgICBpZighVmVydGV4QXJyYXlPYmplY3QuRk9SQ0VfTkFUSVZFKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ01PWl9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hdGl2ZVN0YXRlID0gc3RhdGU7XG5cbiAgICBpZih0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbilcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvID0gdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcblxuICAgICAgICB2YXIgbWF4QXR0cmlicyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX0FUVFJJQlMpO1xuXG4gICAgICAgIC8vIFZBTyAtIG92ZXJ3cml0ZSB0aGUgc3RhdGUuLlxuICAgICAgICB0aGlzLm5hdGl2ZVN0YXRlID0ge1xuICAgICAgICAgICAgdGVtcEF0dHJpYlN0YXRlOiBuZXcgQXJyYXkobWF4QXR0cmlicyksXG4gICAgICAgICAgICBhdHRyaWJTdGF0ZTogbmV3IEFycmF5KG1heEF0dHJpYnMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1BJWEkuZ2xDb3JlLkdMQnVmZmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGZsYWdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufVxuXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZXJ0ZXhBcnJheU9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gVmVydGV4QXJyYXlPYmplY3Q7XG5cbi8qKlxuKiBTb21lIGRldmljZXMgYmVoYXZlIGEgYml0IGZ1bm55IHdoZW4gdXNpbmcgdGhlIG5ld2VyIGV4dGVuc2lvbnMgKGltIGxvb2tpbmcgYXQgeW91IGlwYWQgMiEpXG4qIElmIHlvdSBmaW5kIG9uIG9sZGVyIGRldmljZXMgdGhhdCB0aGluZ3MgaGF2ZSBnb25lIGEgYml0IHdlaXJkIHRoZW4gc2V0IHRoaXMgdG8gdHJ1ZS5cbiovXG4vKipcbiAqIExldHMgdGhlIFZBTyBrbm93IGlmIHlvdSBzaG91bGQgdXNlIHRoZSBXZWJHTCBleHRlbnNpb24gb3IgdGhlIG5hdGl2ZSBtZXRob2RzLlxuICogU29tZSBkZXZpY2VzIGJlaGF2ZSBhIGJpdCBmdW5ueSB3aGVuIHVzaW5nIHRoZSBuZXdlciBleHRlbnNpb25zIChpbSBsb29raW5nIGF0IHlvdSBpcGFkIDIhKVxuICogSWYgeW91IGZpbmQgb24gb2xkZXIgZGV2aWNlcyB0aGF0IHRoaW5ncyBoYXZlIGdvbmUgYSBiaXQgd2VpcmQgdGhlbiBzZXQgdGhpcyB0byB0cnVlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtCb29sZWFufSBGT1JDRV9OQVRJVkVcbiAqL1xuVmVydGV4QXJyYXlPYmplY3QuRk9SQ0VfTkFUSVZFID0gZmFsc2U7XG5cbi8qKlxuICogQmluZHMgdGhlIGJ1ZmZlclxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLm5hdGl2ZVZhbylcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh0aGlzLm5hdGl2ZVZhbyk7XG5cbiAgICAgICAgaWYodGhpcy5kaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVbmJpbmRzIHRoZSBidWZmZXJcbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLm5hdGl2ZVZhbylcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXNlcyB0aGlzIHZhb1xuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbigpXG57XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBsYXN0QnVmZmVyID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYiA9IHRoaXMuYXR0cmlidXRlc1tpXTtcblxuICAgICAgICBpZihsYXN0QnVmZmVyICE9PSBhdHRyaWIuYnVmZmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBhdHRyaWIuYnVmZmVyLmJpbmQoKTtcbiAgICAgICAgICAgIGxhc3RCdWZmZXIgPSBhdHRyaWIuYnVmZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWIuYXR0cmlidXRlLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYi5hdHRyaWJ1dGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWIudHlwZSB8fCBnbC5GTE9BVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWIubm9ybWFsaXplZCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWIuc3RyaWRlIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLnN0YXJ0IHx8IDApO1xuICAgIH1cblxuICAgIHNldFZlcnRleEF0dHJpYkFycmF5cyhnbCwgdGhpcy5hdHRyaWJ1dGVzLCB0aGlzLm5hdGl2ZVN0YXRlKTtcblxuICAgIGlmKHRoaXMuaW5kZXhCdWZmZXIpXG4gICAge1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmJpbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBidWZmZXIgICAgIHtQSVhJLmdsLkdMQnVmZmVyfVxuICogQHBhcmFtIGF0dHJpYnV0ZSAgeyp9XG4gKiBAcGFyYW0gdHlwZSAgICAgICB7U3RyaW5nfVxuICogQHBhcmFtIG5vcm1hbGl6ZWQge0Jvb2xlYW59XG4gKiBAcGFyYW0gc3RyaWRlICAgICB7TnVtYmVyfVxuICogQHBhcmFtIHN0YXJ0ICAgICAge051bWJlcn1cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgYXR0cmlidXRlLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIHN0YXJ0KVxue1xuICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgYnVmZmVyOiAgICAgYnVmZmVyLFxuICAgICAgICBhdHRyaWJ1dGU6ICBhdHRyaWJ1dGUsXG5cbiAgICAgICAgbG9jYXRpb246ICAgYXR0cmlidXRlLmxvY2F0aW9uLFxuICAgICAgICB0eXBlOiAgICAgICB0eXBlIHx8IHRoaXMuZ2wuRkxPQVQsXG4gICAgICAgIG5vcm1hbGl6ZWQ6IG5vcm1hbGl6ZWQgfHwgZmFsc2UsXG4gICAgICAgIHN0cmlkZTogICAgIHN0cmlkZSB8fCAwLFxuICAgICAgICBzdGFydDogICAgICBzdGFydCB8fCAwXG4gICAgfSk7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAgIHtQSVhJLmdsLkdMQnVmZmVyfVxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuYWRkSW5kZXggPSBmdW5jdGlvbihidWZmZXIvKiwgb3B0aW9ucyovKVxue1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBidWZmZXI7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVbmJpbmRzIHRoaXMgdmFvIGFuZCBkaXNhYmxlcyBpdFxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpXG57XG4gICAgLy8gdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIFRPRE8gLSBzaG91bGQgdGhpcyBmdW5jdGlvbiB1bmJpbmQgYWZ0ZXIgY2xlYXI/XG4gICAgLy8gZm9yIG5vdywgbm8gYnV0IGxldHMgc2VlIHdoYXQgaGFwcGVucyBpbiB0aGUgcmVhbCB3b3JsZCFcbiAgICBpZih0aGlzLm5hdGl2ZVZhbylcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyh0aGlzLm5hdGl2ZVZhbyk7XG4gICAgfVxuXG4gICAgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHR5cGUgIHtOdW1iZXJ9XG4gKiBAcGFyYW0gc2l6ZSAge051bWJlcn1cbiAqIEBwYXJhbSBzdGFydCB7TnVtYmVyfVxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHR5cGUsIHNpemUsIHN0YXJ0KVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBpZih0aGlzLmluZGV4QnVmZmVyKVxuICAgIHtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKHR5cGUsIHNpemUgfHwgdGhpcy5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIChzdGFydCB8fCAwKSAqIDIgKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gVE9ETyBuZWVkIGEgYmV0dGVyIHdheSB0byBjYWxjdWxhdGUgc2l6ZS4uXG4gICAgICAgIGdsLmRyYXdBcnJheXModHlwZSwgc3RhcnQsIHNpemUgfHwgdGhpcy5nZXRTaXplKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXN0cm95IHRoaXMgdmFvXG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIC8vIGxvc2UgcmVmZXJlbmNlc1xuICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVTdGF0ZSA9IG51bGw7XG5cbiAgICBpZih0aGlzLm5hdGl2ZVZhbylcbiAgICB7XG4gICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmRlbGV0ZVZlcnRleEFycmF5T0VTKHRoaXMubmF0aXZlVmFvKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbiA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVWYW8gPSBudWxsO1xufTtcblxuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGF0dHJpYiA9IHRoaXMuYXR0cmlidXRlc1swXTtcbiAgICByZXR1cm4gYXR0cmliLmJ1ZmZlci5kYXRhLmxlbmd0aCAvICgoIGF0dHJpYi5zdHJpZGUvNCApIHx8IGF0dHJpYi5hdHRyaWJ1dGUuc2l6ZSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29tcGlsZVByb2dyYW06IHJlcXVpcmUoJy4vY29tcGlsZVByb2dyYW0nKSxcbiAgICBkZWZhdWx0VmFsdWU6IHJlcXVpcmUoJy4vZGVmYXVsdFZhbHVlJyksXG4gICAgZXh0cmFjdEF0dHJpYnV0ZXM6IHJlcXVpcmUoJy4vZXh0cmFjdEF0dHJpYnV0ZXMnKSxcbiAgICBleHRyYWN0VW5pZm9ybXM6IHJlcXVpcmUoJy4vZXh0cmFjdFVuaWZvcm1zJyksXG4gICAgZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0OiByZXF1aXJlKCcuL2dlbmVyYXRlVW5pZm9ybUFjY2Vzc09iamVjdCcpLFxuICAgIHNldFByZWNpc2lvbjogcmVxdWlyZSgnLi9zZXRQcmVjaXNpb24nKSxcbiAgICBtYXBTaXplOiByZXF1aXJlKCcuL21hcFNpemUnKSxcbiAgICBtYXBUeXBlOiByZXF1aXJlKCcuL21hcFR5cGUnKVxufTsiLCJ2YXIgZ2wgPSB7XG4gICAgY3JlYXRlQ29udGV4dDogICAgICAgICAgcmVxdWlyZSgnLi9jcmVhdGVDb250ZXh0JyksXG4gICAgc2V0VmVydGV4QXR0cmliQXJyYXlzOiAgcmVxdWlyZSgnLi9zZXRWZXJ0ZXhBdHRyaWJBcnJheXMnKSxcbiAgICBHTEJ1ZmZlcjogICAgICAgICAgICAgICByZXF1aXJlKCcuL0dMQnVmZmVyJyksXG4gICAgR0xGcmFtZWJ1ZmZlcjogICAgICAgICAgcmVxdWlyZSgnLi9HTEZyYW1lYnVmZmVyJyksXG4gICAgR0xTaGFkZXI6ICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9HTFNoYWRlcicpLFxuICAgIEdMVGV4dHVyZTogICAgICAgICAgICAgIHJlcXVpcmUoJy4vR0xUZXh0dXJlJyksXG4gICAgVmVydGV4QXJyYXlPYmplY3Q6ICAgICAgcmVxdWlyZSgnLi9WZXJ0ZXhBcnJheU9iamVjdCcpLFxuICAgIHNoYWRlcjogICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhZGVyJylcbn07XG5cbi8vIEV4cG9ydCBmb3IgTm9kZS1jb21wYXRpYmxlIGVudmlyb25tZW50c1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxue1xuICAgIC8vIEV4cG9ydCB0aGUgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbDtcbn1cblxuLy8gQWRkIHRvIHRoZSBicm93c2VyIHdpbmRvdyBwaXhpLmdsXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG57XG4gICAgLy8gYWRkIHRoZSB3aW5kb3cgb2JqZWN0XG4gICAgd2luZG93LlBJWEkgPSB3aW5kb3cuUElYSSB8fCB7fTtcbiAgICB3aW5kb3cuUElYSS5nbENvcmUgPSBnbDtcbn1cbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uLy4uLy4uL21hdGgvaW5kZXgnO1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi8uLi8uLi9nZW9tL01hdHJpeCdcbmltcG9ydCB7IFNDQUxFX01PREVTIH0gZnJvbSAnLi4vLi4vLi4vY29uc3QnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCBnbENvcmUgZnJvbSAncGl4aS1nbC1jb3JlJztcblxuY29uc3QgR0xGcmFtZWJ1ZmZlciA9IGdsQ29yZS5HTEZyYW1lYnVmZmVyO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJUYXJnZXRcbntcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCByb290KVxuICAgIHtcblxuICAgICAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAgICAgLy8gZnJhbWVidWZmZXIg5pivV2ViR0zmuLLmn5PnmoTnu4jngrnjgILlvZPkvaDnnIvlsY/luZXml7bvvIzlhbbku5blsLHmmK/lnKjnnIsgZnJhbWVidWZmZXIg5Lit55qE5YaF5a6544CCXG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICB0aGlzLnNpemUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7lpIfliIbovqjnjodcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgc2V0dGluZ3MuUkVTT0xVVElPTjtcblxuICAgICAgICAvL+aKleW9seefqemYte+8jOaKiuaJgOacieeahOmhtueCueaKleWwhOWIsHdlYmds55qEWy0xLDFd55qE5Z2Q5qCH57O75YaFXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblxuICAgICAgICB0aGlzLmZyYW1lID0gbnVsbDtcblxuICAgICAgICB0aGlzLmRlZmF1bHRGcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcblxuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyID0gbmV3IEdMRnJhbWVidWZmZXIoZ2wsIDEwMCwgMTAwKTtcbiAgICAgICAgdGhpcy5mcmFtZUJ1ZmZlci5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgIFxuICAgICAgICB0aGlzLnNldEZyYW1lKCk7XG5cbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgY2xlYXIoY2xlYXJDb2xvcilcbiAgICB7XG4gICAgICAgIGNvbnN0IGNjID0gY2xlYXJDb2xvciB8fCB0aGlzLmNsZWFyQ29sb3I7XG5cbiAgICAgICAgdGhpcy5mcmFtZUJ1ZmZlci5jbGVhcihjY1swXSwgY2NbMV0sIGNjWzJdLCBjY1szXSk7Ly8gcixnLGIsYSk7XG4gICAgfVxuXG4gICAgc2V0RnJhbWUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUpXG4gICAge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBkZXN0aW5hdGlvbkZyYW1lIHx8IHRoaXMuZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlZmF1bHRGcmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZSA9IHNvdXJjZUZyYW1lIHx8IHRoaXMuc291cmNlRnJhbWUgfHwgZGVzdGluYXRpb25GcmFtZTtcbiAgICB9XG5cbiAgICAvL+WcqFdlYkdMUmVuZGVyZXLkuK3ooqvosIPnlKhcbiAgICBhY3RpdmF0ZSgpXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgdGhpcy5mcmFtZUJ1ZmZlci5iaW5kKCk7XG5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuZGVzdGluYXRpb25GcmFtZSwgdGhpcy5zb3VyY2VGcmFtZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVzdGluYXRpb25GcmFtZSAhPT0gdGhpcy5zb3VyY2VGcmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgICAgICBnbC5zY2lzc29yKFxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS54IHwgMCxcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueSB8IDAsXG4gICAgICAgICAgICAgICAgKHRoaXMuZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIHRoaXMucmVzb2x1dGlvbikgfCAwLFxuICAgICAgICAgICAgICAgICh0aGlzLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKSB8IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC52aWV3cG9ydChcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS54IHwgMCxcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS55IHwgMCxcbiAgICAgICAgICAgICh0aGlzLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiB0aGlzLnJlc29sdXRpb24pIHwgMCxcbiAgICAgICAgICAgICh0aGlzLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKSB8IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvL+iuoeeul+aKleW9seefqemYte+8jOaKiuaJgOacieeahOmhtueCueaVsOaNruaKleWwhOWIsCB3ZWJnbCDnmoQgWy0xLDFdIOWdkOagh+ezu+WGheadpVxuICAgIGNhbGN1bGF0ZVByb2plY3Rpb24oZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUpXG4gICAge1xuICAgICAgICBjb25zdCBwbSA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcblxuICAgICAgICBzb3VyY2VGcmFtZSA9IHNvdXJjZUZyYW1lIHx8IGRlc3RpbmF0aW9uRnJhbWU7XG5cbiAgICAgICAgcG0uaWRlbnRpdHkoKTtcblxuICAgICAgICBwbS5hID0gMSAvIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiAyO1xuICAgICAgICBwbS5kID0gLTEgLyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAqIDI7XG5cbiAgICAgICAgcG0udHggPSAtMSAtIChzb3VyY2VGcmFtZS54ICogcG0uYSk7XG4gICAgICAgIHBtLnR5ID0gMSAtIChzb3VyY2VGcmFtZS55ICogcG0uZCk7XG4gICAgfVxuXG4gICAgLy9zdGFnZSDnmoQgc2l6ZeWPkeeUn+WPmOWMlu+8jOmcgOimgemHjeaWsOWIneWni+WMlui/meS6m+WvueixoeeahHNpemXvvIzlsKTlhbbmmK8gcHJvamVjdGlvbk1hdHJpeCDmipXlvbHkuL7or4FcbiAgICByZXNpemUod2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfCAwO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfCAwO1xuXG4gICAgICAgIGlmICh0aGlzLnNpemUud2lkdGggPT09IHdpZHRoICYmIHRoaXMuc2l6ZS5oZWlnaHQgPT09IGhlaWdodClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaXplLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0RnJhbWUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5kZWZhdWx0RnJhbWUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIucmVzaXplKHdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25GcmFtZSA9IHRoaXMuZnJhbWUgfHwgdGhpcy5zaXplO1xuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uRnJhbWUpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKVxuICAgIHtcbiAgICAgICAgdGhpcy5mcmFtZUJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIgPSBudWxsO1xuICAgIH1cbn1cbiIsIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0UmVuZGVyZXJcbntcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcilcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG5cbiAgICBzdGFydCgpXG4gICAge1xuICAgICAgICBcbiAgICB9XG5cbiAgICBzdG9wKClcbiAgICB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG5cbiAgICBmbHVzaCgpXG4gICAge1xuICAgICAgICBcbiAgICB9XG5cbiAgICBkZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIub2ZmKCdjb250ZXh0JywgdGhpcy5vbkNvbnRleHRDaGFuZ2UsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHJlbmRlcihvYmplY3QpIFxuICAgIHtcblxuICAgIH1cbn1cbiIsIlxuY29uc3QgREVQVEhfVEVTVCA9IDE7XG5jb25zdCBGUk9OVF9GQUNFID0gMjtcbmNvbnN0IENVTExfRkFDRSA9IDM7XG5cbi8qKlxuICogQSBXZWJHTCBzdGF0ZSBtYWNoaW5lc1xuICpcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xTdGF0ZVxue1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2wpXG4gICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzdGF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBibGVuZCBtb2RlLi5cbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGVbMF0gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBpbmRleCBpbiB0aGUgc3RhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFja0luZGV4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YWNrIGhvbGRpbmcgYWxsIHRoZSBkaWZmZXJlbnQgc3RhdGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PCo+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAgICAgdGhpcy5tYXhBdHRyaWJzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG5cbiAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZSA9IHtcbiAgICAgICAgICAgIHRlbXBBdHRyaWJTdGF0ZTogbmV3IEFycmF5KHRoaXMubWF4QXR0cmlicyksXG4gICAgICAgICAgICBhdHRyaWJTdGF0ZTogbmV3IEFycmF5KHRoaXMubWF4QXR0cmlicyksXG4gICAgICAgIH07XG5cblxuICAgICAgICAvLyBjaGVjayB3ZSBoYXZlIHZhby4uXG4gICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uID0gKFxuICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpXG4gICAgICAgICAgICB8fCBnbC5nZXRFeHRlbnNpb24oJ01PWl9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpXG4gICAgICAgICAgICB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgbmV3IGFjdGl2ZSBzdGF0ZVxuICAgICAqL1xuICAgIHB1c2goKVxuICAgIHtcbiAgICAgICAgLy8gbmV4dCBzdGF0ZS4uXG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhY2tbKyt0aGlzLnN0YWNrSW5kZXhdO1xuXG4gICAgICAgIGlmICghc3RhdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrSW5kZXhdID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSBzdGF0ZS4uXG4gICAgICAgIC8vIHNldCBhY3RpdmUgc3RhdGUgc28gd2UgY2FuIGZvcmNlIG92ZXJyaWRlcyBvZiBnbCBzdGF0ZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWN0aXZlU3RhdGUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbaV0gPSBzdGF0ZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvcHMgYSBzdGF0ZSBvdXRcbiAgICAgKi9cbiAgICBwb3AoKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YWNrWy0tdGhpcy5zdGFja0luZGV4XTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0RGVwdGhUZXN0KHN0YXRlW0RFUFRIX1RFU1RdKTtcbiAgICAgICAgdGhpcy5zZXRGcm9udEZhY2Uoc3RhdGVbRlJPTlRfRkFDRV0pO1xuICAgICAgICB0aGlzLnNldEN1bGxGYWNlKHN0YXRlW0NVTExfRkFDRV0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGRlcHRoIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgZGVwdGggdGVzdGluZy5cbiAgICAgKi9cbiAgICBzZXREZXB0aFRlc3QodmFsdWUpXG4gICAge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID8gMSA6IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU3RhdGVbREVQVEhfVEVTVF0gPT09IHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW0RFUFRIX1RFU1RdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xbdmFsdWUgPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10odGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgY3VsbCBmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGN1bGwgZmFjZS5cbiAgICAgKi9cbiAgICBzZXRDdWxsRmFjZSh2YWx1ZSlcbiAgICB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyAxIDogMDtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVTdGF0ZVtDVUxMX0ZBQ0VdID09PSB2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZVtDVUxMX0ZBQ0VdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZ2xbdmFsdWUgPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10odGhpcy5nbC5DVUxMX0ZBQ0UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdsIGZyb250IGZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gdHJ1ZSBpcyBjbG9ja3dpc2UgYW5kIGZhbHNlIGlzIGNvdW50ZXItY2xvY2t3aXNlXG4gICAgICovXG4gICAgc2V0RnJvbnRGYWNlKHZhbHVlKVxuICAgIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IDEgOiAwO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVN0YXRlW0ZST05UX0ZBQ0VdID09PSB2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZVtGUk9OVF9GQUNFXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmdsLmZyb250RmFjZSh0aGlzLmdsW3ZhbHVlID8gJ0NXJyA6ICdDQ1cnXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYWxsIHRoZSB2YW9zIGluIHVzZVxuICAgICAqXG4gICAgICovXG4gICAgcmVzZXRBdHRyaWJ1dGVzKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJTdGF0ZS50ZW1wQXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmliU3RhdGUudGVtcEF0dHJpYlN0YXRlW2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJTdGF0ZS5hdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZS5hdHRyaWJTdGF0ZVtpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbSBnb2luZyB0byBhc3N1bWUgb25lIGlzIGFsd2F5cyBhY3RpdmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5tYXhBdHRyaWJzOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXNlZFxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgdGhlIGxvZ2ljIGFuZCBkaXNhYmxlcyB0aGUgdmFvc1xuICAgICAqL1xuICAgIHJlc2V0VG9EZWZhdWx0KClcbiAgICB7XG4gICAgICAgIC8vIHVuYmluZCBhbnkgVkFPIGlmIHRoZXkgZXhpc3QuLlxuICAgICAgICBpZiAodGhpcy5uYXRpdmVWYW9FeHRlbnNpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IGFsbCBhdHRyaWJ1dGVzLi5cbiAgICAgICAgdGhpcy5yZXNldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAvLyBzZXQgYWN0aXZlIHN0YXRlIHNvIHdlIGNhbiBmb3JjZSBvdmVycmlkZXMgb2YgZ2wgc3RhdGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZVN0YXRlLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW2ldID0gMzI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5kZWZhdWx0U3RhdGUpO1xuICAgIH1cbn1cbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIGhleDJyZ2IoaGV4LCBvdXQpe1xuICAgIG91dCA9IG91dCB8fCBbXTtcblxuICAgIG91dFswXSA9ICgoaGV4ID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xuICAgIG91dFsxXSA9ICgoaGV4ID4+IDgpICYgMHhGRikgLyAyNTU7XG4gICAgb3V0WzJdID0gKGhleCAmIDB4RkYpIC8gMjU1O1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleDJzdHJpbmcoaGV4KXtcbiAgICAgaGV4ID0gaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgaGV4ID0gJzAwMDAwMCcuc3Vic3RyKDAsIDYgLSBoZXgubGVuZ3RoKSArIGhleDtcblxuICAgICByZXR1cm4gYCMke2hleH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiMmhleChyZ2Ipe1xuXHRyZXR1cm4gKCgocmdiWzBdICogMjU1KSA8PCAxNikgKyAoKHJnYlsxXSAqIDI1NSkgPDwgOCkgKyAocmdiWzJdICogMjU1KSk7XG59IiwiaW1wb3J0IGdsQ29yZSBmcm9tICdwaXhpLWdsLWNvcmUnO1xuXG4vKipcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIFdlYkdMIHNwZWNpZmljIHByb3BlcnRpZXMgdG8gYmUgdXNlZCBieSB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTEdyYXBoaWNzRGF0YVxue1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgICAqIEBwYXJhbSB7UElYSS5TaGFkZXJ9IHNoYWRlciAtIFRoZSBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cmlic1N0YXRlIC0gVGhlIHN0YXRlIGZvciB0aGUgVkFPXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2wsIHNoYWRlciwgYXR0cmlic1N0YXRlKVxuICAgIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAgICAgLy8gVE9ETyBkb2VzIHRoaXMgbmVlZCB0byBiZSBzcGxpdCBiZWZvcmUgdXBsb2FkaW5nPz9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGNvbG9yIGNvbXBvbmVudHMgKHIsZyxiKVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sb3IgPSBbMCwgMCwgMF07IC8vIGNvbG9yIHNwbGl0IVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiBwb2ludHMgdG8gZHJhd1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50W119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXNcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYWluIGJ1ZmZlclxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gZ2xDb3JlLkdMQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlcihnbCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBidWZmZXJcbiAgICAgICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2xDb3JlLkdMQnVmZmVyLmNyZWF0ZUluZGV4QnVmZmVyKGdsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGdyYXBoaWNzIGlzIGRpcnR5IG9yIG5vdFxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5nbFBvaW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2xJbmRpY2VzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcblxuICAgICAgICB0aGlzLnZhbyA9IG5ldyBnbENvcmUuVmVydGV4QXJyYXlPYmplY3QoZ2wsIGF0dHJpYnNTdGF0ZSlcbiAgICAgICAgLmFkZEluZGV4KHRoaXMuaW5kZXhCdWZmZXIpXG4gICAgICAgIC5hZGRBdHRyaWJ1dGUodGhpcy5idWZmZXIsIHNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogNiwgMClcbiAgICAgICAgLmFkZEF0dHJpYnV0ZSh0aGlzLmJ1ZmZlciwgc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAyICogNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSB2ZXJ0aWNlcyBhbmQgdGhlIGluZGljZXNcbiAgICAgKi9cbiAgICByZXNldCgpXG4gICAge1xuICAgICAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgYnVmZmVycyBhbmQgdXBsb2FkcyB0aGUgZGF0YVxuICAgICAqL1xuICAgIHVwbG9hZCgpXG4gICAge1xuICAgICAgICB0aGlzLmdsUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBvaW50cyk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnVwbG9hZCh0aGlzLmdsUG9pbnRzKTtcblxuICAgICAgICB0aGlzLmdsSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLnVwbG9hZCh0aGlzLmdsSW5kaWNlcyk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgYWxsIHRoZSBkYXRhXG4gICAgICovXG4gICAgZGVzdHJveSgpXG4gICAge1xuICAgICAgICB0aGlzLmNvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmFvLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZ2xQb2ludHMgPSBudWxsO1xuICAgICAgICB0aGlzLmdsSW5kaWNlcyA9IG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IGdsQ29yZSBmcm9tICdwaXhpLWdsLWNvcmUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuXG5jb25zdCB7IFBSRUNJU0lPTiB9ID0gc2V0dGluZ3M7XG5jb25zdCBHTFNoYWRlciA9IGdsQ29yZS5HTFNoYWRlclxuXG5mdW5jdGlvbiBjaGVja1ByZWNpc2lvbihzcmMpXG57XG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5KVxuICAgIHtcbiAgICAgICAgaWYgKHNyY1swXS5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gc3JjLnNsaWNlKDApO1xuXG4gICAgICAgICAgICBjb3B5LnVuc2hpZnQoYHByZWNpc2lvbiAke1BSRUNJU0lPTn0gZmxvYXQ7YCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNyYy5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGBwcmVjaXNpb24gJHtQUkVDSVNJT059IGZsb2F0O1xcbiR7c3JjfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNyYztcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzLCB3ZWJHTCBTaGFkZXIgZm9yIFBpeGkuXG4gKiBBZGRzIHByZWNpc2lvbiBzdHJpbmcgaWYgdmVydGV4U3JjIG9yIGZyYWdtZW50U3JjIGhhdmUgbm8gbWVudGlvbiBvZiBpdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEdMU2hhZGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXIgZXh0ZW5kcyBHTFNoYWRlclxue1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdmVydGV4U3JjIC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYylcbiAgICB7XG4gICAgICAgIHN1cGVyKGdsLCBjaGVja1ByZWNpc2lvbih2ZXJ0ZXhTcmMpLCBjaGVja1ByZWNpc2lvbihmcmFnbWVudFNyYykpO1xuICAgIH1cbn1cbiIsImltcG9ydCBTaGFkZXIgZnJvbSAnLi4vLi4vLi4vU2hhZGVyJztcblxuLyoqXG4gKiBUaGlzIHNoYWRlciBpcyB1c2VkIHRvIGRyYXcgc2ltcGxlIHByaW1pdGl2ZSBzaGFwZXMgZm9yIHtAbGluayBQSVhJLkdyYXBoaWNzfS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAZXh0ZW5kcyBQSVhJLlNoYWRlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmltaXRpdmVTaGFkZXIgZXh0ZW5kcyBTaGFkZXJcbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgd2ViZ2wgc2hhZGVyIG1hbmFnZXIgdGhpcyBzaGFkZXIgd29ya3MgZm9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdsKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZ2wsXG4gICAgICAgICAgICAvLyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjsnLFxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7JyxcblxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7JyxcblxuICAgICAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhOycsXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyB0aW50OycsXG5cbiAgICAgICAgICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOycsXG4gICAgICAgICAgICAgICAgJyAgIHZDb2xvciA9IGFDb2xvciAqIHZlYzQodGludCAqIGFscGhhLCBhbHBoYSk7JyxcbiAgICAgICAgICAgICAgICAnfScsXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgLy8gZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjNCB2Q29sb3I7JyxcblxuICAgICAgICAgICAgICAgICd2b2lkIG1haW4odm9pZCl7JyxcbiAgICAgICAgICAgICAgICAnICAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yOycsXG4gICAgICAgICAgICAgICAgJ30nLFxuICAgICAgICAgICAgXS5qb2luKCdcXG4nKVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vbWF0aC9pbmRleCc7XG5pbXBvcnQgeyBoZXgycmdiIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29sb3InO1xuXG4vKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhd1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgLy8gVE9ETyBPUFRJTUlTRSFcbiAgICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgbGluZSB3aWR0aCBpcyBhbiBvZGQgbnVtYmVyIGFkZCAwLjUgdG8gYWxpZ24gdG8gYSB3aG9sZSBwaXhlbFxuICAgIC8vIGNvbW1lbnRpbmcgdGhpcyBvdXQgZml4ZXMgIzcxMSBhbmQgIzE2MjBcbiAgICAvLyBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCUyKVxuICAgIC8vIHtcbiAgICAvLyAgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICAgcG9pbnRzW2ldICs9IDAuNTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIC8vIGdldCBmaXJzdCBhbmQgbGFzdCBwb2ludC4uIGZpZ3VyZSBvdXQgdGhlIG1pZGRsZSFcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICBsZXQgbGFzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXG4gICAgLy8gaWYgdGhlIGZpcnN0IHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IC0gZ29ubmEgaGF2ZSBpc3N1ZXMgOilcbiAgICBpZiAoZmlyc3RQb2ludC54ID09PSBsYXN0UG9pbnQueCAmJiBmaXJzdFBvaW50LnkgPT09IGxhc3RQb2ludC55KVxuICAgIHtcbiAgICAgICAgLy8gbmVlZCB0byBjbG9uZSBhcyB3ZSBhcmUgZ29pbmcgdG8gc2xpZ2h0bHkgbW9kaWZ5IHRoZSBzaGFwZS4uXG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5zbGljZSgpO1xuXG4gICAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgICAgcG9pbnRzLnBvcCgpO1xuXG4gICAgICAgIGxhc3RQb2ludCA9IG5ldyBQb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblxuICAgICAgICBjb25zdCBtaWRQb2ludFggPSBsYXN0UG9pbnQueCArICgoZmlyc3RQb2ludC54IC0gbGFzdFBvaW50LngpICogMC41KTtcbiAgICAgICAgY29uc3QgbWlkUG9pbnRZID0gbGFzdFBvaW50LnkgKyAoKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqIDAuNSk7XG5cbiAgICAgICAgcG9pbnRzLnVuc2hpZnQobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgICAgICBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgfVxuXG4gICAgY29uc3QgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgIGNvbnN0IGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcbiAgICBjb25zdCBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICBsZXQgaW5kZXhDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgLy8gRFJBVyB0aGUgTGluZVxuICAgIGNvbnN0IHdpZHRoID0gZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aCAvIDI7XG5cbiAgICAvLyBzb3J0IGNvbG9yXG4gICAgY29uc3QgY29sb3IgPSBoZXgycmdiKGdyYXBoaWNzRGF0YS5zdHJva2VTdHlsZSk7XG4gICAgY29uc3QgYWxwaGEgPSBncmFwaGljc0RhdGEubGluZUFscGhhO1xuICAgIGNvbnN0IHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgIGNvbnN0IGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgIGNvbnN0IGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgbGV0IHAxeCA9IHBvaW50c1swXTtcbiAgICBsZXQgcDF5ID0gcG9pbnRzWzFdO1xuICAgIGxldCBwMnggPSBwb2ludHNbMl07XG4gICAgbGV0IHAyeSA9IHBvaW50c1szXTtcbiAgICBsZXQgcDN4ID0gMDtcbiAgICBsZXQgcDN5ID0gMDtcblxuICAgIGxldCBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICBsZXQgcGVycHkgPSBwMXggLSBwMng7XG4gICAgbGV0IHBlcnAyeCA9IDA7XG4gICAgbGV0IHBlcnAyeSA9IDA7XG4gICAgbGV0IHBlcnAzeCA9IDA7XG4gICAgbGV0IHBlcnAzeSA9IDA7XG5cbiAgICBsZXQgZGlzdCA9IE1hdGguc3FydCgocGVycHggKiBwZXJweCkgKyAocGVycHkgKiBwZXJweSkpO1xuXG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgLy8gc3RhcnRcbiAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICBwMXggLSBwZXJweCxcbiAgICAgICAgcDF5IC0gcGVycHksXG4gICAgICAgIHIsIGcsIGIsIGFscGhhXG4gICAgKTtcblxuICAgIHZlcnRzLnB1c2goXG4gICAgICAgIHAxeCArIHBlcnB4LFxuICAgICAgICBwMXkgKyBwZXJweSxcbiAgICAgICAgciwgZywgYiwgYWxwaGFcbiAgICApO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpXG4gICAge1xuICAgICAgICBwMXggPSBwb2ludHNbKGkgLSAxKSAqIDJdO1xuICAgICAgICBwMXkgPSBwb2ludHNbKChpIC0gMSkgKiAyKSArIDFdO1xuXG4gICAgICAgIHAyeCA9IHBvaW50c1tpICogMl07XG4gICAgICAgIHAyeSA9IHBvaW50c1soaSAqIDIpICsgMV07XG5cbiAgICAgICAgcDN4ID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgICAgcDN5ID0gcG9pbnRzWygoaSArIDEpICogMikgKyAxXTtcblxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycHggKiBwZXJweCkgKyAocGVycHkgKiBwZXJweSkpO1xuICAgICAgICBwZXJweCAvPSBkaXN0O1xuICAgICAgICBwZXJweSAvPSBkaXN0O1xuICAgICAgICBwZXJweCAqPSB3aWR0aDtcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICAgICAgcGVycDJ4ID0gLShwMnkgLSBwM3kpO1xuICAgICAgICBwZXJwMnkgPSBwMnggLSBwM3g7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycDJ4ICogcGVycDJ4KSArIChwZXJwMnkgKiBwZXJwMnkpKTtcbiAgICAgICAgcGVycDJ4IC89IGRpc3Q7XG4gICAgICAgIHBlcnAyeSAvPSBkaXN0O1xuICAgICAgICBwZXJwMnggKj0gd2lkdGg7XG4gICAgICAgIHBlcnAyeSAqPSB3aWR0aDtcblxuICAgICAgICBjb25zdCBhMSA9ICgtcGVycHkgKyBwMXkpIC0gKC1wZXJweSArIHAyeSk7XG4gICAgICAgIGNvbnN0IGIxID0gKC1wZXJweCArIHAyeCkgLSAoLXBlcnB4ICsgcDF4KTtcbiAgICAgICAgY29uc3QgYzEgPSAoKC1wZXJweCArIHAxeCkgKiAoLXBlcnB5ICsgcDJ5KSkgLSAoKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KSk7XG4gICAgICAgIGNvbnN0IGEyID0gKC1wZXJwMnkgKyBwM3kpIC0gKC1wZXJwMnkgKyBwMnkpO1xuICAgICAgICBjb25zdCBiMiA9ICgtcGVycDJ4ICsgcDJ4KSAtICgtcGVycDJ4ICsgcDN4KTtcbiAgICAgICAgY29uc3QgYzIgPSAoKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpKSAtICgoLXBlcnAyeCArIHAyeCkgKiAoLXBlcnAyeSArIHAzeSkpO1xuXG4gICAgICAgIGxldCBkZW5vbSA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZGVub20pIDwgMC4xKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZW5vbSArPSAxMC4xO1xuICAgICAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICAgICAgICBwMnggLSBwZXJweCxcbiAgICAgICAgICAgICAgICBwMnkgLSBwZXJweSxcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICAgICAgICBwMnggKyBwZXJweCxcbiAgICAgICAgICAgICAgICBwMnkgKyBwZXJweSxcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBweCA9ICgoYjEgKiBjMikgLSAoYjIgKiBjMSkpIC8gZGVub207XG4gICAgICAgIGNvbnN0IHB5ID0gKChhMiAqIGMxKSAtIChhMSAqIGMyKSkgLyBkZW5vbTtcbiAgICAgICAgY29uc3QgcGRpc3QgPSAoKHB4IC0gcDJ4KSAqIChweCAtIHAyeCkpICsgKChweSAtIHAyeSkgKiAocHkgLSBwMnkpKTtcblxuICAgICAgICBpZiAocGRpc3QgPiAoMTk2ICogd2lkdGggKiB3aWR0aCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBlcnAzeCA9IHBlcnB4IC0gcGVycDJ4O1xuICAgICAgICAgICAgcGVycDN5ID0gcGVycHkgLSBwZXJwMnk7XG5cbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnAzeCAqIHBlcnAzeCkgKyAocGVycDN5ICogcGVycDN5KSk7XG4gICAgICAgICAgICBwZXJwM3ggLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnAzeSAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDN4ICo9IHdpZHRoO1xuICAgICAgICAgICAgcGVycDN5ICo9IHdpZHRoO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC0gcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnAzeCwgcDJ5ICsgcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC0gcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBpbmRleENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHB4LCBweSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocHggLSBwMngpLCBwMnkgLSAocHkgLSBwMnkpKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcDF4ID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDJdO1xuICAgIHAxeSA9IHBvaW50c1soKGxlbmd0aCAtIDIpICogMikgKyAxXTtcblxuICAgIHAyeCA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgICBwMnkgPSBwb2ludHNbKChsZW5ndGggLSAxKSAqIDIpICsgMV07XG5cbiAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICBwZXJweSA9IHAxeCAtIHAyeDtcblxuICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcbiAgICBwZXJweCAvPSBkaXN0O1xuICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgcGVycHggKj0gd2lkdGg7XG4gICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4LCBwMnkgLSBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4LCBwMnkgKyBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4Q291bnQ7ICsraSlcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0KyspO1xuICAgIH1cblxuICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0IC0gMSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlKSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBzaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBzaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKHNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICAvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB2YXIgcCA9IGVhci5uZXh0WjtcblxuICAgIHdoaWxlIChwICYmIHAueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICBwID0gZWFyLnByZXZaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgICAgIHZhciBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICAgIH1cbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGh4ID09PSBxeCkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbS5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFTaXplID09PSAwIHx8ICFxKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHAueiA8PSBxLnopIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIHNpemUgb2YgdGhlIGRhdGEgYm91bmRpbmcgYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpIC8gc2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpIC8gc2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LngpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpO1xufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIGlmICgoZXF1YWxzKHAxLCBxMSkgJiYgZXF1YWxzKHAyLCBxMikpIHx8XG4gICAgICAgIChlcXVhbHMocDEsIHEyKSAmJiBlcXVhbHMocDIsIHExKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgICAgYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IGFyZWEocDIsIHEyLCBxMSkgPiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRpY2UgaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSBudWxsO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsImltcG9ydCBidWlsZExpbmUgZnJvbSAnLi9idWlsZExpbmUnO1xuaW1wb3J0IHsgaGV4MnJnYiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuLyoqXG4gKiBCdWlsZHMgYSBwb2x5Z29uIHRvIGRyYXdcbiAqXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YSAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRQb2x5KGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBncmFwaGljc0RhdGEuc2hhcGUucG9pbnRzLnNsaWNlKCk7XG5cbiAgICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbCAmJiBwb2ludHMubGVuZ3RoID49IDYpXG4gICAge1xuICAgICAgICBjb25zdCBob2xlQXJyYXkgPSBbXTtcbiAgICAgICAgLy8gUHJvY2VzcyBob2xlcy4uXG4gICAgICAgIGNvbnN0IGhvbGVzID0gZ3JhcGhpY3NEYXRhLmhvbGVzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGhvbGUgPSBob2xlc1tpXTtcblxuICAgICAgICAgICAgaG9sZUFycmF5LnB1c2gocG9pbnRzLmxlbmd0aCAvIDIpO1xuXG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGhvbGUucG9pbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBmaXJzdCBhbmQgbGFzdCBwb2ludC4uIGZpZ3VyZSBvdXQgdGhlIG1pZGRsZSFcbiAgICAgICAgY29uc3QgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG5cbiAgICAgICAgLy8gc29ydCBjb2xvclxuICAgICAgICBjb25zdCBjb2xvciA9IGhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxTdHlsZSk7XG4gICAgICAgIGNvbnN0IGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcbiAgICAgICAgY29uc3QgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIGNvbnN0IGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICBjb25zdCBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICBjb25zdCB0cmlhbmdsZXMgPSBlYXJjdXQocG9pbnRzLCBob2xlQXJyYXksIDIpO1xuXG4gICAgICAgIGlmICghdHJpYW5nbGVzKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gNjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVydFBvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kgKyAyXSArIHZlcnRQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmVydHMucHVzaChwb2ludHNbaSAqIDJdLCBwb2ludHNbKGkgKiAyKSArIDFdLFxuICAgICAgICAgICAgICAgIHIsIGcsIGIsIGFscGhhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoID4gMClcbiAgICB7XG4gICAgICAgIGJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IGJ1aWxkTGluZSBmcm9tICcuL2J1aWxkTGluZSc7XG5pbXBvcnQgeyBoZXgycmdiIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29sb3InO1xuXG4vKipcbiAqIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkUmVjdGFuZ2xlKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIC8vIC0tLSAvL1xuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgIC8vXG4gICAgY29uc3QgcmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgY29uc3QgeCA9IHJlY3REYXRhLng7XG4gICAgY29uc3QgeSA9IHJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmZpbGwpXG4gICAge1xuICAgICAgICBjb25zdCBjb2xvciA9IGhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxTdHlsZSk7XG4gICAgICAgIGNvbnN0IGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICBjb25zdCByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgY29uc3QgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIGNvbnN0IGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIGNvbnN0IHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIGNvbnN0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgICAgIC8vIHN0YXJ0XG4gICAgICAgIHZlcnRzLnB1c2goeCwgeSk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgIHZlcnRzLnB1c2goeCArIHdpZHRoLCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXG4gICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAzLCB2ZXJ0UG9zICsgMyk7XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGgpXG4gICAge1xuICAgICAgICBjb25zdCB0ZW1wUG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW3gsIHksXG4gICAgICAgICAgICB4ICsgd2lkdGgsIHksXG4gICAgICAgICAgICB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsXG4gICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgeCwgeV07XG5cbiAgICAgICAgYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59XG4iLCJpbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQgYnVpbGRMaW5lIGZyb20gJy4vYnVpbGRMaW5lJztcbmltcG9ydCB7IGhleDJyZ2IgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb2xvcic7XG5cbi8qKlxuICogQnVpbGRzIGEgcm91bmRlZCByZWN0YW5nbGUgdG8gZHJhd1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSB3ZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFJvdW5kZWRSZWN0YW5nbGUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgY29uc3QgcnJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgIGNvbnN0IHggPSBycmVjdERhdGEueDtcbiAgICBjb25zdCB5ID0gcnJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSBycmVjdERhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcnJlY3REYXRhLmhlaWdodDtcblxuICAgIGNvbnN0IHJhZGl1cyA9IHJyZWN0RGF0YS5yYWRpdXM7XG5cbiAgICBjb25zdCByZWNQb2ludHMgPSBbXTtcblxuICAgIHJlY1BvaW50cy5wdXNoKHgsIHkgKyByYWRpdXMpO1xuICAgIHF1YWRyYXRpY0JlemllckN1cnZlKHgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHgsIHkgKyBoZWlnaHQsIHggKyByYWRpdXMsIHkgKyBoZWlnaHQsIHJlY1BvaW50cyk7XG4gICAgcXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cywgcmVjUG9pbnRzKTtcbiAgICBxdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGgsIHkgKyByYWRpdXMsIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoIC0gcmFkaXVzLCB5LCByZWNQb2ludHMpO1xuICAgIHF1YWRyYXRpY0JlemllckN1cnZlKHggKyByYWRpdXMsIHksIHgsIHksIHgsIHkgKyByYWRpdXMgKyAwLjAwMDAwMDAwMDEsIHJlY1BvaW50cyk7XG5cbiAgICAvLyB0aGlzIHRpbnkgbnVtYmVyIGRlYWxzIHdpdGggdGhlIGlzc3VlIHRoYXQgb2NjdXJzIHdoZW4gcG9pbnRzIG92ZXJsYXAgYW5kIGVhcmN1dCBmYWlscyB0byB0cmlhbmd1bGF0ZSB0aGUgaXRlbS5cbiAgICAvLyBUT0RPIC0gZml4IHRoaXMgcHJvcGVybHksIHRoaXMgaXMgbm90IHZlcnkgZWxlZ2FudC4uIGJ1dCBpdCB3b3JrcyBmb3Igbm93LlxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5maWxsKVxuICAgIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBoZXgycmdiKGdyYXBoaWNzRGF0YS5maWxsU3R5bGUpO1xuICAgICAgICBjb25zdCBhbHBoYSA9IGdyYXBoaWNzRGF0YS5maWxsQWxwaGE7XG5cbiAgICAgICAgY29uc3QgciA9IGNvbG9yWzBdICogYWxwaGE7XG4gICAgICAgIGNvbnN0IGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgICAgICBjb25zdCBiID0gY29sb3JbMl0gKiBhbHBoYTtcblxuICAgICAgICBjb25zdCB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSB3ZWJHTERhdGEuaW5kaWNlcztcblxuICAgICAgICBjb25zdCB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IGVhcmN1dChyZWNQb2ludHMsIG51bGwsIDIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGo7IGkgKz0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVjUG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gcmVjUG9pbnRzLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmVydHMucHVzaChyZWNQb2ludHNbaV0sIHJlY1BvaW50c1srK2ldLCByLCBnLCBiLCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVXaWR0aClcbiAgICB7XG4gICAgICAgIGNvbnN0IHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSByZWNQb2ludHM7XG5cbiAgICAgICAgYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS4gKGhlbHBlciBmdW5jdGlvbi4uKVxuICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVggLSBPcmlnaW4gcG9pbnQgeFxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21ZIC0gT3JpZ2luIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHBhcmFtIHtudW1iZXJbXX0gW291dD1bXV0gLSBUaGUgb3V0cHV0IGFycmF5IHRvIGFkZCBwb2ludHMgaW50by4gSWYgbm90IHBhc3NlZCwgYSBuZXcgYXJyYXkgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSBvZiBwb2ludHNcbiAqL1xuZnVuY3Rpb24gcXVhZHJhdGljQmV6aWVyQ3VydmUoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1ksIG91dCA9IFtdKVxue1xuICAgIGNvbnN0IG4gPSAyMDtcbiAgICBjb25zdCBwb2ludHMgPSBvdXQ7XG5cbiAgICBsZXQgeGEgPSAwO1xuICAgIGxldCB5YSA9IDA7XG4gICAgbGV0IHhiID0gMDtcbiAgICBsZXQgeWIgPSAwO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG5cbiAgICBmdW5jdGlvbiBnZXRQdChuMSwgbjIsIHBlcmMpXG4gICAge1xuICAgICAgICBjb25zdCBkaWZmID0gbjIgLSBuMTtcblxuICAgICAgICByZXR1cm4gbjEgKyAoZGlmZiAqIHBlcmMpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8PSBuOyArK2kpXG4gICAge1xuICAgICAgICBqID0gaSAvIG47XG5cbiAgICAgICAgLy8gVGhlIEdyZWVuIExpbmVcbiAgICAgICAgeGEgPSBnZXRQdChmcm9tWCwgY3BYLCBqKTtcbiAgICAgICAgeWEgPSBnZXRQdChmcm9tWSwgY3BZLCBqKTtcbiAgICAgICAgeGIgPSBnZXRQdChjcFgsIHRvWCwgaik7XG4gICAgICAgIHliID0gZ2V0UHQoY3BZLCB0b1ksIGopO1xuXG4gICAgICAgIC8vIFRoZSBCbGFjayBEb3RcbiAgICAgICAgeCA9IGdldFB0KHhhLCB4Yiwgaik7XG4gICAgICAgIHkgPSBnZXRQdCh5YSwgeWIsIGopO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG59XG4iLCJpbXBvcnQgYnVpbGRMaW5lIGZyb20gJy4vYnVpbGRMaW5lJztcbmltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uLy4uLy4uL2NvbnN0JztcbmltcG9ydCB7IGhleDJyZ2IgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb2xvcic7XG5cbi8qKlxuICogQnVpbGRzIGEgY2lyY2xlIHRvIGRyYXdcbiAqXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIGRyYXdcbiAqIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkQ2lyY2xlKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIFxuICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgIGNvbnN0IGNpcmNsZURhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgY29uc3QgeCA9IGNpcmNsZURhdGEueDtcbiAgICBjb25zdCB5ID0gY2lyY2xlRGF0YS55O1xuICAgIGxldCB3aWR0aDtcbiAgICBsZXQgaGVpZ2h0O1xuXG4gICAgLy8gVE9ETyAtIGJpdCBoYWNreT8/XG4gICAgaWYgKGdyYXBoaWNzRGF0YS50eXBlID09PSBTSEFQRVMuQ0lSQylcbiAgICB7XG4gICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS5yYWRpdXM7XG4gICAgICAgIGhlaWdodCA9IGNpcmNsZURhdGEucmFkaXVzO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGNpcmNsZURhdGEuaGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsU2VncyA9IE1hdGguZmxvb3IoMzAgKiBNYXRoLnNxcnQoY2lyY2xlRGF0YS5yYWRpdXMpKVxuICAgICAgICB8fCBNYXRoLmZsb29yKDE1ICogTWF0aC5zcXJ0KGNpcmNsZURhdGEud2lkdGggKyBjaXJjbGVEYXRhLmhlaWdodCkpO1xuXG4gICAgY29uc3Qgc2VnID0gKE1hdGguUEkgKiAyKSAvIHRvdGFsU2VncztcblxuICAgIGlmIChncmFwaGljc0RhdGEuZmlsbClcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbFN0eWxlKTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIGNvbnN0IHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICBjb25zdCBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgY29uc3QgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgY29uc3QgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgbGV0IHZlY1BvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1Bvcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFNlZ3MgKyAxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeCwgeSwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgICAgIHggKyAoTWF0aC5zaW4oc2VnICogaSkgKiB3aWR0aCksXG4gICAgICAgICAgICAgICAgeSArIChNYXRoLmNvcyhzZWcgKiBpKSAqIGhlaWdodCksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MrKywgdmVjUG9zKyspO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1BvcyAtIDEpO1xuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoKVxuICAgIHtcbiAgICAgICAgY29uc3QgdGVtcFBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxTZWdzICsgMTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgeCArIChNYXRoLnNpbihzZWcgKiBpKSAqIHdpZHRoKSxcbiAgICAgICAgICAgICAgICB5ICsgKE1hdGguY29zKHNlZyAqIGkpICogaGVpZ2h0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSk7XG5cbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IHRlbXBQb2ludHM7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaGV4MnJnYiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbG9yJztcbmltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uLy4uL2NvbnN0JztcbmltcG9ydCBPYmplY3RSZW5kZXJlciBmcm9tICcuLi8uLi9yZW5kZXJlcnMvd2ViZ2wvdXRpbHMvT2JqZWN0UmVuZGVyZXInO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXInO1xuaW1wb3J0IFdlYkdMR3JhcGhpY3NEYXRhIGZyb20gJy4vV2ViR0xHcmFwaGljc0RhdGEnO1xuaW1wb3J0IFByaW1pdGl2ZVNoYWRlciBmcm9tICcuL3NoYWRlcnMvUHJpbWl0aXZlU2hhZGVyJztcblxuaW1wb3J0IGJ1aWxkUG9seSBmcm9tICcuL3V0aWxzL2J1aWxkUG9seSc7XG5pbXBvcnQgYnVpbGRSZWN0YW5nbGUgZnJvbSAnLi91dGlscy9idWlsZFJlY3RhbmdsZSc7XG5pbXBvcnQgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIGZyb20gJy4vdXRpbHMvYnVpbGRSb3VuZGVkUmVjdGFuZ2xlJztcbmltcG9ydCBidWlsZENpcmNsZSBmcm9tICcuL3V0aWxzL2J1aWxkQ2lyY2xlJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaGljc1JlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXJcbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIgdGhpcyBvYmplY3QgcmVuZGVyZXIgd29ya3MgZm9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhUG9vbCA9IFtdO1xuXG4gICAgICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLmdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgLy8gZWFzeSBhY2Nlc3MhXG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgV2ViR0wgY29udGV4dCBjaGFuZ2VcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNvbnRleHRDaGFuZ2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICAgICAgICB0aGlzLnByaW1pdGl2ZVNoYWRlciA9IG5ldyBQcmltaXRpdmVTaGFkZXIodGhpcy5nbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyByZW5kZXJlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKVxuICAgIHtcbiAgICAgICAgT2JqZWN0UmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhUG9vbC5sZW5ndGg7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhUG9vbCA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdyYXBoaWNzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc30gZ3JhcGhpY3MgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIHJlbmRlci5cbiAgICAgKi9cbiAgICByZW5kZXIoIGRpc3BsYXlPYmplY3QgKVxuICAgIHtcbiAgICAgICAgY29uc3QgZ3JhcGhpY3MgPSBkaXNwbGF5T2JqZWN0LmdyYXBoaWNzO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgbGV0IHdlYkdMRGF0YTtcbiAgICAgICAgbGV0IHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW3RoaXMuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIGlmICghd2ViR0wgfHwgZ3JhcGhpY3MuZGlydHkgIT09IHdlYkdMLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdyYXBoaWNzKGdyYXBoaWNzKTtcblxuICAgICAgICAgICAgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzICBjb3VsZCBiZSBzcGVlZGVkIHVwIGZvciBzdXJlIVxuICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnByaW1pdGl2ZVNoYWRlcjtcblxuICAgICAgICByZW5kZXJlci5iaW5kU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB3ZWJHTC5kYXRhLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlclRlbXAgPSB3ZWJHTERhdGEuc2hhZGVyO1xuXG4gICAgICAgICAgICByZW5kZXJlci5iaW5kU2hhZGVyKHNoYWRlclRlbXApO1xuXG4gICAgICAgICAgICB2YXIgZ2xvYmFsTWF0cml4ID0gZGlzcGxheU9iamVjdC5nZXRDb25jYXRlbmF0ZWRNYXRyaXgoKS50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgc2hhZGVyVGVtcC51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IGdsb2JhbE1hdHJpeDtcbiAgICAgICAgICAgIHNoYWRlclRlbXAudW5pZm9ybXMudGludCA9IGhleDJyZ2IoZ3JhcGhpY3MudGludCk7XG4gICAgICAgICAgICBzaGFkZXJUZW1wLnVuaWZvcm1zLmFscGhhID0gZ3JhcGhpY3Mud29ybGRBbHBoYTtcblxuICAgICAgICAgICAgcmVuZGVyZXIuYmluZFZhbyh3ZWJHTERhdGEudmFvKTtcbiAgICAgICAgICAgIHdlYkdMRGF0YS52YW8uZHJhdyhnbC5UUklBTkdMRV9TVFJJUCwgd2ViR0xEYXRhLmluZGljZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdyYXBoaWNzIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gVGhlIGdyYXBoaWNzIG9iamVjdCB0byB1cGRhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVHcmFwaGljcyhncmFwaGljcylcbiAgICB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5yZW5kZXJlci5nbDtcblxuICAgICAgICAgLy8gZ2V0IHRoZSBjb250ZXh0cyBncmFwaGljcyBvYmplY3RcbiAgICAgICAgbGV0IHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW3RoaXMuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIC8vIGlmIHRoZSBncmFwaGljcyBvYmplY3QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHdlYkdMIGNvbnRleHQgdGltZSB0byBjcmVhdGUgaXQhXG4gICAgICAgIGlmICghd2ViR0wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW3RoaXMuQ09OVEVYVF9VSURdID0geyBsYXN0SW5kZXg6IDAsIGRhdGE6IFtdLCBnbCwgY2xlYXJEaXJ0eTogLTEsIGRpcnR5OiAtMSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmxhZyB0aGUgZ3JhcGhpY3MgYXMgbm90IGRpcnR5IGFzIHdlIGFyZSBhYm91dCB0byB1cGRhdGUgaXQuLi5cbiAgICAgICAgd2ViR0wuZGlydHkgPSBncmFwaGljcy5kaXJ0eTtcblxuICAgICAgICAvLyBpZiB0aGUgdXNlciBjbGVhcmVkIHRoZSBncmFwaGljcyBvYmplY3Qgd2Ugd2lsbCBuZWVkIHRvIGNsZWFyIGV2ZXJ5IG9iamVjdFxuICAgICAgICBpZiAoZ3JhcGhpY3MuY2xlYXJEaXJ0eSAhPT0gd2ViR0wuY2xlYXJEaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0wuY2xlYXJEaXJ0eSA9IGdyYXBoaWNzLmNsZWFyRGlydHk7XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbmQgcmV0dXJuIGFsbCB0aGUgd2ViR0xEYXRhcyB0byB0aGUgb2JqZWN0IHBvb2wgc28gdGhhbiBjYW4gYmUgcmV1c2VkIGxhdGVyIG9uXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlYkdMLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sLnB1c2god2ViR0wuZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBhcnJheSBhbmQgcmVzZXQgdGhlIGluZGV4Li5cbiAgICAgICAgICAgIHdlYkdMLmRhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHdlYkdMLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgd2ViR0xEYXRhO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgZ3JhcGhpY3MgZGF0YXMgYW5kIGNvbnN0cnVjdCBlYWNoIG9uZS4uXG4gICAgICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgYSBjb21wbGV4IGZpbGwgdGhlbiB0aGUgbmV3IHN0ZW5jaWwgYnVmZmVyIHRlY2huaXF1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgLy8gb3RoZXIgd2lzZSBncmFwaGljcyBvYmplY3RzIHdpbGwgYmUgcHVzaGVkIGludG8gYSBiYXRjaC4uXG4gICAgICAgIGZvciAobGV0IGkgPSB3ZWJHTC5sYXN0SW5kZXg7IGkgPCBncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBncmFwaGljcy5ncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgICAgIC8vIFRPRE8gLSB0aGlzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgICAgICAgICB3ZWJHTERhdGEgPSB0aGlzLmdldFdlYkdMRGF0YSh3ZWJHTCwgMCk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09IFNIQVBFUy5QT0xZKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJ1aWxkUG9seShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLlJFQ1QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnVpbGRSZWN0YW5nbGUoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLkNJUkMgfHwgZGF0YS50eXBlID09PSBTSEFQRVMuRUxJUClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBidWlsZENpcmNsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuUlJFQylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBidWlsZFJvdW5kZWRSZWN0YW5nbGUoZGF0YSwgd2ViR0xEYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2ViR0wubGFzdEluZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmJpbmRWYW8obnVsbCk7XG5cbiAgICAgICAgLy8gdXBsb2FkIGFsbCB0aGUgZGlydHkgZGF0YS4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlYkdMLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbaV07XG5cbiAgICAgICAgICAgIGlmICh3ZWJHTERhdGEuZGlydHkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2ViR0xEYXRhLnVwbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIHRoZSBjdXJyZW50IFdlYkdMIGRyYXdpbmcgY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIC0gVE9ETyBAQWx2aW5cbiAgICAgKiBAcmV0dXJuIHsqfSBUT0RPXG4gICAgICovXG4gICAgZ2V0V2ViR0xEYXRhKGdsLCB0eXBlKVxuICAgIHtcbiAgICAgICAgbGV0IHdlYkdMRGF0YSA9IGdsLmRhdGFbZ2wuZGF0YS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoIXdlYkdMRGF0YSB8fCB3ZWJHTERhdGEucG9pbnRzLmxlbmd0aCA+IDMyMDAwMClcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5ncmFwaGljc0RhdGFQb29sLnBvcCgpXG4gICAgICAgICAgICAgICAgfHwgbmV3IFdlYkdMR3JhcGhpY3NEYXRhKHRoaXMucmVuZGVyZXIuZ2wsIHRoaXMucHJpbWl0aXZlU2hhZGVyLCB0aGlzLnJlbmRlcmVyLnN0YXRlLmF0dHJpYnNTdGF0ZSk7XG5cbiAgICAgICAgICAgIHdlYkdMRGF0YS5yZXNldCh0eXBlKTtcbiAgICAgICAgICAgIGdsLmRhdGEucHVzaCh3ZWJHTERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2ViR0xEYXRhLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gd2ViR0xEYXRhO1xuICAgIH1cbn0iLCJpbXBvcnQgUmVuZGVyVGFyZ2V0IGZyb20gJy4vdXRpbHMvUmVuZGVyVGFyZ2V0JztcbmltcG9ydCBPYmplY3RSZW5kZXJlciBmcm9tICcuL3V0aWxzL09iamVjdFJlbmRlcmVyJztcbmltcG9ydCBXZWJHTFN0YXRlIGZyb20gJy4vV2ViR0xTdGF0ZSc7XG5pbXBvcnQgZ2xDb3JlIGZyb20gJ3BpeGktZ2wtY29yZSc7XG5pbXBvcnQgeyBSRU5ERVJFUl9UWVBFICwgRFJBV19NT0RFU30gZnJvbSAnLi4vLi4vY29uc3QnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCBHcmFwaGljc1JlbmRlcmVyIGZyb20gJy4uLy4uL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXInO1xuXG5sZXQgQ09OVEVYVF9VSUQgPSAwO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMU3RhZ2VSZW5kZXJlclxue1xuXG4gICAgY29uc3RydWN0b3IoIHN0YWdlICwgYXBwICwgb3B0aW9ucyA9IHt9IClcbiAgICB7XG4gICAgICAgIHRoaXMudHlwZSA9IFJFTkRFUkVSX1RZUEUuV0VCR0w7XG4gICAgICAgIHRoaXMud2lkdGggPSBhcHAud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYXBwLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBzdGFnZS5jYW52YXM7XG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAqIOWkhOeQhuS4iuS4i+aWh+S4ouWkseWSjOaBouWkjVxuICAgICAgICAqIOS9oOeahFdlYkdM56iL5bqP5b+F6aG75pyJ5LiA5Liq55So5LqO5aSE55CG5LiK5LiL5paH5Lii5aSx77yITG9zdCBDb250ZXh077yJ55qE5py65Yi2XG4gICAgICAgICog5a+86Ie05LiK5LiL5paH5Lii5aSx55qE5Y6f5Zug77yaXG4gICAgICAgICog56e75Yqo6K6+5aSH55S15Yqb5LiN6LazXG4gICAgICAgICog5YW25LuW5aSW5Zug5a+86Ie0R1BV6YeN572uXG4gICAgICAgICog5b2T5rWP6KeI5Zmo5qCH562+6aG15aSE5LqO5ZCO5Y+w5pe277yM5rWP6KeI5Zmo5oqb5byD5LqG5LiK5LiL5paHXG4gICAgICAgICog6ICX6LS56LWE5rqQ6L+H5aSa77yM5rWP6KeI5Zmo5oqb5byD5LqG5LiK5LiL5paHXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlQ29udGV4dExvc3QgPSB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkID0gdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpO1xuXG4gXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDB4MDAwMDAwO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSAnIzAwMDAwMCc7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIHRoaXMuX2NvbnRleHRPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxwaGE6IG9wdGlvbnMudHJhbnNwYXJlbnQsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IG9wdGlvbnMuYW50aWFsaWFzLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBvcHRpb25zLnRyYW5zcGFyZW50ICYmIG9wdGlvbnMudHJhbnNwYXJlbnQgIT09ICdub3RNdWx0aXBsaWVkJyxcbiAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZW1wdHlSZW5kZXJlciA9IG5ldyBPYmplY3RSZW5kZXJlcih0aGlzKTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IHRoaXMuZW1wdHlSZW5kZXJlcjtcblxuICAgICAgICB0aGlzLmdsID0gb3B0aW9ucy5jb250ZXh0IHx8IGdsQ29yZS5jcmVhdGVDb250ZXh0KCB0aGlzLmNhbnZhcyAsIHRoaXMuX2NvbnRleHRPcHRpb25zKTtcblxuICAgICAgICB0aGlzLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSUQrKztcblxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFdlYkdMU3RhdGUodGhpcy5nbCk7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPSBudWxsO1xuXG5cbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICBcblxuICAgICAgICAvLyBtYXAgc29tZSB3ZWJHTCBibGVuZCBhbmQgZHJhd21vZGVzLi5cbiAgICAgICAgdGhpcy5kcmF3TW9kZXMgPSB0aGlzLm1hcFdlYkdMRHJhd01vZGVzKCk7XG5cbiAgICAgICAgdGhpcy53ZWJnbEdSID0gbmV3IEdyYXBoaWNzUmVuZGVyZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5faW5pdENvbnRleHQoKTtcbiAgICB9XG5cbiAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRDb250ZXh0KClcbiAgICB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgICAgICAvLyByZXN0b3JlIGEgY29udGV4dCBpZiBpdCB3YXMgcHJldmlvdXNseSBsb3N0XG4gICAgICAgIGlmIChnbC5pc0NvbnRleHRMb3N0KCkgJiYgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKS5yZXN0b3JlQ29udGV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5yZXNldFRvRGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoZ2wsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBzZXR0aW5ncy5SRVNPTFVUSU9OLCB0cnVlKTtcbiAgICAgICAgdGhpcy5yb290UmVuZGVyVGFyZ2V0LmNsZWFyQ29sb3IgPSB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhO1xuXG4gICAgICAgIHRoaXMuYmluZFJlbmRlclRhcmdldCh0aGlzLnJvb3RSZW5kZXJUYXJnZXQpO1xuXG4gICAgICAgIHRoaXMud2ViZ2xHUi5vbkNvbnRleHRDaGFuZ2UoKTtcbiAgICB9XG5cblxuICAgIHJlbmRlcihkaXNwbGF5T2JqZWN0KVxuICAgIHtcblxuICAgICAgICBpZiAoIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0LmNsZWFyKCk7ICAgICAgICBcblxuICAgICAgICB0aGlzLndlYmdsR1IucmVuZGVyKCBkaXNwbGF5T2JqZWN0ICk7XG4gICAgICAgIC8vZGlzcGxheU9iamVjdC5yZW5kZXJXZWJHTCh0aGlzKTtcblxuICAgICAgICAvLyBhcHBseSB0cmFuc2Zvcm0uLlxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5PYmplY3RSZW5kZXJlcn0gb2JqZWN0UmVuZGVyZXIgLSBUaGUgb2JqZWN0IHJlbmRlcmVyIHRvIHVzZS5cbiAgICAgKi9cbiAgICBzZXRPYmplY3RSZW5kZXJlcihvYmplY3RSZW5kZXJlcilcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciA9PT0gb2JqZWN0UmVuZGVyZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSBvYmplY3RSZW5kZXJlcjtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaWYgeW91IHdpc2ggdG8gZG8gc29tZSBjdXN0b20gcmVuZGVyaW5nXG4gICAgICogSXQgd2lsbCBiYXNpY2FsbHkgcmVuZGVyIGFueXRoaW5nIHRoYXQgbWF5IGJlIGJhdGNoZWQgdXAgc3VjaCBhcyBzcHJpdGVzXG4gICAgICpcbiAgICAgKi9cbiAgICBmbHVzaCgpXG4gICAge1xuICAgICAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgd2ViR0wgdmlldyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgbmV3IHdpZHRoIG9mIHRoZSB3ZWJHTCB2aWV3XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB3ZWJHTCB2aWV3XG4gICAgICovXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgLy8gIGlmKHdpZHRoICogdGhpcy5yZXNvbHV0aW9uID09PSB0aGlzLndpZHRoICYmIGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbiA9PT0gdGhpcy5oZWlnaHQpcmV0dXJuO1xuXG4gICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldC5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldCA9PT0gdGhpcy5yb290UmVuZGVyVGFyZ2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJvb3RSZW5kZXJUYXJnZXQuYWN0aXZhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVNoYWRlcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVTaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucm9vdFJlbmRlclRhcmdldC5wcm9qZWN0aW9uTWF0cml4LnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEVyYXNlcyB0aGUgYWN0aXZlIHJlbmRlciB0YXJnZXQgYW5kIGZpbGxzIHRoZSBkcmF3aW5nIGFyZWEgd2l0aCBhIGNvbG91clxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjbGVhckNvbG9yXSAtIFRoZSBjb2xvdXJcbiAgICAgKi9cbiAgICBjbGVhcihjbGVhckNvbG9yKVxuICAgIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0LmNsZWFyKGNsZWFyQ29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgcmVuZGVyIHRhcmdldCB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0IC0gdGhlIG5ldyByZW5kZXIgdGFyZ2V0XG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICBiaW5kUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldClcbiAgICB7XG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQgIT09IHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVTaGFkZXIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSByZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2hhZGVyIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU2hhZGVyfSBzaGFkZXIgLSB0aGUgbmV3IHNoYWRlclxuICAgICAqIEByZXR1cm4ge1BJWEkuV2ViR0xSZW5kZXJlcn0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgYmluZFNoYWRlcihzaGFkZXIpXG4gICAge1xuICAgICAgICAvLyBUT0RPIGNhY2hlXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVTaGFkZXIgIT09IHNoYWRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gc2hhZGVyO1xuICAgICAgICAgICAgc2hhZGVyLmJpbmQoKTtcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWQU8gZnJvbSB0aGlzIHJlbmRlcmVyJ3MgY29udGV4dCBhbmQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWZXJ0ZXhBcnJheU9iamVjdH0gVGhlIG5ldyBWQU8uXG4gICAgICovXG4gICAgY3JlYXRlVmFvKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgZ2xDb3JlLlZlcnRleEFycmF5T2JqZWN0KHRoaXMuZ2wsIHRoaXMuc3RhdGUuYXR0cmliU3RhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgVmFvIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVmVydGV4QXJyYXlPYmplY3R9IHZhbyAtIHRoZSBuZXcgVmFvXG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICBiaW5kVmFvKHZhbylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gPT09IHZhbylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFvKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YW8uYmluZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2FjdGl2ZVZhbylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBhbHdheXMgYmUgdHJ1ZSBpIHRoaW5rP1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmFvLnVuYmluZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gdmFvO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgV2ViR0wgc3RhdGUgc28geW91IGNhbiByZW5kZXIgdGhpbmdzIGhvd2V2ZXIgeW91IGZhbmN5IVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5XZWJHTFJlbmRlcmVyfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICByZXNldCgpXG4gICAge1xuICAgICAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gdGhpcy5yb290UmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIG1haW4gZnJhbWUgYnVmZmVyICh0aGUgc2NyZWVuKTtcbiAgICAgICAgdGhpcy5yb290UmVuZGVyVGFyZ2V0LmFjdGl2YXRlKCk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5yZXNldFRvRGVmYXVsdCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtXZWJHTENvbnRleHRFdmVudH0gZXZlbnQgLSBUaGUgY29udGV4dCBsb3N0IGV2ZW50LlxuICAgICAqL1xuICAgIGhhbmRsZUNvbnRleHRMb3N0KGV2ZW50KVxuICAgIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgcmVzdG9yZWQgd2ViZ2wgY29udGV4dFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBoYW5kbGVDb250ZXh0UmVzdG9yZWQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5faW5pdENvbnRleHQoKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5yZW1vdmVBbGwoKTtcbiAgICB9XG5cbiAgICBtYXBXZWJHTERyYXdNb2Rlcyggb2JqZWN0PXt9IClcbiAgICB7XG4gICAgICAgIG9iamVjdFtEUkFXX01PREVTLlBPSU5UU10gPSB0aGlzLmdsLlBPSU5UUztcbiAgICAgICAgb2JqZWN0W0RSQVdfTU9ERVMuTElORVNdID0gdGhpcy5nbC5MSU5FUztcbiAgICAgICAgb2JqZWN0W0RSQVdfTU9ERVMuTElORV9MT09QXSA9IHRoaXMuZ2wuTElORV9MT09QO1xuICAgICAgICBvYmplY3RbRFJBV19NT0RFUy5MSU5FX1NUUklQXSA9IHRoaXMuZ2wuTElORV9TVFJJUDtcbiAgICAgICAgb2JqZWN0W0RSQVdfTU9ERVMuVFJJQU5HTEVTXSA9IHRoaXMuZ2wuVFJJQU5HTEVTO1xuICAgICAgICBvYmplY3RbRFJBV19NT0RFUy5UUklBTkdMRV9TVFJJUF0gPSB0aGlzLmdsLlRSSUFOR0xFX1NUUklQO1xuICAgICAgICBvYmplY3RbRFJBV19NT0RFUy5UUklBTkdMRV9GQU5dID0gdGhpcy5nbC5UUklBTkdMRV9GQU47XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciAoZXZlbnQgbGlzdGVuZXJzLCBzcHJpdGViYXRjaCwgZXRjLi4uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gLSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAgICogIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL2lzc3Vlcy8yMjMzXG4gICAgICovXG4gICAgZGVzdHJveShyZW1vdmVWaWV3KVxuICAgIHtcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2lucygpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy52aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcbiAgICAgICAgdGhpcy52aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQpO1xuXG4gICAgICAgIC8vIGNhbGwgYmFzZSBkZXN0cm95XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kocmVtb3ZlVmlldyk7XG5cbiAgICAgICAgdGhpcy51aWQgPSAwO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRMb3N0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NvbnRleHRPcHRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuXG4gICAgICAgIGlmICh0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKS5sb3NlQ29udGV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgfVxufSIsImltcG9ydCBTeXN0ZW1SZW5kZXJlciBmcm9tICcuLi9TeXN0ZW1SZW5kZXJlcic7XG5pbXBvcnQgeyBSRU5ERVJFUl9UWVBFIH0gZnJvbSAnLi4vLi4vY29uc3QnO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCBXZWJHTFN0YWdlUmVuZGVyZXIgZnJvbSBcIi4vV2ViR0xTdGFnZVJlbmRlcmVyXCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFJlbmRlcmVyIGV4dGVuZHMgU3lzdGVtUmVuZGVyZXJcbntcbiAgICBjb25zdHJ1Y3RvcihhcHAgLCBvcHRpb25zID0ge30pXG4gICAge1xuICAgICAgICBzdXBlcihSRU5ERVJFUl9UWVBFLkNBTlZBUywgYXBwLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZW5kZXIoIGFwcCAsIG9wdGlvbnMgPSB7fSApXG4gICAge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgbWUuYXBwID0gYXBwO1xuICAgICAgICBfLmV4dGVuZCggdGhpcy5vcHRpb25zICwgb3B0aW9ucyApO1xuXG4gICAgICAgIF8uZWFjaChfLnZhbHVlcyggYXBwLmNvbnZlcnRTdGFnZXMgKSAsIGZ1bmN0aW9uKGNvbnZlcnRTdGFnZSl7XG4gICAgICAgICAgICBtZS5yZW5kZXJTdGFnZSggY29udmVydFN0YWdlLnN0YWdlICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwcC5jb252ZXJ0U3RhZ2VzID0ge307XG4gICAgfVxuXG4gICAgcmVuZGVyU3RhZ2UoIHN0YWdlIClcbiAgICB7XG4gICAgICAgIGlmKCFzdGFnZS53ZWJHTFN0YWdlUmVuZGVyZXIpe1xuICAgICAgICAgICAgc3RhZ2Uud2ViR0xTdGFnZVJlbmRlcmVyID0gbmV3IFdlYkdMU3RhZ2VSZW5kZXJlciggc3RhZ2UgLCBhcHAgLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBzdGFnZS5zdGFnZVJlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbGVhciggc3RhZ2UgKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyKCBzdGFnZSApO1xuICAgICAgICBzdGFnZS5zdGFnZVJlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfcmVuZGVyKCBzdGFnZSAsIGRpc3BsYXlPYmplY3QgKVxuICAgIHtcbiAgICAgICAgaWYoICFkaXNwbGF5T2JqZWN0ICl7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0ID0gc3RhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoICFkaXNwbGF5T2JqZWN0LmNvbnRleHQudmlzaWJsZSB8fCBkaXNwbGF5T2JqZWN0LmNvbnRleHQuZ2xvYmFsQWxwaGEgPD0gMCApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBkaXNwbGF5T2JqZWN0LmdyYXBoaWNzICl7XG4gICAgICAgICAgICBzdGFnZS53ZWJHTFN0YWdlUmVuZGVyZXIucmVuZGVyKCBkaXNwbGF5T2JqZWN0ICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGRpc3BsYXlPYmplY3QuY2hpbGRyZW4gKXtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXIoIHN0YWdlICwgZGlzcGxheU9iamVjdC5jaGlsZHJlbltpXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jbGVhciggc3RhZ2UgKVxuICAgIHtcbiAgICAgICAgc3RhZ2Uud2ViR0xTdGFnZVJlbmRlcmVyLmNsZWFyKCk7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMvaW5kZXgnO1xuaW1wb3J0IENhbnZhc1JlbmRlcmVyIGZyb20gJy4vY2FudmFzL0NhbnZhc1JlbmRlcmVyJztcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gJy4vd2ViZ2wvV2ViR0xSZW5kZXJlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF1dG9SZW5kZXJlciggYXBwICwgb3B0aW9ucylcbntcbiAgICBpZiAoIWFwcC5ub1dlYkdMICYmIHV0aWxzLmlzV2ViR0xTdXBwb3J0ZWQoKSlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR0xSZW5kZXJlciggYXBwICwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDYW52YXNSZW5kZXJlciggYXBwICwgb3B0aW9ucyk7XG59XG4iLCIvKipcbiAqIEFwcGxpY2F0aW9uIHt7UEtHX1ZFUlNJT059fVxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiDkuLvlvJXmk44g57G7XG4gKlxuICog6LSf6LSj5omA5pyJY2FudmFz55qE5bGC57qn566h55CG77yM5ZKM5b+D6Lez5py65Yi255qE5a6e546wLOaNleiOt+WIsOW/g+i3s+WMheWQjiBcbiAqIOWIhuWPkeWIsOWvueW6lOeahHN0YWdlKGNhbnZhcynmnaXnu5jliLblr7nlupTnmoTmlLnliqhcbiAqIOeEtuWQjiDpu5jorqTmnInlrp7njrDkuoZzaGFwZeeahCBtb3VzZW92ZXIgIG1vdXNlb3V0ICBkcmFnIOS6i+S7tlxuICpcbiAqKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuL3V0aWxzL2luZGV4XCI7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gXCIuL2V2ZW50L0V2ZW50SGFuZGxlclwiO1xuaW1wb3J0IERpc3BsYXlPYmplY3RDb250YWluZXIgZnJvbSBcIi4vZGlzcGxheS9EaXNwbGF5T2JqZWN0Q29udGFpbmVyXCI7XG5pbXBvcnQgU3RhZ2UgZnJvbSBcIi4vZGlzcGxheS9TdGFnZVwiO1xuaW1wb3J0IGF1dG9SZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlcnMvYXV0b1JlbmRlcmVyXCI7XG5cblxuLy91dGlsc1xuaW1wb3J0IF8gZnJvbSBcIi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuaW1wb3J0ICQgZnJvbSBcIi4vdXRpbHMvZG9tXCI7XG5cblxudmFyIEFwcGxpY2F0aW9uID0gZnVuY3Rpb24oIG9wdCAsIG9wdGlvbnMgPSB7fSl7XG4gICAgdGhpcy50eXBlID0gXCJjYW52YXhcIjtcbiAgICB0aGlzLl9jaWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIFwiX1wiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjEwMCk7IFxuICAgIFxuICAgIHRoaXMuZWwgPSAkLnF1ZXJ5KG9wdC5lbCk7XG5cbiAgICB0aGlzLndpZHRoID0gcGFyc2VJbnQoXCJ3aWR0aFwiICBpbiBvcHQgfHwgdGhpcy5lbC5vZmZzZXRXaWR0aCAgLCAxMCk7IFxuICAgIHRoaXMuaGVpZ2h0ID0gcGFyc2VJbnQoXCJoZWlnaHRcIiBpbiBvcHQgfHwgdGhpcy5lbC5vZmZzZXRIZWlnaHQgLCAxMCk7IFxuXG4gICAgdmFyIHZpZXdPYmogPSAkLmNyZWF0ZVZpZXcodGhpcy53aWR0aCAsIHRoaXMuaGVpZ2h0LCB0aGlzLl9jaWQpO1xuICAgIHRoaXMudmlldyA9IHZpZXdPYmoudmlldztcbiAgICB0aGlzLnN0YWdlX2MgPSB2aWV3T2JqLnN0YWdlX2M7XG4gICAgdGhpcy5kb21fYyA9IHZpZXdPYmouZG9tX2M7XG4gICAgXG4gICAgdGhpcy5lbC5pbm5lckhUTUwgPSBcIlwiO1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoIHRoaXMudmlldyApO1xuXG4gICAgdGhpcy52aWV3T2Zmc2V0ID0gJC5vZmZzZXQodGhpcy52aWV3KTtcbiAgICB0aGlzLmxhc3RHZXRSTyA9IDA7Ly/mnIDlkI7kuIDmrKHojrflj5Ygdmlld09mZnNldCDnmoTml7bpl7RcblxuICAgIHRoaXMubm9XZWJHTCAgPSBvcHQubm9XZWJHTDtcbiAgICB0aGlzLnJlbmRlcmVyID0gYXV0b1JlbmRlcmVyKHRoaXMgLCBvcHRpb25zKTtcblxuICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fYnVmZmVyU3RhZ2UgPSBudWxsO1xuXG4gICAgLy/mmK/lkKbpmLvmraLmtY/op4jlmajpu5jorqTkuovku7bnmoTmiafooYxcbiAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICBpZiggb3B0LnByZXZlbnREZWZhdWx0ID09PSBmYWxzZSApe1xuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gZmFsc2VcbiAgICB9O1xuXG4gICAgLy/or6XlsZ7mgKflnKhzeXN0ZW5SZW5kZXLph4zpnaLmk43kvZzvvIzmr4/luKfnlLHlv4Pot7PkuIrmiqXnmoQg6ZyA6KaB6YeN57uY55qEc3RhZ2VzIOWIl+ihqFxuICAgIHRoaXMuY29udmVydFN0YWdlcyA9IHt9O1xuXG4gICAgQXBwbGljYXRpb24uc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuVXRpbHMuY3JlYXRDbGFzcyhBcHBsaWNhdGlvbiAsIERpc3BsYXlPYmplY3RDb250YWluZXIgLCB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuY29udGV4dC53aWR0aCAgPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmNvbnRleHQuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7IFxuXG4gICAgICAgIC8v54S25ZCO5Yib5bu65LiA5Liq55So5LqO57uY5Yi25r+A5rS7IHNoYXBlIOeahCBzdGFnZSDliLBhY3RpdmF0aW9uXG4gICAgICAgIHRoaXMuX2NyZWF0SG92ZXJTdGFnZSgpO1xuXG4gICAgICAgIC8v5Yib5bu65LiA5Liq5aaC5p6c6KaB55So5YOP57Sg5qOA5rWL55qE5pe25YCZ55qE5a655ZmoXG4gICAgICAgIHRoaXMuX2NyZWF0ZVBpeGVsQ29udGV4dCgpO1xuICAgICAgICBcbiAgICB9LFxuICAgIHJlZ2lzdEV2ZW50IDogZnVuY3Rpb24ob3B0KXtcbiAgICAgICAgLy/liJ3lp4vljJbkuovku7blp5TmiZjliLByb2905YWD57Sg5LiK6Z2iXG4gICAgICAgIHRoaXMuZXZlbnQgPSBuZXcgRXZlbnRIYW5kbGVyKCB0aGlzICwgb3B0KTs7XG4gICAgICAgIHRoaXMuZXZlbnQuaW5pdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudDtcbiAgICB9LFxuICAgIHJlc2l6ZSA6IGZ1bmN0aW9uKCBvcHQgKXtcbiAgICAgICAgLy/ph43mlrDorr7nva7lnZDmoIfns7vnu58g6auY5a69IOetieOAglxuICAgICAgICB0aGlzLndpZHRoICAgICAgPSBwYXJzZUludCgob3B0ICYmIFwid2lkdGhcIiBpbiBvcHQpIHx8IHRoaXMuZWwub2Zmc2V0V2lkdGggICwgMTApOyBcbiAgICAgICAgdGhpcy5oZWlnaHQgICAgID0gcGFyc2VJbnQoKG9wdCAmJiBcImhlaWdodFwiIGluIG9wdCkgfHwgdGhpcy5lbC5vZmZzZXRIZWlnaHQgLCAxMCk7IFxuXG4gICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCAgPSB0aGlzLndpZHRoICtcInB4XCI7XG4gICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCtcInB4XCI7XG5cbiAgICAgICAgdGhpcy52aWV3T2Zmc2V0ICAgICA9ICQub2Zmc2V0KHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuX25vdFdhdGNoICAgICAgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnRleHQud2lkdGggID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy5jb250ZXh0LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLl9ub3RXYXRjaCAgICAgID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHJlU2l6ZUNhbnZhcyAgICA9IGZ1bmN0aW9uKGN0eCl7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG1lLndpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodD0gbWUuaGVpZ2h0KyBcInB4XCI7XG4gICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiAgLCBtZS53aWR0aCAqIFV0aWxzLl9kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiAsIG1lLmhlaWdodCogVXRpbHMuX2RldmljZVBpeGVsUmF0aW8pO1xuXG4gICAgICAgICAgICAvL+WmguaenOaYr3N3ZueahOivneWwsei/mOimgeiwg+eUqOi/meS4quaWueazleOAglxuICAgICAgICAgICAgaWYgKGN0eC5yZXNpemUpIHtcbiAgICAgICAgICAgICAgICBjdHgucmVzaXplKG1lLndpZHRoICwgbWUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTsgXG4gICAgICAgIF8uZWFjaCh0aGlzLmNoaWxkcmVuICwgZnVuY3Rpb24ocyAsIGkpe1xuICAgICAgICAgICAgcy5fbm90V2F0Y2ggICAgID0gdHJ1ZTtcbiAgICAgICAgICAgIHMuY29udGV4dC53aWR0aCA9IG1lLndpZHRoO1xuICAgICAgICAgICAgcy5jb250ZXh0LmhlaWdodD0gbWUuaGVpZ2h0O1xuICAgICAgICAgICAgcmVTaXplQ2FudmFzKHMuY2FudmFzKTtcbiAgICAgICAgICAgIHMuX25vdFdhdGNoICAgICA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRvbV9jLnN0eWxlLndpZHRoICA9IHRoaXMud2lkdGggICsgXCJweFwiO1xuICAgICAgICB0aGlzLmRvbV9jLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgIHRoaXMuaGVhcnRCZWF0KCk7XG5cbiAgICB9LFxuICAgIGdldEhvdmVyU3RhZ2UgOiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyU3RhZ2U7XG4gICAgfSxcbiAgICBfY3JlYXRIb3ZlclN0YWdlIDogZnVuY3Rpb24oKXtcbiAgICAgICAgLy9UT0RPOuWIm+W7unN0YWdl55qE5pe25YCZ5LiA5a6a6KaB5Lyg5YWld2lkdGggaGVpZ2h0ICDkuKTkuKrlj4LmlbBcbiAgICAgICAgdGhpcy5fYnVmZmVyU3RhZ2UgPSBuZXcgU3RhZ2UoIHtcbiAgICAgICAgICAgIGlkIDogXCJhY3RpdkNhbnZhc1wiKyhuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgICAgICBjb250ZXh0IDoge1xuICAgICAgICAgICAgICAgIHdpZHRoIDogdGhpcy5jb250ZXh0LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5jb250ZXh0LmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG4gICAgICAgIC8v6K+lc3RhZ2XkuI3lj4LkuI7kuovku7bmo4DmtYtcbiAgICAgICAgdGhpcy5fYnVmZmVyU3RhZ2UuX2V2ZW50RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZENoaWxkKCB0aGlzLl9idWZmZXJTdGFnZSApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog55So5p2l5qOA5rWL5paH5pysd2lkdGggaGVpZ2h0IFxuICAgICAqIEByZXR1cm4ge09iamVjdH0g5LiK5LiL5paHXG4gICAgKi9cbiAgICBfY3JlYXRlUGl4ZWxDb250ZXh0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcGl4ZWxDYW52YXMgPSAkLnF1ZXJ5KFwiX3BpeGVsQ2FudmFzXCIpO1xuICAgICAgICBpZighX3BpeGVsQ2FudmFzKXtcbiAgICAgICAgICAgIF9waXhlbENhbnZhcyA9ICQuY3JlYXRlQ2FudmFzKDAsIDAsIFwiX3BpeGVsQ2FudmFzXCIpOyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8v5aaC5p6c5Y+I55qE6K+dIOWwseS4jemcgOimgeWcqOWIm+W7uuS6hlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBfcGl4ZWxDYW52YXMgKTtcbiAgICAgICAgVXRpbHMuaW5pdEVsZW1lbnQoIF9waXhlbENhbnZhcyApO1xuICAgICAgICBpZiggVXRpbHMuY2FudmFzU3VwcG9ydCgpICl7XG4gICAgICAgICAgICAvL2NhbnZhc+eahOivne+8jOWTquaAleaYr2Rpc3BsYXk6bm9uZeeahOmhteWPr+S7peeUqOadpeW3puWDj+e0oOajgOa1i+WSjG1lYXN1cmVUZXh05paH5pysd2lkdGjmo4DmtYtcbiAgICAgICAgICAgIF9waXhlbENhbnZhcy5zdHlsZS5kaXNwbGF5ICAgID0gXCJub25lXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2ZsYXNoQ2FudmFzIOeahOivne+8jHN3ZuWmguaenGRpc3BsYXk6bm9uZeS6huOAguWwseWBmuS4jeS6hm1lYXN1cmVUZXh0IOaWh+acrOWuveW6piDmo4DmtYvkuoZcbiAgICAgICAgICAgIF9waXhlbENhbnZhcy5zdHlsZS56SW5kZXggICAgID0gLTE7XG4gICAgICAgICAgICBfcGl4ZWxDYW52YXMuc3R5bGUucG9zaXRpb24gICA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIF9waXhlbENhbnZhcy5zdHlsZS5sZWZ0ICAgICAgID0gLXRoaXMuY29udGV4dC53aWR0aCAgKyBcInB4XCI7XG4gICAgICAgICAgICBfcGl4ZWxDYW52YXMuc3R5bGUudG9wICAgICAgICA9IC10aGlzLmNvbnRleHQuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgX3BpeGVsQ2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICAgIFV0aWxzLl9waXhlbEN0eCA9IF9waXhlbENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVWaWV3T2Zmc2V0IDogZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBpZiggbm93IC0gdGhpcy5sYXN0R2V0Uk8gPiAxMDAwICl7XG4gICAgICAgICAgICB0aGlzLnZpZXdPZmZzZXQgICAgICA9ICQub2Zmc2V0KHRoaXMudmlldyk7XG4gICAgICAgICAgICB0aGlzLmxhc3RHZXRSTyAgICAgICA9IG5vdztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgX2FmdGVyQWRkQ2hpbGQgOiBmdW5jdGlvbiggc3RhZ2UgLCBpbmRleCApe1xuICAgICAgICB2YXIgY2FudmFzO1xuXG4gICAgICAgIGlmKCFzdGFnZS5jYW52YXMpe1xuICAgICAgICAgICAgY2FudmFzID0gJC5jcmVhdGVDYW52YXMoIHRoaXMuY29udGV4dC53aWR0aCAsIHRoaXMuY29udGV4dC5oZWlnaHQsIHN0YWdlLmlkICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2VfYy5hcHBlbmRDaGlsZCggY2FudmFzICk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmNoaWxkcmVuLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBpZiggaW5kZXggPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIC8v5aaC5p6c5rKh5pyJ5oyH5a6a5L2N572u77yM6YKj5LmI5bCx5pS+5YiwX2J1ZmZlclN0YWdl55qE5LiL6Z2i44CCXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZV9jLmluc2VydEJlZm9yZSggY2FudmFzICwgdGhpcy5fYnVmZmVyU3RhZ2UuY2FudmFzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy/lpoLmnpzmnInmjIflrprnmoTkvY3nva7vvIzpgqPkuYjlsLHmjIflrprnmoTkvY3nva7mnaVcbiAgICAgICAgICAgICAgICBpZiggaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgtMSApe1xuICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2VfYy5hcHBlbmRDaGlsZCggY2FudmFzICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWdlX2MuaW5zZXJ0QmVmb3JlKCBjYW52YXMgLCB0aGlzLmNoaWxkcmVuWyBpbmRleCBdLmNhbnZhcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBVdGlscy5pbml0RWxlbWVudCggY2FudmFzICk7XG4gICAgICAgIHN0YWdlLmluaXRTdGFnZSggY2FudmFzICwgdGhpcy5jb250ZXh0LndpZHRoICwgdGhpcy5jb250ZXh0LmhlaWdodCApOyBcbiAgICB9LFxuICAgIF9hZnRlckRlbENoaWxkIDogZnVuY3Rpb24oc3RhZ2Upe1xuICAgICAgICB0aGlzLnN0YWdlX2MucmVtb3ZlQ2hpbGQoIHN0YWdlLmNhbnZhcyApO1xuICAgIH0sXG4gICAgXG4gICAgaGVhcnRCZWF0IDogZnVuY3Rpb24ob3B0KXtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5oZWFydEJlYXQob3B0KTtcbiAgICB9XG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcGxpY2F0aW9uOyIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOaooeaLn2FzMyDkuK0g55qEc3ByaXRl57G777yM55uu5YmN6L+Y5Y+q5piv5Liq566A5Y2V55qE5a655piT44CCXG4gKi9cbmltcG9ydCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIGZyb20gXCIuL0Rpc3BsYXlPYmplY3RDb250YWluZXJcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcblxudmFyIFNwcml0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy50eXBlID0gXCJzcHJpdGVcIjtcbiAgICBTcHJpdGUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuVXRpbHMuY3JlYXRDbGFzcyhTcHJpdGUgLCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyICwge1xuICAgIGluaXQgOiBmdW5jdGlvbigpe1xuICAgIFxuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTcHJpdGU7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaGljc0RhdGFcbntcbiAgICBjb25zdHJ1Y3RvcihsaW5lV2lkdGgsIHN0cm9rZVN0eWxlLCBsaW5lQWxwaGEsIGZpbGxTdHlsZSwgZmlsbEFscGhhLCBzaGFwZSlcbiAgICB7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICB0aGlzLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIHRoaXMubGluZUFscGhhID0gbGluZUFscGhhO1xuXG4gICAgICAgIHRoaXMuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICB0aGlzLmZpbGxBbHBoYSA9IGZpbGxBbHBoYTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy50eXBlID0gc2hhcGUudHlwZTtcblxuICAgICAgICB0aGlzLmhvbGVzID0gW107XG5cbiAgICAgICAgLy/ov5nkuKTkuKrlj6/ku6XooqvlkI7nu63kv67mlLnvvIwg5YW35pyJ5LiA56Wo5ZCm5Yaz5p2DXG4gICAgICAgIC8v5q+U5aaCcG9seWdvbueahCDomZrnur/mj4/ovrnjgILlv4XpobvlnKhmaWxs55qEcG9seeS4iumdouiuvue9rmxpbmXkuLpmYWxzZVxuICAgICAgICB0aGlzLmZpbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpbmUgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljc0RhdGEoXG4gICAgICAgICAgICB0aGlzLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICB0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgIHRoaXMuZmlsbFN0eWxlLFxuICAgICAgICAgICAgdGhpcy5maWxsQWxwaGEsXG4gICAgICAgICAgICB0aGlzLnNoYXBlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYWRkSG9sZShzaGFwZSlcbiAgICB7XG4gICAgICAgIHRoaXMuaG9sZXMucHVzaChzaGFwZSk7XG4gICAgfVxuXG4gICAgLy/ku47lrr/kuLtncmFwaGljc+S4reWQjOatpeacgOaWsOeahHN0eWxl5bGe5oCnXG4gICAgc3luc1N0eWxlKCBncmFwaGljcyApXG4gICAge1xuICAgICAgICAvL+S7jnNoYXBl5Lit5oqK57uY5Zu+6ZyA6KaB55qEc3R5bGXlsZ7mgKflkIzmraXov4fmnaVcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBncmFwaGljcy5saW5lV2lkdGg7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBncmFwaGljcy5zdHJva2VTdHlsZTtcbiAgICAgICAgdGhpcy5saW5lQWxwaGEgPSBncmFwaGljcy5saW5lQWxwaGE7XG5cbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBncmFwaGljcy5maWxsU3R5bGU7XG4gICAgICAgIHRoaXMuZmlsbEFscGhhID0gZ3JhcGhpY3MuZmlsbEFscGhhO1xuXG4gICAgfVxuXG4gICAgaGFzRmlsbCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxsU3R5bGUgJiZcbiAgICAgICAgICAgICAgIHRoaXMuZmlsbCAmJiBcbiAgICAgICAgICAgICAgICggdGhpcy5zaGFwZS5jbG9zZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNoYXBlLmNsb3NlZCApICYmIFxuICAgICAgICAgICAgICAgdGhpcy5maWxsQWxwaGE7XG4gICAgfVxuXG4gICAgaGFzTGluZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VTdHlsZSAmJiB0aGlzLmxpbmVXaWR0aCAmJiB0aGlzLmxpbmVBbHBoYSAmJiB0aGlzLmxpbmVcbiAgICB9XG5cbiAgICBkZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhvbGVzID0gbnVsbDtcbiAgICB9XG4gICAgXG59XG4iLCIvKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cbiAqXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVggLSBTdGFydGluZyBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVkgLSBTdGFydGluZyBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcn0gY3BYMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcltdfSBbcGF0aD1bXV0gLSBQYXRoIGFycmF5IHRvIHB1c2ggcG9pbnRzIGludG9cbiAqIEByZXR1cm4ge251bWJlcltdfSBBcnJheSBvZiBwb2ludHMgb2YgdGhlIGN1cnZlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJlemllckN1cnZlVG8oZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHBhdGggPSBbXSlcbntcbiAgICBjb25zdCBuID0gMjA7XG4gICAgbGV0IGR0ID0gMDtcbiAgICBsZXQgZHQyID0gMDtcbiAgICBsZXQgZHQzID0gMDtcbiAgICBsZXQgdDIgPSAwO1xuICAgIGxldCB0MyA9IDA7XG5cbiAgICBwYXRoLnB1c2goZnJvbVgsIGZyb21ZKTtcblxuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8PSBuOyArK2kpXG4gICAge1xuICAgICAgICBqID0gaSAvIG47XG5cbiAgICAgICAgZHQgPSAoMSAtIGopO1xuICAgICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgICBkdDMgPSBkdDIgKiBkdDtcblxuICAgICAgICB0MiA9IGogKiBqO1xuICAgICAgICB0MyA9IHQyICogajtcblxuICAgICAgICBwYXRoLnB1c2goXG4gICAgICAgICAgICAoZHQzICogZnJvbVgpICsgKDMgKiBkdDIgKiBqICogY3BYKSArICgzICogZHQgKiB0MiAqIGNwWDIpICsgKHQzICogdG9YKSxcbiAgICAgICAgICAgIChkdDMgKiBmcm9tWSkgKyAoMyAqIGR0MiAqIGogKiBjcFkpICsgKDMgKiBkdCAqIHQyICogY3BZMikgKyAodDMgKiB0b1kpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG59XG4iLCJcblxuLyoqXG4gKiDnur/mrrXljIXlkKvliKTmlq1cbiAqIEBwb2ludHMgWzAsMCwwLDBdXG4gKi9cbnZhciBfaXNJbnNpZGVMaW5lID0gZnVuY3Rpb24oIHBvaW50cywgeCwgeSwgbGluZVdpZHRoICkgXG57XG4gICAgdmFyIHgwID0gcG9pbnRzWzBdO1xuICAgIHZhciB5MCA9IHBvaW50c1sxXTtcbiAgICB2YXIgeDEgPSBwb2ludHNbMl07XG4gICAgdmFyIHkxID0gcG9pbnRzWzNdO1xuICAgIHZhciBfbCA9IE1hdGgubWF4KGxpbmVXaWR0aCAsIDMpO1xuICAgIHZhciBfYSA9IDA7XG4gICAgdmFyIF9iID0geDA7XG5cbiAgICBpZihcbiAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sKSBcbiAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sKSBcbiAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sKSBcbiAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sKSBcbiAgICApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHgwICE9PSB4MSkge1xuICAgICAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICAgICAgX2IgPSAoeDAgKiB5MSAtIHgxICogeTApIC8gKHgwIC0geDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh4IC0geDApIDw9IF9sIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgX3MgPSAoX2EgKiB4IC0geSArIF9iKSAqIChfYSAqIHggLSB5ICsgX2IpIC8gKF9hICogX2EgKyAxKTtcbiAgICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xufSBcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5zaWRlTGluZShkYXRhLCB4LCB5LCBsaW5lKSBcbnsgICBcbiAgICB2YXIgcG9pbnRzID0gZGF0YS5zaGFwZS5wb2ludHM7XG4gICAgdmFyIGxpbmVXaWR0aCA9IGRhdGEubGluZVdpZHRoO1xuICAgIHZhciBpbnNpZGVDYXRjaCA9IGZhbHNlO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpe1xuICAgICAgICBpbnNpZGVDYXRjaCA9IF9pc0luc2lkZUxpbmUoIHBvaW50cy5zbGljZShpICwgaSs0KSAsIHggLCB5ICwgbGluZVdpZHRoICk7XG4gICAgICAgIGlmKCBpbnNpZGVDYXRjaCApe1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICAgIGkgKz0gMVxuICAgIH07XG4gICAgcmV0dXJuIGluc2lkZUNhdGNoO1xufSIsIi8qXG4qIEdyYXBoaWNz57uY5Zu+5rOV5YiZXG4qIOWNleS4qmdyYWhpY3Plrp7kvovph4znmoRmaWxsIGxpbmUg5qC35byP5bGe5oCn77yM6YO95LuO5a+55bqUc2hhcGUuY29udGV4dOS4reiOt+WPllxuKiBcbiovXG5cbmltcG9ydCBHcmFwaGljc0RhdGEgZnJvbSAnLi9HcmFwaGljc0RhdGEnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlLCBFbGxpcHNlLCBQb2x5Z29uLCBDaXJjbGUgfSBmcm9tICcuLi9tYXRoL2luZGV4JztcbmltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uL2NvbnN0JztcbmltcG9ydCBiZXppZXJDdXJ2ZVRvIGZyb20gJy4vdXRpbHMvYmV6aWVyQ3VydmVUbyc7XG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuaW1wb3J0IEluc2lkZUxpbmUgZnJvbSAnLi4vZ2VvbS9JbnNpZGVMaW5lJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaGljcyBcbntcbiAgICBjb25zdHJ1Y3Rvciggc2hhcGUgKVxuICAgIHtcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICAgICAgdGhpcy5zdHJva2VTdHlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZUFscGhhID0gMTtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG5cbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zeW5zU3R5bGUoKTtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gMDsgLy/ohI/mlbDmja5cbiAgICAgICAgdGhpcy5fd2ViR0wgPSB7fTtcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gMTtcbiAgICAgICAgdGhpcy50aW50ID0gMHhGRkZGRkY7IC8v55uu5qCH5a+56LGh6ZmE5Yqg6aKc6ImyXG4gICAgfVxuXG4gICAgc3luc1N0eWxlKClcbiAgICB7XG4gICAgICAgIC8v5LuOc2hhcGXkuK3miornu5jlm77pnIDopoHnmoRzdHlsZeWxnuaAp+WQjOatpei/h+adpVxuICAgICAgICB2YXIgc2N0eCA9IHRoaXMuc2hhcGUuY29udGV4dDtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBzY3R4LmxpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5zdHJva2VTdHlsZSA9IHNjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIHRoaXMubGluZUFscGhhID0gc2N0eC5saW5lQWxwaGEgKiBzY3R4Lmdsb2JhbEFscGhhO1xuXG4gICAgICAgIHRoaXMuZmlsbFN0eWxlID0gc2N0eC5maWxsU3R5bGU7XG4gICAgICAgIHRoaXMuZmlsbEFscGhhID0gc2N0eC5maWxsQWxwaGEgKiBzY3R4Lmdsb2JhbEFscGhhO1xuXG5cblxuXG4gICAgICAgIC8v5aaC5p6cZ3JhcGhpY3NEYXRh5pyJ5aSa5YiG57uE55qE5oOF5Ya15LiL77yM5aaC5p6c5Lul5Li6c2hhcGXnmoQgc3R5bGUg5bGe5oCn5pS55Y+Y6LCD55So55qEc3luc1N0eWxlXG4gICAgICAgIC8v5YiZ5Lya6KaG55uW5YWo6YOo55qEIGdyYXBoaWNzRGF0YSDlhYPntKBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFbaV0uc3luc1N0eWxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgR3JhcGhpY3MoKTtcblxuICAgICAgICBjbG9uZS5kaXJ0eSA9IDA7XG5cbiAgICAgICAgLy8gY29weSBncmFwaGljcyBkYXRhXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsb25lLmdyYXBoaWNzRGF0YS5wdXNoKHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmNsb25lKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvbmUuY3VycmVudFBhdGggPSBjbG9uZS5ncmFwaGljc0RhdGFbY2xvbmUuZ3JhcGhpY3NEYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG5cbiAgICBtb3ZlVG8oeCwgeSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gbmV3IFBvbHlnb24oW3gsIHldKTtcblxuICAgICAgICBzaGFwZS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBcbiAgICBsaW5lVG8oeCwgeSlcbiAgICB7XG4gICAgICAgIGlmKCB0aGlzLmN1cnJlbnRQYXRoICl7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5wdXNoKHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oMCwwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWFkcmF0aWNDdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzID0gWzAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuID0gMjA7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuICAgICAgICBsZXQgeGEgPSAwO1xuICAgICAgICBsZXQgeWEgPSAwO1xuXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgY29uc3QgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG47ICsraSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgaiA9IGkgLyBuO1xuXG4gICAgICAgICAgICB4YSA9IGZyb21YICsgKChjcFggLSBmcm9tWCkgKiBqKTtcbiAgICAgICAgICAgIHlhID0gZnJvbVkgKyAoKGNwWSAtIGZyb21ZKSAqIGopO1xuXG4gICAgICAgICAgICBwb2ludHMucHVzaCh4YSArICgoKGNwWCArICgodG9YIC0gY3BYKSAqIGopKSAtIHhhKSAqIGopLFxuICAgICAgICAgICAgICAgIHlhICsgKCgoY3BZICsgKCh0b1kgLSBjcFkpICogaikpIC0geWEpICogaikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGJlemllckN1cnZlVG8oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMgPSBbMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuXG4gICAgICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgY29uc3QgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHBvaW50cy5sZW5ndGggLT0gMjtcblxuICAgICAgICBiZXppZXJDdXJ2ZVRvKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZLCBwb2ludHMpO1xuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMucHVzaCh4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzO1xuICAgICAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgICAgIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgYTEgPSBmcm9tWSAtIHkxO1xuICAgICAgICBjb25zdCBiMSA9IGZyb21YIC0geDE7XG4gICAgICAgIGNvbnN0IGEyID0geTIgLSB5MTtcbiAgICAgICAgY29uc3QgYjIgPSB4MiAtIHgxO1xuICAgICAgICBjb25zdCBtbSA9IE1hdGguYWJzKChhMSAqIGIyKSAtIChiMSAqIGEyKSk7XG5cbiAgICAgICAgaWYgKG1tIDwgMS4wZS04IHx8IHJhZGl1cyA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gIT09IHgxIHx8IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gIT09IHkxKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHgxLCB5MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkZCA9IChhMSAqIGExKSArIChiMSAqIGIxKTtcbiAgICAgICAgICAgIGNvbnN0IGNjID0gKGEyICogYTIpICsgKGIyICogYjIpO1xuICAgICAgICAgICAgY29uc3QgdHQgPSAoYTEgKiBhMikgKyAoYjEgKiBiMik7XG4gICAgICAgICAgICBjb25zdCBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgICAgICAgICAgIGNvbnN0IGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tO1xuICAgICAgICAgICAgY29uc3QgajEgPSBrMSAqIHR0IC8gZGQ7XG4gICAgICAgICAgICBjb25zdCBqMiA9IGsyICogdHQgLyBjYztcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gKGsxICogYjIpICsgKGsyICogYjEpO1xuICAgICAgICAgICAgY29uc3QgY3kgPSAoazEgKiBhMikgKyAoazIgKiBhMSk7XG4gICAgICAgICAgICBjb25zdCBweCA9IGIxICogKGsyICsgajEpO1xuICAgICAgICAgICAgY29uc3QgcHkgPSBhMSAqIChrMiArIGoxKTtcbiAgICAgICAgICAgIGNvbnN0IHF4ID0gYjIgKiAoazEgKyBqMik7XG4gICAgICAgICAgICBjb25zdCBxeSA9IGEyICogKGsxICsgajIpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCk7XG4gICAgICAgICAgICBjb25zdCBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXJjKGN4ICsgeDEsIGN5ICsgeTEsIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGIxICogYTIgPiBiMiAqIGExKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpXG4gICAge1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbnRpY2xvY2t3aXNlICYmIGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN3ZWVwID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICBjb25zdCBzZWdzID0gTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIChNYXRoLlBJICogMikpICogNDA7XG5cbiAgICAgICAgaWYgKHN3ZWVwID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IGN4ICsgKE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRZID0gY3kgKyAoTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXMpO1xuXG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50UGF0aCBleGlzdHMsIHRha2UgaXRzIHBvaW50cy4gT3RoZXJ3aXNlIGNhbGwgYG1vdmVUb2AgdG8gc3RhcnQgYSBwYXRoLlxuICAgICAgICBsZXQgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aCA/IHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzIDogbnVsbDtcblxuICAgICAgICBpZiAocG9pbnRzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAhPT0gc3RhcnRYIHx8IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gIT09IHN0YXJ0WSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRoZXRhID0gc3dlZXAgLyAoc2VncyAqIDIpO1xuICAgICAgICBjb25zdCB0aGV0YTIgPSB0aGV0YSAqIDI7XG5cbiAgICAgICAgY29uc3QgY1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBjb25zdCBzVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgICAgY29uc3Qgc2VnTWludXMgPSBzZWdzIC0gMTtcblxuICAgICAgICBjb25zdCByZW1haW5kZXIgPSAoc2VnTWludXMgJSAxKSAvIHNlZ01pbnVzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHNlZ01pbnVzOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWwgPSBpICsgKHJlbWFpbmRlciAqIGkpO1xuXG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9ICgodGhldGEpICsgc3RhcnRBbmdsZSArICh0aGV0YTIgKiByZWFsKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICBjb25zdCBzID0gLU1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgICAgICAgKCgoY1RoZXRhICogYykgKyAoc1RoZXRhICogcykpICogcmFkaXVzKSArIGN4LFxuICAgICAgICAgICAgICAgICgoKGNUaGV0YSAqIC1zKSArIChzVGhldGEgKiBjKSkgKiByYWRpdXMpICsgY3lcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5Kys7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkcmF3Q2lyY2xlKHgsIHksIHJhZGl1cylcbiAgICB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBDaXJjbGUoeCwgeSwgcmFkaXVzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZHJhd0VsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICB7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkcmF3UG9seWdvbihwYXRoKVxuICAgIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgYXNzaWdubWVudCBkZW9wdFxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgICAgICBsZXQgcG9pbnRzID0gcGF0aDtcblxuICAgICAgICBsZXQgY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAocG9pbnRzIGluc3RhbmNlb2YgUG9seWdvbilcbiAgICAgICAge1xuICAgICAgICAgICAgY2xvc2VkID0gcG9pbnRzLmNsb3NlZDtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5wb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgbGVhayBkZW9wdFxuICAgICAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4yOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcbiAgICAgICAgICAgIHBvaW50cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gYXJndW1lbnRzW2ldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgUG9seWdvbihwb2ludHMpO1xuXG4gICAgICAgIHNoYXBlLmNsb3NlZCA9IGNsb3NlZDtcblxuICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2xlYXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkrKztcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkcmF3U2hhcGUoc2hhcGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA8PSAyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGEoXG4gICAgICAgICAgICB0aGlzLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICB0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgIHRoaXMuZmlsbFN0eWxlLFxuICAgICAgICAgICAgdGhpcy5maWxsQWxwaGEsXG4gICAgICAgICAgICBzaGFwZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2goZGF0YSk7XG5cbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLlBPTFkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEuc2hhcGUuY2xvc2VkID0gZGF0YS5zaGFwZS5jbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cblxuICAgIGNsb3NlUGF0aCgpXG4gICAge1xuICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXRoICYmIGN1cnJlbnRQYXRoLnNoYXBlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjdXJyZW50UGF0aC5zaGFwZS5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBncmFwaGljcyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIHRlc3RcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50KHBvaW50KVxuICAgIHtcbiAgICAgICAgY29uc3QgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG4gICAgICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICBpZiAoZGF0YS5zaGFwZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvL+WFiOajgOa1i2ZpbGzvvIwgZmlsbOeahOajgOa1i+amgueOh+Wkp+S6m+OAglxuICAgICAgICAgICAgICAgIC8v5YOPY2lyY2xlLGVsbGlwc2Xov5nmoLfnmoRzaGFwZSDlsLHnm7TmjqXmiopsaW5lV2lkdGjnrpflnKhmaWxs6YeM6Z2i6K6h566X5bCx5aW95LqG77yM5omA5Lul5LuW5Lus5piv5rKh5pyJaW5zaWRlTGluZeeahFxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5oYXNGaWxsKCkgJiYgZGF0YS5zaGFwZS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiggaW5zaWRlICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY2lyY2xlLGVsbGlwc2XnrYnlsLHmsqHmnIlwb2ludHNcbiAgICAgICAgICAgICAgICBpZiggZGF0YS5oYXNMaW5lKCkgJiYgZGF0YS5zaGFwZS5wb2ludHMgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy/nhLblkI7mo4DmtYvmmK/lkKblkozmj4/ovrnnorDmkp5cbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gSW5zaWRlTGluZSggZGF0YSAsIHBvaW50LnggLCBwb2ludC55ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBpbnNpZGUgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH1cblxuICAgIFxuXG4gICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZUxvY2FsQm91bmRzKClcbiAgICB7XG4gICAgICAgIGxldCBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtYXhYID0gLUluZmluaXR5O1xuXG4gICAgICAgIGxldCBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBzaGFwZSA9IDA7XG4gICAgICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgICAgICBsZXQgeSA9IDA7XG4gICAgICAgICAgICBsZXQgdyA9IDA7XG4gICAgICAgICAgICBsZXQgaCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZVdpZHRoID0gZGF0YS5saW5lV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBzaGFwZSA9IGRhdGEuc2hhcGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gU0hBUEVTLlJFQ1QgfHwgdHlwZSA9PT0gU0hBUEVTLlJSRUMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4ID0gc2hhcGUueCAtIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHNoYXBlLnkgLSAobGluZVdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBzaGFwZS53aWR0aCArIGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLmhlaWdodCArIGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gU0hBUEVTLkNJUkMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBzaGFwZS5yYWRpdXMgKyAobGluZVdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGggPSBzaGFwZS5yYWRpdXMgKyAobGluZVdpZHRoIC8gMik7XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBTSEFQRVMuRUxJUClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLndpZHRoICsgKGxpbmVXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgKGxpbmVXaWR0aCAvIDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUE9MWVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB5MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBydyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjeSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogKyAyIDwgcG9pbnRzLmxlbmd0aDsgaiArPSAyKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHBvaW50c1tqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHBvaW50c1tqICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBkeCA9IE1hdGguYWJzKHgyIC0geCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkyIC0geSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IE1hdGguc3FydCgoZHggKiBkeCkgKyAoZHkgKiBkeSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodyA8IDFlLTkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ3ID0gKChoIC8gdyAqIGR5KSArIGR4KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByaCA9ICgoaCAvIHcgKiBkeCkgKyBkeSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSAoeDIgKyB4KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeSA9ICh5MiArIHkpIC8gMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IGN4IC0gcncgPCBtaW5YID8gY3ggLSBydyA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gY3ggKyBydyA+IG1heFggPyBjeCArIHJ3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IGN5IC0gcmggPCBtaW5ZID8gY3kgLSByaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhZID0gY3kgKyByaCA+IG1heFkgPyBjeSArIHJoIDogbWF4WTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1pblggPSAwO1xuICAgICAgICAgICAgbWF4WCA9IDA7XG4gICAgICAgICAgICBtaW5ZID0gMDtcbiAgICAgICAgICAgIG1heFkgPSAwO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLkJvdW5kLm1pblggPSBtaW5YIFxuICAgICAgICB0aGlzLkJvdW5kLm1heFggPSBtYXhYO1xuXG4gICAgICAgIHRoaXMuQm91bmQubWluWSA9IG1pblk7XG4gICAgICAgIHRoaXMuQm91bmQubWF4WSA9IG1heFk7XG4gICAgfVxuXG4gICAgZGVzdHJveShvcHRpb25zKVxuICAgIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVtpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLl93ZWJnbClcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl93ZWJnbFtpZF0uZGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWJnbFtpZF0uZGF0YVtqXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLl93ZWJnbCA9IG51bGw7XG4gICAgfVxuXG59IiwiLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICog5qih5oufYXMzIERpc3BsYXlMaXN0IOS4reeahHNoYXBlIOexu1xuICovXG5pbXBvcnQgRGlzcGxheU9iamVjdCBmcm9tIFwiLi9EaXNwbGF5T2JqZWN0XCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XG5pbXBvcnQgR3JhcGhpY3MgZnJvbSBcIi4uL2dyYXBoaWNzL0dyYXBoaWNzXCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuaW1wb3J0IHtTSEFQRV9DT05URVhUX0RFRkFVTFR9IGZyb20gXCIuLi9jb25zdFwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlIGV4dGVuZHMgRGlzcGxheU9iamVjdFxue1xuICAgIGNvbnN0cnVjdG9yKG9wdCl7XG5cbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQob3B0KTtcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gXy5leHRlbmQoIF8uY2xvbmUoU0hBUEVfQ09OVEVYVF9ERUZBVUxUKSAsIG9wdC5jb250ZXh0ICk7XG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XG5cbiAgICAgICAgc3VwZXIoIG9wdCApO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoIHRoaXMgKTtcblxuICAgICAgICAvL+WFg+e0oOaYr+WQpuaciWhvdmVy5LqL5Lu2IOWSjCBjaGlja+S6i+S7tu+8jOeUsWFkZEV2ZW5ldExpc3RlcuWSjHJlbWl2ZUV2ZW50TGlzdGVy5p2l6Kem5Y+R5L+u5pS5XG4gICAgICAgIHRoaXMuX2hvdmVyYWJsZSAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2xpY2thYmxlICA9IGZhbHNlO1xuXG4gICAgICAgIC8vb3ZlcueahOaXtuWAmeWmguaenOacieS/ruaUueagt+W8j++8jOWwseS4unRydWVcbiAgICAgICAgdGhpcy5faG92ZXJDbGFzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhvdmVyQ2xvbmUgID0gdHJ1ZTsgICAgLy/mmK/lkKblvIDlkK/lnKhob3ZlcueahOaXtuWAmWNsb25l5LiA5Lu95YiwYWN0aXZlIHN0YWdlIOS4rSBcbiAgICAgICAgdGhpcy5wb2ludENoa1ByaW9yaXR5ID0gdHJ1ZTsgLy/lnKjpvKDmoIdtb3VzZW92ZXLliLDor6XoioLngrnvvIznhLblkI5tb3VzZW1vdmXnmoTml7blgJnvvIzmmK/lkKbkvJjlhYjmo4DmtYvor6XoioLngrlcblxuICAgICAgICAvL+aLluaLvWRyYWfnmoTml7blgJnmmL7npLrlnKhhY3RpdlNoYXBl55qE5Ymv5pysXG4gICAgICAgIHRoaXMuX2RyYWdEdXBsaWNhdGUgPSBudWxsO1xuXG4gICAgICAgIC8v5YWD57Sg5piv5ZCmIOW8gOWQryBkcmFnIOaLluWKqO+8jOi/meS4quacieeUqOaIt+iuvue9ruS8oOWFpVxuICAgICAgICAvL3NlbGYuZHJhZ2dhYmxlID0gb3B0LmRyYWdnYWJsZSB8fCBmYWxzZTtcblxuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLnR5cGUgfHwgXCJzaGFwZVwiIDtcbiAgICAgICAgb3B0LmRyYXcgJiYgKHRoaXMuZHJhdz1vcHQuZHJhdyk7XG4gICAgICAgIFxuICAgICAgICAvL+WkhOeQhuaJgOacieeahOWbvuW9ouS4gOS6m+WFseacieeahOWxnuaAp+mFjee9rizmiorpmaTlvIBpZCxjb250ZXh05LmL5aSW55qE5omA5pyJ5bGe5oCn77yM5YWo6YOo5oyC6L295YiwdGhpc+S4iumdolxuICAgICAgICB0aGlzLmluaXRDb21wUHJvcGVydHkob3B0KTtcblxuICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbml0KClcbiAgICB7fVxuXG4gICAgZHJhdygpXG4gICAge31cblxuICAgIGluaXRDb21wUHJvcGVydHkob3B0KVxuICAgIHtcbiAgICAgICAgZm9yKCB2YXIgaSBpbiBvcHQgKXtcbiAgICAgICAgICAgaWYoIGkgIT0gXCJpZFwiICYmIGkgIT0gXCJjb250ZXh0XCIpe1xuICAgICAgICAgICAgICAgdGhpc1tpXSA9IG9wdFtpXTtcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAvKlxuICAgICog55S76Jma57q/XG4gICAgKi9cbiAgIGRhc2hlZExpbmVUbyggeDEsIHkxLCB4MiwgeTIsIGRhc2hMZW5ndGggKSBcbiAgIHtcbiAgICAgICAgIGRhc2hMZW5ndGggPSB0eXBlb2YgZGFzaExlbmd0aCA9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgID8gMyA6IGRhc2hMZW5ndGg7XG4gICAgICAgICBkYXNoTGVuZ3RoID0gTWF0aC5tYXgoIGRhc2hMZW5ndGggLCB0aGlzLmNvbnRleHQubGluZVdpZHRoICk7XG4gICAgICAgICB2YXIgZGVsdGFYID0geDIgLSB4MTtcbiAgICAgICAgIHZhciBkZWx0YVkgPSB5MiAtIHkxO1xuICAgICAgICAgdmFyIG51bURhc2hlcyA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSkgLyBkYXNoTGVuZ3RoXG4gICAgICAgICApO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXNoZXM7ICsraSkge1xuICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQoeDEgKyAoZGVsdGFYIC8gbnVtRGFzaGVzKSAqIGkpO1xuICAgICAgICAgICAgIHZhciB5ID0gcGFyc2VJbnQoeTEgKyAoZGVsdGFZIC8gbnVtRGFzaGVzKSAqIGkpO1xuICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NbaSAlIDIgPT09IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXSggeCAsIHkgKTtcbiAgICAgICAgICAgICBpZiggaSA9PSAobnVtRGFzaGVzLTEpICYmIGklMiA9PT0gMCl7XG4gICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKCB4MiAsIHkyICk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgfVxuXG4gICAvKlxuICAgICrku45jcGzoioLngrnkuK3ojrflj5bliLA05Liq5pa55ZCR55qE6L6555WM6IqC54K5XG4gICAgKkBwYXJhbSAgY29udGV4dCBcbiAgICAqXG4gICAgKiovXG4gICBnZXRSZWN0Rm9ybVBvaW50TGlzdCggY29udGV4dCApXG4gICB7XG4gICAgICAgdmFyIG1pblggPSAgTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICB2YXIgbWF4WCA9ICBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgIHZhciBtaW5ZID0gIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgdmFyIG1heFkgPSAgTnVtYmVyLk1JTl9WQUxVRTtcblxuICAgICAgIHZhciBjcGwgPSBjb250ZXh0LnBvaW50TGlzdDsgLy90aGlzLmdldGNwbCgpO1xuICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBjcGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgIGlmIChjcGxbaV1bMF0gPCBtaW5YKSB7XG4gICAgICAgICAgICAgICBtaW5YID0gY3BsW2ldWzBdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmIChjcGxbaV1bMF0gPiBtYXhYKSB7XG4gICAgICAgICAgICAgICBtYXhYID0gY3BsW2ldWzBdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmIChjcGxbaV1bMV0gPCBtaW5ZKSB7XG4gICAgICAgICAgICAgICBtaW5ZID0gY3BsW2ldWzFdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlmIChjcGxbaV1bMV0gPiBtYXhZKSB7XG4gICAgICAgICAgICAgICBtYXhZID0gY3BsW2ldWzFdO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgdmFyIGxpbmVXaWR0aDtcbiAgICAgICBpZiAoY29udGV4dC5zdHJva2VTdHlsZSB8fCBjb250ZXh0LmZpbGxTdHlsZSAgKSB7XG4gICAgICAgICAgIGxpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoIHx8IDE7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgeCAgICAgIDogTWF0aC5yb3VuZChtaW5YIC0gbGluZVdpZHRoIC8gMiksXG4gICAgICAgICAgIHkgICAgICA6IE1hdGgucm91bmQobWluWSAtIGxpbmVXaWR0aCAvIDIpLFxuICAgICAgICAgICB3aWR0aCAgOiBtYXhYIC0gbWluWCArIGxpbmVXaWR0aCxcbiAgICAgICAgICAgaGVpZ2h0IDogbWF4WSAtIG1pblkgKyBsaW5lV2lkdGhcbiAgICAgICB9O1xuICAgfVxufSIsIi8qKlxyXG4gKiBDYW52YXgtLVRleHRcclxuICpcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDmlofmnKwg57G7XHJcbiAqKi9cclxuaW1wb3J0IERpc3BsYXlPYmplY3QgZnJvbSBcIi4vRGlzcGxheU9iamVjdFwiO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XHJcblxyXG52YXIgVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG9wdCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgc2VsZi50eXBlID0gXCJ0ZXh0XCI7XHJcbiAgICBzZWxmLl9yZU5ld2xpbmUgPSAvXFxyP1xcbi87XHJcbiAgICBzZWxmLmZvbnRQcm9wZXJ0cyA9IFtcImZvbnRTdHlsZVwiLCBcImZvbnRWYXJpYW50XCIsIFwiZm9udFdlaWdodFwiLCBcImZvbnRTaXplXCIsIFwiZm9udEZhbWlseVwiXTtcclxuXHJcbiAgICAvL+WBmuS4gOasoeeugOWNleeahG9wdOWPguaVsOagoemqjO+8jOS/neivgeWcqOeUqOaIt+S4jeS8oG9wdOeahOaXtuWAmSDmiJbogIXkvKDkuoZvcHTkvYbmmK/ph4zpnaLmsqHmnIljb250ZXh055qE5pe25YCZ5oql6ZSZXHJcbiAgICBvcHQgPSBVdGlscy5jaGVja09wdChvcHQpO1xyXG5cclxuICAgIHNlbGYuX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgZm9udFNpemU6IDEzLCAvL+Wtl+S9k+Wkp+Wwj+m7mOiupDEzXHJcbiAgICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIixcclxuICAgICAgICBmb250RmFtaWx5OiBcIuW+rui9r+mbhem7kSxzYW5zLXNlcmlmXCIsXHJcbiAgICAgICAgdGV4dERlY29yYXRpb246IG51bGwsXHJcbiAgICAgICAgZmlsbFN0eWxlOiAnYmxhbmsnLFxyXG4gICAgICAgIHN0cm9rZVN0eWxlOiBudWxsLFxyXG4gICAgICAgIGxpbmVXaWR0aDogMCxcclxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjIsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxyXG4gICAgICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6IG51bGxcclxuICAgIH0sIG9wdC5jb250ZXh0KTtcclxuXHJcbiAgICBzZWxmLl9jb250ZXh0LmZvbnQgPSBzZWxmLl9nZXRGb250RGVjbGFyYXRpb24oKTtcclxuXHJcbiAgICBzZWxmLnRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XHJcblxyXG4gICAgVGV4dC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIFtvcHRdKTtcclxufTtcclxuXHJcblV0aWxzLmNyZWF0Q2xhc3MoVGV4dCwgRGlzcGxheU9iamVjdCwge1xyXG4gICAgJHdhdGNoOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpIHtcclxuICAgICAgICAvL2NvbnRleHTlsZ7mgKfmnInlj5jljJbnmoTnm5HlkKzlh73mlbBcclxuICAgICAgICBpZiAoXy5pbmRleE9mKHRoaXMuZm9udFByb3BlcnRzLCBuYW1lKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgLy/lpoLmnpzkv67mlLnnmoTmmK9mb25055qE5p+Q5Liq5YaF5a6577yM5bCx6YeN5paw57uE6KOF5LiA6YGNZm9udOeahOWAvO+8jFxyXG4gICAgICAgICAgICAvL+eEtuWQjumAmuefpeW8leaTjui/measoeWvuWNvbnRleHTnmoTkv67mlLnkuI3pnIDopoHkuIrmiqXlv4Pot7NcclxuICAgICAgICAgICAgdGhpcy5fbm90V2F0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LndpZHRoID0gdGhpcy5nZXRUZXh0V2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmhlaWdodCA9IHRoaXMuZ2V0VGV4dEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpbml0OiBmdW5jdGlvbih0ZXh0LCBvcHQpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgYy53aWR0aCA9IHRoaXMuZ2V0VGV4dFdpZHRoKCk7XHJcbiAgICAgICAgYy5oZWlnaHQgPSB0aGlzLmdldFRleHRIZWlnaHQoKTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gdGhpcy5jb250ZXh0LiRtb2RlbCkge1xyXG4gICAgICAgICAgICBpZiAocCBpbiBjdHgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwICE9IFwidGV4dEJhc2VsaW5lXCIgJiYgdGhpcy5jb250ZXh0LiRtb2RlbFtwXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eFtwXSA9IHRoaXMuY29udGV4dC4kbW9kZWxbcF07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dChjdHgsIHRoaXMuX2dldFRleHRMaW5lcygpKTtcclxuICAgIH0sXHJcbiAgICByZXNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5oZWFydEJlYXQoKTtcclxuICAgIH0sXHJcbiAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IDA7XHJcbiAgICAgICAgVXRpbHMuX3BpeGVsQ3R4LnNhdmUoKTtcclxuICAgICAgICBVdGlscy5fcGl4ZWxDdHguZm9udCA9IHRoaXMuY29udGV4dC5mb250O1xyXG4gICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKFV0aWxzLl9waXhlbEN0eCwgdGhpcy5fZ2V0VGV4dExpbmVzKCkpO1xyXG4gICAgICAgIFV0aWxzLl9waXhlbEN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgfSxcclxuICAgIGdldFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUZXh0SGVpZ2h0KFV0aWxzLl9waXhlbEN0eCwgdGhpcy5fZ2V0VGV4dExpbmVzKCkpO1xyXG4gICAgfSxcclxuICAgIF9nZXRUZXh0TGluZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKTtcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyVGV4dDogZnVuY3Rpb24oY3R4LCB0ZXh0TGluZXMpIHtcclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRTdHJva2UoY3R4LCB0ZXh0TGluZXMpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCwgdGV4dExpbmVzKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfSxcclxuICAgIF9nZXRGb250RGVjbGFyYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgZm9udEFyciA9IFtdO1xyXG5cclxuICAgICAgICBfLmVhY2godGhpcy5mb250UHJvcGVydHMsIGZ1bmN0aW9uKHApIHtcclxuICAgICAgICAgICAgdmFyIGZvbnRQID0gc2VsZi5fY29udGV4dFtwXTtcclxuICAgICAgICAgICAgaWYgKHAgPT0gXCJmb250U2l6ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBmb250UCA9IHBhcnNlRmxvYXQoZm9udFApICsgXCJweFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9udFAgJiYgZm9udEFyci5wdXNoKGZvbnRQKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvbnRBcnIuam9pbignICcpO1xyXG5cclxuICAgIH0sXHJcbiAgICBfcmVuZGVyVGV4dEZpbGw6IGZ1bmN0aW9uKGN0eCwgdGV4dExpbmVzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuZmlsbFN0eWxlKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuX2JvdW5kYXJpZXMgPSBbXTtcclxuICAgICAgICB2YXIgbGluZUhlaWdodHMgPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGhlaWdodE9mTGluZSA9IHRoaXMuX2dldEhlaWdodE9mTGluZShjdHgsIGksIHRleHRMaW5lcyk7XHJcbiAgICAgICAgICAgIGxpbmVIZWlnaHRzICs9IGhlaWdodE9mTGluZTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lKFxyXG4gICAgICAgICAgICAgICAgJ2ZpbGxUZXh0JyxcclxuICAgICAgICAgICAgICAgIGN0eCxcclxuICAgICAgICAgICAgICAgIHRleHRMaW5lc1tpXSxcclxuICAgICAgICAgICAgICAgIDAsIC8vdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VG9wT2Zmc2V0KCkgKyBsaW5lSGVpZ2h0cyxcclxuICAgICAgICAgICAgICAgIGlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3JlbmRlclRleHRTdHJva2U6IGZ1bmN0aW9uKGN0eCwgdGV4dExpbmVzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgfHwgIXRoaXMuY29udGV4dC5saW5lV2lkdGgpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIGxpbmVIZWlnaHRzID0gMDtcclxuXHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBpZiAodGhpcy5zdHJva2VEYXNoQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKDEgJiB0aGlzLnN0cm9rZURhc2hBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlRGFzaEFycmF5LnB1c2guYXBwbHkodGhpcy5zdHJva2VEYXNoQXJyYXksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXBwb3J0c0xpbmVEYXNoICYmIGN0eC5zZXRMaW5lRGFzaCh0aGlzLnN0cm9rZURhc2hBcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0T2ZMaW5lID0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKGN0eCwgaSwgdGV4dExpbmVzKTtcclxuICAgICAgICAgICAgbGluZUhlaWdodHMgKz0gaGVpZ2h0T2ZMaW5lO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmUoXHJcbiAgICAgICAgICAgICAgICAnc3Ryb2tlVGV4dCcsXHJcbiAgICAgICAgICAgICAgICBjdHgsXHJcbiAgICAgICAgICAgICAgICB0ZXh0TGluZXNbaV0sXHJcbiAgICAgICAgICAgICAgICAwLCAvL3RoaXMuX2dldExlZnRPZmZzZXQoKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldFRvcE9mZnNldCgpICsgbGluZUhlaWdodHMsXHJcbiAgICAgICAgICAgICAgICBpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfSxcclxuICAgIF9yZW5kZXJUZXh0TGluZTogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XHJcbiAgICAgICAgdG9wIC09IHRoaXMuX2dldEhlaWdodE9mTGluZSgpIC8gNDtcclxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LnRleHRBbGlnbiAhPT0gJ2p1c3RpZnknKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGg7XHJcbiAgICAgICAgdmFyIHRvdGFsV2lkdGggPSB0aGlzLmNvbnRleHQud2lkdGg7XHJcblxyXG4gICAgICAgIGlmICh0b3RhbFdpZHRoID4gbGluZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQoL1xccysvKTtcclxuICAgICAgICAgICAgdmFyIHdvcmRzV2lkdGggPSBjdHgubWVhc3VyZVRleHQobGluZS5yZXBsYWNlKC9cXHMrL2csICcnKSkud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aERpZmYgPSB0b3RhbFdpZHRoIC0gd29yZHNXaWR0aDtcclxuICAgICAgICAgICAgdmFyIG51bVNwYWNlcyA9IHdvcmRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIHZhciBzcGFjZVdpZHRoID0gd2lkdGhEaWZmIC8gbnVtU3BhY2VzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCB3b3Jkc1tpXSwgbGVmdCArIGxlZnRPZmZzZXQsIHRvcCwgbGluZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQgKz0gY3R4Lm1lYXN1cmVUZXh0KHdvcmRzW2ldKS53aWR0aCArIHNwYWNlV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFycyhtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBjaGFycywgbGVmdCwgdG9wKSB7XHJcbiAgICAgICAgY3R4W21ldGhvZF0oY2hhcnMsIDAsIHRvcCk7XHJcbiAgICB9LFxyXG4gICAgX2dldEhlaWdodE9mTGluZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5mb250U2l6ZSAqIHRoaXMuY29udGV4dC5saW5lSGVpZ2h0O1xyXG4gICAgfSxcclxuICAgIF9nZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKGN0eCwgdGV4dExpbmVzKSB7XHJcbiAgICAgICAgdmFyIG1heFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRleHRMaW5lc1swXSB8fCAnfCcpLndpZHRoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dExpbmVzW2ldKS53aWR0aDtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50TGluZVdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXhXaWR0aDtcclxuICAgIH0sXHJcbiAgICBfZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oY3R4LCB0ZXh0TGluZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmZvbnRTaXplICogdGV4dExpbmVzLmxlbmd0aCAqIHRoaXMuY29udGV4dC5saW5lSGVpZ2h0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRvcCBvZmZzZXRcclxuICAgICAqL1xyXG4gICAgX2dldFRvcE9mZnNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHQgPSAwO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5jb250ZXh0LnRleHRCYXNlbGluZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwidG9wXCI6XHJcbiAgICAgICAgICAgICAgICB0ID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWlkZGxlXCI6XHJcbiAgICAgICAgICAgICAgICB0ID0gLXRoaXMuY29udGV4dC5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcclxuICAgICAgICAgICAgICAgIHQgPSAtdGhpcy5jb250ZXh0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH0sXHJcbiAgICBnZXRSZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgIC8v5pu05YW3dGV4dEFsaWduIOWSjCB0ZXh0QmFzZWxpbmUg6YeN5paw55+r5q2jIHh5XHJcbiAgICAgICAgaWYgKGMudGV4dEFsaWduID09IFwiY2VudGVyXCIpIHtcclxuICAgICAgICAgICAgeCA9IC1jLndpZHRoIC8gMjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjLnRleHRBbGlnbiA9PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgeCA9IC1jLndpZHRoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGMudGV4dEJhc2VsaW5lID09IFwibWlkZGxlXCIpIHtcclxuICAgICAgICAgICAgeSA9IC1jLmhlaWdodCAvIDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYy50ZXh0QmFzZWxpbmUgPT0gXCJib3R0b21cIikge1xyXG4gICAgICAgICAgICB5ID0gLWMuaGVpZ2h0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgIHdpZHRoOiBjLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGMuaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuZXhwb3J0IGRlZmF1bHQgVGV4dDsiLCJcbi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOWQkemHj+aTjeS9nOexu1xuICogKi9cbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbmZ1bmN0aW9uIFZlY3Rvcih4LCB5KSB7XG4gICAgdmFyIHZ4ID0gMCx2eSA9IDA7XG4gICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgXy5pc09iamVjdCggeCApICl7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGlmKCBfLmlzQXJyYXkoIGFyZyApICl7XG4gICAgICAgICAgIHZ4ID0gYXJnWzBdO1xuICAgICAgICAgICB2eSA9IGFyZ1sxXTtcbiAgICAgICAgfSBlbHNlIGlmKCBhcmcuaGFzT3duUHJvcGVydHkoXCJ4XCIpICYmIGFyZy5oYXNPd25Qcm9wZXJ0eShcInlcIikgKSB7XG4gICAgICAgICAgIHZ4ID0gYXJnLng7XG4gICAgICAgICAgIHZ5ID0gYXJnLnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYXhlcyA9IFt2eCwgdnldO1xufTtcblZlY3Rvci5wcm90b3R5cGUgPSB7XG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5fYXhlc1swXSAtIHYuX2F4ZXNbMF07XG4gICAgICAgIHZhciB5ID0gdGhpcy5fYXhlc1sxXSAtIHYuX2F4ZXNbMV07XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG4gICAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IFZlY3RvcjsiLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiDlpITnkIbkuLrlubPmu5Hnur/mnaFcbiAqL1xuaW1wb3J0IFZlY3RvciBmcm9tIFwiLi9WZWN0b3JcIjtcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbi8qKlxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjI1O1xuICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuMjU7XG4gICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0MyBcbiAgICAgICAgICAgKyAoLSAzICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDJcbiAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbn1cbi8qKlxuICog5aSa57q/5q615bmz5ruR5puy57q/IFxuICogb3B0ID09PiBwb2ludHMgLCBpc0xvb3BcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCBvcHQgKSB7XG4gICAgdmFyIHBvaW50cyA9IG9wdC5wb2ludHM7XG4gICAgdmFyIGlzTG9vcCA9IG9wdC5pc0xvb3A7XG4gICAgdmFyIHNtb290aEZpbHRlciA9IG9wdC5zbW9vdGhGaWx0ZXI7XG5cbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICBpZiggbGVuID09IDEgKXtcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciBkaXN0YW5jZSAgPSAwO1xuICAgIHZhciBwcmVWZXJ0b3IgPSBuZXcgVmVjdG9yKCBwb2ludHNbMF0gKTtcbiAgICB2YXIgaVZ0b3IgICAgID0gbnVsbFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaVZ0b3IgPSBuZXcgVmVjdG9yKHBvaW50c1tpXSk7XG4gICAgICAgIGRpc3RhbmNlICs9IHByZVZlcnRvci5kaXN0YW5jZSggaVZ0b3IgKTtcbiAgICAgICAgcHJlVmVydG9yID0gaVZ0b3I7XG4gICAgfVxuXG4gICAgcHJlVmVydG9yID0gbnVsbDtcbiAgICBpVnRvciAgICAgPSBudWxsO1xuXG5cbiAgICAvL+WfuuacrOS4iuetieS6juabsueOh1xuICAgIHZhciBzZWdzID0gZGlzdGFuY2UgLyA2O1xuXG4gICAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSBpIC8gKHNlZ3MtMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG5cbiAgICAgICAgdmFyIHcgPSBwb3MgLSBpZHg7XG5cbiAgICAgICAgdmFyIHAwO1xuICAgICAgICB2YXIgcDEgPSBwb2ludHNbaWR4ICUgbGVuXTtcbiAgICAgICAgdmFyIHAyO1xuICAgICAgICB2YXIgcDM7XG4gICAgICAgIGlmICghaXNMb29wKSB7XG4gICAgICAgICAgICBwMCA9IHBvaW50c1tpZHggPT09IDAgPyBpZHggOiBpZHggLSAxXTtcbiAgICAgICAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICAgICAgICBwMyA9IHBvaW50c1tpZHggPiBsZW4gLSAzID8gbGVuIC0gMSA6IGlkeCArIDJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcDAgPSBwb2ludHNbKGlkeCAtMSArIGxlbikgJSBsZW5dO1xuICAgICAgICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgICAgICAgIHAzID0gcG9pbnRzWyhpZHggKyAyKSAlIGxlbl07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdzIgPSB3ICogdztcbiAgICAgICAgdmFyIHczID0gdyAqIHcyO1xuXG4gICAgICAgIHZhciBycCA9IFtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdywgdzIsIHczKSxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgdywgdzIsIHczKVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgXy5pc0Z1bmN0aW9uKHNtb290aEZpbHRlcikgJiYgc21vb3RoRmlsdGVyKCBycCApO1xuXG4gICAgICAgIHJldC5wdXNoKCBycCApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTsiLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiDmlbDlraYg57G7XG4gKlxuICoqL1xuXG5pbXBvcnQgU21vb3RoU3BsaW5lIGZyb20gXCIuLi9nZW9tL1Ntb290aFNwbGluZVwiO1xuXG5cbnZhciBfY2FjaGUgPSB7XG4gICAgc2luIDoge30sICAgICAvL3Npbue8k+WtmFxuICAgIGNvcyA6IHt9ICAgICAgLy9jb3PnvJPlrZhcbn07XG52YXIgX3JhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiAqIEBwYXJhbSBhbmdsZSDlvKfluqbvvIjop5LluqbvvInlj4LmlbBcbiAqIEBwYXJhbSBpc0RlZ3JlZXMgYW5nbGXlj4LmlbDmmK/lkKbkuLrop5LluqborqHnrpfvvIzpu5jorqTkuLpmYWxzZe+8jGFuZ2xl5Li65Lul5byn5bqm6K6h6YeP55qE6KeS5bqmXG4gKi9cbmZ1bmN0aW9uIHNpbihhbmdsZSwgaXNEZWdyZWVzKSB7XG4gICAgYW5nbGUgPSAoaXNEZWdyZWVzID8gYW5nbGUgKiBfcmFkaWFucyA6IGFuZ2xlKS50b0ZpeGVkKDQpO1xuICAgIGlmKHR5cGVvZiBfY2FjaGUuc2luW2FuZ2xlXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfY2FjaGUuc2luW2FuZ2xlXSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jYWNoZS5zaW5bYW5nbGVdO1xufVxuXG4vKipcbiAqIEBwYXJhbSByYWRpYW5zIOW8p+W6puWPguaVsFxuICovXG5mdW5jdGlvbiBjb3MoYW5nbGUsIGlzRGVncmVlcykge1xuICAgIGFuZ2xlID0gKGlzRGVncmVlcyA/IGFuZ2xlICogX3JhZGlhbnMgOiBhbmdsZSkudG9GaXhlZCg0KTtcbiAgICBpZih0eXBlb2YgX2NhY2hlLmNvc1thbmdsZV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX2NhY2hlLmNvc1thbmdsZV0gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxuICAgIHJldHVybiBfY2FjaGUuY29zW2FuZ2xlXTtcbn1cblxuLyoqXG4gKiDop5LluqbovazlvKfluqZcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbmdsZVxuICovXG5mdW5jdGlvbiBkZWdyZWVUb1JhZGlhbihhbmdsZSkge1xuICAgIHJldHVybiBhbmdsZSAqIF9yYWRpYW5zO1xufVxuXG4vKipcbiAqIOW8p+W6pui9rOinkuW6plxuICogQHBhcmFtIHtPYmplY3R9IGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIHJhZGlhblRvRGVncmVlKGFuZ2xlKSB7XG4gICAgcmV0dXJuIGFuZ2xlIC8gX3JhZGlhbnM7XG59XG5cbi8qXG4gKiDmoKHpqozop5LluqbliLAzNjDluqblhoVcbiAqIEBwYXJhbSB7YW5nbGV9IG51bWJlclxuICovXG5mdW5jdGlvbiBkZWdyZWVUbzM2MCggYW5nbGUgKSB7XG4gICAgdmFyIHJlQW5nID0gKDM2MCArICBhbmdsZSAgJSAzNjApICUgMzYwOy8vTWF0aC5hYnMoMzYwICsgTWF0aC5jZWlsKCBhbmdsZSApICUgMzYwKSAlIDM2MDtcbiAgICBpZiggcmVBbmcgPT0gMCAmJiBhbmdsZSAhPT0gMCApe1xuICAgICAgICByZUFuZyA9IDM2MFxuICAgIH1cbiAgICByZXR1cm4gcmVBbmc7XG59XG5cbmZ1bmN0aW9uIGdldElzZ29uUG9pbnRMaXN0KCBuICwgciApe1xuICAgIHZhciBwb2ludExpc3QgPSBbXTtcbiAgICB2YXIgZFN0ZXAgPSAyICogTWF0aC5QSSAvIG47XG4gICAgdmFyIGJlZ2luRGVnID0gLU1hdGguUEkgLyAyO1xuICAgIHZhciBkZWcgPSBiZWdpbkRlZztcbiAgICBmb3IgKHZhciBpID0gMCwgZW5kID0gbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHBvaW50TGlzdC5wdXNoKFtyICogTWF0aC5jb3MoZGVnKSwgciAqIE1hdGguc2luKGRlZyldKTtcbiAgICAgICAgZGVnICs9IGRTdGVwO1xuICAgIH07XG4gICAgcmV0dXJuIHBvaW50TGlzdDtcbn1cblxuZnVuY3Rpb24gZ2V0U21vb3RoUG9pbnRMaXN0KCBwTGlzdCwgc21vb3RoRmlsdGVyICl7XG4gICAgLy9zbW9vdGhGaWx0ZXIgLS0g5q+U5aaC5Zyo5oqY57q/5Zu+5Lit44CC5Lya5Lyg5LiA5Liqc21vb3RoRmlsdGVy6L+H5p2l5YGacG9pbnTnmoTnuqDmraPjgIJcbiAgICAvL+iuqXnkuI3og73otoXov4flupXpg6jnmoTljp/ngrlcbiAgICB2YXIgb2JqID0ge1xuICAgICAgICBwb2ludHM6IHBMaXN0XG4gICAgfVxuICAgIGlmIChfLmlzRnVuY3Rpb24oc21vb3RoRmlsdGVyKSkge1xuICAgICAgICBvYmouc21vb3RoRmlsdGVyID0gc21vb3RoRmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBjdXJyTCA9IFNtb290aFNwbGluZShvYmopO1xuICAgIGlmIChwTGlzdCAmJiBwTGlzdC5sZW5ndGg+MCkge1xuICAgICAgICBjdXJyTC5wdXNoKCBwTGlzdFtwTGlzdC5sZW5ndGggLSAxXSApO1xuICAgIH07XG5cbiAgICByZXR1cm4gY3Vyckw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBQSSAgOiBNYXRoLlBJICAsXG4gICAgc2luIDogc2luICAgICAgLFxuICAgIGNvcyA6IGNvcyAgICAgICxcbiAgICBkZWdyZWVUb1JhZGlhbiA6IGRlZ3JlZVRvUmFkaWFuLFxuICAgIHJhZGlhblRvRGVncmVlIDogcmFkaWFuVG9EZWdyZWUsXG4gICAgZGVncmVlVG8zNjAgICAgOiBkZWdyZWVUbzM2MCxcbiAgICBnZXRJc2dvblBvaW50TGlzdCA6IGdldElzZ29uUG9pbnRMaXN0LFxuICAgIGdldFNtb290aFBvaW50TGlzdDogZ2V0U21vb3RoUG9pbnRMaXN0ICAgXG59O1xuXG4iLCIvKipcclxuICogQ2FudmF4XHJcbiAqXHJcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcclxuICpcclxuICog5oqY57q/IOexu1xyXG4gKlxyXG4gKiDlr7nlupRjb250ZXh055qE5bGe5oCn5pyJXHJcbiAqIEBwb2ludExpc3Qg5ZCE5Liq6aG26KeS5Z2Q5qCHXHJcbiAqKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuaW1wb3J0IF9NYXRoIGZyb20gXCIuLi9nZW9tL01hdGhcIlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJva2VuTGluZSBleHRlbmRzIFNoYXBlXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdCAsIGF0eXBlKXtcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdChvcHQpO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgbGluZVR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXHJcbiAgICAgICAgICAgIHBvaW50TGlzdDogW10sIC8ve0FycmF5fSAgLy8g5b+F6aG777yM5ZCE5Liq6aG26KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgIHNtb290aEZpbHRlcjogVXRpbHMuX19lbXB0eUZ1bmNcclxuICAgICAgICB9LCBvcHQuY29udGV4dCApO1xyXG5cclxuICAgICAgICBpZiggYXR5cGUgIT09IFwiY2xvbmVcIiAmJiBfY29udGV4dC5zbW9vdGggKXtcclxuICAgICAgICAgICAgX2NvbnRleHQucG9pbnRMaXN0ID0gX01hdGguZ2V0U21vb3RoUG9pbnRMaXN0KCBfY29udGV4dC5wb2ludExpc3QgKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBvcHQuY29udGV4dCA9IF9jb250ZXh0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN1cGVyKG9wdCk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiYnJva2VubGluZVwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgJHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwb2ludExpc3RcIiB8fCBuYW1lID09IFwic21vb3RoXCIgfHwgbmFtZSA9PSBcImxpbmVUeXBlXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRHcmFwaGljcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgc2V0R3JhcGhpY3MoKSBcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMaXN0ID0gY29udGV4dC5wb2ludExpc3Q7XHJcbiAgICAgICAgaWYgKHBvaW50TGlzdC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIC8v5bCR5LqOMuS4queCueWwseS4jeeUu+S6hn5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWNvbnRleHQubGluZVR5cGUgfHwgY29udGV4dC5saW5lVHlwZSA9PSAnc29saWQnKSB7XHJcbiAgICAgICAgICAgIC8v6buY6K6k5Li65a6e57q/XHJcbiAgICAgICAgICAgIC8vVE9ETzrnm67liY3lpoLmnpwg5pyJ6K6+572uc21vb3RoIOeahOaDheWGteS4i+aYr+S4jeaUr+aMgeiZmue6v+eahFxyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyhwb2ludExpc3RbMF1bMF0sIHBvaW50TGlzdFswXVsxXSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8ocG9pbnRMaXN0W2ldWzBdLCBwb2ludExpc3RbaV1bMV0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5saW5lVHlwZSA9PSAnZGFzaGVkJyB8fCBjb250ZXh0LmxpbmVUeXBlID09ICdkb3R0ZWQnKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNtb290aCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwLCBzbCA9IHBvaW50TGlzdC5sZW5ndGg7IHNpIDwgc2w7IHNpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2kgPT0gc2wtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubW92ZVRvKCBwb2ludExpc3Rbc2ldWzBdICwgcG9pbnRMaXN0W3NpXVsxXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKCBwb2ludExpc3Rbc2krMV1bMF0gLCBwb2ludExpc3Rbc2krMV1bMV0gKTtcclxuICAgICAgICAgICAgICAgICAgICBzaSs9MTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+eUu+iZmue6v+eahOaWueazlSAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyhwb2ludExpc3RbMF1bMF0sIHBvaW50TGlzdFswXVsxXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50TGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVggPSBwb2ludExpc3RbaSAtIDFdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b1ggPSBwb2ludExpc3RbaV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRMaXN0W2kgLSAxXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9ZID0gcG9pbnRMaXN0W2ldWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGFzaGVkTGluZVRvKGZyb21YLCBmcm9tWSwgdG9YLCB0b1ksIDUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG59IiwiLyoqXHJcbiAqIENhbnZheFxyXG4gKlxyXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXHJcbiAqXHJcbiAqIOWchuW9oiDnsbtcclxuICpcclxuICog5Z2Q5qCH5Y6f54K55YaN5ZyG5b+DXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQHIg5ZyG5Y2K5b6EXHJcbiAqKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENpcmNsZSBleHRlbmRzIFNoYXBlXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKCBvcHQgKVxyXG4gICAge1xyXG4gICAgICAgIG9wdCA9IFV0aWxzLmNoZWNrT3B0KCBvcHQgKTtcclxuICAgICAgICAvL+m7mOiupOaDheWGteS4i+mdou+8jGNpcmNsZeS4jemcgOimgeaKinh56L+b6KGMcGFyZW50SW506L2s5o2iXHJcbiAgICAgICAgKCBcInh5VG9JbnRcIiBpbiBvcHQgKSB8fCAoIG9wdC54eVRvSW50ID0gZmFsc2UgKTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIHIgOiAwICAgLy97bnVtYmVyfSwgIC8vIOW/hemhu++8jOWchuWNiuW+hFxyXG4gICAgICAgIH0gLCBvcHQuY29udGV4dCk7XHJcblxyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICAgIHN1cGVyKCBvcHQgKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgICR3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpIFxyXG4gICAge1xyXG4gICAgICAgIGlmICggbmFtZSA9PSBcInJcIiApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRHcmFwaGljcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRHcmFwaGljcygpIFxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKTtcclxuICAgICAgICAvL3RoaXMuZ3JhcGhpY3MuYXJjKDAgLCAwLCB0aGlzLmNvbnRleHQuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd0NpcmNsZSgwLCAwLCB0aGlzLmNvbnRleHQucik7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4iLCIvKipcclxuICogQ2FudmF4XHJcbiAqXHJcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcclxuICpcclxuICogUGF0aCDnsbvvvIxQYXRo5Li76KaB55So5LqO5oqKc3ZncGF0aCDlrZfnrKbkuLLovazmjaLkuLpwb2ludExpc3TvvIznhLblkI7mnoTlu7pncmFwaGljc0RhdGFcclxuICpcclxuICog5a+55bqUY29udGV4dOeahOWxnuaAp+aciVxyXG4gKiBAcGF0aCBwYXRo5LiyXHJcbiAqKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuaW1wb3J0IE1hdHJpeCBmcm9tIFwiLi4vZ2VvbS9NYXRyaXhcIjtcclxuaW1wb3J0IEJlemllciBmcm9tIFwiLi4vZ2VvbS9iZXppZXJcIjtcclxuaW1wb3J0IHsgQXJjIH0gZnJvbSAnLi4vbWF0aC9pbmRleCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoIGV4dGVuZHMgU2hhcGVcclxue1xyXG4gICAgY29uc3RydWN0b3Iob3B0KXtcclxuICAgICAgICBcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdChvcHQpO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgcG9pbnRMaXN0OiBbXSwgLy/ku47kuIvpnaLnmoRwYXRo5Lit6K6h566X5b6X5Yiw55qE6L6555WM54K555qE6ZuG5ZCIXHJcbiAgICAgICAgICAgIHBhdGg6IFwiXCIgLy/lrZfnrKbkuLIg5b+F6aG777yM6Lev5b6E44CC5L6L5aaCOk0gMCAwIEwgMCAxMCBMIDEwIDEwIFogKOS4gOS4quS4ieinkuW9oilcclxuICAgICAgICAgICAgICAgIC8vTSA9IG1vdmV0b1xyXG4gICAgICAgICAgICAgICAgLy9MID0gbGluZXRvXHJcbiAgICAgICAgICAgICAgICAvL0ggPSBob3Jpem9udGFsIGxpbmV0b1xyXG4gICAgICAgICAgICAgICAgLy9WID0gdmVydGljYWwgbGluZXRvXHJcbiAgICAgICAgICAgICAgICAvL0MgPSBjdXJ2ZXRvXHJcbiAgICAgICAgICAgICAgICAvL1MgPSBzbW9vdGggY3VydmV0b1xyXG4gICAgICAgICAgICAgICAgLy9RID0gcXVhZHJhdGljIEJlbHppZXIgY3VydmVcclxuICAgICAgICAgICAgICAgIC8vVCA9IHNtb290aCBxdWFkcmF0aWMgQmVsemllciBjdXJ2ZXRvXHJcbiAgICAgICAgICAgICAgICAvL1ogPSBjbG9zZXBhdGhcclxuICAgICAgICB9ICwgb3B0LmNvbnRleHQpO1xyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICAgIHN1cGVyKCBvcHQgKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKFwiZHJhd1R5cGVPbmx5XCIgaW4gb3B0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1R5cGVPbmx5ID0gb3B0LmRyYXdUeXBlT25seTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl9fcGFyc2VQYXRoRGF0YSA9IG51bGw7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicGF0aFwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgJHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwYXRoXCIpIHsgLy/lpoLmnpxwYXRo5pyJ5Y+Y5Yqo77yM6ZyA6KaB6Ieq5Yqo6K6h566X5paw55qEcG9pbnRMaXN0XHJcbiAgICAgICAgICAgIHRoaXMuc2V0R3JhcGhpY3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcGFyc2VQYXRoRGF0YShkYXRhKSBcclxuICAgIHtcclxuICAgICAgICBpZiAodGhpcy5fX3BhcnNlUGF0aERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19wYXJzZVBhdGhEYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8v5YiG5ouG5a2Q5YiG57uEXHJcbiAgICAgICAgdGhpcy5fX3BhcnNlUGF0aERhdGEgPSBbXTtcclxuICAgICAgICB2YXIgcGF0aHMgPSBfLmNvbXBhY3QoZGF0YS5yZXBsYWNlKC9bTW1dL2csIFwiXFxcXHIkJlwiKS5zcGxpdCgnXFxcXHInKSk7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICBfLmVhY2gocGF0aHMsIGZ1bmN0aW9uKHBhdGhTdHIpIHtcclxuICAgICAgICAgICAgbWUuX19wYXJzZVBhdGhEYXRhLnB1c2gobWUuX3BhcnNlQ2hpbGRQYXRoRGF0YShwYXRoU3RyKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19wYXJzZVBhdGhEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIF9wYXJzZUNoaWxkUGF0aERhdGEoZGF0YSlcclxuICAgIHtcclxuICAgICAgICAvLyBjb21tYW5kIHN0cmluZ1xyXG4gICAgICAgIHZhciBjcyA9IGRhdGE7XHJcbiAgICAgICAgLy8gY29tbWFuZCBjaGFyc1xyXG4gICAgICAgIHZhciBjYyA9IFtcclxuICAgICAgICAgICAgJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLFxyXG4gICAgICAgICAgICAnYycsICdDJywgJ3EnLCAnUScsICd0JywgJ1QnLCAncycsICdTJywgJ2EnLCAnQSdcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNzID0gY3MucmVwbGFjZSgvICAvZywgJyAnKTtcclxuICAgICAgICBjcyA9IGNzLnJlcGxhY2UoLyAvZywgJywnKTtcclxuICAgICAgICAvL2NzID0gY3MucmVwbGFjZSgvKC4pLS9nLCBcIiQxLC1cIik7XHJcbiAgICAgICAgY3MgPSBjcy5yZXBsYWNlKC8oXFxkKS0vZywgJyQxLC0nKTtcclxuICAgICAgICBjcyA9IGNzLnJlcGxhY2UoLywsL2csICcsJyk7XHJcbiAgICAgICAgdmFyIG47XHJcbiAgICAgICAgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXHJcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheVxyXG4gICAgICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xyXG4gICAgICAgIHZhciBjYSA9IFtdO1xyXG4gICAgICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxyXG4gICAgICAgIHZhciBjcHggPSAwO1xyXG4gICAgICAgIHZhciBjcHkgPSAwO1xyXG4gICAgICAgIGZvciAobiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgdmFyIHN0ciA9IGFycltuXTtcclxuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ2UsLScsICdnJyksICdlLScpO1xyXG5cclxuICAgICAgICAgICAgLy/mnInnmoTml7blgJnvvIzmr5TlpoLigJwyMu+8jC0yMuKAnSDmlbDmja7lj6/og73kvJrnu4/luLjnmoTooqvlhpnmiJAyMi0yMu+8jOmCo+S5iOmcgOimgeaJi+WKqOS/ruaUuVxyXG4gICAgICAgICAgICAvL3N0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJy0nLCAnZycpLCAnLC0nKTtcclxuICAgICAgICAgICAgLy9zdHIgPSBzdHIucmVwbGFjZSgvKC4pLS9nLCBcIiQxLC1cIilcclxuICAgICAgICAgICAgdmFyIHAgPSBzdHIuc3BsaXQoJywnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgfSBcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcFtpXSA9IHBhcnNlRmxvYXQocFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKHAubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR4O1xyXG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmV2Q21kO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByeDtcclxuICAgICAgICAgICAgICAgIHZhciByeTtcclxuICAgICAgICAgICAgICAgIHZhciBwc2k7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmE7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnM7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gY3B4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkxID0gY3B5O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdNJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ2wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdNJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ0wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0MnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnQycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbM10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCwgY3RsUHR5ID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kLmNvbW1hbmQgPT09ICdDJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1szXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHgsIGN0bFB0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdDJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCwgY3RsUHR5ID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kLmNvbW1hbmQgPT09ICdRJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdRJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCwgY3RsUHR5ID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kLmNvbW1hbmQgPT09ICdRJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ1EnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7IC8veOWNiuW+hFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHAuc2hpZnQoKTsgLy955Y2K5b6EXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTsgLy/ml4vovazop5LluqZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwLnNoaWZ0KCk7IC8v6KeS5bqm5aSn5bCPIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHAuc2hpZnQoKTsgLy/ml7bpkojmlrnlkJFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpLCBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdBJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gWyByeCAsIHJ5ICxwc2kgLCBmYSAsZnMgLGNweCAsIGNweSAsIHgxICwgeTEgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHAuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0EnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBbIHJ4ICwgcnkgLHBzaSAsIGZhICxmcyAsY3B4ICwgY3B5ICwgeDEgLCB5MSBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjYS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjbWQgfHwgYyxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50c1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XHJcbiAgICAgICAgICAgICAgICBjYS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAneicsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjYTtcclxuICAgIH1cclxuXHJcbiAgICAvL+mHjeaWsOagueeahHBhdGjnu5jliLZncmFwaGljc1xyXG4gICAgc2V0R3JhcGhpY3MoKVxyXG4gICAge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl9fcGFyc2VQYXRoRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnBvaW50TGlzdCA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgcGF0aEFycmF5ID0gdGhpcy5fcGFyc2VQYXRoRGF0YSh0aGlzLmNvbnRleHQucGF0aCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGcgPSAwLCBnbCA9IHBhdGhBcnJheS5sZW5ndGg7IGcgPCBnbDsgZysrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aEFycmF5W2ddLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBwYXRoQXJyYXlbZ11baV0uY29tbWFuZCwgcCA9IHBhdGhBcnJheVtnXVtpXS5wb2ludHM7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8ocFswXSwgcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyhwWzBdLCBwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYmV6aWVyQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MucXVhZHJhdGljQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5YmN6Z2iNuS4quWFg+e0oOeUqOadpeaUvnBhdGjnmoRBIDbkuKrlj4LmlbDvvIxwYXRoIEHlkb3ku6Tor6bop4FcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJjLmRyYXdBcmMoIHRoaXMuZ3JhcGhpY3MgLCBwWzddICwgcFs4XSAsIHAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbn0iLCIvKipcclxuICogQ2FudmF4XHJcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcclxuICpcclxuICog5rC05ru05b2iIOexu1xyXG4gKiDmtL7nlJ/oh6pQYXRo57G7XHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQGhyIOawtOa7tOaoquWuve+8iOS4reW/g+WIsOawtOW5s+i+uee8mOacgOWuveWkhOi3neemu++8iVxyXG4gKiBAdnIg5rC05ru057q16auY77yI5Lit5b+D5Yiw5bCW56uv6Led56a777yJXHJcbiAqKi9cclxuaW1wb3J0IFBhdGggZnJvbSBcIi4vUGF0aFwiO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wbGV0IGV4dGVuZHMgUGF0aFxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihvcHQpXHJcbiAgICB7XHJcbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQoIG9wdCApO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgaHIgOiAwLCAvL3tudW1iZXJ9LCAgLy8g5b+F6aG777yM5rC05ru05qiq5a6977yI5Lit5b+D5Yiw5rC05bmz6L6557yY5pyA5a695aSE6Led56a777yJXHJcbiAgICAgICAgICAgIHZyIDogMCAgIC8ve251bWJlcn0sICAvLyDlv4XpobvvvIzmsLTmu7TnurXpq5jvvIjkuK3lv4PliLDlsJbnq6/ot53nprvvvIlcclxuICAgICAgICB9ICwgb3B0LmNvbnRleHQpO1xyXG5cclxuICAgICAgICBvcHQuY29udGV4dCA9IF9jb250ZXh0O1xyXG5cclxuICAgICAgICB2YXIgbXkgPSBzdXBlcihvcHQpO1xyXG5cclxuICAgICAgICB0aGlzLnR5cGUgPSBcImRyb3BsZXRcIjtcclxuICAgICAgICB0aGlzLmlkID0gVXRpbHMuY3JlYXRlSWQodGhpcy50eXBlKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnBhdGggPSB0aGlzLl9jcmVhdGVQYXRoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgJHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCBuYW1lID09IFwiaHJcIiB8fCBuYW1lID09IFwidnJcIiApIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnBhdGggPSB0aGlzLl9jcmVhdGVQYXRoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmFtZSA9PSBcInBhdGhcIikge1xyXG4gICAgICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBfY3JlYXRlUGF0aCgpIFxyXG4gICAge1xyXG4gICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICB2YXIgcHMgPSBcIk0gMCBcIitjb250ZXh0LmhyK1wiIEMgXCIrY29udGV4dC5ocitcIiBcIitjb250ZXh0LmhyK1wiIFwiKyggY29udGV4dC5ociozLzIgKSArXCIgXCIrKC1jb250ZXh0LmhyLzMpK1wiIDAgXCIrKC1jb250ZXh0LnZyKTtcclxuICAgICAgIHBzICs9IFwiIEMgXCIrKC1jb250ZXh0LmhyICogMy8gMikrXCIgXCIrKC1jb250ZXh0LmhyIC8gMykrXCIgXCIrKC1jb250ZXh0LmhyKStcIiBcIitjb250ZXh0LmhyK1wiIDAgXCIrIGNvbnRleHQuaHIrIFwielwiO1xyXG4gICAgICAgcmV0dXJuIHBzO1xyXG4gICAgfVxyXG59IiwiXHJcbi8qKlxyXG4gKiBDYW52YXhcclxuICpcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDmpK3lnIblvaIg57G7XHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIkgXHJcbiAqXHJcbiAqIEBociDmpK3lnIbmqKrovbTljYrlvoRcclxuICogQHZyIOakreWchue6tei9tOWNiuW+hFxyXG4gKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsbGlwc2UgZXh0ZW5kcyBTaGFwZVxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihvcHQpXHJcbiAgICB7XHJcbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQoIG9wdCApO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgLy94ICAgICAgICAgICAgIDogMCAsIC8ve251bWJlcn0sICAvLyDkuKLlvINcclxuICAgICAgICAgICAgLy95ICAgICAgICAgICAgIDogMCAsIC8ve251bWJlcn0sICAvLyDkuKLlvIPvvIzljp/lm6DlkIxjaXJjbGVcclxuICAgICAgICAgICAgaHIgOiAwLCAgLy97bnVtYmVyfSwgIC8vIOW/hemhu++8jOakreWchuaoqui9tOWNiuW+hFxyXG4gICAgICAgICAgICB2ciA6IDAgICAvL3tudW1iZXJ9LCAgLy8g5b+F6aG777yM5qSt5ZyG57q16L205Y2K5b6EXHJcbiAgICAgICAgfSAsIG9wdC5jb250ZXh0KTtcclxuXHJcbiAgICAgICAgb3B0LmNvbnRleHQgPSBfY29udGV4dDtcclxuXHJcbiAgICAgICAgc3VwZXIoIG9wdCApO1xyXG5cclxuICAgICAgICB0aGlzLnR5cGUgPSBcImVsbGlwc2VcIjtcclxuICAgICAgICB0aGlzLmlkID0gVXRpbHMuY3JlYXRlSWQodGhpcy50eXBlKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRHcmFwaGljcygpO1xyXG4gICAgfVxyXG5cclxuICAgICR3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpIFxyXG4gICAge1xyXG4gICAgICAgIGlmICggbmFtZSA9PSBcImhyXCIgfHwgbmFtZSA9PSBcInZyXCIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0R3JhcGhpY3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0R3JhcGhpY3MoKVxyXG4gICAgeyAgICBcclxuICAgICAgICB0aGlzLmdyYXBoaWNzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3RWxsaXBzZSgwLDAsIHRoaXMuY29udGV4dC5ocioyICwgdGhpcy5jb250ZXh0LnZyKjIpO1xyXG4gICAgfVxyXG59O1xyXG4iLCIvKipcclxuICogQ2FudmF4XHJcbiAqXHJcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcclxuICpcclxuICog5aSa6L655b2iIOexuyAg77yI5LiN6KeE5YiZ77yJXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQHBvaW50TGlzdCDlpJrovrnlvaLlkITkuKrpobbop5LlnZDmoIdcclxuICoqL1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL2Rpc3BsYXkvU2hhcGVcIjtcclxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xyXG5pbXBvcnQgX01hdGggZnJvbSBcIi4uL2dlb20vTWF0aFwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIGV4dGVuZHMgU2hhcGUgXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdCwgYXR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQob3B0KTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGxpbmVUeXBlOiBudWxsLFxyXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxyXG4gICAgICAgICAgICBwb2ludExpc3Q6IFtdLCAvL3tBcnJheX0gIC8vIOW/hemhu++8jOWQhOS4qumhtuinkuWdkOagh1xyXG4gICAgICAgICAgICBzbW9vdGhGaWx0ZXI6IFV0aWxzLl9fZW1wdHlGdW5jXHJcbiAgICAgICAgfSwgb3B0LmNvbnRleHQgKTtcclxuXHJcbiAgICAgICAgaWYoYXR5cGUgIT09IFwiY2xvbmVcIil7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IF9jb250ZXh0LnBvaW50TGlzdFswXTtcclxuICAgICAgICAgICAgdmFyIGVuZCAgID0gX2NvbnRleHQucG9pbnRMaXN0LnNsaWNlKCAtIDEgKVswXTtcclxuICAgICAgICAgICAgaWYoIF9jb250ZXh0LnNtb290aCApe1xyXG4gICAgICAgICAgICAgICAgX2NvbnRleHQucG9pbnRMaXN0LnVuc2hpZnQoIGVuZCApO1xyXG4gICAgICAgICAgICAgICAgX2NvbnRleHQucG9pbnRMaXN0ID0gX01hdGguZ2V0U21vb3RoUG9pbnRMaXN0KCBfY29udGV4dC5wb2ludExpc3QgKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgLy9lbHNlIHtcclxuICAgICAgICAgICAgLy8gICAgX2NvbnRleHQucG9pbnRMaXN0LnB1c2goIHN0YXJ0ICk7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3VwZXIob3B0LCBhdHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2RyYXdUeXBlT25seSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwb2x5Z29uXCI7XHJcbiAgICAgICAgdGhpcy5pZCA9IFV0aWxzLmNyZWF0ZUlkKHRoaXMudHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0R3JhcGhpY3MoKTtcclxuICAgIH1cclxuXHJcbiAgICAkd2F0Y2gobmFtZSwgdmFsdWUsIHByZVZhbHVlKSBcclxuICAgIHtcclxuICAgICAgICAvL+iwg+eUqHBhcmVudOeahHNldEdyYXBoaWNzXHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwb2ludExpc3RcIiB8fCBuYW1lID09IFwic21vb3RoXCIgfHwgbmFtZSA9PSBcImxpbmVUeXBlXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRHcmFwaGljcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRHcmFwaGljcygpIFxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICBjb25zdCBwb2ludExpc3QgPSBjb250ZXh0LnBvaW50TGlzdDtcclxuICAgICAgICBpZiAocG9pbnRMaXN0Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgLy/lsJHkuo4y5Liq54K55bCx5LiN55S75LqGflxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy5tb3ZlVG8ocG9pbnRMaXN0WzBdWzBdLCBwb2ludExpc3RbMF1bMV0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbyhwb2ludExpc3RbaV1bMF0sIHBvaW50TGlzdFtpXVsxXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzLmNsb3NlUGF0aCgpO1xyXG5cclxuICAgICAgICAvL+WmguaenOS4uuiZmue6v1xyXG4gICAgICAgIGlmIChjb250ZXh0LmxpbmVUeXBlID09ICdkYXNoZWQnIHx8IGNvbnRleHQubGluZVR5cGUgPT0gJ2RvdHRlZCcpIHtcclxuICAgICAgICAgICAgLy/pppblhYjmiorliY3pnaLnmoRkcmFwaGljc0RhdGHorr7nva7kuLpmaWxsIG9ubHlcclxuICAgICAgICAgICAgLy/kuZ/lsLHmmK/miopsaW5l5by65Yi26K6+572u5Li6ZmFsc2XvvIzov5nngrnlvojph43opoHvvIzlkKbliJnkvaDomZrnur/nlLvkuI3lh7rmnaXvvIzkvJrlkozov5nkuKrlrp7njrDph43lj6DkuoZcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5jdXJyZW50UGF0aC5saW5lID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5zbW9vdGgpIHtcclxuICAgICAgICAgICAgICAgIC8v5aaC5p6c5pivc21vb3Ro77yM5pys6Lqr5bey57uP6KKr55So5puy546H5omT5pWj6L+H5LqG77yM5LiN6ZyA6KaB6YeH55So6Ze06ZqU5rOVXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDAsIHNsID0gcG9pbnRMaXN0Lmxlbmd0aDsgc2kgPCBzbDsgc2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaSA9PSBzbC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5tb3ZlVG8oIHBvaW50TGlzdFtzaV1bMF0gLCBwb2ludExpc3Rbc2ldWzFdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oIHBvaW50TGlzdFtzaSsxXVswXSAsIHBvaW50TGlzdFtzaSsxXVsxXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpKz0xO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8v55S76Jma57q/55qE5pa55rOVICBcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubW92ZVRvKHBvaW50TGlzdFswXVswXSwgcG9pbnRMaXN0WzBdWzFdKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tWCA9IHBvaW50TGlzdFtpIC0gMV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvWCA9IHBvaW50TGlzdFtpXVswXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVkgPSBwb2ludExpc3RbaSAtIDFdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b1kgPSBwb2ludExpc3RbaV1bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXNoZWRMaW5lVG8oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgNSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn07IiwiLyoqXHJcbiAqIENhbnZheFxyXG4gKlxyXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXHJcbiAqXHJcbiAqIOato27ovrnlvaLvvIhuPj0z77yJXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIkgXHJcbiAqXHJcbiAqIEByIOato27ovrnlvaLlpJbmjqXlnIbljYrlvoRcclxuICogQHIg5oyH5piO5q2j5Yeg6L655b2iXHJcbiAqXHJcbiAqIEBwb2ludExpc3Qg56eB5pyJ77yM5LuO5LiK6Z2i55qEcuWSjG7orqHnrpflvpfliLDnmoTovrnnlYzlgLznmoTpm4blkIhcclxuICovXHJcbmltcG9ydCBQb2x5Z29uIGZyb20gXCIuL1BvbHlnb25cIjtcclxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xyXG5pbXBvcnQgX01hdGggZnJvbSBcIi4uL2dlb20vTWF0aFwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJc29nb24gZXh0ZW5kcyBQb2x5Z29uXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdClcclxuICAgIHtcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdChvcHQpO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgcG9pbnRMaXN0OiBbXSwgLy/ku47kuIvpnaLnmoRy5ZKMbuiuoeeul+W+l+WIsOeahOi+ueeVjOWAvOeahOmbhuWQiFxyXG4gICAgICAgICAgICByOiAwLCAvL3tudW1iZXJ9LCAgLy8g5b+F6aG777yM5q2jbui+ueW9ouWkluaOpeWchuWNiuW+hFxyXG4gICAgICAgICAgICBuOiAwIC8ve251bWJlcn0sICAvLyDlv4XpobvvvIzmjIfmmI7mraPlh6DovrnlvaJcclxuICAgICAgICB9ICwgb3B0LmNvbnRleHQpO1xyXG4gICAgICAgIF9jb250ZXh0LnBvaW50TGlzdCA9IF9NYXRoLmdldElzZ29uUG9pbnRMaXN0KCBfY29udGV4dC5uICwgX2NvbnRleHQuciApO1xyXG5cclxuICAgICAgICBvcHQuY29udGV4dCA9IF9jb250ZXh0O1xyXG5cclxuICAgICAgICBzdXBlciggb3B0ICk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiaXNvZ29uXCI7XHJcbiAgICAgICAgdGhpcy5pZCA9IFV0aWxzLmNyZWF0ZUlkKHRoaXMudHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgJHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInJcIiB8fCBuYW1lID09IFwiblwiKXsgLy/lpoLmnpxwYXRo5pyJ5Y+Y5Yqo77yM6ZyA6KaB6Ieq5Yqo6K6h566X5paw55qEcG9pbnRMaXN0XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5wb2ludExpc3QgPSBfTWF0aC5nZXRJc2dvblBvaW50TGlzdCggc3R5bGUubiAsIHN0eWxlLnIgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09IFwicG9pbnRMaXN0XCIgfHwgbmFtZSA9PSBcInNtb290aFwiIHx8IG5hbWUgPT0gXCJsaW5lVHlwZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0R3JhcGhpY3MoKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07IiwiLyoqXHJcbiAqIENhbnZheFxyXG4gKlxyXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXHJcbiAqXHJcbiAqIOe6v+adoSDnsbtcclxuICpcclxuICpcclxuICog5a+55bqUY29udGV4dOeahOWxnuaAp+aciVxyXG4gKiBAbGluZVR5cGUgIOWPr+mAiSDomZrnur8g5a6e546wIOeahCDnsbvlnotcclxuICogQHhTdGFydCAgICDlv4XpobvvvIzotbfngrnmqKrlnZDmoIdcclxuICogQHlTdGFydCAgICDlv4XpobvvvIzotbfngrnnurXlnZDmoIdcclxuICogQHhFbmQgICAgICDlv4XpobvvvIznu4jngrnmqKrlnZDmoIdcclxuICogQHlFbmQgICAgICDlv4XpobvvvIznu4jngrnnurXlnZDmoIdcclxuICoqL1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL2Rpc3BsYXkvU2hhcGVcIjtcclxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZSBleHRlbmRzIFNoYXBlXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdClcclxuICAgIHtcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdChvcHQpO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgbGluZVR5cGU6IG51bGwsIC8v5Y+v6YCJIOiZmue6vyDlrp7njrAg55qEIOexu+Wei1xyXG4gICAgICAgICAgICBzdGFydDoge1xyXG4gICAgICAgICAgICAgICAgeCA6IDAsICAgICAgLy8g5b+F6aG777yM6LW354K55qiq5Z2Q5qCHXHJcbiAgICAgICAgICAgICAgICB5IDogMCAgICAgICAvLyDlv4XpobvvvIzotbfngrnnurXlnZDmoIdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZW5kOiB7XHJcbiAgICAgICAgICAgICAgICB4IDogMCwgICAgICAvLyDlv4XpobvvvIznu4jngrnmqKrlnZDmoIdcclxuICAgICAgICAgICAgICAgIHkgOiAwICAgICAgIC8vIOW/hemhu++8jOe7iOeCuee6teWdkOagh1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkYXNoTGVuZ3RoOiAzICAgIC8vIOiZmue6v+mXtOmalFxyXG4gICAgICAgIH0gLCBvcHQuY29udGV4dCk7XHJcbiAgICAgICAgb3B0LmNvbnRleHQgPSBfY29udGV4dDtcclxuXHJcbiAgICAgICAgc3VwZXIoIG9wdCApO1xyXG5cclxuICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwibGluZVwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgICR3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgLy/lubbkuI3muIXmpZrmmK9zdGFydC54IOi/mOaYr2VuZC5477yMIOW9k+eEtu+8jOi/meW5tuS4jemHjeimgVxyXG4gICAgICAgIGlmIChuYW1lID09IFwieFwiIHx8IG5hbWUgPT0gXCJ5XCIpe1xyXG4gICAgICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldEdyYXBoaWNzKCkgXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy5jbGVhcigpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmxpbmVUeXBlIHx8IGNvbnRleHQubGluZVR5cGUgPT0gJ3NvbGlkJykge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyggY29udGV4dC5zdGFydC54ICwgY29udGV4dC5zdGFydC55ICk7IFxyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbyggY29udGV4dC5lbmQueCAgICwgY29udGV4dC5lbmQueSApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5saW5lVHlwZSA9PSAnZGFzaGVkJyB8fCBjb250ZXh0LmxpbmVUeXBlID09ICdkb3R0ZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGFzaGVkTGluZVRvKFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdGFydC54LCBjb250ZXh0LnN0YXJ0LnksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVuZC54ICAsIGNvbnRleHQuZW5kLnksIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRhc2hMZW5ndGhcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuIFxyXG59OyIsIi8qKlxyXG4gKiBDYW52YXhcclxuICpcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDnn6nnjrAg57G7ICDvvIjkuI3op4TliJnvvIlcclxuICpcclxuICpcclxuICog5a+55bqUY29udGV4dOeahOWxnuaAp+aciVxyXG4gKiBAd2lkdGgg5a695bqmXHJcbiAqIEBoZWlnaHQg6auY5bqmXHJcbiAqIEByYWRpdXMg5aaC5p6c5piv5ZyG6KeS55qE77yM5YiZ5Li644CQ5LiK5Y+z5LiL5bem44CR6aG65bqP55qE5ZyG6KeS5Y2K5b6E5pWw57uEXHJcbiAqKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBTaGFwZVxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihvcHQpXHJcbiAgICB7XHJcbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQoIG9wdCApO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgd2lkdGggOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgICAgICAgIHJhZGl1czogW10sXHJcbiAgICAgICAgfSAsIG9wdC5jb250ZXh0KTtcclxuICAgICAgICBvcHQuY29udGV4dCA9IF9jb250ZXh0O1xyXG5cclxuICAgICAgICBzdXBlciggb3B0ICk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicmVjdFwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgJHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCBuYW1lID09IFwid2lkdGhcIiB8fCBuYW1lID09IFwiaGVpZ2h0XCIgfHwgbmFtZSA9PSBcInJhZGl1c1wiICkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEdyYXBoaWNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uY5Yi25ZyG6KeS55+p5b2iXHJcbiAgICAgKi9cclxuICAgIF9idWlsZFJhZGl1c1BhdGgoKVxyXG4gICAge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIC8v5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcclxuICAgICAgICAvL3LnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxyXG4gICAgICAgIC8vcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXHJcbiAgICAgICAgLy9y57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cclxuICAgICAgICAvL3LnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jb250ZXh0LndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNvbnRleHQuaGVpZ2h0O1xyXG4gICAgXHJcbiAgICAgICAgdmFyIHIgPSBVdGlscy5nZXRDc3NPcmRlckFycihjb250ZXh0LnJhZGl1cyk7XHJcbiAgICAgICAgdmFyIEcgPSB0aGlzLmdyYXBoaWNzO1xyXG4gICAgIFxyXG4gICAgICAgIEcubW92ZVRvKCBwYXJzZUludCh4ICsgclswXSksIHBhcnNlSW50KHkpKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCArIHdpZHRoIC0gclsxXSksIHBhcnNlSW50KHkpKTtcclxuICAgICAgICByWzFdICE9PSAwICYmIEcucXVhZHJhdGljQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgclsxXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCArIHdpZHRoKSwgcGFyc2VJbnQoeSArIGhlaWdodCAtIHJbMl0pKTtcclxuICAgICAgICByWzJdICE9PSAwICYmIEcucXVhZHJhdGljQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gclsyXSwgeSArIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCArIHJbM10pLCBwYXJzZUludCh5ICsgaGVpZ2h0KSk7XHJcbiAgICAgICAgclszXSAhPT0gMCAmJiBHLnF1YWRyYXRpY0N1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gclszXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCksIHBhcnNlSW50KHkgKyByWzBdKSk7XHJcbiAgICAgICAgclswXSAhPT0gMCAmJiBHLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJbMF0sIHkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnn6nlvaLot6/lvoRcclxuICAgICAqIEBwYXJhbSB7Q29udGV4dDJEfSBjdHggQ2FudmFzIDJE5LiK5LiL5paHXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCDmoLflvI9cclxuICAgICAqL1xyXG4gICAgc2V0R3JhcGhpY3MoKSBcclxuICAgIHtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzLmNsZWFyKCk7XHJcbiAgICAgICAgaWYoIXRoaXMuY29udGV4dC5yYWRpdXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoMCwwLHRoaXMuY29udGV4dC53aWR0aCAsIHRoaXMuY29udGV4dC5oZWlnaHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkUmFkaXVzUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyYXBoaWNzLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufSIsIi8qKlxyXG4gKiBDYW52YXhcclxuICpcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDmiYflvaIg57G7XHJcbiAqXHJcbiAqIOWdkOagh+WOn+eCueWGjeWchuW/g1xyXG4gKlxyXG4gKiDlr7nlupRjb250ZXh055qE5bGe5oCn5pyJXHJcbiAqIEByMCDpu5jorqTkuLow77yM5YaF5ZyG5Y2K5b6E5oyH5a6a5ZCO5bCG5Ye6546w5YaF5byn77yM5ZCM5pe25omH6L656ZW/5bqmID0gciAtIHIwXHJcbiAqIEByICDlv4XpobvvvIzlpJblnIbljYrlvoRcclxuICogQHN0YXJ0QW5nbGUg6LW35aeL6KeS5bqmKDAsIDM2MClcclxuICogQGVuZEFuZ2xlICAg57uT5p2f6KeS5bqmKDAsIDM2MClcclxuICoqL1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL2Rpc3BsYXkvU2hhcGVcIjtcclxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xyXG5pbXBvcnQgbXlNYXRoIGZyb20gXCIuLi9nZW9tL01hdGhcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlY3RvciBleHRlbmRzIFNoYXBlXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdClcclxuICAgIHtcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdCggb3B0ICk7XHJcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gXy5leHRlbmQoe1xyXG4gICAgICAgICAgICBwb2ludExpc3QgIDogW10sLy/ovrnnlYzngrnnmoTpm4blkIgs56eB5pyJ77yM5LuO5LiL6Z2i55qE5bGe5oCn6K6h566X55qE5p2lXHJcbiAgICAgICAgICAgIHIwICAgICAgICAgOiAwLC8vIOm7mOiupOS4ujDvvIzlhoXlnIbljYrlvoTmjIflrprlkI7lsIblh7rnjrDlhoXlvKfvvIzlkIzml7bmiYfovrnplb/luqYgPSByIC0gcjBcclxuICAgICAgICAgICAgciAgICAgICAgICA6IDAsLy97bnVtYmVyfSwgIC8vIOW/hemhu++8jOWkluWchuWNiuW+hFxyXG4gICAgICAgICAgICBzdGFydEFuZ2xlIDogMCwvL3tudW1iZXJ9LCAgLy8g5b+F6aG777yM6LW35aeL6KeS5bqmWzAsIDM2MClcclxuICAgICAgICAgICAgZW5kQW5nbGUgICA6IDAsIC8ve251bWJlcn0sICAvLyDlv4XpobvvvIznu5PmnZ/op5LluqYoMCwgMzYwXVxyXG4gICAgICAgICAgICBjbG9ja3dpc2UgIDogZmFsc2UgLy/mmK/lkKbpobrml7bpkojvvIzpu5jorqTkuLpmYWxzZSjpobrml7bpkogpXHJcbiAgICAgICAgfSAsIG9wdC5jb250ZXh0KTtcclxuICAgICAgICBcclxuICAgICAgICBvcHQuY29udGV4dCA9IF9jb250ZXh0O1xyXG5cclxuICAgICAgICBzdXBlcihvcHQpO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5yZWdBbmdsZSAgPSBbXTtcclxuICAgICAgICB0aGlzLmlzUmluZyAgICA9IGZhbHNlOy8v5piv5ZCm5Li65LiA5Liq5ZyG546vXHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZWN0b3JcIjtcclxuICAgICAgICB0aGlzLmlkID0gVXRpbHMuY3JlYXRlSWQodGhpcy50eXBlKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRHcmFwaGljcygpO1xyXG4gICAgfVxyXG5cclxuICAgICR3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpIFxyXG4gICAge1xyXG4gICAgICAgIGlmICggbmFtZSA9PSBcInIwXCIgfHwgbmFtZSA9PSBcInJcIiB8fCBuYW1lID09IFwic3RhcnRBbmdsZVwiIHx8IG5hbWUgPT1cImVuZEFuZ2xlXCIgfHwgbmFtZSA9PVwiY2xvY2t3aXNlXCIgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0R3JhcGhpY3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0R3JhcGhpY3MoKSBcclxuICAgIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAvLyDlvaLlhoXljYrlvoRbMCxyKVxyXG4gICAgICAgIHZhciByMCA9IHR5cGVvZiBjb250ZXh0LnIwID09ICd1bmRlZmluZWQnID8gMCA6IGNvbnRleHQucjA7XHJcbiAgICAgICAgdmFyIHIgID0gY29udGV4dC5yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDmiYflvaLlpJbljYrlvoQoMCxyXVxyXG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gbXlNYXRoLmRlZ3JlZVRvMzYwKGNvbnRleHQuc3RhcnRBbmdsZSk7ICAgICAgICAgIC8vIOi1t+Wni+inkuW6plswLDM2MClcclxuICAgICAgICB2YXIgZW5kQW5nbGUgICA9IG15TWF0aC5kZWdyZWVUbzM2MChjb250ZXh0LmVuZEFuZ2xlKTsgICAgICAgICAgICAgIC8vIOe7k+adn+inkuW6pigwLDM2MF1cclxuXHJcbiAgICAgICAgLy92YXIgaXNSaW5nICAgICA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgLy/mmK/lkKbkuLrlnIbnjq9cclxuXHJcbiAgICAgICAgLy9pZiggc3RhcnRBbmdsZSAhPSBlbmRBbmdsZSAmJiBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgMzYwID09IDAgKSB7XHJcbiAgICAgICAgaWYoIHN0YXJ0QW5nbGUgPT0gZW5kQW5nbGUgJiYgY29udGV4dC5zdGFydEFuZ2xlICE9IGNvbnRleHQuZW5kQW5nbGUgKSB7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5Lik5Liq6KeS5bqm55u4562J77yM6YKj5LmI5bCx6K6k5Li65piv5Liq5ZyG546v5LqGXHJcbiAgICAgICAgICAgIHRoaXMuaXNSaW5nICAgICA9IHRydWU7XHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSAwIDtcclxuICAgICAgICAgICAgZW5kQW5nbGUgICA9IDM2MDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBteU1hdGguZGVncmVlVG9SYWRpYW4oc3RhcnRBbmdsZSk7XHJcbiAgICAgICAgZW5kQW5nbGUgICA9IG15TWF0aC5kZWdyZWVUb1JhZGlhbihlbmRBbmdsZSk7XHJcbiAgICAgXHJcbiAgICAgICAgLy/lpITnkIbkuIvmnoHlsI/lpLnop5LnmoTmg4XlhrVcclxuICAgICAgICBpZiggZW5kQW5nbGUgLSBzdGFydEFuZ2xlIDwgMC4wMjUgKXtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSAtPSAwLjAwM1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIEcgPSB0aGlzLmdyYXBoaWNzO1xyXG5cclxuICAgICAgICBHLmFyYyggMCAsIDAgLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdGhpcy5jb250ZXh0LmNsb2Nrd2lzZSk7XHJcbiAgICAgICAgaWYgKHIwICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmKCB0aGlzLmlzUmluZyApe1xyXG4gICAgICAgICAgICAgICAgLy/liqDkuIrov5nkuKppc1JpbmfnmoTpgLvovpHmmK/kuLrkuoblhbzlrrlmbGFzaGNhbnZhc+S4i+e7mOWItuWchueOr+eahOeahOmXrumimFxyXG4gICAgICAgICAgICAgICAgLy/kuI3liqDov5nkuKrpgLvovpFmbGFzaGNhbnZhc+S8mue7mOWItuS4gOS4quWkp+WchiDvvIwg6ICM5LiN5piv5ZyG546vXHJcbiAgICAgICAgICAgICAgICBHLm1vdmVUbyggcjAgLCAwICk7XHJcbiAgICAgICAgICAgICAgICBHLmFyYyggMCAsIDAgLCByMCAsIHN0YXJ0QW5nbGUgLCBlbmRBbmdsZSAsICF0aGlzLmNvbnRleHQuY2xvY2t3aXNlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIEcuYXJjKCAwICwgMCAsIHIwICwgZW5kQW5nbGUgLCBzdGFydEFuZ2xlICwgIXRoaXMuY29udGV4dC5jbG9ja3dpc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9UT0RPOuWcqHIw5Li6MOeahOaXtuWAme+8jOWmguaenOS4jeWKoGxpbmVUbygwLDAp5p2l5oqK6Lev5b6E6Zet5ZCI77yM5Lya5Ye6546w5pyJ5pCe56yR55qE5LiA5LiqYnVnXHJcbiAgICAgICAgICAgIC8v5pW05Liq5ZyG5Lya5Ye6546w5LiA5Liq5Lul5q+P5Liq5omH5b2i5Lik56uv5Li66IqC54K555qE6ZWC56m677yM5oiR5Y+v6IO95o+P6L+w5LiN5riF5qWa77yM5Y+N5q2j6L+Z5Liq5Yqg5LiK5bCx5aW95LqGXHJcbiAgICAgICAgICAgIEcubGluZVRvKDAsMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBHLmNsb3NlUGF0aCgpO1xyXG4gICAgIH1cclxuXHJcbiAgICAgZ2V0UmVnQW5nbGUoKVxyXG4gICAgIHtcclxuICAgICAgICAgdGhpcy5yZWdJbiAgICAgID0gdHJ1ZTsgIC8v5aaC5p6c5Zyoc3RhcnTlkoxlbmTnmoTmlbDlgLzkuK3vvIxlbmTlpKfkuo5zdGFydOiAjOS4lOaYr+mhuuaXtumSiOWImXJlZ0lu5Li6dHJ1ZVxyXG4gICAgICAgICB2YXIgYyAgICAgICAgICAgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gbXlNYXRoLmRlZ3JlZVRvMzYwKGMuc3RhcnRBbmdsZSk7ICAgICAgICAgIC8vIOi1t+Wni+inkuW6plswLDM2MClcclxuICAgICAgICAgdmFyIGVuZEFuZ2xlICAgPSBteU1hdGguZGVncmVlVG8zNjAoYy5lbmRBbmdsZSk7ICAgICAgICAgICAgLy8g57uT5p2f6KeS5bqmKDAsMzYwXVxyXG5cclxuICAgICAgICAgaWYgKCAoIHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYy5jbG9ja3dpc2UgKSB8fCAoIHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBjLmNsb2Nrd2lzZSApICkge1xyXG4gICAgICAgICAgICAgdGhpcy5yZWdJbiAgPSBmYWxzZTsgLy9vdXRcclxuICAgICAgICAgfTtcclxuICAgICAgICAgLy/luqbnmoTojIPlm7TvvIzku47lsI/liLDlpKdcclxuICAgICAgICAgdGhpcy5yZWdBbmdsZSAgID0gWyBcclxuICAgICAgICAgICAgIE1hdGgubWluKCBzdGFydEFuZ2xlICwgZW5kQW5nbGUgKSAsIFxyXG4gICAgICAgICAgICAgTWF0aC5tYXgoIHN0YXJ0QW5nbGUgLCBlbmRBbmdsZSApIFxyXG4gICAgICAgICBdO1xyXG4gICAgIH1cclxuXHJcbiAgICAgZ2V0UmVjdChjb250ZXh0KVxyXG4gICAgIHtcclxuICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250ZXh0ID8gY29udGV4dCA6IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgdmFyIHIwID0gdHlwZW9mIGNvbnRleHQucjAgPT0gJ3VuZGVmaW5lZCcgICAgIC8vIOW9ouWGheWNiuW+hFswLHIpXHJcbiAgICAgICAgICAgICA/IDAgOiBjb250ZXh0LnIwO1xyXG4gICAgICAgICB2YXIgciA9IGNvbnRleHQucjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5omH5b2i5aSW5Y2K5b6EKDAscl1cclxuICAgICAgICAgXHJcbiAgICAgICAgIHRoaXMuZ2V0UmVnQW5nbGUoKTtcclxuXHJcbiAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gbXlNYXRoLmRlZ3JlZVRvMzYwKGNvbnRleHQuc3RhcnRBbmdsZSk7ICAgICAgICAgIC8vIOi1t+Wni+inkuW6plswLDM2MClcclxuICAgICAgICAgdmFyIGVuZEFuZ2xlICAgPSBteU1hdGguZGVncmVlVG8zNjAoY29udGV4dC5lbmRBbmdsZSk7ICAgICAgICAgICAgLy8g57uT5p2f6KeS5bqmKDAsMzYwXVxyXG5cclxuICAgICAgICAgdmFyIHBvaW50TGlzdCAgPSBbXTtcclxuXHJcbiAgICAgICAgIHZhciBwNERpcmVjdGlvbj0ge1xyXG4gICAgICAgICAgICAgXCI5MFwiIDogWyAwICwgciBdLFxyXG4gICAgICAgICAgICAgXCIxODBcIjogWyAtciwgMCBdLFxyXG4gICAgICAgICAgICAgXCIyNzBcIjogWyAwICwgLXJdLFxyXG4gICAgICAgICAgICAgXCIzNjBcIjogWyByICwgMCBdIFxyXG4gICAgICAgICB9O1xyXG5cclxuICAgICAgICAgZm9yICggdmFyIGQgaW4gcDREaXJlY3Rpb24gKXtcclxuICAgICAgICAgICAgIHZhciBpbkFuZ2xlUmVnID0gcGFyc2VJbnQoZCkgPiB0aGlzLnJlZ0FuZ2xlWzBdICYmIHBhcnNlSW50KGQpIDwgdGhpcy5yZWdBbmdsZVsxXTtcclxuICAgICAgICAgICAgIGlmKCB0aGlzLmlzUmluZyB8fCAoaW5BbmdsZVJlZyAmJiB0aGlzLnJlZ0luKSB8fCAoIWluQW5nbGVSZWcgJiYgIXRoaXMucmVnSW4pICl7XHJcbiAgICAgICAgICAgICAgICAgcG9pbnRMaXN0LnB1c2goIHA0RGlyZWN0aW9uWyBkIF0gKTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgaWYoICF0aGlzLmlzUmluZyApIHtcclxuICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBteU1hdGguZGVncmVlVG9SYWRpYW4oIHN0YXJ0QW5nbGUgKTtcclxuICAgICAgICAgICAgIGVuZEFuZ2xlICAgPSBteU1hdGguZGVncmVlVG9SYWRpYW4oIGVuZEFuZ2xlICAgKTtcclxuXHJcbiAgICAgICAgICAgICBwb2ludExpc3QucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgIG15TWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByMCAsIG15TWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByMFxyXG4gICAgICAgICAgICAgICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgICAgICBwb2ludExpc3QucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgIG15TWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByICAsIG15TWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByXHJcbiAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgbXlNYXRoLmNvcyhlbmRBbmdsZSkgICAqIHIgICwgIG15TWF0aC5zaW4oZW5kQW5nbGUpICAqIHJcclxuICAgICAgICAgICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICAgcG9pbnRMaXN0LnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICBteU1hdGguY29zKGVuZEFuZ2xlKSAgICogcjAgLCAgbXlNYXRoLnNpbihlbmRBbmdsZSkgICogcjBcclxuICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGNvbnRleHQucG9pbnRMaXN0ID0gcG9pbnRMaXN0O1xyXG4gICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWN0Rm9ybVBvaW50TGlzdCggY29udGV4dCApO1xyXG4gICAgIH1cclxufVxyXG4iLCJcbmltcG9ydCBBcHBsaWNhdGlvbiBmcm9tIFwiLi9BcHBsaWNhdGlvblwiO1xuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tIFwiLi9ldmVudC9FdmVudERpc3BhdGNoZXJcIjtcbmltcG9ydCBFdmVudE1hbmFnZXIgZnJvbSBcIi4vZXZlbnQvRXZlbnRNYW5hZ2VyXCI7XG5pbXBvcnQgRGlzcGxheU9iamVjdCBmcm9tIFwiLi9kaXNwbGF5L0Rpc3BsYXlPYmplY3RcIjtcbmltcG9ydCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIGZyb20gXCIuL2Rpc3BsYXkvRGlzcGxheU9iamVjdENvbnRhaW5lclwiO1xuaW1wb3J0IFN0YWdlIGZyb20gXCIuL2Rpc3BsYXkvU3RhZ2VcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4vZGlzcGxheS9TcHJpdGVcIjtcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi9kaXNwbGF5L1NoYXBlXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4vZGlzcGxheS9Qb2ludFwiO1xuaW1wb3J0IFRleHQgZnJvbSBcIi4vZGlzcGxheS9UZXh0XCI7XG5cbi8vc2hhcGVzXG5pbXBvcnQgQnJva2VuTGluZSBmcm9tIFwiLi9zaGFwZS9Ccm9rZW5MaW5lXCI7XG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuL3NoYXBlL0NpcmNsZVwiO1xuaW1wb3J0IERyb3BsZXQgZnJvbSBcIi4vc2hhcGUvRHJvcGxldFwiO1xuaW1wb3J0IEVsbGlwc2UgZnJvbSBcIi4vc2hhcGUvRWxsaXBzZVwiO1xuaW1wb3J0IElzb2dvbiBmcm9tIFwiLi9zaGFwZS9Jc29nb25cIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuL3NoYXBlL0xpbmVcIjtcbmltcG9ydCBQYXRoIGZyb20gXCIuL3NoYXBlL1BhdGhcIjtcbmltcG9ydCBQb2x5Z29uIGZyb20gXCIuL3NoYXBlL1BvbHlnb25cIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuL3NoYXBlL1JlY3RcIjtcbmltcG9ydCBTZWN0b3IgZnJvbSBcIi4vc2hhcGUvU2VjdG9yXCI7XG5cbnZhciBDYW52YXggPSB7XG4gICAgQXBwOiBBcHBsaWNhdGlvblxufTtcblxuQ2FudmF4LkRpc3BsYXkgPSB7XG4gICAgRGlzcGxheU9iamVjdCA6IERpc3BsYXlPYmplY3QsXG4gICAgRGlzcGxheU9iamVjdENvbnRhaW5lciA6IERpc3BsYXlPYmplY3RDb250YWluZXIsXG4gICAgU3RhZ2UgIDogU3RhZ2UsXG4gICAgU3ByaXRlIDogU3ByaXRlLFxuICAgIFNoYXBlICA6IFNoYXBlLFxuICAgIFBvaW50ICA6IFBvaW50LFxuICAgIFRleHQgICA6IFRleHRcbn1cblxuQ2FudmF4LlNoYXBlcyA9IHtcbiAgICBCcm9rZW5MaW5lIDogQnJva2VuTGluZSxcbiAgICBDaXJjbGUgOiBDaXJjbGUsXG4gICAgRHJvcGxldCA6IERyb3BsZXQsXG4gICAgRWxsaXBzZSA6IEVsbGlwc2UsXG4gICAgSXNvZ29uIDogSXNvZ29uLFxuICAgIExpbmUgOiBMaW5lLFxuICAgIFBhdGggOiBQYXRoLFxuICAgIFBvbHlnb24gOiBQb2x5Z29uLFxuICAgIFJlY3QgOiBSZWN0LFxuICAgIFNlY3RvciA6IFNlY3RvclxufVxuXG5DYW52YXguRXZlbnQgPSB7XG4gICAgRXZlbnREaXNwYXRjaGVyIDogRXZlbnREaXNwYXRjaGVyLFxuICAgIEV2ZW50TWFuYWdlciAgICA6IEV2ZW50TWFuYWdlclxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXg7Il0sIm5hbWVzIjpbIl8iLCJicmVha2VyIiwiQXJyYXlQcm90byIsIkFycmF5IiwicHJvdG90eXBlIiwiT2JqUHJvdG8iLCJPYmplY3QiLCJ0b1N0cmluZyIsImhhc093blByb3BlcnR5IiwibmF0aXZlRm9yRWFjaCIsImZvckVhY2giLCJuYXRpdmVGaWx0ZXIiLCJmaWx0ZXIiLCJuYXRpdmVJbmRleE9mIiwiaW5kZXhPZiIsIm5hdGl2ZUlzQXJyYXkiLCJpc0FycmF5IiwibmF0aXZlS2V5cyIsImtleXMiLCJ2YWx1ZXMiLCJvYmoiLCJsZW5ndGgiLCJpIiwiVHlwZUVycm9yIiwia2V5IiwiaGFzIiwicHVzaCIsImNhbGwiLCJlYWNoIiwiaXRlcmF0b3IiLCJjb250ZXh0IiwiY29tcGFjdCIsImFycmF5IiwiaWRlbnRpdHkiLCJzZWxlY3QiLCJyZXN1bHRzIiwidmFsdWUiLCJpbmRleCIsImxpc3QiLCJuYW1lIiwiaXNGdW5jdGlvbiIsImlzRmluaXRlIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiaXNOdW1iZXIiLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc0VtcHR5IiwiaXNTdHJpbmciLCJpc0VsZW1lbnQiLCJub2RlVHlwZSIsImlzT2JqZWN0IiwiaXRlbSIsImlzU29ydGVkIiwiTWF0aCIsIm1heCIsInNvcnRlZEluZGV4IiwiaXNXaW5kb3ciLCJ3aW5kb3ciLCJpc1BsYWluT2JqZWN0IiwiY29uc3RydWN0b3IiLCJoYXNPd24iLCJlIiwidW5kZWZpbmVkIiwiZXh0ZW5kIiwib3B0aW9ucyIsInNyYyIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwidGFyZ2V0IiwiYXJndW1lbnRzIiwiZGVlcCIsInNsaWNlIiwiVXRpbHMiLCJkZXZpY2VQaXhlbFJhdGlvIiwiX1VJRCIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImdldFVJRCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJwcm90byIsIm5ld1Byb3RvIiwiT2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwiX19lbXB0eUZ1bmMiLCJyIiwicyIsInB4Iiwic3AiLCJycCIsImNyZWF0ZU9iamVjdCIsInN1cGVyY2xhc3MiLCJjYW52YXMiLCJGbGFzaENhbnZhcyIsImluaXRFbGVtZW50Iiwib3B0IiwicjEiLCJyMiIsInIzIiwicjQiLCJjb250ZXh0T3B0aW9ucyIsInN0ZW5jaWwiLCJXZWJHTFJlbmRlcmluZ0NvbnRleHQiLCJnbCIsImdldENvbnRleHRBdHRyaWJ1dGVzIiwiUG9pbnQiLCJ4IiwieSIsImJhYmVsSGVscGVycy50eXBlb2YiLCJhcmciLCJwIiwiQ2FudmF4RXZlbnQiLCJldnQiLCJwYXJhbXMiLCJldmVudFR5cGUiLCJ0eXBlIiwiY3VycmVudFRhcmdldCIsInBvaW50IiwiX3N0b3BQcm9wYWdhdGlvbiIsImFkZE9yUm1vdmVFdmVudEhhbmQiLCJkb21IYW5kIiwiaWVIYW5kIiwiZXZlbnREb21GbiIsImVsIiwiZm4iLCJldmVudEZuIiwiZXZlbnQiLCJnZXRFbGVtZW50QnlJZCIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJib2R5IiwiZG9jRWxlbSIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJib3VuZCIsInJpZ2h0IiwibGVmdCIsImNsaWVudFdpZHRoIiwiem9vbSIsInRvcCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwicGFnZVgiLCJjbGllbnRYIiwicGFnZVkiLCJjbGllbnRZIiwiX3dpZHRoIiwiX2hlaWdodCIsImlkIiwic3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0Iiwic2V0QXR0cmlidXRlIiwic2V0dGluZ3MiLCJSRVNPTFVUSU9OIiwidmlldyIsImNsYXNzTmFtZSIsImNzc1RleHQiLCJzdGFnZV9jIiwiZG9tX2MiLCJhcHBlbmRDaGlsZCIsIl9tb3VzZUV2ZW50VHlwZXMiLCJfaGFtbWVyRXZlbnRUeXBlcyIsIkV2ZW50SGFuZGxlciIsImNhbnZheCIsImN1clBvaW50cyIsImN1clBvaW50c1RhcmdldCIsIl90b3VjaGluZyIsIl9kcmFnaW5nIiwiX2N1cnNvciIsInR5cGVzIiwiZHJhZyIsImNvbnRhaW5zIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJwYXJlbnQiLCJjaGlsZCIsIm1lIiwiYWRkRXZlbnQiLCJfX21vdXNlSGFuZGxlciIsIm9uIiwiX19saWJIYW5kbGVyIiwicm9vdCIsInVwZGF0ZVZpZXdPZmZzZXQiLCIkIiwidmlld09mZnNldCIsImN1ck1vdXNlUG9pbnQiLCJjdXJNb3VzZVRhcmdldCIsImdldE9iamVjdHNVbmRlclBvaW50IiwiZHJhZ0VuYWJsZWQiLCJ0b0VsZW1lbnQiLCJyZWxhdGVkVGFyZ2V0IiwiX2RyYWdFbmQiLCJmaXJlIiwiX19nZXRjdXJQb2ludHNUYXJnZXQiLCJnbG9iYWxBbHBoYSIsImNsb25lT2JqZWN0IiwiX2Nsb25lMmhvdmVyU3RhZ2UiLCJfZ2xvYmFsQWxwaGEiLCJfZHJhZ01vdmVIYW5kZXIiLCJfX2Rpc3BhdGNoRXZlbnRJbkNoaWxkcyIsIl9jdXJzb3JIYW5kZXIiLCJwcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwib2xkT2JqIiwiX2hvdmVyQ2xhc3MiLCJwb2ludENoa1ByaW9yaXR5IiwiZ2V0Q2hpbGRJblBvaW50IiwiZ2xvYmFsVG9Mb2NhbCIsImRpc3BhdGNoRXZlbnQiLCJ0b1RhcmdldCIsImZyb21UYXJnZXQiLCJfc2V0Q3Vyc29yIiwiY3Vyc29yIiwiX19nZXRDYW52YXhQb2ludEluVG91Y2hzIiwiX19nZXRDaGlsZEluVG91Y2hzIiwic3RhcnQiLCJtb3ZlIiwiZW5kIiwiY3VyVG91Y2hzIiwidG91Y2giLCJ0b3VjaHMiLCJ0b3VjaGVzVGFyZ2V0IiwiY2hpbGRzIiwiaGFzQ2hpbGQiLCJjZSIsInN0YWdlUG9pbnQiLCJfZHJhZ0R1cGxpY2F0ZSIsIl9idWZmZXJTdGFnZSIsImdldENoaWxkQnlJZCIsIl90cmFuc2Zvcm0iLCJnZXRDb25jYXRlbmF0ZWRNYXRyaXgiLCJhZGRDaGlsZEF0IiwiX2RyYWdQb2ludCIsIl9wb2ludCIsIl9ub3RXYXRjaCIsIl9tb3ZlU3RhZ2UiLCJtb3ZlaW5nIiwiaGVhcnRCZWF0IiwiZGVzdHJveSIsIkV2ZW50TWFuYWdlciIsIl9ldmVudE1hcCIsImxpc3RlbmVyIiwiYWRkUmVzdWx0Iiwic2VsZiIsInNwbGl0IiwibWFwIiwiX2V2ZW50RW5hYmxlZCIsInJlbW92ZUV2ZW50TGlzdGVuZXJCeVR5cGUiLCJsaSIsInNwbGljZSIsIl9kaXNwYXRjaEV2ZW50IiwiRXZlbnREaXNwYXRjaGVyIiwiY3JlYXRDbGFzcyIsIl9hZGRFdmVudExpc3RlbmVyIiwiX3JlbW92ZUV2ZW50TGlzdGVuZXIiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lckJ5VHlwZSIsIl9yZW1vdmVBbGxFdmVudExpc3RlbmVycyIsImxvZyIsImVUeXBlIiwiY2hpbGRyZW4iLCJwcmVIZWFydEJlYXQiLCJfaGVhcnRCZWF0TnVtIiwicHJlZ0FscGhhIiwiaG92ZXJDbG9uZSIsImdldFN0YWdlIiwiYWN0aXZTaGFwZSIsInJlbW92ZUNoaWxkQnlJZCIsIl9oYXNFdmVudExpc3RlbmVyIiwib3ZlckZ1biIsIm91dEZ1biIsIm9uY2VIYW5kbGUiLCJhcHBseSIsInVuIiwiTWF0cml4IiwiYSIsImIiLCJjIiwiZCIsInR4IiwidHkiLCJtdHgiLCJzY2FsZVgiLCJzY2FsZVkiLCJyb3RhdGlvbiIsImNvcyIsInNpbiIsIlBJIiwiY29uY2F0IiwiYW5nbGUiLCJzdCIsImFicyIsImN0Iiwic3giLCJzeSIsImR4IiwiZHkiLCJ0cmFuc3Bvc2UiLCJvdXQiLCJGbG9hdDMyQXJyYXkiLCJ2IiwiYWEiLCJhYyIsImF0eCIsImFiIiwiYWQiLCJhdHkiLCJUV0VFTiIsIl90d2VlbnMiLCJ0d2VlbiIsInRpbWUiLCJwcmVzZXJ2ZSIsIm5vdyIsIl90IiwiX3VwZGF0ZVJlcyIsInVwZGF0ZSIsInByb2Nlc3MiLCJocnRpbWUiLCJwZXJmb3JtYW5jZSIsImJpbmQiLCJEYXRlIiwiZ2V0VGltZSIsIlR3ZWVuIiwib2JqZWN0IiwiX29iamVjdCIsIl92YWx1ZXNTdGFydCIsIl92YWx1ZXNFbmQiLCJfdmFsdWVzU3RhcnRSZXBlYXQiLCJfZHVyYXRpb24iLCJfcmVwZWF0IiwiX3JlcGVhdERlbGF5VGltZSIsIl95b3lvIiwiX2lzUGxheWluZyIsIl9yZXZlcnNlZCIsIl9kZWxheVRpbWUiLCJfc3RhcnRUaW1lIiwiX2Vhc2luZ0Z1bmN0aW9uIiwiRWFzaW5nIiwiTGluZWFyIiwiTm9uZSIsIl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24iLCJJbnRlcnBvbGF0aW9uIiwiX2NoYWluZWRUd2VlbnMiLCJfb25TdGFydENhbGxiYWNrIiwiX29uU3RhcnRDYWxsYmFja0ZpcmVkIiwiX29uVXBkYXRlQ2FsbGJhY2siLCJfb25Db21wbGV0ZUNhbGxiYWNrIiwiX29uU3RvcENhbGxiYWNrIiwidG8iLCJwcm9wZXJ0aWVzIiwiZHVyYXRpb24iLCJhZGQiLCJwcm9wZXJ0eSIsInN0b3AiLCJyZW1vdmUiLCJzdG9wQ2hhaW5lZFR3ZWVucyIsIm51bUNoYWluZWRUd2VlbnMiLCJkZWxheSIsImFtb3VudCIsInJlcGVhdCIsInRpbWVzIiwicmVwZWF0RGVsYXkiLCJ5b3lvIiwiZWFzaW5nIiwiaW50ZXJwb2xhdGlvbiIsImNoYWluIiwib25TdGFydCIsImNhbGxiYWNrIiwib25VcGRhdGUiLCJvbkNvbXBsZXRlIiwib25TdG9wIiwiZWxhcHNlZCIsImNoYXJBdCIsInRtcCIsImsiLCJwb3ciLCJzcXJ0IiwiQm91bmNlIiwiT3V0IiwiSW4iLCJtIiwiZiIsImZsb29yIiwibiIsInB3IiwiYm4iLCJCZXJuc3RlaW4iLCJDYXRtdWxsUm9tIiwicDAiLCJwMSIsInQiLCJmYyIsIkZhY3RvcmlhbCIsInAyIiwicDMiLCJ2MCIsInYxIiwidDIiLCJ0MyIsImxhc3RUaW1lIiwidmVuZG9ycyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZWxlbWVudCIsImN1cnJUaW1lIiwidGltZVRvQ2FsbCIsInNldFRpbWVvdXQiLCJfdGFza0xpc3QiLCJfcmVxdWVzdEFpZCIsImVuYWJsZWRBbmltYXRpb25GcmFtZSIsImN1cnJUYXNrTGlzdCIsInNoaWZ0IiwidGFzayIsInJlZ2lzdEZyYW1lIiwiJGZyYW1lIiwiZGVzdHJveUZyYW1lIiwiZF9yZXN1bHQiLCJsIiwicmVnaXN0VHdlZW4iLCJ0aWQiLCJmcm9tIiwiYW5pbWF0ZSIsIl9pc0NvbXBsZXRlZWQiLCJfaXNTdG9wZWQiLCJkZXNjIiwiZGVzdHJveVR3ZWVuIiwibXNnIiwidW53YXRjaE9uZSIsIk9ic2VydmUiLCJzY29wZSIsIm1vZGVsIiwid2F0Y2hNb3JlIiwic3RvcFJlcGVhdEFzc2lnbiIsInNraXBBcnJheSIsIiRza2lwQXJyYXkiLCJWQlB1YmxpY3MiLCJsb29wIiwidmFsIiwidmFsdWVUeXBlIiwiYWNjZXNzb3IiLCJuZW8iLCJwcmVWYWx1ZSIsImNvbXBsZXhWYWx1ZSIsIm5lb1R5cGUiLCJhZGRDb2xvclN0b3AiLCIkbW9kZWwiLCIkZmlyZSIsInBtb2RlbCIsImhhc1dhdGNoTW9kZWwiLCIkd2F0Y2giLCIkcGFyZW50IiwiZGVmaW5lUHJvcGVydGllcyIsImFjY2Vzc29yZXMiLCIkYWNjZXNzb3IiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3AiLCJfX2RlZmluZUdldHRlcl9fIiwiZ2V0IiwiX19kZWZpbmVTZXR0ZXJfXyIsInNldCIsImRlc2NzIiwiVkJBcnJheSIsIlZCTWVkaWF0b3IiLCJkZXNjcmlwdGlvbiIsImV4ZWNTY3JpcHQiLCJqb2luIiwicHVibGljcyIsIm93bmVyIiwiYnVmZmVyIiwicGFyc2VWQiIsIlJFTkRFUkVSX1RZUEUiLCJEUkFXX01PREVTIiwiU0hBUEVTIiwiQ09OVEVYVF9ERUZBVUxUIiwiU0hBUEVfQ09OVEVYVF9ERUZBVUxUIiwiRGlzcGxheU9iamVjdCIsImNoZWNrT3B0Iiwic3RhZ2UiLCJ4eVRvSW50IiwiX2NyZWF0ZUNvbnRleHQiLCJjcmVhdGVJZCIsImluaXQiLCJfdXBkYXRlVHJhbnNmb3JtIiwiX2NvbnRleHRBVFRSUyIsIiRvd25lciIsInRyYW5zRm9ybVByb3BzIiwibXlzZWxmIiwiY29uZiIsIm5ld09iaiIsInRleHQiLCJjb250YWluZXIiLCJjbSIsImludmVydCIsImxvY2FsVG9HbG9iYWwiLCJvIiwiYm9vbCIsIm51bSIsImZyb21JbmRleCIsImdldEluZGV4IiwidG9JbmRleCIsInBjbCIsIm9yaWdpbiIsInNjYWxlT3JpZ2luIiwidHJhbnNsYXRlIiwic2NhbGUiLCJyb3RhdGVPcmlnaW4iLCJyb3RhdGUiLCJwYXJzZUludCIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwicmVzdWx0IiwiaW52ZXJzZU1hdHJpeCIsIm9yaWdpblBvcyIsIm11bFZlY3RvciIsImdyYXBoaWNzIiwiY29udGFpbnNQb2ludCIsInRvQ29udGVudCIsInVwRnVuIiwiY29tcEZ1biIsIkFuaW1hdGlvbkZyYW1lIiwiY3R4IiwidmlzaWJsZSIsInNhdmUiLCJ0cmFuc0Zvcm0iLCJ0cmFuc2Zvcm0iLCJ0b0FycmF5IiwicmVuZGVyIiwicmVzdG9yZSIsInJlbW92ZUNoaWxkIiwiRGlzcGxheU9iamVjdENvbnRhaW5lciIsIm1vdXNlQ2hpbGRyZW4iLCJnZXRDaGlsZEluZGV4IiwiX2FmdGVyQWRkQ2hpbGQiLCJyZW1vdmVDaGlsZEF0IiwiX2FmdGVyRGVsQ2hpbGQiLCJsZW4iLCJnZXRDaGlsZEF0IiwiYm9vbGVuIiwib2xkSW5kZXgiLCJnZXROdW1DaGlsZHJlbiIsIm9ianMiLCJTdGFnZSIsInN0YWdlUmVuZGluZyIsIl9pc1JlYWR5IiwiX2RldmljZVBpeGVsUmF0aW8iLCJTeXN0ZW1SZW5kZXJlciIsIlVOS05PV04iLCJhcHAiLCJSRU5ERVJfT1BUSU9OUyIsInJlcXVlc3RBaWQiLCJfaGVhcnRCZWF0IiwiX3ByZVJlbmRlclRpbWUiLCJlbnRlckZyYW1lIiwiX2JlZ2luIiwiX2VuZCIsImNvbnZlcnRUeXBlIiwic2hhcGUiLCJfY29udmVydENhbnZheCIsImNvbnZlcnRTdGFnZXMiLCJjb252ZXJ0U2hhcGVzIiwic3RhcnRFbnRlciIsIkNhbnZhc0dyYXBoaWNzUmVuZGVyZXIiLCJyZW5kZXJlciIsImRpc3BsYXlPYmplY3QiLCJncmFwaGljc0RhdGEiLCJkYXRhIiwiZmlsbFN0eWxlIiwiUE9MWSIsImJlZ2luUGF0aCIsInJlbmRlclBvbHlnb24iLCJwb2ludHMiLCJjbG9zZWQiLCJoYXNGaWxsIiwiZmlsbEFscGhhIiwiZmlsbCIsImhhc0xpbmUiLCJsaW5lQWxwaGEiLCJzdHJva2UiLCJSRUNUIiwiZmlsbFJlY3QiLCJzdHJva2VSZWN0IiwiQ0lSQyIsImFyYyIsInJhZGl1cyIsImNsb3NlUGF0aCIsIkVMSVAiLCJ3IiwiaCIsImthcHBhIiwib3giLCJveSIsInhlIiwieWUiLCJ4bSIsInltIiwibW92ZVRvIiwiYmV6aWVyQ3VydmVUbyIsImNsb3NlIiwiaiIsImxpbmVUbyIsIkNhbnZhc1JlbmRlcmVyIiwiQ0FOVkFTIiwiQ0dSIiwiY29udmVydFN0YWdlIiwicmVuZGVyU3RhZ2UiLCJfY2xlYXIiLCJfcmVuZGVyIiwiY2xlYXJSZWN0IiwiU2V0dGluZ3MiLCJhcmNUb1NlZ21lbnRzQ2FjaGUiLCJzZWdtZW50VG9CZXppZXJDYWNoZSIsImJvdW5kc09mQ3VydmVDYWNoZSIsIl9qb2luIiwiYXJjVG9TZWdtZW50cyIsInRvWCIsInRvWSIsInJ4IiwicnkiLCJsYXJnZSIsInN3ZWVwIiwicm90YXRlWCIsImFyZ3NTdHJpbmciLCJ0aCIsInNpblRoIiwiY29zVGgiLCJmcm9tWCIsImZyb21ZIiwicHkiLCJyeDIiLCJyeTIiLCJweTIiLCJweDIiLCJwbCIsImN4IiwiY3kiLCJjeDEiLCJjeTEiLCJtVGhldGEiLCJjYWxjVmVjdG9yQW5nbGUiLCJkdGhldGEiLCJzZWdtZW50cyIsImNlaWwiLCJtRGVsdGEiLCJtVCIsInRoMyIsInNlZ21lbnRUb0JlemllciIsInRoMiIsImFyZ3NTdHJpbmcyIiwiY29zdGgyIiwic2ludGgyIiwiY29zdGgzIiwic2ludGgzIiwiY3AxWCIsImNwMVkiLCJjcDJYIiwiY3AyWSIsInV4IiwidXkiLCJ2eCIsInZ5IiwidGEiLCJhdGFuMiIsInRiIiwiZHJhd0FyYyIsImZ4IiwiZnkiLCJjb29yZHMiLCJyb3QiLCJzZWdzIiwic2Vnc05vcm0iLCJnZXRCb3VuZHNPZkFyYyIsImJvdW5kcyIsImdldEJvdW5kc09mQ3VydmUiLCJ4MCIsInkwIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4MyIsInkzIiwibWluIiwidHZhbHVlcyIsInQxIiwiYjJhYyIsInNxcnRiMmFjIiwiamxlbiIsIm10IiwiUmVjdGFuZ2xlIiwicmVjdGFuZ2xlIiwicGFkZGluZ1giLCJwYWRkaW5nWSIsIkNpcmNsZSIsIkVsbGlwc2UiLCJub3JteCIsIm5vcm15IiwiUG9seWdvbiIsImlsIiwiX2lzSW5zaWRlUG9seWdvbl9XaW5kaW5nTnVtYmVyIiwid24iLCJzaGlmdFAiLCJUZXh0dXJlIiwibWFwU2l6ZSIsImRlZmF1bHRWYWx1ZSIsInNldFByZWNpc2lvbiIsImNvbXBpbGVQcm9ncmFtIiwiZXh0cmFjdEF0dHJpYnV0ZXMiLCJleHRyYWN0VW5pZm9ybXMiLCJnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QiLCJzZXRWZXJ0ZXhBdHRyaWJBcnJheXMiLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkNCIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsIkdMRnJhbWVidWZmZXIiLCJnbENvcmUiLCJSZW5kZXJUYXJnZXQiLCJyZXNvbHV0aW9uIiwiZnJhbWVCdWZmZXIiLCJjbGVhckNvbG9yIiwic2l6ZSIsInByb2plY3Rpb25NYXRyaXgiLCJmcmFtZSIsImRlZmF1bHRGcmFtZSIsImRlc3RpbmF0aW9uRnJhbWUiLCJzb3VyY2VGcmFtZSIsImZyYW1lYnVmZmVyIiwic2V0RnJhbWUiLCJyZXNpemUiLCJjYyIsImNsZWFyIiwiY2FsY3VsYXRlUHJvamVjdGlvbiIsImVuYWJsZSIsIlNDSVNTT1JfVEVTVCIsInNjaXNzb3IiLCJkaXNhYmxlIiwidmlld3BvcnQiLCJwbSIsInByb2plY3Rpb25GcmFtZSIsIk9iamVjdFJlbmRlcmVyIiwiZmx1c2giLCJvZmYiLCJvbkNvbnRleHRDaGFuZ2UiLCJERVBUSF9URVNUIiwiRlJPTlRfRkFDRSIsIkNVTExfRkFDRSIsIldlYkdMU3RhdGUiLCJhY3RpdmVTdGF0ZSIsIlVpbnQ4QXJyYXkiLCJkZWZhdWx0U3RhdGUiLCJzdGFja0luZGV4Iiwic3RhY2siLCJtYXhBdHRyaWJzIiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1ZFUlRFWF9BVFRSSUJTIiwiYXR0cmliU3RhdGUiLCJuYXRpdmVWYW9FeHRlbnNpb24iLCJnZXRFeHRlbnNpb24iLCJzdGF0ZSIsInNldFN0YXRlIiwic2V0RGVwdGhUZXN0Iiwic2V0RnJvbnRGYWNlIiwic2V0Q3VsbEZhY2UiLCJmcm9udEZhY2UiLCJ0ZW1wQXR0cmliU3RhdGUiLCJkaXNhYmxlVmVydGV4QXR0cmliQXJyYXkiLCJiaW5kVmVydGV4QXJyYXlPRVMiLCJyZXNldEF0dHJpYnV0ZXMiLCJwaXhlbFN0b3JlaSIsIlVOUEFDS19GTElQX1lfV0VCR0wiLCJoZXgycmdiIiwiaGV4IiwiV2ViR0xHcmFwaGljc0RhdGEiLCJzaGFkZXIiLCJhdHRyaWJzU3RhdGUiLCJjb2xvciIsImluZGljZXMiLCJHTEJ1ZmZlciIsImNyZWF0ZVZlcnRleEJ1ZmZlciIsImluZGV4QnVmZmVyIiwiY3JlYXRlSW5kZXhCdWZmZXIiLCJkaXJ0eSIsImdsUG9pbnRzIiwiZ2xJbmRpY2VzIiwidmFvIiwiVmVydGV4QXJyYXlPYmplY3QiLCJhZGRJbmRleCIsImFkZEF0dHJpYnV0ZSIsImF0dHJpYnV0ZXMiLCJhVmVydGV4UG9zaXRpb24iLCJGTE9BVCIsImFDb2xvciIsInVwbG9hZCIsIlVpbnQxNkFycmF5IiwiUFJFQ0lTSU9OIiwiR0xTaGFkZXIiLCJjaGVja1ByZWNpc2lvbiIsInN1YnN0cmluZyIsInVuc2hpZnQiLCJTaGFkZXIiLCJ2ZXJ0ZXhTcmMiLCJmcmFnbWVudFNyYyIsIlByaW1pdGl2ZVNoYWRlciIsImJ1aWxkTGluZSIsIndlYkdMRGF0YSIsImZpcnN0UG9pbnQiLCJsYXN0UG9pbnQiLCJwb3AiLCJtaWRQb2ludFgiLCJtaWRQb2ludFkiLCJ2ZXJ0cyIsImluZGV4Q291bnQiLCJpbmRleFN0YXJ0IiwiYWxwaGEiLCJnIiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwicDN4IiwicDN5IiwicGVycHgiLCJwZXJweSIsInBlcnAyeCIsInBlcnAyeSIsInBlcnAzeCIsInBlcnAzeSIsImRpc3QiLCJhMSIsImIxIiwiYzEiLCJhMiIsImIyIiwiYzIiLCJkZW5vbSIsInBkaXN0IiwiYnVpbGRQb2x5IiwiaG9sZUFycmF5IiwiaG9sZXMiLCJob2xlIiwidHJpYW5nbGVzIiwiZWFyY3V0IiwidmVydFBvcyIsImJ1aWxkUmVjdGFuZ2xlIiwicmVjdERhdGEiLCJ0ZW1wUG9pbnRzIiwiYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIiwicnJlY3REYXRhIiwicmVjUG9pbnRzIiwidmVjUG9zIiwicXVhZHJhdGljQmV6aWVyQ3VydmUiLCJjcFgiLCJjcFkiLCJ4YSIsInlhIiwieGIiLCJ5YiIsImdldFB0IiwibjEiLCJuMiIsInBlcmMiLCJkaWZmIiwiYnVpbGRDaXJjbGUiLCJjaXJjbGVEYXRhIiwidG90YWxTZWdzIiwic2VnIiwiR3JhcGhpY3NSZW5kZXJlciIsImdyYXBoaWNzRGF0YVBvb2wiLCJwcmltaXRpdmVTaGFkZXIiLCJDT05URVhUX1VJRCIsIndlYkdMIiwiX3dlYkdMIiwidXBkYXRlR3JhcGhpY3MiLCJiaW5kU2hhZGVyIiwic2hhZGVyVGVtcCIsImdsb2JhbE1hdHJpeCIsInVuaWZvcm1zIiwidHJhbnNsYXRpb25NYXRyaXgiLCJ0aW50Iiwid29ybGRBbHBoYSIsImJpbmRWYW8iLCJkcmF3IiwiVFJJQU5HTEVfU1RSSVAiLCJsYXN0SW5kZXgiLCJjbGVhckRpcnR5IiwiZ2V0V2ViR0xEYXRhIiwiUlJFQyIsInJlc2V0IiwiV2ViR0xTdGFnZVJlbmRlcmVyIiwiV0VCR0wiLCJoYW5kbGVDb250ZXh0TG9zdCIsImhhbmRsZUNvbnRleHRSZXN0b3JlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfYmFja2dyb3VuZENvbG9yIiwiX2JhY2tncm91bmRDb2xvclJnYmEiLCJfYmFja2dyb3VuZENvbG9yU3RyaW5nIiwiYmFja2dyb3VuZENvbG9yIiwiX2NvbnRleHRPcHRpb25zIiwidHJhbnNwYXJlbnQiLCJhbnRpYWxpYXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJlbXB0eVJlbmRlcmVyIiwiY3VycmVudFJlbmRlcmVyIiwiY3JlYXRlQ29udGV4dCIsIl9hY3RpdmVTaGFkZXIiLCJfYWN0aXZlVmFvIiwiX2FjdGl2ZVJlbmRlclRhcmdldCIsImRyYXdNb2RlcyIsIm1hcFdlYkdMRHJhd01vZGVzIiwid2ViZ2xHUiIsIl9pbml0Q29udGV4dCIsImlzQ29udGV4dExvc3QiLCJyZXN0b3JlQ29udGV4dCIsInJlc2V0VG9EZWZhdWx0Iiwicm9vdFJlbmRlclRhcmdldCIsImJpbmRSZW5kZXJUYXJnZXQiLCJvYmplY3RSZW5kZXJlciIsInNldE9iamVjdFJlbmRlcmVyIiwiYWN0aXZhdGUiLCJyZW5kZXJUYXJnZXQiLCJ1bmJpbmQiLCJ0ZXh0dXJlTWFuYWdlciIsInJlbW92ZUFsbCIsIlBPSU5UUyIsIkxJTkVTIiwiTElORV9MT09QIiwiTElORV9TVFJJUCIsIlRSSUFOR0xFUyIsIlRSSUFOR0xFX0ZBTiIsInJlbW92ZVZpZXciLCJkZXN0cm95UGx1Z2lucyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1aWQiLCJ1c2VQcm9ncmFtIiwibG9zZUNvbnRleHQiLCJXZWJHTFJlbmRlcmVyIiwid2ViR0xTdGFnZVJlbmRlcmVyIiwiYXV0b1JlbmRlcmVyIiwibm9XZWJHTCIsInV0aWxzIiwiaXNXZWJHTFN1cHBvcnRlZCIsIkFwcGxpY2F0aW9uIiwiX2NpZCIsInJhbmRvbSIsInF1ZXJ5Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJ2aWV3T2JqIiwiY3JlYXRlVmlldyIsImlubmVySFRNTCIsIm9mZnNldCIsImxhc3RHZXRSTyIsIl9jcmVhdEhvdmVyU3RhZ2UiLCJfY3JlYXRlUGl4ZWxDb250ZXh0IiwicmVTaXplQ2FudmFzIiwiYWRkQ2hpbGQiLCJfcGl4ZWxDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJjYW52YXNTdXBwb3J0IiwiZGlzcGxheSIsInpJbmRleCIsInZpc2liaWxpdHkiLCJfcGl4ZWxDdHgiLCJpbnNlcnRCZWZvcmUiLCJpbml0U3RhZ2UiLCJTcHJpdGUiLCJHcmFwaGljc0RhdGEiLCJsaW5lIiwiY3BYMiIsImNwWTIiLCJwYXRoIiwiZHQiLCJkdDIiLCJkdDMiLCJfaXNJbnNpZGVMaW5lIiwiX2wiLCJfYSIsIl9iIiwiX3MiLCJpbnNpZGVMaW5lIiwiaW5zaWRlQ2F0Y2giLCJHcmFwaGljcyIsImN1cnJlbnRQYXRoIiwic3luc1N0eWxlIiwic2N0eCIsImRyYXdTaGFwZSIsIm1tIiwiZGQiLCJ0dCIsImsxIiwiazIiLCJqMSIsImoyIiwicXgiLCJxeSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImFudGljbG9ja3dpc2UiLCJzdGFydFgiLCJzdGFydFkiLCJ0aGV0YSIsInRoZXRhMiIsImNUaGV0YSIsInNUaGV0YSIsInNlZ01pbnVzIiwicmVtYWluZGVyIiwicmVhbCIsImluc2lkZSIsIkluc2lkZUxpbmUiLCJtaW5YIiwiSW5maW5pdHkiLCJtYXhYIiwibWluWSIsIm1heFkiLCJydyIsInJoIiwiQm91bmQiLCJfd2ViZ2wiLCJTaGFwZSIsIl9jb250ZXh0IiwiX2hvdmVyYWJsZSIsIl9jbGlja2FibGUiLCJpbml0Q29tcFByb3BlcnR5IiwiX3JlY3QiLCJkYXNoTGVuZ3RoIiwiZGVsdGFYIiwiZGVsdGFZIiwibnVtRGFzaGVzIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiTUlOX1ZBTFVFIiwiY3BsIiwicG9pbnRMaXN0Iiwicm91bmQiLCJUZXh0IiwiX3JlTmV3bGluZSIsImZvbnRQcm9wZXJ0cyIsImZvbnQiLCJfZ2V0Rm9udERlY2xhcmF0aW9uIiwiZ2V0VGV4dFdpZHRoIiwiZ2V0VGV4dEhlaWdodCIsIl9yZW5kZXJUZXh0IiwiX2dldFRleHRMaW5lcyIsIl9nZXRUZXh0V2lkdGgiLCJfZ2V0VGV4dEhlaWdodCIsInRleHRMaW5lcyIsIl9yZW5kZXJUZXh0U3Ryb2tlIiwiX3JlbmRlclRleHRGaWxsIiwiZm9udEFyciIsImZvbnRQIiwiX2JvdW5kYXJpZXMiLCJsaW5lSGVpZ2h0cyIsImhlaWdodE9mTGluZSIsIl9nZXRIZWlnaHRPZkxpbmUiLCJfcmVuZGVyVGV4dExpbmUiLCJfZ2V0VG9wT2Zmc2V0Iiwic3Ryb2tlRGFzaEFycmF5Iiwic2V0TGluZURhc2giLCJtZXRob2QiLCJsaW5lSW5kZXgiLCJ0ZXh0QWxpZ24iLCJfcmVuZGVyQ2hhcnMiLCJtZWFzdXJlVGV4dCIsInRvdGFsV2lkdGgiLCJ3b3JkcyIsIndvcmRzV2lkdGgiLCJyZXBsYWNlIiwid2lkdGhEaWZmIiwibnVtU3BhY2VzIiwic3BhY2VXaWR0aCIsImxlZnRPZmZzZXQiLCJjaGFycyIsImZvbnRTaXplIiwibGluZUhlaWdodCIsIm1heFdpZHRoIiwiY3VycmVudExpbmVXaWR0aCIsInRleHRCYXNlbGluZSIsIlZlY3RvciIsIl9heGVzIiwiaW50ZXJwb2xhdGUiLCJpc0xvb3AiLCJzbW9vdGhGaWx0ZXIiLCJyZXQiLCJkaXN0YW5jZSIsInByZVZlcnRvciIsImlWdG9yIiwicG9zIiwiaWR4IiwidzIiLCJ3MyIsIl9jYWNoZSIsIl9yYWRpYW5zIiwiaXNEZWdyZWVzIiwidG9GaXhlZCIsImRlZ3JlZVRvUmFkaWFuIiwicmFkaWFuVG9EZWdyZWUiLCJkZWdyZWVUbzM2MCIsInJlQW5nIiwiZ2V0SXNnb25Qb2ludExpc3QiLCJkU3RlcCIsImJlZ2luRGVnIiwiZGVnIiwiZ2V0U21vb3RoUG9pbnRMaXN0IiwicExpc3QiLCJjdXJyTCIsIlNtb290aFNwbGluZSIsIkJyb2tlbkxpbmUiLCJhdHlwZSIsInNtb290aCIsIl9NYXRoIiwic2V0R3JhcGhpY3MiLCJsaW5lVHlwZSIsInNpIiwic2wiLCJkYXNoZWRMaW5lVG8iLCJkcmF3Q2lyY2xlIiwiUGF0aCIsImRyYXdUeXBlT25seSIsIl9fcGFyc2VQYXRoRGF0YSIsInBhdGhzIiwicGF0aFN0ciIsIl9wYXJzZUNoaWxkUGF0aERhdGEiLCJjcyIsIlJlZ0V4cCIsImFyciIsImNhIiwiY3B4IiwiY3B5Iiwic3RyIiwiY21kIiwiY3RsUHR4IiwiY3RsUHR5IiwicHJldkNtZCIsInBzaSIsImZhIiwiZnMiLCJjb21tYW5kIiwicGF0aEFycmF5IiwiX3BhcnNlUGF0aERhdGEiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiRHJvcGxldCIsIm15IiwiX2NyZWF0ZVBhdGgiLCJwcyIsImhyIiwidnIiLCJkcmF3RWxsaXBzZSIsIl9kcmF3VHlwZU9ubHkiLCJJc29nb24iLCJMaW5lIiwiUmVjdCIsImdldENzc09yZGVyQXJyIiwiRyIsImRyYXdSZWN0IiwiX2J1aWxkUmFkaXVzUGF0aCIsIlNlY3RvciIsInJlZ0FuZ2xlIiwiaXNSaW5nIiwicjAiLCJteU1hdGgiLCJjbG9ja3dpc2UiLCJyZWdJbiIsImdldFJlZ0FuZ2xlIiwicDREaXJlY3Rpb24iLCJpbkFuZ2xlUmVnIiwiZ2V0UmVjdEZvcm1Qb2ludExpc3QiLCJDYW52YXgiLCJEaXNwbGF5IiwiU2hhcGVzIiwiRXZlbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLE1BQUksRUFBUjtBQUNBLElBQUlDLFVBQVUsRUFBZDtBQUNBLElBQUlDLGFBQWFDLE1BQU1DLFNBQXZCO0lBQWtDQyxXQUFXQyxPQUFPRixTQUFwRDtBQUNBLElBQ0FHLFdBQW1CRixTQUFTRSxRQUQ1QjtJQUVBQyxpQkFBbUJILFNBQVNHLGNBRjVCOztBQUlBLElBQ0FDLGdCQUFxQlAsV0FBV1EsT0FEaEM7SUFFQUMsZUFBcUJULFdBQVdVLE1BRmhDO0lBR0FDLGdCQUFxQlgsV0FBV1ksT0FIaEM7SUFJQUMsZ0JBQXFCWixNQUFNYSxPQUozQjtJQUtBQyxhQUFxQlgsT0FBT1ksSUFMNUI7O0FBT0FsQixJQUFFbUIsTUFBRixHQUFXLFVBQVNDLEdBQVQsRUFBYztNQUNuQkYsT0FBT2xCLElBQUVrQixJQUFGLENBQU9FLEdBQVAsQ0FBWDtNQUNJQyxTQUFTSCxLQUFLRyxNQUFsQjtNQUNJRixTQUFTLElBQUloQixLQUFKLENBQVVrQixNQUFWLENBQWI7T0FDSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlELE1BQXBCLEVBQTRCQyxHQUE1QixFQUFpQztXQUN4QkEsQ0FBUCxJQUFZRixJQUFJRixLQUFLSSxDQUFMLENBQUosQ0FBWjs7U0FFS0gsTUFBUDtDQVBGOztBQVVBbkIsSUFBRWtCLElBQUYsR0FBU0QsY0FBYyxVQUFTRyxHQUFULEVBQWM7TUFDL0JBLFFBQVFkLE9BQU9jLEdBQVAsQ0FBWixFQUF5QixNQUFNLElBQUlHLFNBQUosQ0FBYyxnQkFBZCxDQUFOO01BQ3JCTCxPQUFPLEVBQVg7T0FDSyxJQUFJTSxHQUFULElBQWdCSixHQUFoQjtRQUF5QnBCLElBQUV5QixHQUFGLENBQU1MLEdBQU4sRUFBV0ksR0FBWCxDQUFKLEVBQXFCTixLQUFLUSxJQUFMLENBQVVGLEdBQVY7R0FDeEMsT0FBT04sSUFBUDtDQUpKOztBQU9BbEIsSUFBRXlCLEdBQUYsR0FBUSxVQUFTTCxHQUFULEVBQWNJLEdBQWQsRUFBbUI7U0FDbEJoQixlQUFlbUIsSUFBZixDQUFvQlAsR0FBcEIsRUFBeUJJLEdBQXpCLENBQVA7Q0FERjs7QUFJQSxJQUFJSSxPQUFPNUIsSUFBRTRCLElBQUYsR0FBUzVCLElBQUVVLE9BQUYsR0FBWSxVQUFTVSxHQUFULEVBQWNTLFFBQWQsRUFBd0JDLE9BQXhCLEVBQWlDO01BQzNEVixPQUFPLElBQVgsRUFBaUI7TUFDYlgsaUJBQWlCVyxJQUFJVixPQUFKLEtBQWdCRCxhQUFyQyxFQUFvRDtRQUM5Q0MsT0FBSixDQUFZbUIsUUFBWixFQUFzQkMsT0FBdEI7R0FERixNQUVPLElBQUlWLElBQUlDLE1BQUosS0FBZSxDQUFDRCxJQUFJQyxNQUF4QixFQUFnQztTQUNoQyxJQUFJQyxJQUFJLENBQVIsRUFBV0QsU0FBU0QsSUFBSUMsTUFBN0IsRUFBcUNDLElBQUlELE1BQXpDLEVBQWlEQyxHQUFqRCxFQUFzRDtVQUNoRE8sU0FBU0YsSUFBVCxDQUFjRyxPQUFkLEVBQXVCVixJQUFJRSxDQUFKLENBQXZCLEVBQStCQSxDQUEvQixFQUFrQ0YsR0FBbEMsTUFBMkNuQixPQUEvQyxFQUF3RDs7R0FGckQsTUFJQTtRQUNEaUIsT0FBT2xCLElBQUVrQixJQUFGLENBQU9FLEdBQVAsQ0FBWDtTQUNLLElBQUlFLElBQUksQ0FBUixFQUFXRCxTQUFTSCxLQUFLRyxNQUE5QixFQUFzQ0MsSUFBSUQsTUFBMUMsRUFBa0RDLEdBQWxELEVBQXVEO1VBQ2pETyxTQUFTRixJQUFULENBQWNHLE9BQWQsRUFBdUJWLElBQUlGLEtBQUtJLENBQUwsQ0FBSixDQUF2QixFQUFxQ0osS0FBS0ksQ0FBTCxDQUFyQyxFQUE4Q0YsR0FBOUMsTUFBdURuQixPQUEzRCxFQUFvRTs7O0NBWDFFOztBQWdCQUQsSUFBRStCLE9BQUYsR0FBWSxVQUFTQyxLQUFULEVBQWdCO1NBQ25CaEMsSUFBRVksTUFBRixDQUFTb0IsS0FBVCxFQUFnQmhDLElBQUVpQyxRQUFsQixDQUFQO0NBREY7O0FBSUFqQyxJQUFFWSxNQUFGLEdBQVdaLElBQUVrQyxNQUFGLEdBQVcsVUFBU2QsR0FBVCxFQUFjUyxRQUFkLEVBQXdCQyxPQUF4QixFQUFpQztNQUNqREssVUFBVSxFQUFkO01BQ0lmLE9BQU8sSUFBWCxFQUFpQixPQUFPZSxPQUFQO01BQ2J4QixnQkFBZ0JTLElBQUlSLE1BQUosS0FBZUQsWUFBbkMsRUFBaUQsT0FBT1MsSUFBSVIsTUFBSixDQUFXaUIsUUFBWCxFQUFxQkMsT0FBckIsQ0FBUDtPQUM1Q1YsR0FBTCxFQUFVLFVBQVNnQixLQUFULEVBQWdCQyxLQUFoQixFQUF1QkMsSUFBdkIsRUFBNkI7UUFDakNULFNBQVNGLElBQVQsQ0FBY0csT0FBZCxFQUF1Qk0sS0FBdkIsRUFBOEJDLEtBQTlCLEVBQXFDQyxJQUFyQyxDQUFKLEVBQWdESCxRQUFRVCxJQUFSLENBQWFVLEtBQWI7R0FEbEQ7U0FHT0QsT0FBUDtDQVBGOztBQVVBUCxLQUFLLENBQUMsV0FBRCxFQUFjLFVBQWQsRUFBMEIsUUFBMUIsRUFBb0MsUUFBcEMsRUFBOEMsTUFBOUMsRUFBc0QsUUFBdEQsQ0FBTCxFQUFzRSxVQUFTVyxJQUFULEVBQWU7TUFDakYsT0FBT0EsSUFBVCxJQUFpQixVQUFTbkIsR0FBVCxFQUFjO1dBQ3RCYixTQUFTb0IsSUFBVCxDQUFjUCxHQUFkLEtBQXNCLGFBQWFtQixJQUFiLEdBQW9CLEdBQWpEO0dBREY7Q0FERjs7QUFNQSxBQUFJLEFBQUosQUFBaUM7TUFDN0JDLFVBQUYsR0FBZSxVQUFTcEIsR0FBVCxFQUFjO1dBQ3BCLE9BQU9BLEdBQVAsS0FBZSxVQUF0QjtHQURGOzs7QUFLRnBCLElBQUV5QyxRQUFGLEdBQWEsVUFBU3JCLEdBQVQsRUFBYztTQUNsQnFCLFNBQVNyQixHQUFULEtBQWlCLENBQUNzQixNQUFNQyxXQUFXdkIsR0FBWCxDQUFOLENBQXpCO0NBREY7O0FBSUFwQixJQUFFMEMsS0FBRixHQUFVLFVBQVN0QixHQUFULEVBQWM7U0FDZnBCLElBQUU0QyxRQUFGLENBQVd4QixHQUFYLEtBQW1CQSxPQUFPLENBQUNBLEdBQWxDO0NBREY7O0FBSUFwQixJQUFFNkMsU0FBRixHQUFjLFVBQVN6QixHQUFULEVBQWM7U0FDbkJBLFFBQVEsSUFBUixJQUFnQkEsUUFBUSxLQUF4QixJQUFpQ2IsU0FBU29CLElBQVQsQ0FBY1AsR0FBZCxLQUFzQixrQkFBOUQ7Q0FERjs7QUFJQXBCLElBQUU4QyxNQUFGLEdBQVcsVUFBUzFCLEdBQVQsRUFBYztTQUNoQkEsUUFBUSxJQUFmO0NBREY7O0FBSUFwQixJQUFFK0MsT0FBRixHQUFZLFVBQVMzQixHQUFULEVBQWM7TUFDcEJBLE9BQU8sSUFBWCxFQUFpQixPQUFPLElBQVA7TUFDYnBCLElBQUVnQixPQUFGLENBQVVJLEdBQVYsS0FBa0JwQixJQUFFZ0QsUUFBRixDQUFXNUIsR0FBWCxDQUF0QixFQUF1QyxPQUFPQSxJQUFJQyxNQUFKLEtBQWUsQ0FBdEI7T0FDbEMsSUFBSUcsR0FBVCxJQUFnQkosR0FBaEI7UUFBeUJwQixJQUFFeUIsR0FBRixDQUFNTCxHQUFOLEVBQVdJLEdBQVgsQ0FBSixFQUFxQixPQUFPLEtBQVA7R0FDeEMsT0FBTyxJQUFQO0NBSko7O0FBT0F4QixJQUFFaUQsU0FBRixHQUFjLFVBQVM3QixHQUFULEVBQWM7U0FDbkIsQ0FBQyxFQUFFQSxPQUFPQSxJQUFJOEIsUUFBSixLQUFpQixDQUExQixDQUFSO0NBREY7O0FBSUFsRCxJQUFFZ0IsT0FBRixHQUFZRCxpQkFBaUIsVUFBU0ssR0FBVCxFQUFjO1NBQ2xDYixTQUFTb0IsSUFBVCxDQUFjUCxHQUFkLEtBQXNCLGdCQUE3QjtDQURGOztBQUlBcEIsSUFBRW1ELFFBQUYsR0FBYSxVQUFTL0IsR0FBVCxFQUFjO1NBQ2xCQSxRQUFRZCxPQUFPYyxHQUFQLENBQWY7Q0FERjs7QUFJQXBCLElBQUVpQyxRQUFGLEdBQWEsVUFBU0csS0FBVCxFQUFnQjtTQUNwQkEsS0FBUDtDQURGOztBQUlBcEMsSUFBRWMsT0FBRixHQUFZLFVBQVNrQixLQUFULEVBQWdCb0IsSUFBaEIsRUFBc0JDLFFBQXRCLEVBQWdDO01BQ3RDckIsU0FBUyxJQUFiLEVBQW1CLE9BQU8sQ0FBQyxDQUFSO01BQ2ZWLElBQUksQ0FBUjtNQUFXRCxTQUFTVyxNQUFNWCxNQUExQjtNQUNJZ0MsUUFBSixFQUFjO1FBQ1IsT0FBT0EsUUFBUCxJQUFtQixRQUF2QixFQUFpQztVQUMxQkEsV0FBVyxDQUFYLEdBQWVDLEtBQUtDLEdBQUwsQ0FBUyxDQUFULEVBQVlsQyxTQUFTZ0MsUUFBckIsQ0FBZixHQUFnREEsUUFBckQ7S0FERixNQUVPO1VBQ0RyRCxJQUFFd0QsV0FBRixDQUFjeEIsS0FBZCxFQUFxQm9CLElBQXJCLENBQUo7YUFDT3BCLE1BQU1WLENBQU4sTUFBYThCLElBQWIsR0FBb0I5QixDQUFwQixHQUF3QixDQUFDLENBQWhDOzs7TUFHQVQsaUJBQWlCbUIsTUFBTWxCLE9BQU4sS0FBa0JELGFBQXZDLEVBQXNELE9BQU9tQixNQUFNbEIsT0FBTixDQUFjc0MsSUFBZCxFQUFvQkMsUUFBcEIsQ0FBUDtTQUMvQy9CLElBQUlELE1BQVgsRUFBbUJDLEdBQW5CO1FBQTRCVSxNQUFNVixDQUFOLE1BQWE4QixJQUFqQixFQUF1QixPQUFPOUIsQ0FBUDtHQUM3QyxPQUFPLENBQUMsQ0FBUjtDQWJKOztBQWdCQXRCLElBQUV5RCxRQUFGLEdBQWEsVUFBVXJDLEdBQVYsRUFBZ0I7U0FDbkJBLE9BQU8sSUFBUCxJQUFlQSxPQUFPQSxJQUFJc0MsTUFBakM7Q0FESDtBQUdBMUQsSUFBRTJELGFBQUYsR0FBa0IsVUFBVXZDLEdBQVYsRUFBZ0I7OztNQUd6QixDQUFDQSxHQUFELElBQVEsUUFBT0EsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQXZCLElBQW1DQSxJQUFJOEIsUUFBdkMsSUFBbURsRCxJQUFFeUQsUUFBRixDQUFZckMsR0FBWixDQUF4RCxFQUE0RTtXQUNqRSxLQUFQOztNQUVBOztRQUVLQSxJQUFJd0MsV0FBSixJQUNELENBQUNDLE9BQU9sQyxJQUFQLENBQVlQLEdBQVosRUFBaUIsYUFBakIsQ0FEQSxJQUVELENBQUN5QyxPQUFPbEMsSUFBUCxDQUFZUCxJQUFJd0MsV0FBSixDQUFnQnhELFNBQTVCLEVBQXVDLGVBQXZDLENBRkwsRUFFK0Q7YUFDcEQsS0FBUDs7R0FMUixDQU9FLE9BQVEwRCxDQUFSLEVBQVk7O1dBRUgsS0FBUDs7OztNQUlBdEMsR0FBSjtPQUNNQSxHQUFOLElBQWFKLEdBQWIsRUFBbUI7O1NBRVpJLFFBQVF1QyxTQUFSLElBQXFCRixPQUFPbEMsSUFBUCxDQUFhUCxHQUFiLEVBQWtCSSxHQUFsQixDQUE1QjtDQXRCSjs7Ozs7O0FBNkJBeEIsSUFBRWdFLE1BQUYsR0FBVyxZQUFXO01BQ2hCQyxPQUFKO01BQWExQixJQUFiO01BQW1CMkIsR0FBbkI7TUFBd0JDLElBQXhCO01BQThCQyxXQUE5QjtNQUEyQ0MsS0FBM0M7TUFDSUMsU0FBU0MsVUFBVSxDQUFWLEtBQWdCLEVBRDdCO01BRUlqRCxJQUFJLENBRlI7TUFHSUQsU0FBU2tELFVBQVVsRCxNQUh2QjtNQUlJbUQsT0FBTyxLQUpYO01BS0ssT0FBT0YsTUFBUCxLQUFrQixTQUF2QixFQUFtQztXQUN4QkEsTUFBUDthQUNTQyxVQUFVLENBQVYsS0FBZ0IsRUFBekI7UUFDSSxDQUFKOztNQUVDLFFBQU9ELE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEIsQ0FBQ3RFLElBQUV3QyxVQUFGLENBQWE4QixNQUFiLENBQXBDLEVBQTJEO2FBQzlDLEVBQVQ7O01BRUNqRCxXQUFXQyxDQUFoQixFQUFvQjthQUNQLElBQVQ7TUFDRUEsQ0FBRjs7U0FFSUEsSUFBSUQsTUFBWixFQUFvQkMsR0FBcEIsRUFBMEI7UUFDakIsQ0FBQzJDLFVBQVVNLFVBQVdqRCxDQUFYLENBQVgsS0FBOEIsSUFBbkMsRUFBMEM7V0FDaENpQixJQUFOLElBQWMwQixPQUFkLEVBQXdCO2NBQ2RLLE9BQVEvQixJQUFSLENBQU47ZUFDTzBCLFFBQVMxQixJQUFULENBQVA7WUFDSytCLFdBQVdILElBQWhCLEVBQXVCOzs7WUFHbEJLLFFBQVFMLElBQVIsS0FBa0JuRSxJQUFFMkQsYUFBRixDQUFnQlEsSUFBaEIsTUFBMEJDLGNBQWNwRSxJQUFFZ0IsT0FBRixDQUFVbUQsSUFBVixDQUF4QyxDQUFsQixDQUFMLEVBQW9GO2NBQzNFQyxXQUFMLEVBQW1COzBCQUNELEtBQWQ7b0JBQ1FGLE9BQU9sRSxJQUFFZ0IsT0FBRixDQUFVa0QsR0FBVixDQUFQLEdBQXdCQSxHQUF4QixHQUE4QixFQUF0QztXQUZKLE1BR087b0JBQ0tBLE9BQU9sRSxJQUFFMkQsYUFBRixDQUFnQk8sR0FBaEIsQ0FBUCxHQUE4QkEsR0FBOUIsR0FBb0MsRUFBNUM7O2lCQUVJM0IsSUFBUixJQUFpQnZDLElBQUVnRSxNQUFGLENBQVVRLElBQVYsRUFBZ0JILEtBQWhCLEVBQXVCRixJQUF2QixDQUFqQjtTQVBKLE1BUU8sSUFBS0EsU0FBU0osU0FBZCxFQUEwQjtpQkFDckJ4QixJQUFSLElBQWlCNEIsSUFBakI7Ozs7O1NBS1RHLE1BQVA7Q0F4Q0Y7QUEwQ0F0RSxJQUFFcUUsS0FBRixHQUFVLFVBQVNqRCxHQUFULEVBQWM7TUFDbEIsQ0FBQ3BCLElBQUVtRCxRQUFGLENBQVcvQixHQUFYLENBQUwsRUFBc0IsT0FBT0EsR0FBUDtTQUNmcEIsSUFBRWdCLE9BQUYsQ0FBVUksR0FBVixJQUFpQkEsSUFBSXFELEtBQUosRUFBakIsR0FBK0J6RSxJQUFFZ0UsTUFBRixDQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CNUMsR0FBbkIsQ0FBdEM7Q0FGRixDQUlBOztBQ2xOQTs7Ozs7QUFLQSxBQUVBLElBQUlzRCxRQUFRO21CQUNVLEVBRFY7U0FFRixDQUZFOztlQUlNLElBSk47aUJBS00sdUJBQVUsRUFMaEI7O3VCQU9ZaEIsT0FBT2lCLGdCQUFQLElBQTJCLENBUHZDO1VBUUEsQ0FSQTtZQVNELGtCQUFVO2VBQ04sS0FBS0MsSUFBTCxFQUFQO0tBVkk7Y0FZRyxrQkFBU3JDLElBQVQsRUFBZTtZQUNuQixDQUFDQSxJQUFKLEVBQVM7Ozs7WUFJTHNDLFdBQVd0QyxLQUFLdUMsVUFBTCxDQUFnQnZDLEtBQUtsQixNQUFMLEdBQWMsQ0FBOUIsQ0FBZjtZQUNJd0QsWUFBWSxFQUFaLElBQWtCQSxZQUFZLEVBQWxDLEVBQXNDdEMsUUFBUSxHQUFSO2VBQy9CQSxPQUFPbUMsTUFBTUssTUFBTixFQUFkO0tBbkJJO21CQXFCUSx5QkFBVztlQUNoQixDQUFDLENBQUNDLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsRUFBaUNDLFVBQTFDO0tBdEJJO2tCQXdCTyxzQkFBVUMsS0FBVixFQUFrQnZCLFdBQWxCLEVBQWdDO1lBQ3ZDd0IsUUFBSjtZQUNJQyxlQUFlL0UsT0FBT2dGLE1BQTFCO1lBQ0lELFlBQUosRUFBa0I7dUJBQ0hBLGFBQWFGLEtBQWIsQ0FBWDtTQURKLE1BRU87a0JBQ0dJLFdBQU4sQ0FBa0JuRixTQUFsQixHQUE4QitFLEtBQTlCO3VCQUNXLElBQUlULE1BQU1hLFdBQVYsRUFBWDs7aUJBRUszQixXQUFULEdBQXVCQSxXQUF2QjtlQUNPd0IsUUFBUDtLQWxDSTtnQkFvQ0ssb0JBQVNJLENBQVQsRUFBWUMsQ0FBWixFQUFlQyxFQUFmLEVBQWtCO1lBQ3ZCLENBQUNELENBQUQsSUFBTSxDQUFDRCxDQUFYLEVBQWM7bUJBQ0hBLENBQVA7O1lBRUFHLEtBQUtGLEVBQUVyRixTQUFYO1lBQXNCd0YsRUFBdEI7O2FBRUtsQixNQUFNbUIsWUFBTixDQUFtQkYsRUFBbkIsRUFBdUJILENBQXZCLENBQUw7VUFDRXBGLFNBQUYsR0FBY0osSUFBRWdFLE1BQUYsQ0FBUzRCLEVBQVQsRUFBYUosRUFBRXBGLFNBQWYsQ0FBZDtVQUNFMEYsVUFBRixHQUFlcEIsTUFBTW1CLFlBQU4sQ0FBbUJGLEVBQW5CLEVBQXVCRixDQUF2QixDQUFmOztZQUVJQyxFQUFKLEVBQVE7Z0JBQ0YxQixNQUFGLENBQVM0QixFQUFULEVBQWFGLEVBQWI7O2VBRUdGLENBQVA7S0FqREk7aUJBbURNLHFCQUFVTyxNQUFWLEVBQWtCO1lBQ3hCckMsT0FBT3NDLFdBQVAsSUFBc0JBLFlBQVlDLFdBQXRDLEVBQWtEO3dCQUNsQ0EsV0FBWixDQUF5QkYsTUFBekI7O0tBckRBOztjQXlETSxrQkFBU0csR0FBVCxFQUFhO1lBQ25CLENBQUNBLEdBQUwsRUFBVTttQkFDRDt5QkFDSzthQURaO1NBREYsTUFNTyxJQUFJQSxPQUFPLENBQUNBLElBQUlwRSxPQUFoQixFQUEwQjtnQkFDM0JBLE9BQUosR0FBYyxFQUFkO21CQUNPb0UsR0FBUDtTQUZLLE1BR0E7bUJBQ0VBLEdBQVA7O0tBcEVFOzs7OztvQkEyRVMsd0JBQVVWLENBQVYsRUFBYTtZQUN0QlcsRUFBSjtZQUNJQyxFQUFKO1lBQ0lDLEVBQUo7WUFDSUMsRUFBSjs7WUFFRyxPQUFPZCxDQUFQLEtBQWEsUUFBaEIsRUFBMEI7aUJBQ2pCWSxLQUFLQyxLQUFLQyxLQUFLZCxDQUFwQjtTQURKLE1BR0ssSUFBR0EsYUFBYXJGLEtBQWhCLEVBQXVCO2dCQUNwQnFGLEVBQUVuRSxNQUFGLEtBQWEsQ0FBakIsRUFBb0I7cUJBQ1grRSxLQUFLQyxLQUFLQyxLQUFLZCxFQUFFLENBQUYsQ0FBcEI7YUFESixNQUdLLElBQUdBLEVBQUVuRSxNQUFGLEtBQWEsQ0FBaEIsRUFBbUI7cUJBQ2ZnRixLQUFLYixFQUFFLENBQUYsQ0FBVjtxQkFDS2MsS0FBS2QsRUFBRSxDQUFGLENBQVY7YUFGQyxNQUlBLElBQUdBLEVBQUVuRSxNQUFGLEtBQWEsQ0FBaEIsRUFBbUI7cUJBQ2ZtRSxFQUFFLENBQUYsQ0FBTDtxQkFDS2MsS0FBS2QsRUFBRSxDQUFGLENBQVY7cUJBQ0tBLEVBQUUsQ0FBRixDQUFMO2FBSEMsTUFJRTtxQkFDRUEsRUFBRSxDQUFGLENBQUw7cUJBQ0tBLEVBQUUsQ0FBRixDQUFMO3FCQUNLQSxFQUFFLENBQUYsQ0FBTDtxQkFDS0EsRUFBRSxDQUFGLENBQUw7O1NBaEJILE1Ba0JFO2lCQUNFWSxLQUFLQyxLQUFLQyxLQUFLLENBQXBCOztlQUVHLENBQUNILEVBQUQsRUFBSUMsRUFBSixFQUFPQyxFQUFQLEVBQVVDLEVBQVYsQ0FBUDtLQXpHSTs7c0JBNEdXLDRCQUFXO1lBQ3RCQyxpQkFBaUIsRUFBRUMsU0FBUyxJQUFYLEVBQXJCO1lBRUE7Z0JBQ1EsQ0FBQzlDLE9BQU8rQyxxQkFBWjs7MkJBRVcsS0FBUDs7Z0JBRUFWLFNBQVNmLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtnQkFDSXlCLEtBQUtYLE9BQU9iLFVBQVAsQ0FBa0IsT0FBbEIsRUFBMkJxQixjQUEzQixLQUE4Q1IsT0FBT2IsVUFBUCxDQUFrQixvQkFBbEIsRUFBd0NxQixjQUF4QyxDQUR2RDttQkFFTyxDQUFDLEVBQUVHLE1BQU1BLEdBQUdDLG9CQUFILEdBQTBCSCxPQUFsQyxDQUFSLENBUEo7U0FEQSxDQVVBLE9BQU8xQyxDQUFQLEVBQ0E7bUJBQ1csS0FBUDs7O0NBMUhaLENBK0hBOztBQ3RJQTs7Ozs7SUFLcUI4QztxQkFHakI7WUFEYUMsQ0FDYix1RUFEZSxDQUNmO1lBRG1CQyxDQUNuQix1RUFEcUIsQ0FDckI7OztZQUNRdkMsVUFBVWxELE1BQVYsSUFBa0IsQ0FBbEIsSUFBdUIwRixRQUFPeEMsVUFBVSxDQUFWLENBQVAsS0FBdUIsUUFBbEQsRUFBNEQ7Z0JBQ3BEeUMsTUFBSXpDLFVBQVUsQ0FBVixDQUFSO2dCQUNJLE9BQU95QyxHQUFQLElBQWMsT0FBT0EsR0FBekIsRUFBOEI7cUJBQ3JCSCxDQUFMLEdBQVNHLElBQUlILENBQUosR0FBTSxDQUFmO3FCQUNLQyxDQUFMLEdBQVNFLElBQUlGLENBQUosR0FBTSxDQUFmO2FBRkosTUFHTztvQkFDQ3hGLElBQUUsQ0FBTjtxQkFDSyxJQUFJMkYsQ0FBVCxJQUFjRCxHQUFkLEVBQWtCO3dCQUNYMUYsS0FBRyxDQUFOLEVBQVE7NkJBQ0N1RixDQUFMLEdBQVNHLElBQUlDLENBQUosSUFBTyxDQUFoQjtxQkFESixNQUVPOzZCQUNFSCxDQUFMLEdBQVNFLElBQUlDLENBQUosSUFBTyxDQUFoQjs7Ozs7O1NBWGhCLE1BaUJPO2lCQUNFSixDQUFMLEdBQVNBLElBQUUsQ0FBWDtpQkFDS0MsQ0FBTCxHQUFTQSxJQUFFLENBQVg7Ozs7OztxQ0FLUjttQkFDVyxDQUFDLEtBQUtELENBQU4sRUFBVSxLQUFLQyxDQUFmLENBQVA7Ozs7SUFFUDs7QUNwQ0Q7Ozs7Ozs7QUFPQSxBQUNBLEFBRUEsSUFBSUksY0FBYyxTQUFkQSxXQUFjLENBQVVDLEdBQVYsRUFBZ0JDLE1BQWhCLEVBQXlCOztRQUV0Q0MsWUFBWSxhQUFoQjtRQUNPckgsSUFBRWdELFFBQUYsQ0FBWW1FLEdBQVosQ0FBSixFQUF1QjtvQkFDVkEsR0FBWjs7UUFFR25ILElBQUVtRCxRQUFGLENBQVlnRSxHQUFaLEtBQXFCQSxJQUFJRyxJQUE3QixFQUFtQztvQkFDdEJILElBQUlHLElBQWhCOzs7U0FHSWhELE1BQUwsR0FBYyxJQUFkO1NBQ0tpRCxhQUFMLEdBQXFCLElBQXJCO1NBQ0tELElBQUwsR0FBY0QsU0FBZDtTQUNLRyxLQUFMLEdBQWMsSUFBZDs7U0FFS0MsZ0JBQUwsR0FBd0IsS0FBeEIsQ0FmdUM7Q0FBM0M7QUFpQkFQLFlBQVk5RyxTQUFaLEdBQXdCO3FCQUNGLDJCQUFXO2FBQ3BCcUgsZ0JBQUwsR0FBd0IsSUFBeEI7O0NBRlIsQ0FLQTs7QUNoQ0EsZUFBZTs7Y0FFQy9ELE9BQU9pQixnQkFBUCxJQUEyQixDQUY1Qjs7Ozs7Ozs7OztlQWFFLElBYkY7Ozs7Ozs7Ozs7O21CQXdCTSxJQXhCTjs7Ozs7Ozs7OztxQkFrQ1EsQ0FsQ1I7Ozs7Ozs7Ozs7Ozs7OztxQkFrRFEsSUFsRFI7Ozs7Ozs7Ozs7O2lCQTZESSxRQTdESjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQWtGSztVQUNOLElBRE07ZUFFRCxJQUZDO2VBR0QsS0FIQztnQkFJQSxLQUpBO2lCQUtDLElBTEQ7cUJBTUssUUFOTDt1QkFPTyxJQVBQOzJCQVFXLEtBUlg7aUJBU0M7R0EzRk47Ozs7Ozs7Ozs7a0JBc0dLLENBdEdMOzs7Ozs7Ozs7O1dBZ0hGLENBaEhFOzs7Ozs7Ozs7O2VBMEhFLEtBQUssRUExSFA7Ozs7Ozs7Ozs7c0JBb0lTLEtBQUssRUFwSWQ7Ozs7Ozs7Ozs7YUE4SUEsQ0E5SUE7Ozs7Ozs7Ozs7Y0F3SkMsQ0F4SkQ7Ozs7Ozs7Ozs7YUFrS0E7O0NBbEtmOztBQ0dBLElBQUkrQyxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFVQyxPQUFWLEVBQW9CQyxNQUFwQixFQUE0QjtRQUM5QzVDLFNBQVUyQyxPQUFWLENBQUosRUFBeUI7O2dCQUNaRSxVQURZLEdBQ3JCLFNBQVNBLFVBQVQsQ0FBcUJDLEVBQXJCLEVBQTBCUixJQUExQixFQUFpQ1MsRUFBakMsRUFBcUM7b0JBQzdCRCxHQUFHekcsTUFBUCxFQUFlO3lCQUNQLElBQUlDLElBQUUsQ0FBVixFQUFjQSxJQUFJd0csR0FBR3pHLE1BQXJCLEVBQThCQyxHQUE5QixFQUFrQzttQ0FDbEJ3RyxHQUFHeEcsQ0FBSCxDQUFaLEVBQW9CZ0csSUFBcEIsRUFBMkJTLEVBQTNCOztpQkFGUixNQUlPO3VCQUNDSixPQUFKLEVBQWVMLElBQWYsRUFBc0JTLEVBQXRCLEVBQTJCLEtBQTNCOzthQVBhOzs7O21CQVVkRjs7Ozs7S0FWWCxNQVdPOztnQkFDTUcsT0FETixHQUNILFNBQVNBLE9BQVQsQ0FBa0JGLEVBQWxCLEVBQXVCUixJQUF2QixFQUE4QlMsRUFBOUIsRUFBa0M7b0JBQzFCRCxHQUFHekcsTUFBUCxFQUFlO3lCQUNQLElBQUlDLElBQUUsQ0FBVixFQUFjQSxJQUFJd0csR0FBR3pHLE1BQXJCLEVBQThCQyxHQUE5QixFQUFrQztnQ0FDckJ3RyxHQUFHeEcsQ0FBSCxDQUFULEVBQWVnRyxJQUFmLEVBQW9CUyxFQUFwQjs7aUJBRlIsTUFJTzt1QkFDQ0gsTUFBSixFQUFjLE9BQUtOLElBQW5CLEVBQTBCLFlBQVU7K0JBQ3pCUyxHQUFHcEcsSUFBSCxDQUFTbUcsRUFBVCxFQUFjcEUsT0FBT3VFLEtBQXJCLENBQVA7cUJBREo7O2FBUEw7Ozs7bUJBWUlEOzs7Ozs7Q0F4QmY7O0FBNEJBLFFBQWU7O1dBRUgsZUFBU0YsRUFBVCxFQUFZO1lBQ2I5SCxJQUFFZ0QsUUFBRixDQUFXOEUsRUFBWCxDQUFILEVBQWtCO21CQUNSOUMsU0FBU2tELGNBQVQsQ0FBd0JKLEVBQXhCLENBQVA7O1lBRUFBLEdBQUc1RSxRQUFILElBQWUsQ0FBbEIsRUFBb0I7O21CQUVWNEUsRUFBUDs7WUFFQUEsR0FBR3pHLE1BQU4sRUFBYTttQkFDSHlHLEdBQUcsQ0FBSCxDQUFQOztlQUVJLElBQVA7S0FiTztZQWVGLGdCQUFTQSxFQUFULEVBQVk7WUFDYkssTUFBTUwsR0FBR00scUJBQUgsRUFBVjtZQUNBQyxNQUFNUCxHQUFHUSxhQURUO1lBRUFDLE9BQU9GLElBQUlFLElBRlg7WUFHQUMsVUFBVUgsSUFBSUksZUFIZDs7OztvQkFNWUQsUUFBUUUsU0FBUixJQUFxQkgsS0FBS0csU0FBMUIsSUFBdUMsQ0FObkQ7WUFPQUMsYUFBYUgsUUFBUUcsVUFBUixJQUFzQkosS0FBS0ksVUFBM0IsSUFBeUMsQ0FQdEQ7Ozs7O2VBV08sQ0FYUDtZQVlJSixLQUFLSCxxQkFBVCxFQUFnQztnQkFDeEJRLFFBQVFMLEtBQUtILHFCQUFMLEVBQVo7bUJBQ08sQ0FBQ1EsTUFBTUMsS0FBTixHQUFjRCxNQUFNRSxJQUFyQixJQUEyQlAsS0FBS1EsV0FBdkM7O1lBRUFDLE9BQU8sQ0FBWCxFQUFhO3dCQUNHLENBQVo7eUJBQ2EsQ0FBYjs7WUFFQUMsTUFBTWQsSUFBSWMsR0FBSixHQUFRRCxJQUFSLElBQWdCdEYsT0FBT3dGLFdBQVAsSUFBc0JWLFdBQVdBLFFBQVFXLFNBQVIsR0FBa0JILElBQW5ELElBQTJEVCxLQUFLWSxTQUFMLEdBQWVILElBQTFGLElBQWtHTixTQUE1RztZQUNJSSxPQUFPWCxJQUFJVyxJQUFKLEdBQVNFLElBQVQsSUFBaUJ0RixPQUFPMEYsV0FBUCxJQUFxQlosV0FBV0EsUUFBUWEsVUFBUixHQUFtQkwsSUFBbkQsSUFBMkRULEtBQUtjLFVBQUwsR0FBZ0JMLElBQTVGLElBQW9HTCxVQUQvRzs7ZUFHTztpQkFDRU0sR0FERjtrQkFFR0g7U0FGVjtLQXZDTztjQTRDQXBCLG9CQUFxQixrQkFBckIsRUFBMEMsYUFBMUMsQ0E1Q0E7aUJBNkNHQSxvQkFBcUIscUJBQXJCLEVBQTZDLGFBQTdDLENBN0NIO1dBOENKLGVBQVM1RCxDQUFULEVBQVk7WUFDWEEsRUFBRXdGLEtBQU4sRUFBYSxPQUFPeEYsRUFBRXdGLEtBQVQsQ0FBYixLQUNLLElBQUl4RixFQUFFeUYsT0FBTixFQUNELE9BQU96RixFQUFFeUYsT0FBRixJQUFhdkUsU0FBU3lELGVBQVQsQ0FBeUJZLFVBQXpCLEdBQ1pyRSxTQUFTeUQsZUFBVCxDQUF5QlksVUFEYixHQUMwQnJFLFNBQVN1RCxJQUFULENBQWNjLFVBRHJELENBQVAsQ0FEQyxLQUdBLE9BQU8sSUFBUDtLQW5ERTtXQXFESixlQUFTdkYsQ0FBVCxFQUFZO1lBQ1hBLEVBQUUwRixLQUFOLEVBQWEsT0FBTzFGLEVBQUUwRixLQUFULENBQWIsS0FDSyxJQUFJMUYsRUFBRTJGLE9BQU4sRUFDRCxPQUFPM0YsRUFBRTJGLE9BQUYsSUFBYXpFLFNBQVN5RCxlQUFULENBQXlCVSxTQUF6QixHQUNabkUsU0FBU3lELGVBQVQsQ0FBeUJVLFNBRGIsR0FDeUJuRSxTQUFTdUQsSUFBVCxDQUFjWSxTQURwRCxDQUFQLENBREMsS0FHQSxPQUFPLElBQVA7S0ExREU7Ozs7OztrQkFpRUksc0JBQVVPLE1BQVYsRUFBbUJDLE9BQW5CLEVBQTZCQyxFQUE3QixFQUFpQztZQUN4QzdELFNBQVNmLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtlQUNPNEUsS0FBUCxDQUFhQyxRQUFiLEdBQXdCLFVBQXhCO2VBQ09ELEtBQVAsQ0FBYUUsS0FBYixHQUFzQkwsU0FBUyxJQUEvQjtlQUNPRyxLQUFQLENBQWFHLE1BQWIsR0FBc0JMLFVBQVUsSUFBaEM7ZUFDT0UsS0FBUCxDQUFhZixJQUFiLEdBQXNCLENBQXRCO2VBQ09lLEtBQVAsQ0FBYVosR0FBYixHQUFzQixDQUF0QjtlQUNPZ0IsWUFBUCxDQUFvQixPQUFwQixFQUE2QlAsU0FBU1EsU0FBU0MsVUFBL0M7ZUFDT0YsWUFBUCxDQUFvQixRQUFwQixFQUE4Qk4sVUFBVU8sU0FBU0MsVUFBakQ7ZUFDT0YsWUFBUCxDQUFvQixJQUFwQixFQUEwQkwsRUFBMUI7ZUFDTzdELE1BQVA7S0EzRU87Z0JBNkVDLG9CQUFTMkQsTUFBVCxFQUFrQkMsT0FBbEIsRUFBMkJDLEVBQTNCLEVBQThCO1lBQ2xDUSxPQUFPcEYsU0FBU0MsYUFBVCxDQUF1QixLQUF2QixDQUFYO2FBQ0tvRixTQUFMLEdBQWlCLGFBQWpCO2FBQ0tSLEtBQUwsQ0FBV1MsT0FBWCxJQUFzQiw2QkFBNkJaLE1BQTdCLEdBQXNDLFlBQXRDLEdBQXFEQyxPQUFyRCxHQUE4RCxLQUFwRjs7WUFFSVksVUFBVXZGLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDthQUNLNEUsS0FBTCxDQUFXUyxPQUFYLElBQXNCLDZCQUE2QlosTUFBN0IsR0FBc0MsWUFBdEMsR0FBcURDLE9BQXJELEdBQThELEtBQXBGOzs7WUFHSWEsUUFBUXhGLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjthQUNLNEUsS0FBTCxDQUFXUyxPQUFYLElBQXNCLDZCQUE2QlosTUFBN0IsR0FBc0MsWUFBdEMsR0FBcURDLE9BQXJELEdBQThELEtBQXBGOzthQUVLYyxXQUFMLENBQWlCRixPQUFqQjthQUNLRSxXQUFMLENBQWlCRCxLQUFqQjs7ZUFFTztrQkFDSUosSUFESjtxQkFFTUcsT0FGTjttQkFHSUM7U0FIWDs7O0NBNUZSOztBQy9CQTs7Ozs7O0FBTUEsQUFDQSxBQUNBLEFBQ0EsQUFFQSxJQUFJRSxtQkFBbUIsQ0FBQyxPQUFELEVBQVMsVUFBVCxFQUFvQixXQUFwQixFQUFnQyxXQUFoQyxFQUE0QyxTQUE1QyxFQUFzRCxVQUF0RCxDQUF2QjtBQUNBLElBQUlDLG9CQUFvQixDQUNwQixLQURvQixFQUNkLFVBRGMsRUFDSCxTQURHLEVBQ08sUUFEUCxFQUNnQixXQURoQixFQUM0QixTQUQ1QixFQUNzQyxVQUR0QyxFQUNpRCxPQURqRCxFQUN5RCxTQUR6RCxFQUVwQixPQUZvQixFQUVWLFNBRlUsRUFHcEIsT0FIb0IsRUFHVixXQUhVLEVBR0ksWUFISixFQUdtQixTQUhuQixFQUcrQixXQUgvQixFQUlwQixLQUpvQixDQUF4Qjs7QUFPQSxJQUFJQyxlQUFlLFNBQWZBLFlBQWUsQ0FBU0MsTUFBVCxFQUFrQjNFLEdBQWxCLEVBQXVCO1NBQ2pDMkUsTUFBTCxHQUFjQSxNQUFkOztTQUVLQyxTQUFMLEdBQWlCLENBQUMsSUFBSWxFLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFELENBQWpCLENBSHNDOztTQUtqQ21FLGVBQUwsR0FBdUIsRUFBdkI7O1NBRUtDLFNBQUwsR0FBaUIsS0FBakI7O1NBRUtDLFFBQUwsR0FBZ0IsS0FBaEI7OztTQUdLQyxPQUFMLEdBQWUsU0FBZjs7U0FFSzVHLE1BQUwsR0FBYyxLQUFLdUcsTUFBTCxDQUFZVCxJQUExQjtTQUNLZSxLQUFMLEdBQWEsRUFBYjs7OztTQUlLQyxJQUFMLEdBQVk7ZUFDQSxVQURBO2NBRUQsU0FGQzthQUdGO0tBSFY7O1FBTUVwSCxNQUFGLENBQVUsSUFBVixFQUFpQixJQUFqQixFQUF3QmtDLEdBQXhCO0NBekJKOzs7QUE4QkEsSUFBSW1GLFdBQVdyRyxTQUFTc0csdUJBQVQsR0FBbUMsVUFBVUMsTUFBVixFQUFrQkMsS0FBbEIsRUFBeUI7UUFDbkUsQ0FBQ0EsS0FBTCxFQUFZO2VBQ0QsS0FBUDs7V0FFRyxDQUFDLEVBQUVELE9BQU9ELHVCQUFQLENBQStCRSxLQUEvQixJQUF3QyxFQUExQyxDQUFSO0NBSlcsR0FLWCxVQUFVRCxNQUFWLEVBQWtCQyxLQUFsQixFQUF5QjtRQUNyQixDQUFDQSxLQUFMLEVBQVk7ZUFDRCxLQUFQOztXQUVHQSxVQUFVQSxLQUFWLEtBQW9CRCxPQUFPRixRQUFQLEdBQWtCRSxPQUFPRixRQUFQLENBQWdCRyxLQUFoQixDQUFsQixHQUEyQyxJQUEvRCxDQUFQO0NBVEo7O0FBWUFaLGFBQWF4SyxTQUFiLEdBQXlCO1VBQ2QsZ0JBQVU7OztZQUdUcUwsS0FBTyxJQUFYO1lBQ0lBLEdBQUduSCxNQUFILENBQVVwQixRQUFWLElBQXNCYSxTQUExQixFQUFxQzs7O2dCQUc3QixDQUFDMEgsR0FBR04sS0FBSixJQUFhTSxHQUFHTixLQUFILENBQVM5SixNQUFULElBQW1CLENBQXBDLEVBQXdDO21CQUNqQzhKLEtBQUgsR0FBV1IsaUJBQVg7O1NBSlIsTUFNTyxJQUFJYyxHQUFHbkgsTUFBSCxDQUFVcEIsUUFBVixJQUFzQixDQUExQixFQUE2QjtlQUM3QmlJLEtBQUgsR0FBV1QsZ0JBQVg7OztZQUdGOUksSUFBRixDQUFRNkosR0FBR04sS0FBWCxFQUFtQixVQUFVN0QsSUFBVixFQUFnQjs7O2dCQUczQm1FLEdBQUduSCxNQUFILENBQVVwQixRQUFWLElBQXNCLENBQTFCLEVBQTZCO2tCQUN2QndJLFFBQUYsQ0FBWUQsR0FBR25ILE1BQWYsRUFBd0JnRCxJQUF4QixFQUErQixVQUFVeEQsQ0FBVixFQUFhO3VCQUNyQzZILGNBQUgsQ0FBbUI3SCxDQUFuQjtpQkFESjthQURKLE1BSU87bUJBQ0FRLE1BQUgsQ0FBVXNILEVBQVYsQ0FBY3RFLElBQWQsRUFBcUIsVUFBVXhELENBQVYsRUFBYTt1QkFDM0IrSCxZQUFILENBQWlCL0gsQ0FBakI7aUJBREo7O1NBUlI7S0FmaUI7Ozs7O29CQWlDSix3QkFBU0EsQ0FBVCxFQUFZO1lBQ3JCMkgsS0FBSyxJQUFUO1lBQ0lLLE9BQU9MLEdBQUdaLE1BQWQ7O2FBRUtrQixnQkFBTDs7V0FFR2pCLFNBQUgsR0FBZSxDQUFFLElBQUlsRSxLQUFKLENBQ2JvRixFQUFFMUMsS0FBRixDQUFTeEYsQ0FBVCxJQUFlZ0ksS0FBS0csVUFBTCxDQUFnQm5ELElBRGxCLEVBRWJrRCxFQUFFeEMsS0FBRixDQUFTMUYsQ0FBVCxJQUFlZ0ksS0FBS0csVUFBTCxDQUFnQmhELEdBRmxCLENBQUYsQ0FBZjs7Ozs7O1lBU0lpRCxnQkFBaUJULEdBQUdYLFNBQUgsQ0FBYSxDQUFiLENBQXJCO1lBQ0lxQixpQkFBaUJWLEdBQUdWLGVBQUgsQ0FBbUIsQ0FBbkIsQ0FBckI7Ozs7O1lBS0lqSCxFQUFFd0QsSUFBRixJQUFVLFdBQWQsRUFBMkI7O2dCQUVwQixDQUFDNkUsY0FBTCxFQUFxQjtvQkFDZi9LLE1BQU0wSyxLQUFLTSxvQkFBTCxDQUEyQkYsYUFBM0IsRUFBMkMsQ0FBM0MsRUFBOEMsQ0FBOUMsQ0FBVjtvQkFDRzlLLEdBQUgsRUFBTzt1QkFDRjJKLGVBQUgsR0FBcUIsQ0FBRTNKLEdBQUYsQ0FBckI7Ozs2QkFHYXFLLEdBQUdWLGVBQUgsQ0FBbUIsQ0FBbkIsQ0FBakI7Z0JBQ0tvQixrQkFBa0JBLGVBQWVFLFdBQXRDLEVBQW1EOzttQkFFNUNyQixTQUFILEdBQWUsSUFBZjs7OztZQUlIbEgsRUFBRXdELElBQUYsSUFBVSxTQUFWLElBQXdCeEQsRUFBRXdELElBQUYsSUFBVSxVQUFWLElBQXdCLENBQUMrRCxTQUFTUyxLQUFLMUIsSUFBZCxFQUFzQnRHLEVBQUV3SSxTQUFGLElBQWV4SSxFQUFFeUksYUFBdkMsQ0FBckQsRUFBK0c7Z0JBQ3hHZCxHQUFHUixRQUFILElBQWUsSUFBbEIsRUFBdUI7O21CQUVoQnVCLFFBQUgsQ0FBYTFJLENBQWIsRUFBaUJxSSxjQUFqQixFQUFrQyxDQUFsQzsrQkFDZU0sSUFBZixDQUFvQixTQUFwQjs7ZUFFRHhCLFFBQUgsR0FBZSxLQUFmO2VBQ0dELFNBQUgsR0FBZSxLQUFmOzs7WUFHQWxILEVBQUV3RCxJQUFGLElBQVUsVUFBZCxFQUEwQjtnQkFDbEIsQ0FBQytELFNBQVNTLEtBQUsxQixJQUFkLEVBQXNCdEcsRUFBRXdJLFNBQUYsSUFBZXhJLEVBQUV5SSxhQUF2QyxDQUFMLEVBQThEO21CQUN2REcsb0JBQUgsQ0FBd0I1SSxDQUF4QixFQUE0Qm9JLGFBQTVCOztTQUZSLE1BSU8sSUFBSXBJLEVBQUV3RCxJQUFGLElBQVUsV0FBZCxFQUEyQjs7O2dCQUUzQm1FLEdBQUdULFNBQUgsSUFBZ0JsSCxFQUFFd0QsSUFBRixJQUFVLFdBQTFCLElBQXlDNkUsY0FBNUMsRUFBMkQ7O29CQUVwRCxDQUFDVixHQUFHUixRQUFQLEVBQWdCOzttQ0FFR3dCLElBQWYsQ0FBb0IsV0FBcEI7O21DQUVlM0ssT0FBZixDQUF1QjZLLFdBQXZCLEdBQXFDLENBQXJDOzs7d0JBR0lDLGNBQWNuQixHQUFHb0IsaUJBQUgsQ0FBc0JWLGNBQXRCLEVBQXVDLENBQXZDLENBQWxCO2dDQUNZckssT0FBWixDQUFvQjZLLFdBQXBCLEdBQWtDUixlQUFlVyxZQUFqRDtpQkFSSixNQVNPOzt1QkFFQUMsZUFBSCxDQUFvQmpKLENBQXBCLEVBQXdCcUksY0FBeEIsRUFBeUMsQ0FBekM7O21CQUVEbEIsUUFBSCxHQUFjLElBQWQ7YUFmSixNQWdCTzs7OzttQkFJQXlCLG9CQUFILENBQXlCNUksQ0FBekIsRUFBNkJvSSxhQUE3Qjs7U0F0QkQsTUF5QkE7O2dCQUVDVixRQUFRVyxjQUFaO2dCQUNJLENBQUNYLEtBQUwsRUFBWTt3QkFDQU0sSUFBUjs7ZUFFRGtCLHVCQUFILENBQTRCbEosQ0FBNUIsRUFBZ0MsQ0FBRTBILEtBQUYsQ0FBaEM7ZUFDR3lCLGFBQUgsQ0FBa0J6QixLQUFsQjs7O1lBR0FNLEtBQUtvQixjQUFULEVBQTBCOztnQkFFakJwSixLQUFLQSxFQUFFb0osY0FBWixFQUE2QjtrQkFDdkJBLGNBQUY7YUFESixNQUVPO3VCQUNJakYsS0FBUCxDQUFha0YsV0FBYixHQUEyQixLQUEzQjs7O0tBM0hTOzBCQStIRSw4QkFBU3JKLENBQVQsRUFBYTBELEtBQWIsRUFBcUI7WUFDcENpRSxLQUFTLElBQWI7WUFDSUssT0FBU0wsR0FBR1osTUFBaEI7WUFDSXVDLFNBQVMzQixHQUFHVixlQUFILENBQW1CLENBQW5CLENBQWI7O1lBRUlxQyxVQUFVLENBQUNBLE9BQU90TCxPQUF0QixFQUErQjtxQkFDbEIsSUFBVDs7O1lBR0FnQyxJQUFJLElBQUlvRCxXQUFKLENBQWlCcEQsQ0FBakIsQ0FBUjs7WUFFSUEsRUFBRXdELElBQUYsSUFBUSxXQUFSLElBQ0c4RixNQURILElBQ2FBLE9BQU9DLFdBRHBCLElBQ21DRCxPQUFPRSxnQkFEMUMsSUFFR0YsT0FBT0csZUFBUCxDQUF3Qi9GLEtBQXhCLENBRlAsRUFFd0M7Ozs7Y0FJbENsRCxNQUFGLEdBQVdSLEVBQUV5RCxhQUFGLEdBQWtCNkYsTUFBN0I7Y0FDRTVGLEtBQUYsR0FBVzRGLE9BQU9JLGFBQVAsQ0FBc0JoRyxLQUF0QixDQUFYO21CQUNPaUcsYUFBUCxDQUFzQjNKLENBQXRCOzs7WUFHQTFDLE1BQU0wSyxLQUFLTSxvQkFBTCxDQUEyQjVFLEtBQTNCLEVBQW1DLENBQW5DLEVBQXNDLENBQXRDLENBQVY7O1lBRUc0RixVQUFVQSxVQUFVaE0sR0FBcEIsSUFBMkIwQyxFQUFFd0QsSUFBRixJQUFRLFVBQXRDLEVBQWtEO2dCQUMxQzhGLFVBQVVBLE9BQU90TCxPQUFyQixFQUE4QjttQkFDdkJpSixlQUFILENBQW1CLENBQW5CLElBQXdCLElBQXhCO2tCQUNFekQsSUFBRixHQUFhLFVBQWI7a0JBQ0VvRyxRQUFGLEdBQWF0TSxHQUFiO2tCQUNFa0QsTUFBRixHQUFhUixFQUFFeUQsYUFBRixHQUFrQjZGLE1BQS9CO2tCQUNFNUYsS0FBRixHQUFhNEYsT0FBT0ksYUFBUCxDQUFzQmhHLEtBQXRCLENBQWI7dUJBQ09pRyxhQUFQLENBQXNCM0osQ0FBdEI7Ozs7WUFJSjFDLE9BQU9nTSxVQUFVaE0sR0FBckIsRUFBMEI7O2VBQ25CMkosZUFBSCxDQUFtQixDQUFuQixJQUF3QjNKLEdBQXhCO2NBQ0VrRyxJQUFGLEdBQWUsV0FBZjtjQUNFcUcsVUFBRixHQUFlUCxNQUFmO2NBQ0U5SSxNQUFGLEdBQWVSLEVBQUV5RCxhQUFGLEdBQWtCbkcsR0FBakM7Y0FDRW9HLEtBQUYsR0FBZXBHLElBQUlvTSxhQUFKLENBQW1CaEcsS0FBbkIsQ0FBZjtnQkFDSWlHLGFBQUosQ0FBbUIzSixDQUFuQjs7O1lBR0FBLEVBQUV3RCxJQUFGLElBQVUsV0FBVixJQUF5QmxHLEdBQTdCLEVBQWtDO2NBQzVCa0QsTUFBRixHQUFXUixFQUFFeUQsYUFBRixHQUFrQjZGLE1BQTdCO2NBQ0U1RixLQUFGLEdBQVc0RixPQUFPSSxhQUFQLENBQXNCaEcsS0FBdEIsQ0FBWDttQkFDT2lHLGFBQVAsQ0FBc0IzSixDQUF0Qjs7V0FFRG1KLGFBQUgsQ0FBa0I3TCxHQUFsQixFQUF3QmdNLE1BQXhCO0tBaExpQjttQkFrTEYsdUJBQVVoTSxHQUFWLEVBQWdCZ00sTUFBaEIsRUFBd0I7WUFDcEMsQ0FBQ2hNLEdBQUQsSUFBUSxDQUFDZ00sTUFBWixFQUFvQjtpQkFDWFEsVUFBTCxDQUFnQixTQUFoQjs7WUFFRHhNLE9BQU9nTSxVQUFVaE0sR0FBakIsSUFBd0JBLElBQUlVLE9BQS9CLEVBQXVDO2lCQUM5QjhMLFVBQUwsQ0FBZ0J4TSxJQUFJVSxPQUFKLENBQVkrTCxNQUE1Qjs7S0F2TGE7Z0JBMExSLG9CQUFTQSxNQUFULEVBQWlCO1lBQ3ZCLEtBQUszQyxPQUFMLElBQWdCMkMsTUFBbkIsRUFBMEI7Ozs7YUFJckJoRCxNQUFMLENBQVlULElBQVosQ0FBaUJQLEtBQWpCLENBQXVCZ0UsTUFBdkIsR0FBZ0NBLE1BQWhDO2FBQ0szQyxPQUFMLEdBQWUyQyxNQUFmO0tBaE1pQjs7Ozs7Ozs7O2tCQTBNTixzQkFBVS9KLENBQVYsRUFBYztZQUNyQjJILEtBQU8sSUFBWDtZQUNJSyxPQUFPTCxHQUFHWixNQUFkO2FBQ0trQixnQkFBTDs7O1dBR0dqQixTQUFILEdBQWVXLEdBQUdxQyx3QkFBSCxDQUE2QmhLLENBQTdCLENBQWY7WUFDSSxDQUFDMkgsR0FBR1IsUUFBUixFQUFrQjs7ZUFFWEYsZUFBSCxHQUFxQlUsR0FBR3NDLGtCQUFILENBQXVCdEMsR0FBR1gsU0FBMUIsQ0FBckI7O1lBRUFXLEdBQUdWLGVBQUgsQ0FBbUIxSixNQUFuQixHQUE0QixDQUFoQyxFQUFtQzs7Z0JBRTNCeUMsRUFBRXdELElBQUYsSUFBVW1FLEdBQUdMLElBQUgsQ0FBUTRDLEtBQXRCLEVBQTRCOzs7b0JBR3RCcE0sSUFBRixDQUFRNkosR0FBR1YsZUFBWCxFQUE2QixVQUFVUyxLQUFWLEVBQWtCbEssQ0FBbEIsRUFBcUI7d0JBQzFDa0ssU0FBU0EsTUFBTWEsV0FBbkIsRUFBZ0M7OzJCQUUxQnBCLFFBQUgsR0FBYyxJQUFkOzsyQkFFRzRCLGlCQUFILENBQXNCckIsS0FBdEIsRUFBOEJsSyxDQUE5Qjs7OEJBRU1RLE9BQU4sQ0FBYzZLLFdBQWQsR0FBNEIsQ0FBNUI7OzhCQUVNRixJQUFOLENBQVcsV0FBWDs7K0JBRU8sS0FBUDs7aUJBWFA7Ozs7Z0JBaUJBM0ksRUFBRXdELElBQUYsSUFBVW1FLEdBQUdMLElBQUgsQ0FBUTZDLElBQXRCLEVBQTJCO29CQUNuQnhDLEdBQUdSLFFBQVAsRUFBaUI7d0JBQ1hySixJQUFGLENBQVE2SixHQUFHVixlQUFYLEVBQTZCLFVBQVVTLEtBQVYsRUFBa0JsSyxDQUFsQixFQUFxQjs0QkFDMUNrSyxTQUFTQSxNQUFNYSxXQUFuQixFQUFnQzsrQkFDMUJVLGVBQUgsQ0FBb0JqSixDQUFwQixFQUF3QjBILEtBQXhCLEVBQWdDbEssQ0FBaEM7O3FCQUZQOzs7OztnQkFTSndDLEVBQUV3RCxJQUFGLElBQVVtRSxHQUFHTCxJQUFILENBQVE4QyxHQUF0QixFQUEwQjtvQkFDbEJ6QyxHQUFHUixRQUFQLEVBQWlCO3dCQUNYckosSUFBRixDQUFRNkosR0FBR1YsZUFBWCxFQUE2QixVQUFVUyxLQUFWLEVBQWtCbEssQ0FBbEIsRUFBcUI7NEJBQzFDa0ssU0FBU0EsTUFBTWEsV0FBbkIsRUFBZ0M7K0JBQ3pCRyxRQUFILENBQWExSSxDQUFiLEVBQWlCMEgsS0FBakIsRUFBeUIsQ0FBekI7a0NBQ01pQixJQUFOLENBQVcsU0FBWDs7cUJBSFI7dUJBTUd4QixRQUFILEdBQWMsS0FBZDs7O2VBR0wrQix1QkFBSCxDQUE0QmxKLENBQTVCLEVBQWdDMkgsR0FBR1YsZUFBbkM7U0E1Q0osTUE2Q087O2VBRUFpQyx1QkFBSCxDQUE0QmxKLENBQTVCLEVBQWdDLENBQUVnSSxJQUFGLENBQWhDOztLQXBRYTs7OEJBd1FNLGtDQUFVaEksQ0FBVixFQUFhO1lBQ2hDMkgsS0FBWSxJQUFoQjtZQUNJSyxPQUFZTCxHQUFHWixNQUFuQjtZQUNJc0QsWUFBWSxFQUFoQjtZQUNFdk0sSUFBRixDQUFRa0MsRUFBRTBELEtBQVYsRUFBa0IsVUFBVTRHLEtBQVYsRUFBaUI7c0JBQ3RCMU0sSUFBVixDQUFnQjttQkFDUndGLFlBQVlvQyxLQUFaLENBQW1COEUsS0FBbkIsSUFBNkJ0QyxLQUFLRyxVQUFMLENBQWdCbkQsSUFEckM7bUJBRVI1QixZQUFZc0MsS0FBWixDQUFtQjRFLEtBQW5CLElBQTZCdEMsS0FBS0csVUFBTCxDQUFnQmhEO2FBRnJEO1NBREg7ZUFNT2tGLFNBQVA7S0FsUmlCO3dCQW9SQSw0QkFBVUUsTUFBVixFQUFrQjtZQUMvQjVDLEtBQU8sSUFBWDtZQUNJSyxPQUFPTCxHQUFHWixNQUFkO1lBQ0l5RCxnQkFBZ0IsRUFBcEI7WUFDRTFNLElBQUYsQ0FBUXlNLE1BQVIsRUFBaUIsVUFBU0QsS0FBVCxFQUFlOzBCQUNkMU0sSUFBZCxDQUFvQm9LLEtBQUtNLG9CQUFMLENBQTJCZ0MsS0FBM0IsRUFBbUMsQ0FBbkMsRUFBc0MsQ0FBdEMsQ0FBcEI7U0FESjtlQUdPRSxhQUFQO0tBM1JpQjs7Ozs7Ozs7NkJBcVNJLGlDQUFTeEssQ0FBVCxFQUFZeUssTUFBWixFQUFvQjtZQUNyQyxDQUFDQSxNQUFELElBQVcsRUFBRSxZQUFZQSxNQUFkLENBQWYsRUFBc0M7bUJBQzNCLEtBQVA7O1lBRUE5QyxLQUFLLElBQVQ7WUFDSStDLFdBQVcsS0FBZjtZQUNFNU0sSUFBRixDQUFPMk0sTUFBUCxFQUFlLFVBQVMvQyxLQUFULEVBQWdCbEssQ0FBaEIsRUFBbUI7Z0JBQzFCa0ssS0FBSixFQUFXOzJCQUNJLElBQVg7b0JBQ0lpRCxLQUFLLElBQUl2SCxXQUFKLENBQWdCcEQsQ0FBaEIsQ0FBVDttQkFDR1EsTUFBSCxHQUFZbUssR0FBR2xILGFBQUgsR0FBbUJpRSxTQUFTLElBQXhDO21CQUNHa0QsVUFBSCxHQUFnQmpELEdBQUdYLFNBQUgsQ0FBYXhKLENBQWIsQ0FBaEI7bUJBQ0drRyxLQUFILEdBQVdpSCxHQUFHbkssTUFBSCxDQUFVa0osYUFBVixDQUF3QmlCLEdBQUdDLFVBQTNCLENBQVg7c0JBQ01qQixhQUFOLENBQW9CZ0IsRUFBcEI7O1NBUFI7ZUFVT0QsUUFBUDtLQXJUaUI7O3VCQXdURiwyQkFBU2xLLE1BQVQsRUFBaUJoRCxDQUFqQixFQUFvQjtZQUMvQm1LLEtBQUssSUFBVDtZQUNJSyxPQUFPTCxHQUFHWixNQUFkO1lBQ0k4RCxpQkFBaUI3QyxLQUFLOEMsWUFBTCxDQUFrQkMsWUFBbEIsQ0FBK0J2SyxPQUFPc0YsRUFBdEMsQ0FBckI7WUFDSSxDQUFDK0UsY0FBTCxFQUFxQjs2QkFDQXJLLE9BQU9ELEtBQVAsQ0FBYSxJQUFiLENBQWpCOzJCQUNleUssVUFBZixHQUE0QnhLLE9BQU95SyxxQkFBUCxFQUE1Qjs7Ozs7Ozs7aUJBUUtILFlBQUwsQ0FBa0JJLFVBQWxCLENBQTZCTCxjQUE3QixFQUE2QyxDQUE3Qzs7dUJBRVc3TSxPQUFmLENBQXVCNkssV0FBdkIsR0FBcUNySSxPQUFPd0ksWUFBNUM7ZUFDT21DLFVBQVAsR0FBb0IzSyxPQUFPa0osYUFBUCxDQUFxQi9CLEdBQUdYLFNBQUgsQ0FBYXhKLENBQWIsQ0FBckIsQ0FBcEI7ZUFDT3FOLGNBQVA7S0ExVWlCOztxQkE2VUoseUJBQVM3SyxDQUFULEVBQVlRLE1BQVosRUFBb0JoRCxDQUFwQixFQUF1QjtZQUNoQ21LLEtBQUssSUFBVDtZQUNJSyxPQUFPTCxHQUFHWixNQUFkO1lBQ0lxRSxTQUFTNUssT0FBT2tKLGFBQVAsQ0FBc0IvQixHQUFHWCxTQUFILENBQWF4SixDQUFiLENBQXRCLENBQWI7OztlQUdPNk4sU0FBUCxHQUFtQixJQUFuQjtZQUNJQyxhQUFhOUssT0FBTytLLE9BQXhCO2VBQ09BLE9BQVAsR0FBaUIsSUFBakI7ZUFDT3ZOLE9BQVAsQ0FBZStFLENBQWYsSUFBcUJxSSxPQUFPckksQ0FBUCxHQUFXdkMsT0FBTzJLLFVBQVAsQ0FBa0JwSSxDQUFsRDtlQUNPL0UsT0FBUCxDQUFlZ0YsQ0FBZixJQUFxQm9JLE9BQU9wSSxDQUFQLEdBQVd4QyxPQUFPMkssVUFBUCxDQUFrQm5JLENBQWxEO2VBQ08yRixJQUFQLENBQVksVUFBWjtlQUNPNEMsT0FBUCxHQUFpQkQsVUFBakI7ZUFDT0QsU0FBUCxHQUFtQixLQUFuQjs7OztZQUlJUixpQkFBaUI3QyxLQUFLOEMsWUFBTCxDQUFrQkMsWUFBbEIsQ0FBK0J2SyxPQUFPc0YsRUFBdEMsQ0FBckI7dUJBQ2VrRixVQUFmLEdBQTRCeEssT0FBT3lLLHFCQUFQLEVBQTVCOzs7dUJBR2VPLFNBQWY7S0FsV2lCOztjQXFXWCxrQkFBU3hMLENBQVQsRUFBWVEsTUFBWixFQUFvQmhELENBQXBCLEVBQXVCO1lBQ3pCbUssS0FBSyxJQUFUO1lBQ0lLLE9BQU9MLEdBQUdaLE1BQWQ7OztZQUdJOEQsaUJBQWlCN0MsS0FBSzhDLFlBQUwsQ0FBa0JDLFlBQWxCLENBQStCdkssT0FBT3NGLEVBQXRDLENBQXJCO3VCQUNlMkYsT0FBZjs7ZUFFT3pOLE9BQVAsQ0FBZTZLLFdBQWYsR0FBNkJySSxPQUFPd0ksWUFBcEM7O0NBN1dSLENBZ1hBOztBQzdhQTs7Ozs7OztBQU9BLEFBRUE7Ozs7O0FBS0EsSUFBSTBDLGVBQWUsU0FBZkEsWUFBZSxHQUFXOztTQUVyQkMsU0FBTCxHQUFpQixFQUFqQjtDQUZKOztBQUtBRCxhQUFhcFAsU0FBYixHQUF5Qjs7Ozt1QkFJRCwyQkFBU2tILElBQVQsRUFBZW9JLFFBQWYsRUFBeUI7O1lBRXJDLE9BQU9BLFFBQVAsSUFBbUIsVUFBdkIsRUFBbUM7O21CQUUxQixLQUFQOztZQUVFQyxZQUFZLElBQWhCO1lBQ0lDLE9BQVksSUFBaEI7WUFDRWhPLElBQUYsQ0FBUTBGLEtBQUt1SSxLQUFMLENBQVcsR0FBWCxDQUFSLEVBQTBCLFVBQVN2SSxJQUFULEVBQWM7Z0JBQ2hDd0ksTUFBTUYsS0FBS0gsU0FBTCxDQUFlbkksSUFBZixDQUFWO2dCQUNHLENBQUN3SSxHQUFKLEVBQVE7c0JBQ0VGLEtBQUtILFNBQUwsQ0FBZW5JLElBQWYsSUFBdUIsRUFBN0I7b0JBQ0k1RixJQUFKLENBQVNnTyxRQUFUO3FCQUNLSyxhQUFMLEdBQXFCLElBQXJCO3VCQUNPLElBQVA7OztnQkFHRC9QLElBQUVjLE9BQUYsQ0FBVWdQLEdBQVYsRUFBZUosUUFBZixLQUE0QixDQUFDLENBQWhDLEVBQW1DO29CQUMzQmhPLElBQUosQ0FBU2dPLFFBQVQ7cUJBQ0tLLGFBQUwsR0FBcUIsSUFBckI7dUJBQ08sSUFBUDs7O3dCQUdRLEtBQVo7U0FmSjtlQWlCT0osU0FBUDtLQTdCaUI7Ozs7MEJBa0NFLDhCQUFTckksSUFBVCxFQUFlb0ksUUFBZixFQUF5QjtZQUN6Q25MLFVBQVVsRCxNQUFWLElBQW9CLENBQXZCLEVBQTBCLE9BQU8sS0FBSzJPLHlCQUFMLENBQStCMUksSUFBL0IsQ0FBUDs7WUFFdEJ3SSxNQUFNLEtBQUtMLFNBQUwsQ0FBZW5JLElBQWYsQ0FBVjtZQUNHLENBQUN3SSxHQUFKLEVBQVE7bUJBQ0csS0FBUDs7O2FBR0EsSUFBSXhPLElBQUksQ0FBWixFQUFlQSxJQUFJd08sSUFBSXpPLE1BQXZCLEVBQStCQyxHQUEvQixFQUFvQztnQkFDNUIyTyxLQUFLSCxJQUFJeE8sQ0FBSixDQUFUO2dCQUNHMk8sT0FBT1AsUUFBVixFQUFvQjtvQkFDWlEsTUFBSixDQUFXNU8sQ0FBWCxFQUFjLENBQWQ7b0JBQ0d3TyxJQUFJek8sTUFBSixJQUFpQixDQUFwQixFQUF1QjsyQkFDWixLQUFLb08sU0FBTCxDQUFlbkksSUFBZixDQUFQOzt3QkFFR3RILElBQUUrQyxPQUFGLENBQVUsS0FBSzBNLFNBQWYsQ0FBSCxFQUE2Qjs7NkJBRXBCTSxhQUFMLEdBQXFCLEtBQXJCOzs7dUJBR0QsSUFBUDs7OztlQUlELEtBQVA7S0ExRGlCOzs7O2dDQStEUSxvQ0FBU3pJLElBQVQsRUFBZTtZQUNwQ3dJLE1BQU0sS0FBS0wsU0FBTCxDQUFlbkksSUFBZixDQUFWO1lBQ0csQ0FBQ3dJLEdBQUosRUFBUzttQkFDRSxLQUFLTCxTQUFMLENBQWVuSSxJQUFmLENBQVA7OztnQkFHR3RILElBQUUrQyxPQUFGLENBQVUsS0FBSzBNLFNBQWYsQ0FBSCxFQUE2Qjs7cUJBRXBCTSxhQUFMLEdBQXFCLEtBQXJCOzs7bUJBR0csSUFBUDs7ZUFFRyxLQUFQO0tBNUVpQjs7Ozs4QkFpRk0sb0NBQVc7YUFDN0JOLFNBQUwsR0FBaUIsRUFBakI7YUFDS00sYUFBTCxHQUFxQixLQUFyQjtLQW5GaUI7Ozs7b0JBd0ZKLHdCQUFTak0sQ0FBVCxFQUFZO1lBQ3JCZ00sTUFBTSxLQUFLTCxTQUFMLENBQWUzTCxFQUFFd0QsSUFBakIsQ0FBVjs7WUFFSXdJLEdBQUosRUFBUztnQkFDRixDQUFDaE0sRUFBRVEsTUFBTixFQUFjUixFQUFFUSxNQUFGLEdBQVcsSUFBWDtrQkFDUndMLElBQUlyTCxLQUFKLEVBQU47O2lCQUVJLElBQUluRCxJQUFJLENBQVosRUFBZUEsSUFBSXdPLElBQUl6TyxNQUF2QixFQUErQkMsR0FBL0IsRUFBb0M7b0JBQzVCb08sV0FBV0ksSUFBSXhPLENBQUosQ0FBZjtvQkFDRyxPQUFPb08sUUFBUCxJQUFvQixVQUF2QixFQUFtQzs2QkFDdEIvTixJQUFULENBQWMsSUFBZCxFQUFvQm1DLENBQXBCOzs7OztZQUtSLENBQUNBLEVBQUUyRCxnQkFBUCxFQUEwQjs7Z0JBRWxCLEtBQUs4RCxNQUFULEVBQWlCO2tCQUNYaEUsYUFBRixHQUFrQixLQUFLZ0UsTUFBdkI7cUJBQ0tBLE1BQUwsQ0FBWTRFLGNBQVosQ0FBNEJyTSxDQUE1Qjs7O2VBR0QsSUFBUDtLQTlHaUI7Ozs7dUJBbUhELDJCQUFTd0QsSUFBVCxFQUFlO1lBQzNCd0ksTUFBTSxLQUFLTCxTQUFMLENBQWVuSSxJQUFmLENBQVY7ZUFDT3dJLE9BQU8sSUFBUCxJQUFlQSxJQUFJek8sTUFBSixHQUFhLENBQW5DOztDQXJIUixDQXlIQTs7QUM1SUE7Ozs7Ozs7QUFPQSxBQUNBLEFBQ0EsQUFDQSxBQUdBLElBQUkrTyxrQkFBa0IsU0FBbEJBLGVBQWtCLEdBQVU7b0JBQ1p0SyxVQUFoQixDQUEyQmxDLFdBQTNCLENBQXVDakMsSUFBdkMsQ0FBNEMsSUFBNUMsRUFBa0RZLElBQWxEO0NBREo7O0FBSUFtQyxNQUFNMkwsVUFBTixDQUFpQkQsZUFBakIsRUFBbUNaLFlBQW5DLEVBQWtEO1FBQ3pDLFlBQVNsSSxJQUFULEVBQWVvSSxRQUFmLEVBQXdCO2FBQ3BCWSxpQkFBTCxDQUF3QmhKLElBQXhCLEVBQThCb0ksUUFBOUI7ZUFDTyxJQUFQO0tBSDBDO3NCQUs3QiwwQkFBU3BJLElBQVQsRUFBZW9JLFFBQWYsRUFBd0I7YUFDaENZLGlCQUFMLENBQXdCaEosSUFBeEIsRUFBOEJvSSxRQUE5QjtlQUNPLElBQVA7S0FQMEM7UUFTekMsWUFBU3BJLElBQVQsRUFBY29JLFFBQWQsRUFBdUI7YUFDbkJhLG9CQUFMLENBQTJCakosSUFBM0IsRUFBaUNvSSxRQUFqQztlQUNPLElBQVA7S0FYMEM7eUJBYTFCLDZCQUFTcEksSUFBVCxFQUFjb0ksUUFBZCxFQUF1QjthQUNsQ2Esb0JBQUwsQ0FBMkJqSixJQUEzQixFQUFpQ29JLFFBQWpDO2VBQ08sSUFBUDtLQWYwQzsrQkFpQnBCLG1DQUFTcEksSUFBVCxFQUFjO2FBQy9Ca0osMEJBQUwsQ0FBaUNsSixJQUFqQztlQUNPLElBQVA7S0FuQjBDOzZCQXFCdEIsbUNBQVU7YUFDekJtSix3QkFBTDtlQUNPLElBQVA7S0F2QjBDOzs7VUEyQnZDLGNBQVNwSixTQUFULEVBQXFCRCxNQUFyQixFQUE0QjtZQUMzQnRELElBQUksSUFBSW9ELFdBQUosQ0FBaUJHLFNBQWpCLENBQVI7O1lBRUlELE1BQUosRUFBWTtpQkFDSCxJQUFJSCxDQUFULElBQWNHLE1BQWQsRUFBc0I7b0JBQ2RILEtBQUtuRCxDQUFULEVBQVk7OzRCQUVBNE0sR0FBUixDQUFhekosSUFBSSxxQkFBakI7aUJBRkosTUFHTztzQkFDREEsQ0FBRixJQUFPRyxPQUFPSCxDQUFQLENBQVA7Ozs7O1lBS1J3RSxLQUFLLElBQVQ7WUFDRTdKLElBQUYsQ0FBUXlGLFVBQVV3SSxLQUFWLENBQWdCLEdBQWhCLENBQVIsRUFBK0IsVUFBU2MsS0FBVCxFQUFlO2NBQ3hDcEosYUFBRixHQUFrQmtFLEVBQWxCO2VBQ0dnQyxhQUFILENBQWtCM0osQ0FBbEI7U0FGSjtlQUlPLElBQVA7S0E5QzBDO21CQWdEaEMsdUJBQVNtRSxLQUFULEVBQWU7Ozs7WUFJckIsS0FBSzJJLFFBQUwsSUFBa0IzSSxNQUFNVCxLQUE1QixFQUFtQztnQkFDM0JsRCxTQUFTLEtBQUs4SCxvQkFBTCxDQUEyQm5FLE1BQU1ULEtBQWpDLEVBQXlDLENBQXpDLEVBQTRDLENBQTVDLENBQWI7Z0JBQ0lsRCxNQUFKLEVBQVk7dUJBQ0RtSixhQUFQLENBQXNCeEYsS0FBdEI7Ozs7O1lBS0wsS0FBS25HLE9BQUwsSUFBZ0JtRyxNQUFNWCxJQUFOLElBQWMsV0FBakMsRUFBNkM7O2dCQUVyQ3VKLGVBQWUsS0FBS0MsYUFBeEI7Z0JBQ0lDLFlBQWUsS0FBS2pQLE9BQUwsQ0FBYTZLLFdBQWhDO2lCQUNLd0QsY0FBTCxDQUFxQmxJLEtBQXJCO2dCQUNJNEksZ0JBQWdCLEtBQUtDLGFBQXpCLEVBQXdDO3FCQUMvQnpELFdBQUwsR0FBbUIsSUFBbkI7b0JBQ0ksS0FBSzJELFVBQVQsRUFBcUI7d0JBQ2JuRyxTQUFTLEtBQUtvRyxRQUFMLEdBQWdCMUYsTUFBN0I7O3dCQUVJMkYsYUFBYSxLQUFLN00sS0FBTCxDQUFXLElBQVgsQ0FBakI7K0JBQ1d5SyxVQUFYLEdBQXdCLEtBQUtDLHFCQUFMLEVBQXhCOzJCQUNPSCxZQUFQLENBQW9CSSxVQUFwQixDQUFnQ2tDLFVBQWhDLEVBQTZDLENBQTdDOzt5QkFFS3BFLFlBQUwsR0FBb0JpRSxTQUFwQjt5QkFDS2pQLE9BQUwsQ0FBYTZLLFdBQWIsR0FBMkIsQ0FBM0I7Ozs7OzthQU1Qd0QsY0FBTCxDQUFxQmxJLEtBQXJCOztZQUVJLEtBQUtuRyxPQUFMLElBQWdCbUcsTUFBTVgsSUFBTixJQUFjLFVBQWxDLEVBQTZDO2dCQUN0QyxLQUFLK0YsV0FBUixFQUFvQjs7b0JBRVp4QyxTQUFTLEtBQUtvRyxRQUFMLEdBQWdCMUYsTUFBN0I7cUJBQ0s4QixXQUFMLEdBQW1CLEtBQW5COzt1QkFFT3VCLFlBQVAsQ0FBb0J1QyxlQUFwQixDQUFvQyxLQUFLdkgsRUFBekM7O29CQUVJLEtBQUtrRCxZQUFULEVBQXVCO3lCQUNkaEwsT0FBTCxDQUFhNkssV0FBYixHQUEyQixLQUFLRyxZQUFoQzsyQkFDTyxLQUFLQSxZQUFaOzs7OztlQUtMLElBQVA7S0FsRzBDO2NBb0dyQyxrQkFBU3hGLElBQVQsRUFBYztlQUNaLEtBQUs4SixpQkFBTCxDQUF1QjlKLElBQXZCLENBQVA7S0FyRzBDO3NCQXVHN0IsMEJBQVNBLElBQVQsRUFBYztlQUNwQixLQUFLOEosaUJBQUwsQ0FBdUI5SixJQUF2QixDQUFQO0tBeEcwQztXQTBHdEMsZUFBVStKLE9BQVYsRUFBb0JDLE1BQXBCLEVBQTRCO2FBQzNCMUYsRUFBTCxDQUFRLFdBQVIsRUFBc0J5RixPQUF0QjthQUNLekYsRUFBTCxDQUFRLFVBQVIsRUFBc0IwRixNQUF0QjtlQUNPLElBQVA7S0E3RzBDO1VBK0d2QyxjQUFTaEssSUFBVCxFQUFlb0ksUUFBZixFQUF3QjtZQUN2QmpFLEtBQUssSUFBVDtZQUNJOEYsYUFBYSxTQUFiQSxVQUFhLEdBQVU7cUJBQ2RDLEtBQVQsQ0FBZS9GLEVBQWYsRUFBb0JsSCxTQUFwQjtpQkFDS2tOLEVBQUwsQ0FBUW5LLElBQVIsRUFBZWlLLFVBQWY7U0FGSjthQUlLM0YsRUFBTCxDQUFRdEUsSUFBUixFQUFlaUssVUFBZjtlQUNPLElBQVA7O0NBdEhSLEVBMEhBOztBQzFJQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxJQUFJRyxTQUFTLFNBQVRBLE1BQVMsQ0FBU0MsQ0FBVCxFQUFZQyxDQUFaLEVBQWVDLENBQWYsRUFBa0JDLENBQWxCLEVBQXFCQyxFQUFyQixFQUF5QkMsRUFBekIsRUFBNEI7U0FDaENMLENBQUwsR0FBU0EsS0FBSzVOLFNBQUwsR0FBaUI0TixDQUFqQixHQUFxQixDQUE5QjtTQUNLQyxDQUFMLEdBQVNBLEtBQUs3TixTQUFMLEdBQWlCNk4sQ0FBakIsR0FBcUIsQ0FBOUI7U0FDS0MsQ0FBTCxHQUFTQSxLQUFLOU4sU0FBTCxHQUFpQjhOLENBQWpCLEdBQXFCLENBQTlCO1NBQ0tDLENBQUwsR0FBU0EsS0FBSy9OLFNBQUwsR0FBaUIrTixDQUFqQixHQUFxQixDQUE5QjtTQUNLQyxFQUFMLEdBQVVBLE1BQU1oTyxTQUFOLEdBQWtCZ08sRUFBbEIsR0FBdUIsQ0FBakM7U0FDS0MsRUFBTCxHQUFVQSxNQUFNak8sU0FBTixHQUFrQmlPLEVBQWxCLEdBQXVCLENBQWpDO1NBQ0toUSxLQUFMLEdBQWEsSUFBYjtDQVBKOztBQVVBMFAsT0FBT3RSLFNBQVAsR0FBbUI7WUFDTixnQkFBUzZSLEdBQVQsRUFBYTtZQUNkTixJQUFJLEtBQUtBLENBQWI7WUFDSUUsSUFBSSxLQUFLQSxDQUFiO1lBQ0lFLEtBQUssS0FBS0EsRUFBZDs7YUFFS0osQ0FBTCxHQUFTQSxJQUFJTSxJQUFJTixDQUFSLEdBQVksS0FBS0MsQ0FBTCxHQUFTSyxJQUFJSixDQUFsQzthQUNLRCxDQUFMLEdBQVNELElBQUlNLElBQUlMLENBQVIsR0FBWSxLQUFLQSxDQUFMLEdBQVNLLElBQUlILENBQWxDO2FBQ0tELENBQUwsR0FBU0EsSUFBSUksSUFBSU4sQ0FBUixHQUFZLEtBQUtHLENBQUwsR0FBU0csSUFBSUosQ0FBbEM7YUFDS0MsQ0FBTCxHQUFTRCxJQUFJSSxJQUFJTCxDQUFSLEdBQVksS0FBS0UsQ0FBTCxHQUFTRyxJQUFJSCxDQUFsQzthQUNLQyxFQUFMLEdBQVVBLEtBQUtFLElBQUlOLENBQVQsR0FBYSxLQUFLSyxFQUFMLEdBQVVDLElBQUlKLENBQTNCLEdBQStCSSxJQUFJRixFQUE3QzthQUNLQyxFQUFMLEdBQVVELEtBQUtFLElBQUlMLENBQVQsR0FBYSxLQUFLSSxFQUFMLEdBQVVDLElBQUlILENBQTNCLEdBQStCRyxJQUFJRCxFQUE3QztlQUNPLElBQVA7S0FaVztxQkFjRyx5QkFBU25MLENBQVQsRUFBWUMsQ0FBWixFQUFlb0wsTUFBZixFQUF1QkMsTUFBdkIsRUFBK0JDLFFBQS9CLEVBQXdDO1lBQ2xEQyxNQUFNLENBQVY7WUFDSUMsTUFBTSxDQUFWO1lBQ0dGLFdBQVMsR0FBWixFQUFnQjtnQkFDUjVNLElBQUk0TSxXQUFXOU8sS0FBS2lQLEVBQWhCLEdBQXFCLEdBQTdCO2tCQUNNalAsS0FBSytPLEdBQUwsQ0FBUzdNLENBQVQsQ0FBTjtrQkFDTWxDLEtBQUtnUCxHQUFMLENBQVM5TSxDQUFULENBQU47OzthQUdDZ04sTUFBTCxDQUFZLElBQUlkLE1BQUosQ0FBV1csTUFBSUgsTUFBZixFQUF1QkksTUFBSUosTUFBM0IsRUFBbUMsQ0FBQ0ksR0FBRCxHQUFLSCxNQUF4QyxFQUFnREUsTUFBSUYsTUFBcEQsRUFBNER0TCxDQUE1RCxFQUErREMsQ0FBL0QsQ0FBWjtlQUNPLElBQVA7S0F4Qlc7WUEwQk4sZ0JBQVMyTCxLQUFULEVBQWU7O1lBRWhCSixNQUFNL08sS0FBSytPLEdBQUwsQ0FBU0ksS0FBVCxDQUFWO1lBQ0lILE1BQU1oUCxLQUFLZ1AsR0FBTCxDQUFTRyxLQUFULENBQVY7O1lBRUlkLElBQUksS0FBS0EsQ0FBYjtZQUNJRSxJQUFJLEtBQUtBLENBQWI7WUFDSUUsS0FBSyxLQUFLQSxFQUFkOztZQUVJVSxRQUFNLENBQVYsRUFBWTtpQkFDSGQsQ0FBTCxHQUFTQSxJQUFJVSxHQUFKLEdBQVUsS0FBS1QsQ0FBTCxHQUFTVSxHQUE1QjtpQkFDS1YsQ0FBTCxHQUFTRCxJQUFJVyxHQUFKLEdBQVUsS0FBS1YsQ0FBTCxHQUFTUyxHQUE1QjtpQkFDS1IsQ0FBTCxHQUFTQSxJQUFJUSxHQUFKLEdBQVUsS0FBS1AsQ0FBTCxHQUFTUSxHQUE1QjtpQkFDS1IsQ0FBTCxHQUFTRCxJQUFJUyxHQUFKLEdBQVUsS0FBS1IsQ0FBTCxHQUFTTyxHQUE1QjtpQkFDS04sRUFBTCxHQUFVQSxLQUFLTSxHQUFMLEdBQVcsS0FBS0wsRUFBTCxHQUFVTSxHQUEvQjtpQkFDS04sRUFBTCxHQUFVRCxLQUFLTyxHQUFMLEdBQVcsS0FBS04sRUFBTCxHQUFVSyxHQUEvQjtTQU5KLE1BT087Z0JBQ0NLLEtBQUtwUCxLQUFLZ1AsR0FBTCxDQUFTaFAsS0FBS3FQLEdBQUwsQ0FBU0YsS0FBVCxDQUFULENBQVQ7Z0JBQ0lHLEtBQUt0UCxLQUFLK08sR0FBTCxDQUFTL08sS0FBS3FQLEdBQUwsQ0FBU0YsS0FBVCxDQUFULENBQVQ7O2lCQUVLZCxDQUFMLEdBQVNBLElBQUVpQixFQUFGLEdBQU8sS0FBS2hCLENBQUwsR0FBT2MsRUFBdkI7aUJBQ0tkLENBQUwsR0FBUyxDQUFDRCxDQUFELEdBQUdlLEVBQUgsR0FBUSxLQUFLZCxDQUFMLEdBQU9nQixFQUF4QjtpQkFDS2YsQ0FBTCxHQUFTQSxJQUFFZSxFQUFGLEdBQU8sS0FBS2QsQ0FBTCxHQUFPWSxFQUF2QjtpQkFDS1osQ0FBTCxHQUFTLENBQUNELENBQUQsR0FBR2EsRUFBSCxHQUFRRSxLQUFHLEtBQUtkLENBQXpCO2lCQUNLQyxFQUFMLEdBQVVhLEtBQUdiLEVBQUgsR0FBUVcsS0FBRyxLQUFLVixFQUExQjtpQkFDS0EsRUFBTCxHQUFVWSxLQUFHLEtBQUtaLEVBQVIsR0FBYVUsS0FBR1gsRUFBMUI7O2VBRUcsSUFBUDtLQXJEVztXQXVEUCxlQUFTYyxFQUFULEVBQWFDLEVBQWIsRUFBZ0I7YUFDZm5CLENBQUwsSUFBVWtCLEVBQVY7YUFDS2YsQ0FBTCxJQUFVZ0IsRUFBVjthQUNLZixFQUFMLElBQVdjLEVBQVg7YUFDS2IsRUFBTCxJQUFXYyxFQUFYO2VBQ08sSUFBUDtLQTVEVztlQThESCxtQkFBU0MsRUFBVCxFQUFhQyxFQUFiLEVBQWdCO2FBQ25CakIsRUFBTCxJQUFXZ0IsRUFBWDthQUNLZixFQUFMLElBQVdnQixFQUFYO2VBQ08sSUFBUDtLQWpFVztjQW1FSixvQkFBVTs7YUFFWnJCLENBQUwsR0FBUyxLQUFLRyxDQUFMLEdBQVMsQ0FBbEI7YUFDS0YsQ0FBTCxHQUFTLEtBQUtDLENBQUwsR0FBUyxLQUFLRSxFQUFMLEdBQVUsS0FBS0MsRUFBTCxHQUFVLENBQXRDO2VBQ08sSUFBUDtLQXZFVztZQXlFTixrQkFBVTs7WUFFWEwsSUFBSSxLQUFLQSxDQUFiO1lBQ0lDLElBQUksS0FBS0EsQ0FBYjtZQUNJQyxJQUFJLEtBQUtBLENBQWI7WUFDSUMsSUFBSSxLQUFLQSxDQUFiO1lBQ0lDLEtBQUssS0FBS0EsRUFBZDtZQUNJelEsSUFBSXFRLElBQUlHLENBQUosR0FBUUYsSUFBSUMsQ0FBcEI7O2FBRUtGLENBQUwsR0FBU0csSUFBSXhRLENBQWI7YUFDS3NRLENBQUwsR0FBUyxDQUFDQSxDQUFELEdBQUt0USxDQUFkO2FBQ0t1USxDQUFMLEdBQVMsQ0FBQ0EsQ0FBRCxHQUFLdlEsQ0FBZDthQUNLd1EsQ0FBTCxHQUFTSCxJQUFJclEsQ0FBYjthQUNLeVEsRUFBTCxHQUFVLENBQUNGLElBQUksS0FBS0csRUFBVCxHQUFjRixJQUFJQyxFQUFuQixJQUF5QnpRLENBQW5DO2FBQ0swUSxFQUFMLEdBQVUsRUFBRUwsSUFBSSxLQUFLSyxFQUFULEdBQWNKLElBQUlHLEVBQXBCLElBQTBCelEsQ0FBcEM7ZUFDTyxJQUFQO0tBeEZXO1dBMEZQLGlCQUFVO2VBQ1AsSUFBSW9RLE1BQUosQ0FBVyxLQUFLQyxDQUFoQixFQUFtQixLQUFLQyxDQUF4QixFQUEyQixLQUFLQyxDQUFoQyxFQUFtQyxLQUFLQyxDQUF4QyxFQUEyQyxLQUFLQyxFQUFoRCxFQUFvRCxLQUFLQyxFQUF6RCxDQUFQO0tBM0ZXO2FBNkZMLGlCQUFTaUIsU0FBVCxFQUFvQkMsR0FBcEIsRUFBd0I7WUFDMUIzTyxVQUFVbEQsTUFBVixJQUFvQixDQUF4QixFQUNBOzttQkFFVyxDQUFFLEtBQUtzUSxDQUFQLEVBQVcsS0FBS0MsQ0FBaEIsRUFBb0IsS0FBS0MsQ0FBekIsRUFBNkIsS0FBS0MsQ0FBbEMsRUFBc0MsS0FBS0MsRUFBM0MsRUFBZ0QsS0FBS0MsRUFBckQsQ0FBUDs7OztZQUlBLENBQUMsS0FBS2hRLEtBQVYsRUFDQTtpQkFDU0EsS0FBTCxHQUFhLElBQUltUixZQUFKLENBQWlCLENBQWpCLENBQWI7OztZQUdBblIsUUFBUWtSLE9BQU8sS0FBS2xSLEtBQXhCOztZQUVJaVIsU0FBSixFQUNBO2tCQUNVLENBQU4sSUFBVyxLQUFLdEIsQ0FBaEI7a0JBQ00sQ0FBTixJQUFXLEtBQUtDLENBQWhCO2tCQUNNLENBQU4sSUFBVyxDQUFYO2tCQUNNLENBQU4sSUFBVyxLQUFLQyxDQUFoQjtrQkFDTSxDQUFOLElBQVcsS0FBS0MsQ0FBaEI7a0JBQ00sQ0FBTixJQUFXLENBQVg7a0JBQ00sQ0FBTixJQUFXLEtBQUtDLEVBQWhCO2tCQUNNLENBQU4sSUFBVyxLQUFLQyxFQUFoQjtrQkFDTSxDQUFOLElBQVcsQ0FBWDtTQVZKLE1BYUE7a0JBQ1UsQ0FBTixJQUFXLEtBQUtMLENBQWhCO2tCQUNNLENBQU4sSUFBVyxLQUFLRSxDQUFoQjtrQkFDTSxDQUFOLElBQVcsS0FBS0UsRUFBaEI7a0JBQ00sQ0FBTixJQUFXLEtBQUtILENBQWhCO2tCQUNNLENBQU4sSUFBVyxLQUFLRSxDQUFoQjtrQkFDTSxDQUFOLElBQVcsS0FBS0UsRUFBaEI7a0JBQ00sQ0FBTixJQUFXLENBQVg7a0JBQ00sQ0FBTixJQUFXLENBQVg7a0JBQ00sQ0FBTixJQUFXLENBQVg7OztlQUdHaFEsS0FBUDtLQXJJVzs7OztlQTBJSCxtQkFBU29SLENBQVQsRUFBWTtZQUNoQkMsS0FBSyxLQUFLMUIsQ0FBZDtZQUFpQjJCLEtBQUssS0FBS3pCLENBQTNCO1lBQThCMEIsTUFBTSxLQUFLeEIsRUFBekM7WUFDSXlCLEtBQUssS0FBSzVCLENBQWQ7WUFBaUI2QixLQUFLLEtBQUszQixDQUEzQjtZQUE4QjRCLE1BQU0sS0FBSzFCLEVBQXpDOztZQUVJa0IsTUFBTSxDQUFDLENBQUQsRUFBRyxDQUFILENBQVY7WUFDSSxDQUFKLElBQVNFLEVBQUUsQ0FBRixJQUFPQyxFQUFQLEdBQVlELEVBQUUsQ0FBRixJQUFPRSxFQUFuQixHQUF3QkMsR0FBakM7WUFDSSxDQUFKLElBQVNILEVBQUUsQ0FBRixJQUFPSSxFQUFQLEdBQVlKLEVBQUUsQ0FBRixJQUFPSyxFQUFuQixHQUF3QkMsR0FBakM7O2VBRU9SLEdBQVA7O0NBbEpSLENBc0pBOztBQy9LQTs7Ozs7Ozs7O0FBU0MsSUFBSVMsUUFBUUEsU0FBVSxZQUFZOztLQUU3QkMsVUFBVSxFQUFkOztRQUVPOztVQUVFLGtCQUFZOztVQUVaQSxPQUFQO0dBSks7O2FBUUsscUJBQVk7O2FBRVosRUFBVjtHQVZLOztPQWNELGFBQVVDLEtBQVYsRUFBaUI7O1dBRWJuUyxJQUFSLENBQWFtUyxLQUFiO0dBaEJLOztVQW9CRSxnQkFBVUEsS0FBVixFQUFpQjs7T0FFckJ2UyxJQUFJdEIsSUFBRWMsT0FBRixDQUFXOFMsT0FBWCxFQUFxQkMsS0FBckIsQ0FBUixDQUZ5Qjs7T0FJckJ2UyxNQUFNLENBQUMsQ0FBWCxFQUFjO1lBQ0w0TyxNQUFSLENBQWU1TyxDQUFmLEVBQWtCLENBQWxCOztHQXpCSzs7VUE4QkMsZ0JBQVV3UyxJQUFWLEVBQWdCQyxRQUFoQixFQUEwQjs7T0FFN0JILFFBQVF2UyxNQUFSLEtBQW1CLENBQXZCLEVBQTBCO1dBQ2xCLEtBQVA7OztPQUdHQyxJQUFJLENBQVI7O1VBRU93UyxTQUFTL1AsU0FBVCxHQUFxQitQLElBQXJCLEdBQTRCSCxNQUFNSyxHQUFOLEVBQW5DOztVQUVPMVMsSUFBSXNTLFFBQVF2UyxNQUFuQixFQUEyQjs7Ozs7Ozs7Ozs7Ozs7UUFjVjRTLEtBQUtMLFFBQVF0UyxDQUFSLENBQVQ7UUFDSTRTLGFBQWFELEdBQUdFLE1BQUgsQ0FBVUwsSUFBVixDQUFqQjs7UUFFSSxDQUFDRixRQUFRdFMsQ0FBUixDQUFMLEVBQWlCOzs7UUFHWjJTLE9BQU9MLFFBQVF0UyxDQUFSLENBQVosRUFBeUI7U0FDbkI0UyxjQUFjSCxRQUFuQixFQUE4Qjs7TUFBOUIsTUFFTztjQUNFN0QsTUFBUixDQUFlNU8sQ0FBZixFQUFrQixDQUFsQjs7Ozs7VUFNQyxJQUFQOztFQXRFVjtDQUpvQixFQUFyQjs7OztBQW9GRCxJQUFJLE9BQVFvQyxNQUFSLEtBQW9CLFdBQXBCLElBQW1DLE9BQVEwUSxPQUFSLEtBQXFCLFdBQTVELEVBQXlFO09BQ2xFSixHQUFOLEdBQVksWUFBWTtNQUNuQkYsT0FBT00sUUFBUUMsTUFBUixFQUFYOzs7U0FHT1AsS0FBSyxDQUFMLElBQVUsSUFBVixHQUFpQkEsS0FBSyxDQUFMLElBQVUsT0FBbEM7RUFKRDs7O0tBUUksSUFBSSxPQUFRcFEsTUFBUixLQUFvQixXQUFwQixJQUNSQSxPQUFPNFEsV0FBUCxLQUF1QnZRLFNBRGYsSUFFUkwsT0FBTzRRLFdBQVAsQ0FBbUJOLEdBQW5CLEtBQTJCalEsU0FGdkIsRUFFa0M7OztRQUdoQ2lRLEdBQU4sR0FBWXRRLE9BQU80USxXQUFQLENBQW1CTixHQUFuQixDQUF1Qk8sSUFBdkIsQ0FBNEI3USxPQUFPNFEsV0FBbkMsQ0FBWjs7O01BR0ksSUFBSUUsS0FBS1IsR0FBTCxLQUFhalEsU0FBakIsRUFBNEI7U0FDMUJpUSxHQUFOLEdBQVlRLEtBQUtSLEdBQWpCOzs7T0FHSTtVQUNFQSxHQUFOLEdBQVksWUFBWTtZQUNoQixJQUFJUSxJQUFKLEdBQVdDLE9BQVgsRUFBUDtLQUREOzs7QUFNRGQsTUFBTWUsS0FBTixHQUFjLFVBQVVDLE1BQVYsRUFBa0I7O0tBRTNCQyxVQUFVRCxNQUFkO0tBQ0lFLGVBQWUsRUFBbkI7S0FDSUMsYUFBYSxFQUFqQjtLQUNJQyxxQkFBcUIsRUFBekI7S0FDSUMsWUFBWSxJQUFoQjtLQUNJQyxVQUFVLENBQWQ7S0FDSUMsZ0JBQUo7S0FDSUMsUUFBUSxLQUFaO0tBQ0lDLGFBQWEsS0FBakI7S0FDSUMsWUFBWSxLQUFoQjtLQUNJQyxhQUFhLENBQWpCO0tBQ0lDLGFBQWEsSUFBakI7S0FDSUMsa0JBQWtCN0IsTUFBTThCLE1BQU4sQ0FBYUMsTUFBYixDQUFvQkMsSUFBMUM7S0FDSUMseUJBQXlCakMsTUFBTWtDLGFBQU4sQ0FBb0JILE1BQWpEO0tBQ0lJLGlCQUFpQixFQUFyQjtLQUNJQyxtQkFBbUIsSUFBdkI7S0FDSUMsd0JBQXdCLEtBQTVCO0tBQ0lDLG9CQUFvQixJQUF4QjtLQUNJQyxzQkFBc0IsSUFBMUI7S0FDSUMsa0JBQWtCLElBQXRCOztNQUVLQyxFQUFMLEdBQVUsVUFBVUMsVUFBVixFQUFzQkMsUUFBdEIsRUFBZ0M7O2VBRTVCRCxVQUFiOztNQUVJQyxhQUFhdlMsU0FBakIsRUFBNEI7ZUFDZnVTLFFBQVo7OztTQUdNLElBQVA7RUFSRDs7TUFZS3RJLEtBQUwsR0FBYSxVQUFVOEYsSUFBVixFQUFnQjs7UUFFdEJ5QyxHQUFOLENBQVUsSUFBVjs7ZUFFYSxJQUFiOzswQkFFd0IsS0FBeEI7O2VBRWF6QyxTQUFTL1AsU0FBVCxHQUFxQitQLElBQXJCLEdBQTRCSCxNQUFNSyxHQUFOLEVBQXpDO2dCQUNjc0IsVUFBZDs7T0FFSyxJQUFJa0IsUUFBVCxJQUFxQjFCLFVBQXJCLEVBQWlDOzs7T0FHNUJBLFdBQVcwQixRQUFYLGFBQWdDclcsS0FBcEMsRUFBMkM7O1FBRXRDMlUsV0FBVzBCLFFBQVgsRUFBcUJuVixNQUFyQixLQUFnQyxDQUFwQyxFQUF1Qzs7Ozs7ZUFLNUJtVixRQUFYLElBQXVCLENBQUM1QixRQUFRNEIsUUFBUixDQUFELEVBQW9CaEUsTUFBcEIsQ0FBMkJzQyxXQUFXMEIsUUFBWCxDQUEzQixDQUF2Qjs7Ozs7T0FNRzVCLFFBQVE0QixRQUFSLE1BQXNCelMsU0FBMUIsRUFBcUM7Ozs7O2dCQUt4QnlTLFFBQWIsSUFBeUI1QixRQUFRNEIsUUFBUixDQUF6Qjs7T0FFSzNCLGFBQWEyQixRQUFiLGFBQWtDclcsS0FBbkMsS0FBOEMsS0FBbEQsRUFBeUQ7aUJBQzNDcVcsUUFBYixLQUEwQixHQUExQixDQUR3RDs7O3NCQUl0Q0EsUUFBbkIsSUFBK0IzQixhQUFhMkIsUUFBYixLQUEwQixDQUF6RDs7O1NBSU0sSUFBUDtFQTFDRDs7TUE4Q0tDLElBQUwsR0FBWSxZQUFZOztNQUVuQixDQUFDckIsVUFBTCxFQUFpQjtVQUNULElBQVA7OztRQUdLc0IsTUFBTixDQUFhLElBQWI7ZUFDYSxLQUFiOztNQUVJUCxvQkFBb0IsSUFBeEIsRUFBOEI7bUJBQ2J4VSxJQUFoQixDQUFxQmlULE9BQXJCLEVBQThCQSxPQUE5Qjs7O09BR0krQixpQkFBTDtTQUNPLElBQVA7RUFkRDs7TUFrQkt6SSxHQUFMLEdBQVcsWUFBWTs7T0FFakJpRyxNQUFMLENBQVlvQixhQUFhUCxTQUF6QjtTQUNPLElBQVA7RUFIRDs7TUFPSzJCLGlCQUFMLEdBQXlCLFlBQVk7O09BRS9CLElBQUlyVixJQUFJLENBQVIsRUFBV3NWLG1CQUFtQmQsZUFBZXpVLE1BQWxELEVBQTBEQyxJQUFJc1YsZ0JBQTlELEVBQWdGdFYsR0FBaEYsRUFBcUY7a0JBQ3JFQSxDQUFmLEVBQWtCbVYsSUFBbEI7O0VBSEY7O01BUUtJLEtBQUwsR0FBYSxVQUFVQyxNQUFWLEVBQWtCOztlQUVqQkEsTUFBYjtTQUNPLElBQVA7RUFIRDs7TUFPS0MsTUFBTCxHQUFjLFVBQVVDLEtBQVYsRUFBaUI7O1lBRXBCQSxLQUFWO1NBQ08sSUFBUDtFQUhEOztNQU9LQyxXQUFMLEdBQW1CLFVBQVVILE1BQVYsRUFBa0I7O3FCQUVqQkEsTUFBbkI7U0FDTyxJQUFQO0VBSEQ7O01BT0tJLElBQUwsR0FBWSxVQUFVQSxJQUFWLEVBQWdCOztVQUVuQkEsSUFBUjtTQUNPLElBQVA7RUFIRDs7TUFRS0MsTUFBTCxHQUFjLFVBQVVBLE1BQVYsRUFBa0I7O29CQUViQSxNQUFsQjtTQUNPLElBQVA7RUFIRDs7TUFPS0MsYUFBTCxHQUFxQixVQUFVQSxhQUFWLEVBQXlCOzsyQkFFcEJBLGFBQXpCO1NBQ08sSUFBUDtFQUhEOztNQU9LQyxLQUFMLEdBQWEsWUFBWTs7bUJBRVA5UyxTQUFqQjtTQUNPLElBQVA7RUFIRDs7TUFPSytTLE9BQUwsR0FBZSxVQUFVQyxRQUFWLEVBQW9COztxQkFFZkEsUUFBbkI7U0FDTyxJQUFQO0VBSEQ7O01BT0tDLFFBQUwsR0FBZ0IsVUFBVUQsUUFBVixFQUFvQjs7c0JBRWZBLFFBQXBCO1NBQ08sSUFBUDtFQUhEOztNQU9LRSxVQUFMLEdBQWtCLFVBQVVGLFFBQVYsRUFBb0I7O3dCQUVmQSxRQUF0QjtTQUNPLElBQVA7RUFIRDs7TUFPS0csTUFBTCxHQUFjLFVBQVVILFFBQVYsRUFBb0I7O29CQUVmQSxRQUFsQjtTQUNPLElBQVA7RUFIRDs7TUFPS3BELE1BQUwsR0FBYyxVQUFVTCxJQUFWLEVBQWdCOztNQUV6QjBDLFFBQUo7TUFDSW1CLE9BQUo7TUFDSXZWLEtBQUo7O01BRUkwUixPQUFPeUIsVUFBWCxFQUF1QjtVQUNmLElBQVA7OztNQUdHUywwQkFBMEIsS0FBOUIsRUFBcUM7O09BRWhDRCxxQkFBcUIsSUFBekIsRUFBK0I7cUJBQ2JwVSxJQUFqQixDQUFzQmlULE9BQXRCLEVBQStCQSxPQUEvQjs7OzJCQUd1QixJQUF4Qjs7O1lBR1MsQ0FBQ2QsT0FBT3lCLFVBQVIsSUFBc0JQLFNBQWhDO1lBQ1UyQyxVQUFVLENBQVYsR0FBYyxDQUFkLEdBQWtCQSxPQUE1Qjs7VUFFUW5DLGdCQUFnQm1DLE9BQWhCLENBQVI7O09BRUtuQixRQUFMLElBQWlCMUIsVUFBakIsRUFBNkI7OztPQUd4QkQsYUFBYTJCLFFBQWIsTUFBMkJ6UyxTQUEvQixFQUEwQzs7OztPQUl0Q2lLLFFBQVE2RyxhQUFhMkIsUUFBYixLQUEwQixDQUF0QztPQUNJdEksTUFBTTRHLFdBQVcwQixRQUFYLENBQVY7O09BRUl0SSxlQUFlL04sS0FBbkIsRUFBMEI7O1lBRWpCcVcsUUFBUixJQUFvQlosdUJBQXVCMUgsR0FBdkIsRUFBNEI5TCxLQUE1QixDQUFwQjtJQUZELE1BSU87OztRQUdGLE9BQVE4TCxHQUFSLEtBQWlCLFFBQXJCLEVBQStCOztTQUUxQkEsSUFBSTBKLE1BQUosQ0FBVyxDQUFYLE1BQWtCLEdBQWxCLElBQXlCMUosSUFBSTBKLE1BQUosQ0FBVyxDQUFYLE1BQWtCLEdBQS9DLEVBQW9EO1lBQzdDNUosUUFBUXJMLFdBQVd1TCxHQUFYLENBQWQ7TUFERCxNQUVPO1lBQ0F2TCxXQUFXdUwsR0FBWCxDQUFOOzs7OztRQUtFLE9BQVFBLEdBQVIsS0FBaUIsUUFBckIsRUFBK0I7YUFDdEJzSSxRQUFSLElBQW9CeEksUUFBUSxDQUFDRSxNQUFNRixLQUFQLElBQWdCNUwsS0FBNUM7Ozs7O01BT0M2VCxzQkFBc0IsSUFBMUIsRUFBZ0M7cUJBQ2J0VSxJQUFsQixDQUF1QmlULE9BQXZCLEVBQWdDeFMsS0FBaEM7OztNQUdHdVYsWUFBWSxDQUFoQixFQUFtQjs7T0FFZDFDLFVBQVUsQ0FBZCxFQUFpQjs7UUFFWnhTLFNBQVN3UyxPQUFULENBQUosRUFBdUI7Ozs7O1NBS2xCdUIsUUFBTCxJQUFpQnpCLGtCQUFqQixFQUFxQzs7U0FFaEMsT0FBUUQsV0FBVzBCLFFBQVgsQ0FBUixLQUFrQyxRQUF0QyxFQUFnRDt5QkFDNUJBLFFBQW5CLElBQStCekIsbUJBQW1CeUIsUUFBbkIsSUFBK0I3VCxXQUFXbVMsV0FBVzBCLFFBQVgsQ0FBWCxDQUE5RDs7O1NBR0dyQixLQUFKLEVBQVc7VUFDTjBDLE1BQU05QyxtQkFBbUJ5QixRQUFuQixDQUFWOzt5QkFFbUJBLFFBQW5CLElBQStCMUIsV0FBVzBCLFFBQVgsQ0FBL0I7aUJBQ1dBLFFBQVgsSUFBdUJxQixHQUF2Qjs7O2tCQUdZckIsUUFBYixJQUF5QnpCLG1CQUFtQnlCLFFBQW5CLENBQXpCOzs7UUFJR3JCLEtBQUosRUFBVztpQkFDRSxDQUFDRSxTQUFiOzs7UUFHR0gscUJBQXFCblIsU0FBekIsRUFBb0M7a0JBQ3RCK1AsT0FBT29CLGdCQUFwQjtLQURELE1BRU87a0JBQ09wQixPQUFPd0IsVUFBcEI7OztXQUdNLElBQVA7SUFsQ0QsTUFvQ087O1FBRUZZLHdCQUF3QixJQUE1QixFQUFrQzs7eUJBRWJ2VSxJQUFwQixDQUF5QmlULE9BQXpCLEVBQWtDQSxPQUFsQzs7O1NBR0ksSUFBSXRULElBQUksQ0FBUixFQUFXc1YsbUJBQW1CZCxlQUFlelUsTUFBbEQsRUFBMERDLElBQUlzVixnQkFBOUQsRUFBZ0Z0VixHQUFoRixFQUFxRjs7O29CQUdyRUEsQ0FBZixFQUFrQjBNLEtBQWxCLENBQXdCdUgsYUFBYVAsU0FBckM7OztXQUdNLEtBQVA7Ozs7U0FNSyxJQUFQO0VBeEhEO0NBaE1EOztBQStUQXJCLE1BQU04QixNQUFOLEdBQWU7O1NBRU47O1FBRUQsY0FBVXFDLENBQVYsRUFBYTs7VUFFWEEsQ0FBUDs7O0VBTlk7O1lBWUg7O01BRU4sWUFBVUEsQ0FBVixFQUFhOztVQUVUQSxJQUFJQSxDQUFYO0dBSlM7O09BUUwsYUFBVUEsQ0FBVixFQUFhOztVQUVWQSxLQUFLLElBQUlBLENBQVQsQ0FBUDtHQVZTOztTQWNILGVBQVVBLENBQVYsRUFBYTs7T0FFZixDQUFDQSxLQUFLLENBQU4sSUFBVyxDQUFmLEVBQWtCO1dBQ1YsTUFBTUEsQ0FBTixHQUFVQSxDQUFqQjs7O1VBR00sQ0FBRSxHQUFGLElBQVMsRUFBRUEsQ0FBRixJQUFPQSxJQUFJLENBQVgsSUFBZ0IsQ0FBekIsQ0FBUDs7O0VBaENZOztRQXNDUDs7TUFFRixZQUFVQSxDQUFWLEVBQWE7O1VBRVRBLElBQUlBLENBQUosR0FBUUEsQ0FBZjtHQUpLOztPQVFELGFBQVVBLENBQVYsRUFBYTs7VUFFVixFQUFFQSxDQUFGLEdBQU1BLENBQU4sR0FBVUEsQ0FBVixHQUFjLENBQXJCO0dBVks7O1NBY0MsZUFBVUEsQ0FBVixFQUFhOztPQUVmLENBQUNBLEtBQUssQ0FBTixJQUFXLENBQWYsRUFBa0I7V0FDVixNQUFNQSxDQUFOLEdBQVVBLENBQVYsR0FBY0EsQ0FBckI7OztVQUdNLE9BQU8sQ0FBQ0EsS0FBSyxDQUFOLElBQVdBLENBQVgsR0FBZUEsQ0FBZixHQUFtQixDQUExQixDQUFQOzs7RUExRFk7O1VBZ0VMOztNQUVKLFlBQVVBLENBQVYsRUFBYTs7VUFFVEEsSUFBSUEsQ0FBSixHQUFRQSxDQUFSLEdBQVlBLENBQW5CO0dBSk87O09BUUgsYUFBVUEsQ0FBVixFQUFhOztVQUVWLElBQUssRUFBRUEsQ0FBRixHQUFNQSxDQUFOLEdBQVVBLENBQVYsR0FBY0EsQ0FBMUI7R0FWTzs7U0FjRCxlQUFVQSxDQUFWLEVBQWE7O09BRWYsQ0FBQ0EsS0FBSyxDQUFOLElBQVcsQ0FBZixFQUFrQjtXQUNWLE1BQU1BLENBQU4sR0FBVUEsQ0FBVixHQUFjQSxDQUFkLEdBQWtCQSxDQUF6Qjs7O1VBR00sQ0FBRSxHQUFGLElBQVMsQ0FBQ0EsS0FBSyxDQUFOLElBQVdBLENBQVgsR0FBZUEsQ0FBZixHQUFtQkEsQ0FBbkIsR0FBdUIsQ0FBaEMsQ0FBUDs7O0VBcEZZOztVQTBGTDs7TUFFSixZQUFVQSxDQUFWLEVBQWE7O1VBRVRBLElBQUlBLENBQUosR0FBUUEsQ0FBUixHQUFZQSxDQUFaLEdBQWdCQSxDQUF2QjtHQUpPOztPQVFILGFBQVVBLENBQVYsRUFBYTs7VUFFVixFQUFFQSxDQUFGLEdBQU1BLENBQU4sR0FBVUEsQ0FBVixHQUFjQSxDQUFkLEdBQWtCQSxDQUFsQixHQUFzQixDQUE3QjtHQVZPOztTQWNELGVBQVVBLENBQVYsRUFBYTs7T0FFZixDQUFDQSxLQUFLLENBQU4sSUFBVyxDQUFmLEVBQWtCO1dBQ1YsTUFBTUEsQ0FBTixHQUFVQSxDQUFWLEdBQWNBLENBQWQsR0FBa0JBLENBQWxCLEdBQXNCQSxDQUE3Qjs7O1VBR00sT0FBTyxDQUFDQSxLQUFLLENBQU4sSUFBV0EsQ0FBWCxHQUFlQSxDQUFmLEdBQW1CQSxDQUFuQixHQUF1QkEsQ0FBdkIsR0FBMkIsQ0FBbEMsQ0FBUDs7O0VBOUdZOzthQW9IRjs7TUFFUCxZQUFVQSxDQUFWLEVBQWE7O1VBRVQsSUFBSXhVLEtBQUsrTyxHQUFMLENBQVN5RixJQUFJeFUsS0FBS2lQLEVBQVQsR0FBYyxDQUF2QixDQUFYO0dBSlU7O09BUU4sYUFBVXVGLENBQVYsRUFBYTs7VUFFVnhVLEtBQUtnUCxHQUFMLENBQVN3RixJQUFJeFUsS0FBS2lQLEVBQVQsR0FBYyxDQUF2QixDQUFQO0dBVlU7O1NBY0osZUFBVXVGLENBQVYsRUFBYTs7VUFFWixPQUFPLElBQUl4VSxLQUFLK08sR0FBTCxDQUFTL08sS0FBS2lQLEVBQUwsR0FBVXVGLENBQW5CLENBQVgsQ0FBUDs7O0VBcElZOztjQTBJRDs7TUFFUixZQUFVQSxDQUFWLEVBQWE7O1VBRVRBLE1BQU0sQ0FBTixHQUFVLENBQVYsR0FBY3hVLEtBQUt5VSxHQUFMLENBQVMsSUFBVCxFQUFlRCxJQUFJLENBQW5CLENBQXJCO0dBSlc7O09BUVAsYUFBVUEsQ0FBVixFQUFhOztVQUVWQSxNQUFNLENBQU4sR0FBVSxDQUFWLEdBQWMsSUFBSXhVLEtBQUt5VSxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUUsRUFBRixHQUFPRCxDQUFuQixDQUF6QjtHQVZXOztTQWNMLGVBQVVBLENBQVYsRUFBYTs7T0FFZkEsTUFBTSxDQUFWLEVBQWE7V0FDTCxDQUFQOzs7T0FHR0EsTUFBTSxDQUFWLEVBQWE7V0FDTCxDQUFQOzs7T0FHRyxDQUFDQSxLQUFLLENBQU4sSUFBVyxDQUFmLEVBQWtCO1dBQ1YsTUFBTXhVLEtBQUt5VSxHQUFMLENBQVMsSUFBVCxFQUFlRCxJQUFJLENBQW5CLENBQWI7OztVQUdNLE9BQU8sQ0FBRXhVLEtBQUt5VSxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUUsRUFBRixJQUFRRCxJQUFJLENBQVosQ0FBWixDQUFGLEdBQWdDLENBQXZDLENBQVA7OztFQXRLWTs7V0E0S0o7O01BRUwsWUFBVUEsQ0FBVixFQUFhOztVQUVULElBQUl4VSxLQUFLMFUsSUFBTCxDQUFVLElBQUlGLElBQUlBLENBQWxCLENBQVg7R0FKUTs7T0FRSixhQUFVQSxDQUFWLEVBQWE7O1VBRVZ4VSxLQUFLMFUsSUFBTCxDQUFVLElBQUssRUFBRUYsQ0FBRixHQUFNQSxDQUFyQixDQUFQO0dBVlE7O1NBY0YsZUFBVUEsQ0FBVixFQUFhOztPQUVmLENBQUNBLEtBQUssQ0FBTixJQUFXLENBQWYsRUFBa0I7V0FDVixDQUFFLEdBQUYsSUFBU3hVLEtBQUswVSxJQUFMLENBQVUsSUFBSUYsSUFBSUEsQ0FBbEIsSUFBdUIsQ0FBaEMsQ0FBUDs7O1VBR00sT0FBT3hVLEtBQUswVSxJQUFMLENBQVUsSUFBSSxDQUFDRixLQUFLLENBQU4sSUFBV0EsQ0FBekIsSUFBOEIsQ0FBckMsQ0FBUDs7O0VBaE1ZOztVQXNNTDs7TUFFSixZQUFVQSxDQUFWLEVBQWE7O09BRVpBLE1BQU0sQ0FBVixFQUFhO1dBQ0wsQ0FBUDs7O09BR0dBLE1BQU0sQ0FBVixFQUFhO1dBQ0wsQ0FBUDs7O1VBR00sQ0FBQ3hVLEtBQUt5VSxHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU1ELElBQUksQ0FBVixDQUFaLENBQUQsR0FBNkJ4VSxLQUFLZ1AsR0FBTCxDQUFTLENBQUN3RixJQUFJLEdBQUwsSUFBWSxDQUFaLEdBQWdCeFUsS0FBS2lQLEVBQTlCLENBQXBDO0dBWk87O09BZ0JILGFBQVV1RixDQUFWLEVBQWE7O09BRWJBLE1BQU0sQ0FBVixFQUFhO1dBQ0wsQ0FBUDs7O09BR0dBLE1BQU0sQ0FBVixFQUFhO1dBQ0wsQ0FBUDs7O1VBR014VSxLQUFLeVUsR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEVBQUQsR0FBTUQsQ0FBbEIsSUFBdUJ4VSxLQUFLZ1AsR0FBTCxDQUFTLENBQUN3RixJQUFJLEdBQUwsSUFBWSxDQUFaLEdBQWdCeFUsS0FBS2lQLEVBQTlCLENBQXZCLEdBQTJELENBQWxFO0dBMUJPOztTQThCRCxlQUFVdUYsQ0FBVixFQUFhOztPQUVmQSxNQUFNLENBQVYsRUFBYTtXQUNMLENBQVA7OztPQUdHQSxNQUFNLENBQVYsRUFBYTtXQUNMLENBQVA7OztRQUdJLENBQUw7O09BRUlBLElBQUksQ0FBUixFQUFXO1dBQ0gsQ0FBQyxHQUFELEdBQU94VSxLQUFLeVUsR0FBTCxDQUFTLENBQVQsRUFBWSxNQUFNRCxJQUFJLENBQVYsQ0FBWixDQUFQLEdBQW1DeFUsS0FBS2dQLEdBQUwsQ0FBUyxDQUFDd0YsSUFBSSxHQUFMLElBQVksQ0FBWixHQUFnQnhVLEtBQUtpUCxFQUE5QixDQUExQzs7O1VBR00sTUFBTWpQLEtBQUt5VSxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBRCxJQUFPRCxJQUFJLENBQVgsQ0FBWixDQUFOLEdBQW1DeFUsS0FBS2dQLEdBQUwsQ0FBUyxDQUFDd0YsSUFBSSxHQUFMLElBQVksQ0FBWixHQUFnQnhVLEtBQUtpUCxFQUE5QixDQUFuQyxHQUF1RSxDQUE5RTs7O0VBcFBZOztPQTBQUjs7TUFFRCxZQUFVdUYsQ0FBVixFQUFhOztPQUVaclMsSUFBSSxPQUFSOztVQUVPcVMsSUFBSUEsQ0FBSixJQUFTLENBQUNyUyxJQUFJLENBQUwsSUFBVXFTLENBQVYsR0FBY3JTLENBQXZCLENBQVA7R0FOSTs7T0FVQSxhQUFVcVMsQ0FBVixFQUFhOztPQUViclMsSUFBSSxPQUFSOztVQUVPLEVBQUVxUyxDQUFGLEdBQU1BLENBQU4sSUFBVyxDQUFDclMsSUFBSSxDQUFMLElBQVVxUyxDQUFWLEdBQWNyUyxDQUF6QixJQUE4QixDQUFyQztHQWRJOztTQWtCRSxlQUFVcVMsQ0FBVixFQUFhOztPQUVmclMsSUFBSSxVQUFVLEtBQWxCOztPQUVJLENBQUNxUyxLQUFLLENBQU4sSUFBVyxDQUFmLEVBQWtCO1dBQ1YsT0FBT0EsSUFBSUEsQ0FBSixJQUFTLENBQUNyUyxJQUFJLENBQUwsSUFBVXFTLENBQVYsR0FBY3JTLENBQXZCLENBQVAsQ0FBUDs7O1VBR00sT0FBTyxDQUFDcVMsS0FBSyxDQUFOLElBQVdBLENBQVgsSUFBZ0IsQ0FBQ3JTLElBQUksQ0FBTCxJQUFVcVMsQ0FBVixHQUFjclMsQ0FBOUIsSUFBbUMsQ0FBMUMsQ0FBUDs7O0VBcFJZOztTQTBSTjs7TUFFSCxZQUFVcVMsQ0FBVixFQUFhOztVQUVULElBQUluRSxNQUFNOEIsTUFBTixDQUFhd0MsTUFBYixDQUFvQkMsR0FBcEIsQ0FBd0IsSUFBSUosQ0FBNUIsQ0FBWDtHQUpNOztPQVFGLGFBQVVBLENBQVYsRUFBYTs7T0FFYkEsSUFBSyxJQUFJLElBQWIsRUFBb0I7V0FDWixTQUFTQSxDQUFULEdBQWFBLENBQXBCO0lBREQsTUFFTyxJQUFJQSxJQUFLLElBQUksSUFBYixFQUFvQjtXQUNuQixVQUFVQSxLQUFNLE1BQU0sSUFBdEIsSUFBK0JBLENBQS9CLEdBQW1DLElBQTFDO0lBRE0sTUFFQSxJQUFJQSxJQUFLLE1BQU0sSUFBZixFQUFzQjtXQUNyQixVQUFVQSxLQUFNLE9BQU8sSUFBdkIsSUFBZ0NBLENBQWhDLEdBQW9DLE1BQTNDO0lBRE0sTUFFQTtXQUNDLFVBQVVBLEtBQU0sUUFBUSxJQUF4QixJQUFpQ0EsQ0FBakMsR0FBcUMsUUFBNUM7O0dBakJLOztTQXNCQSxlQUFVQSxDQUFWLEVBQWE7O09BRWZBLElBQUksR0FBUixFQUFhO1dBQ0xuRSxNQUFNOEIsTUFBTixDQUFhd0MsTUFBYixDQUFvQkUsRUFBcEIsQ0FBdUJMLElBQUksQ0FBM0IsSUFBZ0MsR0FBdkM7OztVQUdNbkUsTUFBTThCLE1BQU4sQ0FBYXdDLE1BQWIsQ0FBb0JDLEdBQXBCLENBQXdCSixJQUFJLENBQUosR0FBUSxDQUFoQyxJQUFxQyxHQUFyQyxHQUEyQyxHQUFsRDs7Ozs7Q0F0VEg7O0FBOFRBbkUsTUFBTWtDLGFBQU4sR0FBc0I7O1NBRWIsZ0JBQVV6QyxDQUFWLEVBQWEwRSxDQUFiLEVBQWdCOztNQUVuQk0sSUFBSWhGLEVBQUUvUixNQUFGLEdBQVcsQ0FBbkI7TUFDSWdYLElBQUlELElBQUlOLENBQVo7TUFDSXhXLElBQUlnQyxLQUFLZ1YsS0FBTCxDQUFXRCxDQUFYLENBQVI7TUFDSXRRLEtBQUs0TCxNQUFNa0MsYUFBTixDQUFvQm5SLEtBQXBCLENBQTBCZ1IsTUFBbkM7O01BRUlvQyxJQUFJLENBQVIsRUFBVztVQUNIL1AsR0FBR3FMLEVBQUUsQ0FBRixDQUFILEVBQVNBLEVBQUUsQ0FBRixDQUFULEVBQWVpRixDQUFmLENBQVA7OztNQUdHUCxJQUFJLENBQVIsRUFBVztVQUNIL1AsR0FBR3FMLEVBQUVnRixDQUFGLENBQUgsRUFBU2hGLEVBQUVnRixJQUFJLENBQU4sQ0FBVCxFQUFtQkEsSUFBSUMsQ0FBdkIsQ0FBUDs7O1NBR010USxHQUFHcUwsRUFBRTlSLENBQUYsQ0FBSCxFQUFTOFIsRUFBRTlSLElBQUksQ0FBSixHQUFROFcsQ0FBUixHQUFZQSxDQUFaLEdBQWdCOVcsSUFBSSxDQUF0QixDQUFULEVBQW1DK1csSUFBSS9XLENBQXZDLENBQVA7RUFqQm9COztTQXFCYixnQkFBVThSLENBQVYsRUFBYTBFLENBQWIsRUFBZ0I7O01BRW5CbEcsSUFBSSxDQUFSO01BQ0kyRyxJQUFJbkYsRUFBRS9SLE1BQUYsR0FBVyxDQUFuQjtNQUNJbVgsS0FBS2xWLEtBQUt5VSxHQUFkO01BQ0lVLEtBQUs5RSxNQUFNa0MsYUFBTixDQUFvQm5SLEtBQXBCLENBQTBCZ1UsU0FBbkM7O09BRUssSUFBSXBYLElBQUksQ0FBYixFQUFnQkEsS0FBS2lYLENBQXJCLEVBQXdCalgsR0FBeEIsRUFBNkI7UUFDdkJrWCxHQUFHLElBQUlWLENBQVAsRUFBVVMsSUFBSWpYLENBQWQsSUFBbUJrWCxHQUFHVixDQUFILEVBQU14VyxDQUFOLENBQW5CLEdBQThCOFIsRUFBRTlSLENBQUYsQ0FBOUIsR0FBcUNtWCxHQUFHRixDQUFILEVBQU1qWCxDQUFOLENBQTFDOzs7U0FHTXNRLENBQVA7RUFoQ29COzthQW9DVCxvQkFBVXdCLENBQVYsRUFBYTBFLENBQWIsRUFBZ0I7O01BRXZCTSxJQUFJaEYsRUFBRS9SLE1BQUYsR0FBVyxDQUFuQjtNQUNJZ1gsSUFBSUQsSUFBSU4sQ0FBWjtNQUNJeFcsSUFBSWdDLEtBQUtnVixLQUFMLENBQVdELENBQVgsQ0FBUjtNQUNJdFEsS0FBSzRMLE1BQU1rQyxhQUFOLENBQW9CblIsS0FBcEIsQ0FBMEJpVSxVQUFuQzs7TUFFSXZGLEVBQUUsQ0FBRixNQUFTQSxFQUFFZ0YsQ0FBRixDQUFiLEVBQW1COztPQUVkTixJQUFJLENBQVIsRUFBVztRQUNOeFUsS0FBS2dWLEtBQUwsQ0FBV0QsSUFBSUQsS0FBSyxJQUFJTixDQUFULENBQWYsQ0FBSjs7O1VBR00vUCxHQUFHcUwsRUFBRSxDQUFDOVIsSUFBSSxDQUFKLEdBQVE4VyxDQUFULElBQWNBLENBQWhCLENBQUgsRUFBdUJoRixFQUFFOVIsQ0FBRixDQUF2QixFQUE2QjhSLEVBQUUsQ0FBQzlSLElBQUksQ0FBTCxJQUFVOFcsQ0FBWixDQUE3QixFQUE2Q2hGLEVBQUUsQ0FBQzlSLElBQUksQ0FBTCxJQUFVOFcsQ0FBWixDQUE3QyxFQUE2REMsSUFBSS9XLENBQWpFLENBQVA7R0FORCxNQVFPOztPQUVGd1csSUFBSSxDQUFSLEVBQVc7V0FDSDFFLEVBQUUsQ0FBRixLQUFRckwsR0FBR3FMLEVBQUUsQ0FBRixDQUFILEVBQVNBLEVBQUUsQ0FBRixDQUFULEVBQWVBLEVBQUUsQ0FBRixDQUFmLEVBQXFCQSxFQUFFLENBQUYsQ0FBckIsRUFBMkIsQ0FBQ2lGLENBQTVCLElBQWlDakYsRUFBRSxDQUFGLENBQXpDLENBQVA7OztPQUdHMEUsSUFBSSxDQUFSLEVBQVc7V0FDSDFFLEVBQUVnRixDQUFGLEtBQVFyUSxHQUFHcUwsRUFBRWdGLENBQUYsQ0FBSCxFQUFTaEYsRUFBRWdGLENBQUYsQ0FBVCxFQUFlaEYsRUFBRWdGLElBQUksQ0FBTixDQUFmLEVBQXlCaEYsRUFBRWdGLElBQUksQ0FBTixDQUF6QixFQUFtQ0MsSUFBSUQsQ0FBdkMsSUFBNENoRixFQUFFZ0YsQ0FBRixDQUFwRCxDQUFQOzs7VUFHTXJRLEdBQUdxTCxFQUFFOVIsSUFBSUEsSUFBSSxDQUFSLEdBQVksQ0FBZCxDQUFILEVBQXFCOFIsRUFBRTlSLENBQUYsQ0FBckIsRUFBMkI4UixFQUFFZ0YsSUFBSTlXLElBQUksQ0FBUixHQUFZOFcsQ0FBWixHQUFnQjlXLElBQUksQ0FBdEIsQ0FBM0IsRUFBcUQ4UixFQUFFZ0YsSUFBSTlXLElBQUksQ0FBUixHQUFZOFcsQ0FBWixHQUFnQjlXLElBQUksQ0FBdEIsQ0FBckQsRUFBK0UrVyxJQUFJL1csQ0FBbkYsQ0FBUDs7RUE3RG1COztRQW1FZDs7VUFFRSxnQkFBVXNYLEVBQVYsRUFBY0MsRUFBZCxFQUFrQkMsQ0FBbEIsRUFBcUI7O1VBRXJCLENBQUNELEtBQUtELEVBQU4sSUFBWUUsQ0FBWixHQUFnQkYsRUFBdkI7R0FKSzs7YUFRSyxtQkFBVUwsQ0FBVixFQUFhalgsQ0FBYixFQUFnQjs7T0FFdEJ5WCxLQUFLcEYsTUFBTWtDLGFBQU4sQ0FBb0JuUixLQUFwQixDQUEwQnNVLFNBQW5DOztVQUVPRCxHQUFHUixDQUFILElBQVFRLEdBQUd6WCxDQUFILENBQVIsR0FBZ0J5WCxHQUFHUixJQUFJalgsQ0FBUCxDQUF2QjtHQVpLOzthQWdCTSxZQUFZOztPQUVuQnFRLElBQUksQ0FBQyxDQUFELENBQVI7O1VBRU8sVUFBVTRHLENBQVYsRUFBYTs7UUFFZjlTLElBQUksQ0FBUjs7UUFFSWtNLEVBQUU0RyxDQUFGLENBQUosRUFBVTtZQUNGNUcsRUFBRTRHLENBQUYsQ0FBUDs7O1NBR0ksSUFBSWpYLElBQUlpWCxDQUFiLEVBQWdCalgsSUFBSSxDQUFwQixFQUF1QkEsR0FBdkIsRUFBNEI7VUFDdEJBLENBQUw7OztNQUdDaVgsQ0FBRixJQUFPOVMsQ0FBUDtXQUNPQSxDQUFQO0lBYkQ7R0FKVSxFQWhCTDs7Y0F1Q00sb0JBQVVtVCxFQUFWLEVBQWNDLEVBQWQsRUFBa0JJLEVBQWxCLEVBQXNCQyxFQUF0QixFQUEwQkosQ0FBMUIsRUFBNkI7O09BRXBDSyxLQUFLLENBQUNGLEtBQUtMLEVBQU4sSUFBWSxHQUFyQjtPQUNJUSxLQUFLLENBQUNGLEtBQUtMLEVBQU4sSUFBWSxHQUFyQjtPQUNJUSxLQUFLUCxJQUFJQSxDQUFiO09BQ0lRLEtBQUtSLElBQUlPLEVBQWI7O1VBRU8sQ0FBQyxJQUFJUixFQUFKLEdBQVMsSUFBSUksRUFBYixHQUFrQkUsRUFBbEIsR0FBdUJDLEVBQXhCLElBQThCRSxFQUE5QixHQUFtQyxDQUFDLENBQUUsQ0FBRixHQUFNVCxFQUFOLEdBQVcsSUFBSUksRUFBZixHQUFvQixJQUFJRSxFQUF4QixHQUE2QkMsRUFBOUIsSUFBb0NDLEVBQXZFLEdBQTRFRixLQUFLTCxDQUFqRixHQUFxRkQsRUFBNUY7Ozs7O0NBakhILENBeUhBOztBQzcyQkE7OztBQUdBLElBQUlVLFdBQVcsQ0FBZjtBQUNBLElBQUlDLFVBQVUsQ0FBQyxJQUFELEVBQU8sS0FBUCxFQUFjLFFBQWQsRUFBd0IsR0FBeEIsQ0FBZDtBQUNBLEtBQUssSUFBSTNTLElBQUksQ0FBYixFQUFnQkEsSUFBSTJTLFFBQVFuWSxNQUFaLElBQXNCLENBQUNxQyxPQUFPK1YscUJBQTlDLEVBQXFFLEVBQUU1UyxDQUF2RSxFQUEwRTtXQUMvRDRTLHFCQUFQLEdBQStCL1YsT0FBTzhWLFFBQVEzUyxDQUFSLElBQWEsdUJBQXBCLENBQS9CO1dBQ082UyxvQkFBUCxHQUE4QmhXLE9BQU84VixRQUFRM1MsQ0FBUixJQUFhLHNCQUFwQixLQUErQ25ELE9BQU84VixRQUFRM1MsQ0FBUixJQUFhLDZCQUFwQixDQUE3RTs7QUFFSixJQUFJLENBQUNuRCxPQUFPK1YscUJBQVosRUFBbUM7V0FDeEJBLHFCQUFQLEdBQStCLFVBQVNsQyxRQUFULEVBQW1Cb0MsT0FBbkIsRUFBNEI7WUFDbkRDLFdBQVcsSUFBSXBGLElBQUosR0FBV0MsT0FBWCxFQUFmO1lBQ0lvRixhQUFhdlcsS0FBS0MsR0FBTCxDQUFTLENBQVQsRUFBWSxNQUFNcVcsV0FBV0wsUUFBakIsQ0FBWixDQUFqQjtZQUNJM1AsS0FBS2xHLE9BQU9vVyxVQUFQLENBQWtCLFlBQVc7cUJBQ3JCRixXQUFXQyxVQUFwQjtTQURDLEVBR0xBLFVBSEssQ0FBVDttQkFJV0QsV0FBV0MsVUFBdEI7ZUFDT2pRLEVBQVA7S0FSSjs7QUFXSixJQUFJLENBQUNsRyxPQUFPZ1csb0JBQVosRUFBa0M7V0FDdkJBLG9CQUFQLEdBQThCLFVBQVM5UCxFQUFULEVBQWE7cUJBQzFCQSxFQUFiO0tBREo7Ozs7QUFNSixJQUFJbVEsWUFBWSxFQUFoQjtBQUNBLElBQUlDLGNBQWMsSUFBbEI7O0FBRUEsU0FBU0MscUJBQVQsR0FBZ0M7UUFDeEIsQ0FBQ0QsV0FBTCxFQUFrQjtzQkFDQVAsc0JBQXNCLFlBQVc7OztrQkFHckN0RixNQUFOLEdBSDJDOztnQkFLdkMrRixlQUFlSCxTQUFuQjt3QkFDWSxFQUFaOzBCQUNjLElBQWQ7bUJBQ09HLGFBQWE3WSxNQUFiLEdBQXNCLENBQTdCLEVBQWdDOzZCQUNmOFksS0FBYixHQUFxQkMsSUFBckI7O1NBVE0sQ0FBZDs7V0FhR0osV0FBUDs7Ozs7OztBQU9KLFNBQVNLLFdBQVQsQ0FBc0JDLE1BQXRCLEVBQStCO1FBQ3ZCLENBQUNBLE1BQUwsRUFBYTs7O2NBR0g1WSxJQUFWLENBQWU0WSxNQUFmO1dBQ09MLHVCQUFQOzs7Ozs7QUFNSixTQUFTTSxZQUFULENBQXVCRCxNQUF2QixFQUFnQztRQUN4QkUsV0FBVyxLQUFmO1NBQ0ssSUFBSWxaLElBQUksQ0FBUixFQUFXbVosSUFBSVYsVUFBVTFZLE1BQTlCLEVBQXNDQyxJQUFJbVosQ0FBMUMsRUFBNkNuWixHQUE3QyxFQUFrRDtZQUMxQ3lZLFVBQVV6WSxDQUFWLEVBQWFzSSxFQUFiLEtBQW9CMFEsT0FBTzFRLEVBQS9CLEVBQW1DO3VCQUNwQixJQUFYO3NCQUNVc0csTUFBVixDQUFpQjVPLENBQWpCLEVBQW9CLENBQXBCOzs7OztRQUtKeVksVUFBVTFZLE1BQVYsSUFBb0IsQ0FBeEIsRUFBMkI7NkJBQ0YyWSxXQUFyQjtzQkFDYyxJQUFkOztXQUVHUSxRQUFQOzs7Ozs7O0FBUUosU0FBU0UsV0FBVCxDQUFxQnpXLE9BQXJCLEVBQThCO1FBQ3RCaUMsTUFBTWxHLElBQUVnRSxNQUFGLENBQVM7Y0FDVCxJQURTO1lBRVgsSUFGVztrQkFHTCxHQUhLO2lCQUlOLG1CQUFVLEVBSko7a0JBS0wsb0JBQVcsRUFMTjtvQkFNSCxzQkFBVyxFQU5SO2dCQU9QLGtCQUFVLEVBUEg7Z0JBUVAsQ0FSTztlQVNSLENBVFE7Z0JBVVAsYUFWTztjQVdULEVBWFM7S0FBVCxFQVlQQyxPQVpPLENBQVY7O1FBY0k0UCxRQUFRLEVBQVo7UUFDSThHLE1BQU0sV0FBV2pXLE1BQU1LLE1BQU4sRUFBckI7UUFDSTZFLEVBQUosS0FBWStRLE1BQU1BLE1BQUksR0FBSixHQUFRelUsSUFBSTBELEVBQTlCOztRQUVJMUQsSUFBSTBVLElBQUosSUFBWTFVLElBQUlrUSxFQUFwQixFQUF3Qjs7Z0JBOEJYeUUsT0E5QlcsR0E4QnBCLFNBQVNBLE9BQVQsR0FBbUI7O29CQUVWaEgsTUFBTWlILGFBQU4sSUFBdUJqSCxNQUFNa0gsU0FBbEMsRUFBOEM7NEJBQ2xDLElBQVI7Ozs0QkFHUTt3QkFDSkosR0FESTswQkFFRkUsT0FGRTswQkFHRjNVLElBQUk4VSxJQUhGOzJCQUlEbkg7aUJBSlg7YUFwQ2dCOztvQkFDWixJQUFJYSxNQUFNQSxLQUFWLENBQWlCeE8sSUFBSTBVLElBQXJCLEVBQ1B4RSxFQURPLENBQ0hsUSxJQUFJa1EsRUFERCxFQUNLbFEsSUFBSW9RLFFBRFQsRUFFUGdCLE9BRk8sQ0FFQyxZQUFVO29CQUNYQSxPQUFKLENBQVk5RixLQUFaLENBQW1CLElBQW5CO2FBSEksRUFLUGdHLFFBTE8sQ0FLRyxZQUFVO29CQUNiQSxRQUFKLENBQWFoRyxLQUFiLENBQW9CLElBQXBCO2FBTkksRUFRUGlHLFVBUk8sQ0FRSyxZQUFXOzZCQUNQO3dCQUNMa0Q7aUJBRFI7c0JBR01HLGFBQU4sR0FBc0IsSUFBdEI7b0JBQ0lyRCxVQUFKLENBQWVqRyxLQUFmLENBQXNCLElBQXRCLEVBQTZCLENBQUMsSUFBRCxDQUE3QixFQUxvQjthQVJoQixFQWVQa0csTUFmTyxDQWVDLFlBQVU7NkJBQ0Y7d0JBQ0xpRDtpQkFEUjtzQkFHTUksU0FBTixHQUFrQixJQUFsQjtvQkFDSXJELE1BQUosQ0FBV2xHLEtBQVgsQ0FBa0IsSUFBbEIsRUFBeUIsQ0FBQyxJQUFELENBQXpCO2FBcEJJLEVBc0JQdUYsTUF0Qk8sQ0FzQkM3USxJQUFJNlEsTUF0QkwsRUF1QlBGLEtBdkJPLENBdUJBM1EsSUFBSTJRLEtBdkJKLEVBd0JQTSxNQXhCTyxDQXdCQ3pDLE1BQU1lLE1BQU4sQ0FBYXZQLElBQUlpUixNQUFKLENBQVd0SCxLQUFYLENBQWlCLEdBQWpCLEVBQXNCLENBQXRCLENBQWIsRUFBdUMzSixJQUFJaVIsTUFBSixDQUFXdEgsS0FBWCxDQUFpQixHQUFqQixFQUFzQixDQUF0QixDQUF2QyxDQXhCRCxDQUFSOztrQkEwQk1qRyxFQUFOLEdBQVcrUSxHQUFYO2tCQUNNM00sS0FBTjs7Ozs7O1dBa0JHNkYsS0FBUDs7Ozs7O0FBTUosU0FBU29ILFlBQVQsQ0FBc0JwSCxLQUF0QixFQUE4QnFILEdBQTlCLEVBQW1DO1VBQ3pCekUsSUFBTjs7O0FBR0oscUJBQWU7aUJBQ0U0RCxXQURGO2tCQUVHRSxZQUZIO2lCQUdFRyxXQUhGO2tCQUlHTztDQUpsQjs7QUNyS0E7Ozs7Ozs7O0FBUUEsQUFFQTtBQUNBLElBQUlFLGFBQWE7a0JBQ0UsQ0FERjtjQUVFLENBRkY7YUFHRSxDQUhGO2NBSUUsQ0FKRjtpQkFLRSxDQUxGO2NBTUUsQ0FORjs7ZUFRRSxDQVJGO0NBQWpCOztBQVdBLFNBQVNDLE9BQVQsQ0FBaUJDLEtBQWpCLEVBQXdCQyxLQUF4QixFQUErQkMsU0FBL0IsRUFBMEM7O1FBRWxDQyxtQkFBaUIsSUFBckI7O1FBRUlDLFlBQVlKLE1BQU1LLFVBQXRCOzthQUNhLEVBRGI7O2lCQUVpQixFQUZqQjs7Z0JBR2dCMWIsSUFBRWtCLElBQUYsQ0FBUWlhLFVBQVIsQ0FIaEIsQ0FKc0M7O1lBUzFCRyxTQUFTLEVBQWpCLENBVGtDO2dCQVV0QkMsYUFBYSxFQUF6QixDQVZrQztnQkFXdEJ2YixJQUFFZ0IsT0FBRixDQUFVeWEsU0FBVixJQUF1QkEsVUFBVWpKLE1BQVYsQ0FBaUJtSixTQUFqQixDQUF2QixHQUFxREEsU0FBakU7O2FBRUtDLElBQVQsQ0FBY3JaLElBQWQsRUFBb0JzWixHQUFwQixFQUF5QjtZQUNoQixDQUFDVixXQUFXNVksSUFBWCxDQUFELElBQXNCNFksV0FBVzVZLElBQVgsS0FBb0JBLEtBQUtxVixNQUFMLENBQVksQ0FBWixNQUFtQixHQUFsRSxFQUF5RTtrQkFDL0RyVixJQUFOLElBQWNzWixHQUFkOztZQUVBQyxtQkFBbUJELEdBQW5CLHlDQUFtQkEsR0FBbkIsQ0FBSjtZQUNJQyxjQUFjLFVBQWxCLEVBQThCO2dCQUN2QixDQUFDWCxXQUFXNVksSUFBWCxDQUFKLEVBQXFCOzBCQUNUYixJQUFWLENBQWVhLElBQWYsRUFEbUI7O1NBRHpCLE1BSU87Z0JBQ0N2QyxJQUFFYyxPQUFGLENBQVUyYSxTQUFWLEVBQW9CbFosSUFBcEIsTUFBOEIsQ0FBQyxDQUEvQixJQUFxQ0EsS0FBS3FWLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLElBQTBCLENBQUMyRCxVQUFVaFosSUFBVixDQUFwRSxFQUFzRjt1QkFDM0VvWixVQUFVamEsSUFBVixDQUFlYSxJQUFmLENBQVA7O2dCQUVBd1osV0FBVyxTQUFYQSxRQUFXLENBQVNDLEdBQVQsRUFBYzs7b0JBQ3JCNVosUUFBUTJaLFNBQVMzWixLQUFyQjtvQkFBNEI2WixXQUFXN1osS0FBdkM7b0JBQThDOFosWUFBOUM7O29CQUVJM1gsVUFBVWxELE1BQWQsRUFBc0I7Ozt3QkFHZDhhLGlCQUFpQkgsR0FBakIseUNBQWlCQSxHQUFqQixDQUFKOzt3QkFFSVIsZ0JBQUosRUFBc0I7K0JBQUE7O3dCQUdsQnBaLFVBQVU0WixHQUFkLEVBQW1COzRCQUNYQSxPQUFPRyxZQUFZLFFBQW5CLElBQ0EsRUFBRUgsZUFBZTdiLEtBQWpCLENBREEsSUFFQSxDQUFDNmIsSUFBSUksWUFGVDswQkFHRTt3Q0FDVUosSUFBSUssTUFBSixHQUFhTCxHQUFiLEdBQW1CWixRQUFRWSxHQUFSLEVBQWNBLEdBQWQsQ0FBM0I7K0NBQ2U1WixNQUFNaWEsTUFBckI7NkJBTEosTUFNTzs7Ozs7b0NBSVNMLEdBQVI7OztpQ0FHQzVaLEtBQVQsR0FBaUJBLEtBQWpCOzhCQUNNRyxJQUFOLElBQWMyWixlQUFlQSxZQUFmLEdBQThCOVosS0FBNUMsQ0FmZTs0QkFnQlgsQ0FBQzhaLFlBQUwsRUFBbUI7bUNBQ1JJLEtBQVAsSUFBZ0JDLE9BQU9ELEtBQVAsQ0FBYS9aLElBQWIsRUFBbUJILEtBQW5CLEVBQTBCNlosUUFBMUIsQ0FBaEI7OzRCQUVESCxhQUFhSyxPQUFoQixFQUF3Qjs7O3dDQUdSQSxPQUFaOzs0QkFFQUssZ0JBQWdCRCxNQUFwQjs7NEJBRUssQ0FBQ0EsT0FBT0UsTUFBYixFQUFzQjttQ0FDYkQsY0FBY0UsT0FBckIsRUFBOEI7Z0RBQ1hGLGNBQWNFLE9BQTlCOzs7NEJBR0FGLGNBQWNDLE1BQW5CLEVBQTRCOzBDQUNaQSxNQUFkLENBQXFCOWEsSUFBckIsQ0FBMEI2YSxhQUExQixFQUEwQ2phLElBQTFDLEVBQWdESCxLQUFoRCxFQUF1RDZaLFFBQXZEOzs7aUJBeENWLE1BMkNPOzs7O3dCQUlFN1osU0FBVTBaLGNBQWMsUUFBeEIsSUFDQyxFQUFFMVosaUJBQWlCakMsS0FBbkIsQ0FERCxJQUVDLENBQUNpQyxNQUFNaWEsTUFGUixJQUdDLENBQUNqYSxNQUFNZ2EsWUFIYixFQUcyQjs7OEJBRWpCTSxPQUFOLEdBQWdCSCxNQUFoQjtnQ0FDUW5CLFFBQVFoWixLQUFSLEVBQWdCQSxLQUFoQixDQUFSOzs7aUNBR1NBLEtBQVQsR0FBaUJBLEtBQWpCOzsyQkFFR0EsS0FBUDs7YUE3RFI7cUJBZ0VTQSxLQUFULEdBQWlCeVosR0FBakI7O3VCQUVXdFosSUFBWCxJQUFtQjtxQkFDVndaLFFBRFU7cUJBRVZBLFFBRlU7NEJBR0g7YUFIaEI7Ozs7U0FRSCxJQUFJemEsQ0FBVCxJQUFjK1osS0FBZCxFQUFxQjthQUNaL1osQ0FBTCxFQUFRK1osTUFBTS9aLENBQU4sQ0FBUjs7O2FBR0txYixpQkFBaUJKLE1BQWpCLEVBQXlCSyxVQUF6QixFQUFxQ2pCLFNBQXJDLENBQVQsQ0F4R3NDOztRQTBHcENqYixPQUFGLENBQVVpYixTQUFWLEVBQW9CLFVBQVNwWixJQUFULEVBQWU7WUFDM0I4WSxNQUFNOVksSUFBTixDQUFKLEVBQWlCOztnQkFDVixPQUFPOFksTUFBTTlZLElBQU4sQ0FBUCxJQUFzQixVQUF6QixFQUFxQzt1QkFDM0JBLElBQVAsSUFBZSxZQUFVOzBCQUNoQkEsSUFBTixFQUFZaVAsS0FBWixDQUFrQixJQUFsQixFQUF5QmpOLFNBQXpCO2lCQURIO2FBREgsTUFJTzt1QkFDR2hDLElBQVAsSUFBZThZLE1BQU05WSxJQUFOLENBQWY7OztLQVBYOztXQVlPOFosTUFBUCxHQUFnQmYsS0FBaEI7V0FDT3VCLFNBQVAsR0FBbUJELFVBQW5COztXQUVPcGMsY0FBUCxHQUF3QixVQUFTK0IsSUFBVCxFQUFlO2VBQzVCQSxRQUFRZ2EsT0FBT0YsTUFBdEI7S0FESjs7dUJBSW1CLEtBQW5COztXQUVPRSxNQUFQOztBQUVKLElBQUlPLG1CQUFpQnhjLE9BQU93YyxjQUE1Qjs7O0FBR0ksSUFBSTtxQkFDZSxFQUFmLEVBQW1CLEdBQW5CLEVBQXdCO2VBQ2I7S0FEWDtRQUdJSCxtQkFBbUJyYyxPQUFPcWMsZ0JBQTlCO0NBSkosQ0FLRSxPQUFPN1ksQ0FBUCxFQUFVO1FBQ0osc0JBQXNCeEQsTUFBMUIsRUFBa0M7MkJBQ2IsMkJBQVNjLEdBQVQsRUFBYzJiLElBQWQsRUFBb0IvQixJQUFwQixFQUEwQjtnQkFDbkMsV0FBV0EsSUFBZixFQUFxQjtvQkFDYitCLElBQUosSUFBWS9CLEtBQUs1WSxLQUFqQjs7Z0JBRUEsU0FBUzRZLElBQWIsRUFBbUI7b0JBQ1hnQyxnQkFBSixDQUFxQkQsSUFBckIsRUFBMkIvQixLQUFLaUMsR0FBaEM7O2dCQUVBLFNBQVNqQyxJQUFiLEVBQW1CO29CQUNYa0MsZ0JBQUosQ0FBcUJILElBQXJCLEVBQTJCL0IsS0FBS21DLEdBQWhDOzttQkFFRy9iLEdBQVA7U0FWSjsyQkFZbUIsMEJBQVNBLEdBQVQsRUFBY2djLEtBQWQsRUFBcUI7aUJBQy9CLElBQUlMLElBQVQsSUFBaUJLLEtBQWpCLEVBQXdCO29CQUNoQkEsTUFBTTVjLGNBQU4sQ0FBcUJ1YyxJQUFyQixDQUFKLEVBQWdDO3FDQUNiM2IsR0FBZixFQUFvQjJiLElBQXBCLEVBQTBCSyxNQUFNTCxJQUFOLENBQTFCOzs7bUJBR0QzYixHQUFQO1NBTko7Ozs7QUFXWixJQUFJLENBQUN1YixnQkFBRCxJQUFxQmpaLE9BQU8yWixPQUFoQyxFQUF5Qzs7WUFPNUJDLFVBUDRCLEdBT3JDLFNBQVNBLFVBQVQsQ0FBb0JDLFdBQXBCLEVBQWlDaGIsSUFBakMsRUFBdUNILEtBQXZDLEVBQThDO2dCQUN0QzJGLEtBQUt3VixZQUFZaGIsSUFBWixLQUFxQmdiLFlBQVloYixJQUFaLEVBQWtCNGEsR0FBaEQ7Z0JBQ0k1WSxVQUFVbEQsTUFBVixLQUFxQixDQUF6QixFQUE0QjttQkFDckJlLEtBQUg7YUFESixNQUVPO3VCQUNJMkYsSUFBUDs7U0FaNkI7O2VBQzlCeVYsVUFBUCxDQUFrQixDQUNWLHdCQURVLEVBRVYsdUJBRlUsRUFHVixjQUhVLEVBSVJDLElBSlEsQ0FJSCxJQUpHLENBQWxCLEVBSXNCLFVBSnRCOzs7MkJBY21CLDBCQUFTQyxPQUFULEVBQWtCSCxXQUFsQixFQUErQnZiLEtBQS9CLEVBQXNDO3NCQUMzQ0EsTUFBTXlDLEtBQU4sQ0FBWSxDQUFaLENBQVY7b0JBQ1EvQyxJQUFSLENBQWEsZ0JBQWI7Z0JBQ0kySSxZQUFZLFlBQVl5UCxXQUFXLEdBQVgsQ0FBNUI7Z0JBQTZDNkQsUUFBUSxFQUFyRDtnQkFBeURDLFNBQVMsRUFBbEU7bUJBQ09sYyxJQUFQLENBQ1EsV0FBVzJJLFNBRG5CLEVBRVEsbUNBRlIsRUFHUSw2Q0FIUixFQUlRLDZDQUpSLEVBS1EsMEJBTFI7NEJBQUE7Z0JBT0UzSixPQUFGLENBQVVnZCxPQUFWLEVBQWtCLFVBQVNuYixJQUFULEVBQWU7O29CQUN6Qm9iLE1BQU1wYixJQUFOLE1BQWdCLElBQXBCLEVBQTBCOzBCQUNoQkEsSUFBTixJQUFjLElBQWQsQ0FEc0I7MkJBRW5CYixJQUFQLENBQVksZUFBZWEsSUFBZixHQUFzQixHQUFsQyxFQUYwQjs7YUFEOUI7aUJBTUssSUFBSUEsSUFBVCxJQUFpQmdiLFdBQWpCLEVBQThCO3NCQUNwQmhiLElBQU4sSUFBYyxJQUFkO3VCQUNXYixJQUFQOzs0Q0FFb0NhLElBQTVCLEdBQW1DLFFBRjNDO3dEQUdnREEsSUFBeEMsR0FBK0MsVUFIdkQsRUFJUSxnQkFKUixFQUtRLDRCQUE0QkEsSUFBNUIsR0FBbUMsUUFMM0M7d0RBTWdEQSxJQUF4QyxHQUErQyxVQU52RCxFQU9RLGdCQVBSLEVBUVEsNEJBQTRCQSxJQUE1QixHQUFtQyxHQVIzQzt3Q0FBQTs2QkFVcUJBLElBQWIsR0FBb0IsK0JBQXBCLEdBQXNEQSxJQUF0RCxHQUE2RCxLQVZyRSxFQVdRLDJCQVhSLEVBWVEsVUFBVUEsSUFBVixHQUFpQiwrQkFBakIsR0FBbURBLElBQW5ELEdBQTBELEtBWmxFLEVBYVEsVUFiUixFQWNRLG1CQWRSLEVBZVEsZ0JBZlI7O21CQWlCRGIsSUFBUCxDQUFZLFdBQVosRUFwQ3FEO21CQXFDOUNBLElBQVAsQ0FDUSxjQUFjMkksU0FBZCxHQUEwQixlQURsQztxQkFBQSxFQUdRLG9CQUFvQkEsU0FBcEIsR0FBZ0MsU0FIeEMsRUFJUSxXQUFXQSxTQUFYLEdBQXVCLGFBSi9CLEVBS1EsY0FMUjttQkFNT3dULE9BQVAsQ0FBZUQsT0FBT0gsSUFBUCxDQUFZLE1BQVosQ0FBZixFQTNDcUQ7bUJBNEM3Qy9aLE9BQU8yRyxZQUFZLFNBQW5CLEVBQThCa1QsV0FBOUIsRUFBMkNELFVBQTNDLENBQVIsQ0E1Q3FEO1NBQXpEOztDQStDSjs7QUM3T08sSUFBTVEsZ0JBQWdCO2FBQ2IsQ0FEYTtXQUViLENBRmE7WUFHYjtDQUhUOztBQU1QLEFBQU8sSUFBTUMsYUFBYTtZQUNOLENBRE07V0FFTixDQUZNO2VBR04sQ0FITTtnQkFJTixDQUpNO2VBS04sQ0FMTTtvQkFNTixDQU5NO2tCQU9OO0NBUGI7O0FBVVAsQUFBTyxJQUFNQyxTQUFTO1VBQ1osQ0FEWTtVQUVaLENBRlk7VUFHWixDQUhZO1VBSVosQ0FKWTtVQUtaO0NBTEg7O0FBUVAsQUFBTzs7QUFLUCxBQUFPLElBQU1DLGtCQUFrQjtXQUNYLENBRFc7WUFFWCxDQUZXO09BR1gsQ0FIVztPQUlYLENBSlc7WUFLWCxDQUxXO1lBTVgsQ0FOVztpQkFPWDtXQUNSLENBRFE7V0FFUjtLQVRtQjtjQVdYLENBWFc7a0JBWVY7V0FDVCxDQURTO1dBRVQ7S0FkbUI7YUFnQlgsSUFoQlc7aUJBaUJYOztDQWpCYjtBQXFEUCxBQUFPLElBQU1DLHdCQUF3QjtZQUNqQixTQURpQjs7ZUFHakIsQ0FIaUI7ZUFJakIsSUFKaUI7O2FBTWpCLElBTmlCO2NBT2pCLElBUGlCO2dCQVFqQixJQVJpQjs7ZUFVakIsQ0FWaUI7aUJBV2pCLElBWGlCO2NBWWpCLE9BWmlCO2VBYWpCO0NBYmI7O0FDM0ZQOzs7Ozs7O0FBT0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUVBLElBQUlDLGdCQUFnQixTQUFoQkEsYUFBZ0IsQ0FBU2pZLEdBQVQsRUFBYTtrQkFDZkosVUFBZCxDQUF5QmxDLFdBQXpCLENBQXFDNE4sS0FBckMsQ0FBMkMsSUFBM0MsRUFBaURqTixTQUFqRDs7O1VBR1dHLE1BQU0wWixRQUFOLENBQWdCbFksR0FBaEIsQ0FBWDs7O1NBR0s0SSxVQUFMLEdBQXVCLElBQXZCOzs7U0FHS2dDLGFBQUwsR0FBdUIsQ0FBdkI7OztTQUdLdU4sS0FBTCxHQUF1QixJQUF2Qjs7O1NBR0s5UyxNQUFMLEdBQXVCLElBQXZCOztTQUVLd0UsYUFBTCxHQUF1QixLQUF2QixDQWxCNkI7O1NBb0J4QjFELFdBQUwsR0FBdUIsSUFBdkIsQ0FwQjZCOztTQXNCeEJpUyxPQUFMLEdBQXVCLGFBQWFwWSxHQUFiLEdBQW1CQSxJQUFJb1ksT0FBdkIsR0FBaUMsSUFBeEQsQ0F0QjZCOztTQXdCeEJqUCxPQUFMLEdBQXVCLEtBQXZCLENBeEI2Qjs7O1NBMkJ4QmtQLGNBQUwsQ0FBcUJyWSxHQUFyQjs7U0FFSzBELEVBQUwsR0FBVWxGLE1BQU04WixRQUFOLENBQWUsS0FBS2xYLElBQUwsSUFBYSxlQUE1QixDQUFWOztTQUVLbVgsSUFBTCxDQUFVak4sS0FBVixDQUFnQixJQUFoQixFQUF1QmpOLFNBQXZCOzs7U0FHS21hLGdCQUFMO0NBbENKOztBQXFDQWhhLE1BQU0yTCxVQUFOLENBQWtCOE4sYUFBbEIsRUFBa0MvTixlQUFsQyxFQUFvRDtVQUN6QyxnQkFBVSxFQUQrQjtvQkFFL0Isd0JBQVVsSyxHQUFWLEVBQWU7WUFDeEIwSixPQUFPLElBQVg7Ozs7YUFJSzlOLE9BQUwsR0FBZSxJQUFmOzs7O1lBSUk2YyxnQkFBZ0IzZSxJQUFFZ0UsTUFBRixDQUFVaEUsSUFBRXFFLEtBQUYsQ0FBUTRaLGVBQVIsQ0FBVixFQUFvQy9YLElBQUlwRSxPQUF4QyxFQUFrRCxJQUFsRCxDQUFwQjs7O2FBR0txTixTQUFMLEdBQWlCLEtBQWpCOztzQkFFY3lQLE1BQWQsR0FBdUJoUCxJQUF2QjtzQkFDYzZNLE1BQWQsR0FBdUIsVUFBU2xhLElBQVQsRUFBZ0JILEtBQWhCLEVBQXdCNlosUUFBeEIsRUFBaUM7OztnQkFHaEQ0QyxpQkFBaUIsQ0FBRSxHQUFGLEVBQVEsR0FBUixFQUFjLFFBQWQsRUFBeUIsUUFBekIsRUFBb0MsVUFBcEMsRUFBaUQsYUFBakQsRUFBaUUseUJBQWpFLENBQXJCOztnQkFFSTdlLElBQUVjLE9BQUYsQ0FBVytkLGNBQVgsRUFBNEJ0YyxJQUE1QixLQUFzQyxDQUExQyxFQUE4QztxQkFDckNxYyxNQUFMLENBQVlGLGdCQUFaOzs7Z0JBR0EsS0FBS0UsTUFBTCxDQUFZelAsU0FBaEIsRUFBMkI7Ozs7Z0JBSXZCLEtBQUt5UCxNQUFMLENBQVluQyxNQUFoQixFQUF3QjtxQkFDZm1DLE1BQUwsQ0FBWW5DLE1BQVosQ0FBb0JsYSxJQUFwQixFQUEyQkgsS0FBM0IsRUFBbUM2WixRQUFuQzs7O2lCQUdDMkMsTUFBTCxDQUFZdFAsU0FBWixDQUF1Qjs2QkFDUCxTQURPO3VCQUVOLEtBQUtzUCxNQUZDO3NCQUdOcmMsSUFITTt1QkFJTkgsS0FKTTswQkFLTjZaO2FBTGpCO1NBakJKOzs7YUE0QktuYSxPQUFMLEdBQWVzWixRQUFTdUQsYUFBVCxDQUFmO0tBN0M0Qzs7Ozs7O1dBb0R4QyxlQUFVRyxNQUFWLEVBQWtCO1lBQ2xCQyxPQUFTO2dCQUNDLEtBQUtuVixFQUROO3FCQUVDNUosSUFBRXFFLEtBQUYsQ0FBUSxLQUFLdkMsT0FBTCxDQUFhdWEsTUFBckI7U0FGZDs7WUFLSTJDLE1BQUo7WUFDSSxLQUFLMVgsSUFBTCxJQUFhLE1BQWpCLEVBQXlCO3FCQUNaLElBQUksS0FBSzFELFdBQVQsQ0FBc0IsS0FBS3FiLElBQTNCLEVBQWtDRixJQUFsQyxDQUFUO1NBREosTUFFTztxQkFDTSxJQUFJLEtBQUtuYixXQUFULENBQXNCbWIsSUFBdEIsQ0FBVDs7O2VBR0duVixFQUFQLEdBQVltVixLQUFLblYsRUFBakI7O1lBRUksS0FBS2dILFFBQVQsRUFBbUI7bUJBQ1JBLFFBQVAsR0FBa0IsS0FBS0EsUUFBdkI7OztZQUdBLENBQUNrTyxNQUFMLEVBQVk7bUJBQ0RsVixFQUFQLEdBQVlsRixNQUFNOFosUUFBTixDQUFlUSxPQUFPMVgsSUFBdEIsQ0FBWjs7ZUFFRzBYLE1BQVA7S0ExRTRDO2VBNEVwQyxtQkFBUzlZLEdBQVQsRUFBYTs7O1lBR2pCbVksUUFBUSxLQUFLcE4sUUFBTCxFQUFaO1lBQ0lvTixLQUFKLEVBQVc7aUJBQ0Z2TixhQUFMO2tCQUNNeEIsU0FBTixJQUFtQitPLE1BQU0vTyxTQUFOLENBQWlCcEosR0FBakIsQ0FBbkI7O0tBbEZ3QztxQkFxRjlCLDJCQUFVO2VBQ2xCNUMsS0FBS3FQLEdBQUwsQ0FBUyxLQUFLN1EsT0FBTCxDQUFhaUksS0FBYixHQUFxQixLQUFLakksT0FBTCxDQUFhb1EsTUFBM0MsQ0FBUDtLQXRGNkM7c0JBd0Y3Qiw0QkFBVTtlQUNuQjVPLEtBQUtxUCxHQUFMLENBQVMsS0FBSzdRLE9BQUwsQ0FBYWtJLE1BQWIsR0FBc0IsS0FBS2xJLE9BQUwsQ0FBYXFRLE1BQTVDLENBQVA7S0F6RjZDO2NBMkZyQyxvQkFBVTtZQUNiLEtBQUtrTSxLQUFULEVBQWlCO21CQUNOLEtBQUtBLEtBQVo7O1lBRUFwWCxJQUFJLElBQVI7WUFDSUEsRUFBRUssSUFBRixJQUFVLE9BQWQsRUFBc0I7bUJBQ2RMLEVBQUVzRSxNQUFSLEVBQWdCO29CQUNWdEUsRUFBRXNFLE1BQU47b0JBQ0l0RSxFQUFFSyxJQUFGLElBQVUsT0FBZCxFQUFzQjs7OztnQkFJcEJMLEVBQUVLLElBQUYsS0FBVyxPQUFmLEVBQXdCOzs7O3VCQUlmLEtBQVA7Ozs7YUFJQytXLEtBQUwsR0FBYXBYLENBQWI7ZUFDT0EsQ0FBUDtLQWhINEM7bUJBa0hoQyx1QkFBVU8sS0FBVixFQUFrQjBYLFNBQWxCLEVBQTZCO1NBQ3hDMVgsS0FBRCxLQUFZQSxRQUFRLElBQUlaLEtBQUosQ0FBVyxDQUFYLEVBQWUsQ0FBZixDQUFwQjtZQUNJdVksS0FBSyxLQUFLcFEscUJBQUwsQ0FBNEJtUSxTQUE1QixDQUFUOztZQUVJQyxNQUFNLElBQVYsRUFBZ0IsT0FBT3ZZLE1BQU8sQ0FBUCxFQUFXLENBQVgsQ0FBUDtZQUNad1IsSUFBSSxJQUFJMUcsTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCbEssTUFBTVgsQ0FBN0IsRUFBaUNXLE1BQU1WLENBQXZDLENBQVI7VUFDRTBMLE1BQUYsQ0FBUzJNLEVBQVQ7ZUFDTyxJQUFJdlksS0FBSixDQUFXd1IsRUFBRXJHLEVBQWIsRUFBa0JxRyxFQUFFcEcsRUFBcEIsQ0FBUCxDQVB5QztLQWxIRzttQkEySGhDLHVCQUFVeEssS0FBVixFQUFrQjBYLFNBQWxCLEVBQTZCO1NBQ3hDMVgsS0FBRCxLQUFZQSxRQUFRLElBQUlaLEtBQUosQ0FBVyxDQUFYLEVBQWUsQ0FBZixDQUFwQjs7WUFFSSxLQUFLVSxJQUFMLElBQWEsT0FBakIsRUFBMEI7bUJBQ2ZFLEtBQVA7O1lBRUEyWCxLQUFLLEtBQUtwUSxxQkFBTCxDQUE0Qm1RLFNBQTVCLENBQVQ7O1lBRUlDLE1BQU0sSUFBVixFQUFnQixPQUFPLElBQUl2WSxLQUFKLENBQVcsQ0FBWCxFQUFlLENBQWYsQ0FBUCxDQVJ5QjtXQVN0Q3dZLE1BQUg7WUFDSWhILElBQUksSUFBSTFHLE1BQUosQ0FBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QmxLLE1BQU1YLENBQTdCLEVBQWlDVyxNQUFNVixDQUF2QyxDQUFSO1VBQ0UwTCxNQUFGLENBQVMyTSxFQUFUO2VBQ08sSUFBSXZZLEtBQUosQ0FBV3dSLEVBQUVyRyxFQUFiLEVBQWtCcUcsRUFBRXBHLEVBQXBCLENBQVAsQ0FaeUM7S0EzSEc7bUJBeUloQyx1QkFBVXhLLEtBQVYsRUFBa0JsRCxNQUFsQixFQUF5QjtZQUNqQzJDLElBQUlvWSxjQUFlN1gsS0FBZixDQUFSO2VBQ09sRCxPQUFPa0osYUFBUCxDQUFzQnZHLENBQXRCLENBQVA7S0EzSTRDOzJCQTZJeEIsK0JBQVVpWSxTQUFWLEVBQXFCO1lBQ3JDQyxLQUFLLElBQUl6TixNQUFKLEVBQVQ7YUFDSyxJQUFJNE4sSUFBSSxJQUFiLEVBQW1CQSxLQUFLLElBQXhCLEVBQThCQSxJQUFJQSxFQUFFL1QsTUFBcEMsRUFBNEM7ZUFDckNpSCxNQUFILENBQVc4TSxFQUFFeFEsVUFBYjtnQkFDSSxDQUFDd1EsRUFBRS9ULE1BQUgsSUFBZTJULGFBQWFJLEVBQUUvVCxNQUFmLElBQXlCK1QsRUFBRS9ULE1BQUYsSUFBWTJULFNBQXBELElBQXFFSSxFQUFFL1QsTUFBRixJQUFZK1QsRUFBRS9ULE1BQUYsQ0FBU2pFLElBQVQsSUFBZSxPQUFwRyxFQUFnSDs7dUJBRXJHNlgsRUFBUCxDQUY0Rzs7O2VBSzdHQSxFQUFQO0tBdEo0Qzs7Ozs7b0JBNEovQix3QkFBVUksSUFBVixFQUFnQjtZQUMxQnZmLElBQUU2QyxTQUFGLENBQVkwYyxJQUFaLENBQUgsRUFBcUI7aUJBQ1p4UCxhQUFMLEdBQXFCd1AsSUFBckI7bUJBQ08sSUFBUDs7ZUFFRyxLQUFQO0tBaks0Qzs7OztjQXNLbkMsb0JBQVU7WUFDaEIsQ0FBQyxLQUFLaFUsTUFBVCxFQUFpQjs7O2VBR1Z2TCxJQUFFYyxPQUFGLENBQVUsS0FBS3lLLE1BQUwsQ0FBWXFGLFFBQXRCLEVBQWlDLElBQWpDLENBQVA7S0ExSzRDOzs7OztZQWdMdkMsZ0JBQVU0TyxHQUFWLEVBQWU7WUFDakIsQ0FBQyxLQUFLalUsTUFBVCxFQUFpQjs7O1lBR2JrVSxZQUFZLEtBQUtDLFFBQUwsRUFBaEI7WUFDSUMsVUFBVSxDQUFkOztZQUVHM2YsSUFBRTRDLFFBQUYsQ0FBWTRjLEdBQVosQ0FBSCxFQUFxQjtnQkFDZkEsT0FBTyxDQUFYLEVBQWM7Ozs7c0JBSUpDLFlBQVlELEdBQXRCOztZQUVFL1QsS0FBSyxLQUFLRixNQUFMLENBQVlxRixRQUFaLENBQXFCVixNQUFyQixDQUE2QnVQLFNBQTdCLEVBQXlDLENBQXpDLEVBQTZDLENBQTdDLENBQVQ7WUFDSUUsVUFBVSxDQUFkLEVBQWlCO3NCQUNILENBQVY7O2FBRUNwVSxNQUFMLENBQVl5RCxVQUFaLENBQXdCdkQsRUFBeEIsRUFBNkJrVSxPQUE3QjtLQWxNNEM7Ozs7O2FBd010QyxpQkFBVUgsR0FBVixFQUFlO1lBQ2xCLENBQUMsS0FBS2pVLE1BQVQsRUFBaUI7OztZQUdia1UsWUFBWSxLQUFLQyxRQUFMLEVBQWhCO1lBQ0lFLE1BQU0sS0FBS3JVLE1BQUwsQ0FBWXFGLFFBQVosQ0FBcUJ2UCxNQUEvQjtZQUNJc2UsVUFBVUMsR0FBZDs7WUFFRzVmLElBQUU0QyxRQUFGLENBQVk0YyxHQUFaLENBQUgsRUFBcUI7Z0JBQ2ZBLE9BQU8sQ0FBWCxFQUFjOzs7O3NCQUlKQyxZQUFZRCxHQUFaLEdBQWtCLENBQTVCOztZQUVFL1QsS0FBSyxLQUFLRixNQUFMLENBQVlxRixRQUFaLENBQXFCVixNQUFyQixDQUE2QnVQLFNBQTdCLEVBQXlDLENBQXpDLEVBQTZDLENBQTdDLENBQVQ7WUFDR0UsVUFBVUMsR0FBYixFQUFpQjtzQkFDSEEsR0FBVjs7YUFFQ3JVLE1BQUwsQ0FBWXlELFVBQVosQ0FBd0J2RCxFQUF4QixFQUE2QmtVLFVBQVEsQ0FBckM7S0EzTjRDO3NCQTZON0IsNEJBQVc7WUFDdEI3USxhQUFhLElBQUk0QyxNQUFKLEVBQWpCO21CQUNXelAsUUFBWDtZQUNJSCxVQUFVLEtBQUtBLE9BQW5COztZQUVHQSxRQUFRb1EsTUFBUixLQUFtQixDQUFuQixJQUF3QnBRLFFBQVFxUSxNQUFSLEtBQWtCLENBQTdDLEVBQWdEOzs7Z0JBR3hDME4sU0FBUyxJQUFJalosS0FBSixDQUFVOUUsUUFBUWdlLFdBQWxCLENBQWI7Z0JBQ0lELE9BQU9oWixDQUFQLElBQVlnWixPQUFPL1ksQ0FBdkIsRUFBMEI7MkJBQ1hpWixTQUFYLENBQXNCLENBQUNGLE9BQU9oWixDQUE5QixFQUFrQyxDQUFDZ1osT0FBTy9ZLENBQTFDOzt1QkFFT2taLEtBQVgsQ0FBa0JsZSxRQUFRb1EsTUFBMUIsRUFBbUNwUSxRQUFRcVEsTUFBM0M7Z0JBQ0kwTixPQUFPaFosQ0FBUCxJQUFZZ1osT0FBTy9ZLENBQXZCLEVBQTBCOzJCQUNYaVosU0FBWCxDQUFzQkYsT0FBT2haLENBQTdCLEVBQWlDZ1osT0FBTy9ZLENBQXhDOzs7O1lBSUpzTCxXQUFXdFEsUUFBUXNRLFFBQXZCO1lBQ0lBLFFBQUosRUFBYzs7O2dCQUdOeU4sU0FBUyxJQUFJalosS0FBSixDQUFVOUUsUUFBUW1lLFlBQWxCLENBQWI7Z0JBQ0lKLE9BQU9oWixDQUFQLElBQVlnWixPQUFPL1ksQ0FBdkIsRUFBMEI7MkJBQ1hpWixTQUFYLENBQXNCLENBQUNGLE9BQU9oWixDQUE5QixFQUFrQyxDQUFDZ1osT0FBTy9ZLENBQTFDOzt1QkFFT29aLE1BQVgsQ0FBbUI5TixXQUFXLEdBQVgsR0FBaUI5TyxLQUFLaVAsRUFBdEIsR0FBeUIsR0FBNUM7Z0JBQ0lzTixPQUFPaFosQ0FBUCxJQUFZZ1osT0FBTy9ZLENBQXZCLEVBQTBCOzJCQUNYaVosU0FBWCxDQUFzQkYsT0FBT2haLENBQTdCLEVBQWlDZ1osT0FBTy9ZLENBQXhDOzs7OztZQUtKRCxDQUFKLEVBQU1DLENBQU47WUFDSSxLQUFLd1gsT0FBTCxJQUFnQixDQUFDLEtBQUtqUCxPQUExQixFQUFtQzs7O2dCQUczQnhJLElBQUlzWixTQUFVcmUsUUFBUStFLENBQWxCLENBQVI7Z0JBQ0lDLElBQUlxWixTQUFVcmUsUUFBUWdGLENBQWxCLENBQVI7O2dCQUVJcVosU0FBU3JlLFFBQVFzZSxTQUFqQixFQUE2QixFQUE3QixJQUFtQyxDQUFuQyxJQUF3QyxDQUF4QyxJQUE2Q3RlLFFBQVF1ZSxXQUF6RCxFQUFzRTtxQkFDN0QsR0FBTDtxQkFDSyxHQUFMOztTQVJSLE1BVU87Z0JBQ0N2ZSxRQUFRK0UsQ0FBWjtnQkFDSS9FLFFBQVFnRixDQUFaOzs7WUFHQUQsS0FBSyxDQUFMLElBQVVDLEtBQUssQ0FBbkIsRUFBc0I7dUJBQ1BpWixTQUFYLENBQXNCbFosQ0FBdEIsRUFBMEJDLENBQTFCOzthQUVDZ0ksVUFBTCxHQUFrQkEsVUFBbEI7ZUFDT0EsVUFBUDtLQWxSNEM7O3FCQXFSOUIseUJBQVV0SCxLQUFWLEVBQWlCOztZQUUzQjhZLFNBQVMsS0FBYixDQUYrQjs7O1lBSzNCLEtBQUtoWixJQUFMLElBQWEsT0FBYixJQUF3QixLQUFLaUUsTUFBN0IsSUFBdUMsS0FBS0EsTUFBTCxDQUFZakUsSUFBWixJQUFvQixPQUEvRCxFQUF5RTtvQkFDN0QsS0FBS2lFLE1BQUwsQ0FBWWlDLGFBQVosQ0FBMkJoRyxLQUEzQixDQUFSOzs7WUFHQVgsSUFBSVcsTUFBTVgsQ0FBZDtZQUNJQyxJQUFJVSxNQUFNVixDQUFkOzs7WUFHSSxLQUFLZ0ksVUFBVCxFQUFxQjtnQkFDYnlSLGdCQUFnQixLQUFLelIsVUFBTCxDQUFnQnpLLEtBQWhCLEdBQXdCK2EsTUFBeEIsRUFBcEI7Z0JBQ0lvQixZQUFZLENBQUMzWixDQUFELEVBQUlDLENBQUosQ0FBaEI7d0JBQ1l5WixjQUFjRSxTQUFkLENBQXlCRCxTQUF6QixDQUFaOztnQkFFSUEsVUFBVSxDQUFWLENBQUo7Z0JBQ0lBLFVBQVUsQ0FBVixDQUFKOzs7WUFHQSxLQUFLRSxRQUFULEVBQW1CO3FCQUNOLEtBQUtBLFFBQUwsQ0FBY0MsYUFBZCxDQUE2QixFQUFDOVosR0FBR0EsQ0FBSixFQUFRQyxHQUFHQSxDQUFYLEVBQTdCLENBQVQ7OztlQUdHd1osTUFBUDtLQS9TNEM7Ozs7OzthQXNUdEMsaUJBQVVNLFNBQVYsRUFBc0IzYyxPQUF0QixFQUErQjtZQUNqQ21TLEtBQUt3SyxTQUFUO1lBQ0loRyxPQUFPLEVBQVg7YUFDSyxJQUFJM1QsQ0FBVCxJQUFjbVAsRUFBZCxFQUFrQjtpQkFDUm5QLENBQU4sSUFBWSxLQUFLbkYsT0FBTCxDQUFhbUYsQ0FBYixDQUFaOztTQUVIaEQsT0FBRCxLQUFhQSxVQUFVLEVBQXZCO2dCQUNRMlcsSUFBUixHQUFlQSxJQUFmO2dCQUNReEUsRUFBUixHQUFhQSxFQUFiOztZQUVJeEcsT0FBTyxJQUFYO1lBQ0lpUixRQUFRLGlCQUFVLEVBQXRCO1lBQ0k1YyxRQUFRdVQsUUFBWixFQUFzQjtvQkFDVnZULFFBQVF1VCxRQUFoQjs7WUFFQTNELEtBQUo7Z0JBQ1EyRCxRQUFSLEdBQW1CLFlBQVU7O2dCQUVyQixDQUFDNUgsS0FBSzlOLE9BQU4sSUFBaUIrUixLQUFyQixFQUE0QjsrQkFDVG9ILFlBQWYsQ0FBNEJwSCxLQUE1Qjt3QkFDUSxJQUFSOzs7aUJBR0MsSUFBSTVNLENBQVQsSUFBYyxJQUFkLEVBQW9CO3FCQUNYbkYsT0FBTCxDQUFhbUYsQ0FBYixJQUFrQixLQUFLQSxDQUFMLENBQWxCOztrQkFFRXVLLEtBQU4sQ0FBWTVCLElBQVosRUFBbUIsQ0FBQyxJQUFELENBQW5CO1NBVko7WUFZSWtSLFVBQVUsbUJBQVUsRUFBeEI7WUFDSTdjLFFBQVF3VCxVQUFaLEVBQXdCO3NCQUNWeFQsUUFBUXdULFVBQWxCOztnQkFFSUEsVUFBUixHQUFxQixVQUFVdlIsR0FBVixFQUFlO29CQUN4QnNMLEtBQVIsQ0FBYzVCLElBQWQsRUFBcUJyTCxTQUFyQjtTQURKO2dCQUdRd2MsZUFBZXJHLFdBQWYsQ0FBNEJ6VyxPQUE1QixDQUFSO2VBQ080UCxLQUFQO0tBMVY0Qzs7O2FBK1Z0QyxpQkFBVW1OLEdBQVYsRUFBZTtZQUNqQixDQUFDLEtBQUtsZixPQUFMLENBQWFtZixPQUFkLElBQXlCLEtBQUtuZixPQUFMLENBQWE2SyxXQUFiLElBQTRCLENBQXpELEVBQTREOzs7WUFHeER1VSxJQUFKOztZQUdJQyxZQUFZLEtBQUtyUyxVQUFyQjtZQUNJLENBQUNxUyxTQUFMLEVBQWlCO3dCQUNELEtBQUt6QyxnQkFBTCxFQUFaOzs7WUFHQTBDLFNBQUosQ0FBYzVQLEtBQWQsQ0FBcUJ3UCxHQUFyQixFQUEyQkcsVUFBVUUsT0FBVixFQUEzQjs7O1lBR0ksS0FBSy9aLElBQUwsSUFBYSxNQUFqQixFQUEwQjtnQkFDbEJ1QyxRQUFRLEtBQUsvSCxPQUFMLENBQWF1YSxNQUF6QjtpQkFDSSxJQUFJcFYsQ0FBUixJQUFhNEMsS0FBYixFQUFtQjtvQkFDWDVDLEtBQUssY0FBTCxJQUF5QkEsS0FBSytaLEdBQWxDLEVBQXlDO3dCQUNoQ25YLE1BQU01QyxDQUFOLEtBQVlqSCxJQUFFNEMsUUFBRixDQUFZaUgsTUFBTTVDLENBQU4sQ0FBWixDQUFqQixFQUEwQzs0QkFDbENBLEtBQUssYUFBVCxFQUF3Qjs7Z0NBRWhCQSxDQUFKLEtBQVU0QyxNQUFNNUMsQ0FBTixDQUFWO3lCQUZKLE1BR087Z0NBQ0NBLENBQUosSUFBUzRDLE1BQU01QyxDQUFOLENBQVQ7Ozs7Ozs7YUFPZnFhLE1BQUwsQ0FBYU4sR0FBYjtZQUNJTyxPQUFKO0tBL1g0QztZQWlZdkMsZ0JBQVVQLEdBQVYsRUFBZ0I7O0tBall1Qjs7WUFxWXZDLGtCQUFVO1lBQ1gsS0FBS3pWLE1BQVQsRUFBaUI7aUJBQ1JBLE1BQUwsQ0FBWWlXLFdBQVosQ0FBd0IsSUFBeEI7aUJBQ0tqVyxNQUFMLEdBQWMsSUFBZDs7S0F4WXdDOzthQTRZdEMsbUJBQVU7YUFDWG1MLE1BQUw7YUFDS2pLLElBQUwsQ0FBVSxTQUFWOzthQUVLM0ssT0FBTCxHQUFlLElBQWY7ZUFDTyxLQUFLQSxPQUFaOztDQWpaUixFQXFaQTs7QUMxY0E7Ozs7Ozs7QUFPQSxBQUNBLEFBQ0EsQUFDQSxBQUVBLElBQUkyZix5QkFBeUIsU0FBekJBLHNCQUF5QixDQUFTdmIsR0FBVCxFQUFhO1FBQ25DMEosT0FBTyxJQUFYO1NBQ0tnQixRQUFMLEdBQWdCLEVBQWhCO1NBQ0s4USxhQUFMLEdBQXFCLEVBQXJCOzJCQUN1QjViLFVBQXZCLENBQWtDbEMsV0FBbEMsQ0FBOEM0TixLQUE5QyxDQUFvRCxJQUFwRCxFQUEwRGpOLFNBQTFEOzs7OztTQUtLd0wsYUFBTCxHQUFxQixJQUFyQjtDQVRIOztBQVlBckwsTUFBTTJMLFVBQU4sQ0FBa0JvUixzQkFBbEIsRUFBMkN0RCxhQUEzQyxFQUEyRDtjQUM1QyxrQkFBUzNTLEtBQVQsRUFBZTtZQUNsQixDQUFDQSxLQUFMLEVBQWE7OztZQUdWLEtBQUttVyxhQUFMLENBQW1CblcsS0FBbkIsS0FBNkIsQ0FBQyxDQUFqQyxFQUFvQztrQkFDMUJELE1BQU4sR0FBZSxJQUFmO21CQUNPQyxLQUFQOzs7WUFHREEsTUFBTUQsTUFBVCxFQUFpQjtrQkFDUEEsTUFBTixDQUFhaVcsV0FBYixDQUF5QmhXLEtBQXpCOzthQUVDb0YsUUFBTCxDQUFjbFAsSUFBZCxDQUFvQjhKLEtBQXBCO2NBQ01ELE1BQU4sR0FBZSxJQUFmO1lBQ0csS0FBSytELFNBQVIsRUFBa0I7aUJBQ1ZBLFNBQUwsQ0FBZTs2QkFDQyxVQUREO3dCQUVDOUQsS0FGRDtxQkFHQzthQUhoQjs7O1lBT0EsS0FBS29XLGNBQVIsRUFBdUI7aUJBQ2ZBLGNBQUwsQ0FBb0JwVyxLQUFwQjs7O2VBR0lBLEtBQVA7S0EzQm1EO2dCQTZCMUMsb0JBQVNBLEtBQVQsRUFBZ0JuSixLQUFoQixFQUF1QjtZQUM3QixLQUFLc2YsYUFBTCxDQUFtQm5XLEtBQW5CLEtBQTZCLENBQUMsQ0FBakMsRUFBb0M7a0JBQzFCRCxNQUFOLEdBQWUsSUFBZjttQkFDT0MsS0FBUDs7WUFFREEsTUFBTUQsTUFBVCxFQUFpQjtrQkFDUEEsTUFBTixDQUFhaVcsV0FBYixDQUF5QmhXLEtBQXpCOzthQUVDb0YsUUFBTCxDQUFjVixNQUFkLENBQXFCN04sS0FBckIsRUFBNEIsQ0FBNUIsRUFBK0JtSixLQUEvQjtjQUNNRCxNQUFOLEdBQWUsSUFBZjs7O1lBR0csS0FBSytELFNBQVIsRUFBa0I7aUJBQ1ZBLFNBQUwsQ0FBZTs2QkFDQyxVQUREO3dCQUVFOUQsS0FGRjtxQkFHRjthQUhiOzs7WUFPQSxLQUFLb1csY0FBUixFQUF1QjtpQkFDZkEsY0FBTCxDQUFvQnBXLEtBQXBCLEVBQTBCbkosS0FBMUI7OztlQUdJbUosS0FBUDtLQXJEbUQ7aUJBdUR6QyxxQkFBU0EsS0FBVCxFQUFnQjtlQUNuQixLQUFLcVcsYUFBTCxDQUFtQjdoQixJQUFFYyxPQUFGLENBQVcsS0FBSzhQLFFBQWhCLEVBQTJCcEYsS0FBM0IsQ0FBbkIsQ0FBUDtLQXhEbUQ7bUJBMER2Qyx1QkFBU25KLEtBQVQsRUFBZ0I7WUFDeEJBLFFBQVEsQ0FBUixJQUFhQSxRQUFRLEtBQUt1TyxRQUFMLENBQWN2UCxNQUFkLEdBQXVCLENBQWhELEVBQW1EO21CQUN4QyxLQUFQOztZQUVBbUssUUFBUSxLQUFLb0YsUUFBTCxDQUFjdk8sS0FBZCxDQUFaO1lBQ0ltSixTQUFTLElBQWIsRUFBbUI7a0JBQ1RELE1BQU4sR0FBZSxJQUFmOzthQUVDcUYsUUFBTCxDQUFjVixNQUFkLENBQXFCN04sS0FBckIsRUFBNEIsQ0FBNUI7O1lBRUcsS0FBS2lOLFNBQVIsRUFBa0I7aUJBQ1ZBLFNBQUwsQ0FBZTs2QkFDQyxVQUREO3dCQUVFOUQsS0FGRjtxQkFHRjthQUhiOzs7WUFPQSxLQUFLc1csY0FBUixFQUF1QjtpQkFDZkEsY0FBTCxDQUFvQnRXLEtBQXBCLEVBQTRCbkosS0FBNUI7OztlQUdJbUosS0FBUDtLQWhGbUQ7cUJBa0ZyQyx5QkFBVTVCLEVBQVYsRUFBZTthQUN6QixJQUFJdEksSUFBSSxDQUFSLEVBQVd5Z0IsTUFBTSxLQUFLblIsUUFBTCxDQUFjdlAsTUFBbkMsRUFBMkNDLElBQUl5Z0IsR0FBL0MsRUFBb0R6Z0IsR0FBcEQsRUFBeUQ7Z0JBQ2xELEtBQUtzUCxRQUFMLENBQWN0UCxDQUFkLEVBQWlCc0ksRUFBakIsSUFBdUJBLEVBQTFCLEVBQThCO3VCQUNuQixLQUFLaVksYUFBTCxDQUFtQnZnQixDQUFuQixDQUFQOzs7ZUFHRCxLQUFQO0tBeEZtRDt1QkEwRm5DLDZCQUFXO2VBQ3JCLEtBQUtzUCxRQUFMLENBQWN2UCxNQUFkLEdBQXVCLENBQTdCLEVBQWdDO2lCQUN2QndnQixhQUFMLENBQW1CLENBQW5COztLQTVGK0M7O2FBZ0c3QyxtQkFBVTtZQUNaLEtBQUt0VyxNQUFULEVBQWlCO2lCQUNSQSxNQUFMLENBQVlpVyxXQUFaLENBQXdCLElBQXhCO2lCQUNLalcsTUFBTCxHQUFjLElBQWQ7O2FBRUNrQixJQUFMLENBQVUsU0FBVjs7YUFFSyxJQUFJbkwsSUFBRSxDQUFOLEVBQVFtWixJQUFFLEtBQUs3SixRQUFMLENBQWN2UCxNQUE3QixFQUFzQ0MsSUFBRW1aLENBQXhDLEVBQTRDblosR0FBNUMsRUFBZ0Q7aUJBQ3ZDMGdCLFVBQUwsQ0FBZ0IxZ0IsQ0FBaEIsRUFBbUJpTyxPQUFuQjs7OztLQXhHK0M7Ozs7O2tCQWlIeEMsc0JBQVMzRixFQUFULEVBQWNxWSxNQUFkLEVBQXFCO1lBQzdCLENBQUNBLE1BQUosRUFBWTtpQkFDSixJQUFJM2dCLElBQUksQ0FBUixFQUFXeWdCLE1BQU0sS0FBS25SLFFBQUwsQ0FBY3ZQLE1BQW5DLEVBQTJDQyxJQUFJeWdCLEdBQS9DLEVBQW9EemdCLEdBQXBELEVBQXdEO29CQUNqRCxLQUFLc1AsUUFBTCxDQUFjdFAsQ0FBZCxFQUFpQnNJLEVBQWpCLElBQXVCQSxFQUExQixFQUE4QjsyQkFDbkIsS0FBS2dILFFBQUwsQ0FBY3RQLENBQWQsQ0FBUDs7O1NBSFosTUFNTzs7O21CQUdJLElBQVA7O2VBRUcsSUFBUDtLQTdIbUQ7Z0JBK0gxQyxvQkFBU2UsS0FBVCxFQUFnQjtZQUNyQkEsUUFBUSxDQUFSLElBQWFBLFFBQVEsS0FBS3VPLFFBQUwsQ0FBY3ZQLE1BQWQsR0FBdUIsQ0FBaEQsRUFBbUQsT0FBTyxJQUFQO2VBQzVDLEtBQUt1UCxRQUFMLENBQWN2TyxLQUFkLENBQVA7S0FqSW1EO21CQW1JdkMsdUJBQVNtSixLQUFULEVBQWdCO2VBQ3JCeEwsSUFBRWMsT0FBRixDQUFXLEtBQUs4UCxRQUFoQixFQUEyQnBGLEtBQTNCLENBQVA7S0FwSW1EO21CQXNJdkMsdUJBQVNBLEtBQVQsRUFBZ0JuSixLQUFoQixFQUFzQjtZQUMvQm1KLE1BQU1ELE1BQU4sSUFBZ0IsSUFBbkIsRUFBeUI7WUFDckIyVyxXQUFXbGlCLElBQUVjLE9BQUYsQ0FBVyxLQUFLOFAsUUFBaEIsRUFBMkJwRixLQUEzQixDQUFmO1lBQ0duSixTQUFTNmYsUUFBWixFQUFzQjthQUNqQnRSLFFBQUwsQ0FBY1YsTUFBZCxDQUFxQmdTLFFBQXJCLEVBQStCLENBQS9CO2FBQ0t0UixRQUFMLENBQWNWLE1BQWQsQ0FBcUI3TixLQUFyQixFQUE0QixDQUE1QixFQUErQm1KLEtBQS9CO0tBM0ltRDtvQkE2SXRDLDBCQUFXO2VBQ2pCLEtBQUtvRixRQUFMLENBQWN2UCxNQUFyQjtLQTlJbUQ7OzBCQWlKaEMsOEJBQVVtRyxLQUFWLEVBQWtCZ1ksR0FBbEIsRUFBdUI7WUFDdENjLFNBQVMsRUFBYjs7YUFFSSxJQUFJaGYsSUFBSSxLQUFLc1AsUUFBTCxDQUFjdlAsTUFBZCxHQUF1QixDQUFuQyxFQUFzQ0MsS0FBSyxDQUEzQyxFQUE4Q0EsR0FBOUMsRUFBbUQ7Z0JBQzNDa0ssUUFBUSxLQUFLb0YsUUFBTCxDQUFjdFAsQ0FBZCxDQUFaOztnQkFFSWtLLFNBQVMsSUFBVCxJQUNDLENBQUNBLE1BQU11RSxhQUFQLElBQXdCLENBQUN2RSxNQUFNYSxXQURoQyxJQUVBLENBQUNiLE1BQU0xSixPQUFOLENBQWNtZixPQUZuQixFQUdFOzs7Z0JBR0V6VixpQkFBaUJpVyxzQkFBckIsRUFBOEM7O29CQUV0Q2pXLE1BQU1rVyxhQUFOLElBQXVCbFcsTUFBTTJXLGNBQU4sS0FBeUIsQ0FBcEQsRUFBc0Q7d0JBQy9DQyxPQUFPNVcsTUFBTVksb0JBQU4sQ0FBNEI1RSxLQUE1QixDQUFYO3dCQUNJNGEsS0FBSy9nQixNQUFMLEdBQWMsQ0FBbEIsRUFBb0I7aUNBQ1JpZixPQUFPOU4sTUFBUCxDQUFlNFAsSUFBZixDQUFUOzs7YUFMVixNQVFPOztvQkFFQzVXLE1BQU0rQixlQUFOLENBQXVCL0YsS0FBdkIsQ0FBSixFQUFvQzsyQkFDekI5RixJQUFQLENBQVk4SixLQUFaO3dCQUNJZ1UsT0FBT3piLFNBQVAsSUFBb0IsQ0FBQ3JCLE1BQU04YyxHQUFOLENBQXpCLEVBQW9DOzRCQUM5QmMsT0FBT2pmLE1BQVAsSUFBaUJtZSxHQUFwQixFQUF3QjttQ0FDZGMsTUFBUDs7Ozs7O2VBTVhBLE1BQVA7O0NBakxSLEVBb0xBOztBQzVNQTs7Ozs7Ozs7O0FBU0EsQUFDQSxBQUVBLElBQUkrQixRQUFRLFNBQVJBLEtBQVEsR0FBVztRQUNmelMsT0FBTyxJQUFYO1NBQ0t0SSxJQUFMLEdBQVksT0FBWjtTQUNLdkIsTUFBTCxHQUFjLElBQWQ7U0FDS2liLEdBQUwsR0FBVyxJQUFYLENBSm1COztTQU1kc0IsWUFBTCxHQUFvQixLQUFwQjtTQUNLQyxRQUFMLEdBQWdCLEtBQWhCO1VBQ016YyxVQUFOLENBQWlCbEMsV0FBakIsQ0FBNkI0TixLQUE3QixDQUFtQyxJQUFuQyxFQUF5Q2pOLFNBQXpDO0NBUko7QUFVQUcsTUFBTTJMLFVBQU4sQ0FBa0JnUyxLQUFsQixFQUEwQlosc0JBQTFCLEVBQW1EO1VBQ3hDLGdCQUFVLEVBRDhCOztlQUduQyxtQkFBVTFiLE1BQVYsRUFBbUJnRSxLQUFuQixFQUEyQkMsTUFBM0IsRUFBbUM7WUFDeEM0RixPQUFPLElBQVg7YUFDSzdKLE1BQUwsR0FBY0EsTUFBZDthQUNLakUsT0FBTCxDQUFhaUksS0FBYixHQUFzQkEsS0FBdEI7YUFDS2pJLE9BQUwsQ0FBYWtJLE1BQWIsR0FBc0JBLE1BQXRCO2FBQ0tsSSxPQUFMLENBQWFvUSxNQUFiLEdBQXNCeE4sTUFBTThkLGlCQUE1QjthQUNLMWdCLE9BQUwsQ0FBYXFRLE1BQWIsR0FBc0J6TixNQUFNOGQsaUJBQTVCO2FBQ0tELFFBQUwsR0FBZ0IsSUFBaEI7S0FWNEM7ZUFZbkMsbUJBQVVyYyxHQUFWLEVBQWU7OztZQUduQixDQUFDLEtBQUtxYyxRQUFWLEVBQW9COzs7O2dCQUlYcmMsTUFBTSxFQUFmLEVBUHVCO1lBUW5CbVksS0FBSixHQUFjLElBQWQ7OzthQUdLOVMsTUFBTCxJQUFlLEtBQUtBLE1BQUwsQ0FBWStELFNBQVosQ0FBc0JwSixHQUF0QixDQUFmOztDQXZCUixFQTBCQTs7SUMxQ3FCdWM7OEJBR2pCO1lBRGFuYixJQUNiLHVFQURrQndXLGNBQWM0RSxPQUNoQztZQUQwQ0MsR0FDMUM7WUFEZ0QxZSxPQUNoRDs7O2FBQ01xRCxJQUFMLEdBQVlBLElBQVosQ0FERDthQUVTcWIsR0FBTCxHQUFXQSxHQUFYOzs7WUFHSTFlLE9BQUosRUFDQTtpQkFDUyxJQUFNM0MsQ0FBWCxJQUFnQjRJLFNBQVMwWSxjQUF6QixFQUNBO29CQUNRLE9BQU8zZSxRQUFRM0MsQ0FBUixDQUFQLEtBQXNCLFdBQTFCLEVBQ0E7NEJBQ1lBLENBQVIsSUFBYTRJLFNBQVMwWSxjQUFULENBQXdCdGhCLENBQXhCLENBQWI7OztTQU5aLE1BV0E7c0JBQ2M0SSxTQUFTMFksY0FBbkI7OzthQUdDM2UsT0FBTCxHQUFlQSxPQUFmOzthQUdLNGUsVUFBTCxHQUFrQixJQUFsQjs7YUFFREMsVUFBTCxHQUFrQixLQUFsQixDQXpCRTs7YUEyQkdDLGNBQUwsR0FBc0IsQ0FBdEI7Ozs7Ozs7O3FDQUtFO2dCQUNPblQsT0FBTyxJQUFYO2dCQUNJLENBQUNBLEtBQUtpVCxVQUFWLEVBQXNCO3FCQUNiQSxVQUFMLEdBQWtCOUIsZUFBZTFHLFdBQWYsQ0FBNEI7d0JBQ3JDLFlBRHFDOzBCQUVuQyxnQkFBVTs2QkFDUDJJLFVBQUwsQ0FBZ0J4UixLQUFoQixDQUFzQjVCLElBQXRCOztpQkFIUyxDQUFsQjs7Ozs7cUNBVVA7Z0JBQ1FBLE9BQU8sSUFBWDs7O2lCQUdLaVQsVUFBTCxHQUFrQixJQUFsQjtrQkFDTTdPLEdBQU4sR0FBWSxJQUFJUSxJQUFKLEdBQVdDLE9BQVgsRUFBWjtnQkFDSTdFLEtBQUtrVCxVQUFULEVBQXFCOztvQkFFYkcsU0FBUyxJQUFJek8sSUFBSixHQUFXQyxPQUFYLEVBQWI7cUJBQ0s2TSxNQUFMLENBQWEsS0FBS3FCLEdBQWxCO29CQUNJTyxPQUFPLElBQUkxTyxJQUFKLEdBQVdDLE9BQVgsRUFBWDt3QkFDUS9ELEdBQVIsQ0FBYXdTLE9BQU9ELE1BQXBCOztxQkFFS0gsVUFBTCxHQUFrQixLQUFsQjs7cUJBRUtDLGNBQUwsR0FBc0IsSUFBSXZPLElBQUosR0FBV0MsT0FBWCxFQUF0Qjs7Ozs7dUNBSU92TyxLQUNmO2dCQUNRdUYsS0FBSyxJQUFUO2dCQUNFN0osSUFBRixDQUFRNkosR0FBR2tYLEdBQUgsQ0FBTy9SLFFBQWYsRUFBMEIsVUFBU3lOLEtBQVQsRUFBZTtzQkFDL0J2YyxPQUFOLENBQWNvRSxJQUFJM0QsSUFBbEIsSUFBMEIyRCxJQUFJOUQsS0FBOUI7YUFESjs7OztrQ0FLTzhELEtBQ1g7O2dCQUVRMEosT0FBTyxJQUFYO2dCQUNJMUosR0FBSixFQUFTOzs7b0JBR0RBLElBQUlpZCxXQUFKLElBQW1CLFNBQXZCLEVBQWlDO3dCQUN6QjlFLFFBQVVuWSxJQUFJbVksS0FBbEI7d0JBQ0krRSxRQUFVbGQsSUFBSWtkLEtBQWxCO3dCQUNJN2dCLE9BQVUyRCxJQUFJM0QsSUFBbEI7d0JBQ0lILFFBQVU4RCxJQUFJOUQsS0FBbEI7d0JBQ0k2WixXQUFVL1YsSUFBSStWLFFBQWxCOzt3QkFFSW1ILE1BQU05YixJQUFOLElBQWMsUUFBbEIsRUFBNEI7NkJBQ25CK2IsY0FBTCxDQUFvQm5kLEdBQXBCO3FCQURKLE1BRU87NEJBQ0EsQ0FBQzBKLEtBQUsrUyxHQUFMLENBQVNXLGFBQVQsQ0FBdUJqRixNQUFNelUsRUFBN0IsQ0FBSixFQUFxQztpQ0FDNUIrWSxHQUFMLENBQVNXLGFBQVQsQ0FBdUJqRixNQUFNelUsRUFBN0IsSUFBaUM7dUNBQ3JCeVUsS0FEcUI7K0NBRWI7NkJBRnBCOzs0QkFLRCtFLEtBQUgsRUFBUztnQ0FDRCxDQUFDeFQsS0FBSytTLEdBQUwsQ0FBU1csYUFBVCxDQUF3QmpGLE1BQU16VSxFQUE5QixFQUFtQzJaLGFBQW5DLENBQWtESCxNQUFNeFosRUFBeEQsQ0FBTCxFQUFrRTtxQ0FDekQrWSxHQUFMLENBQVNXLGFBQVQsQ0FBd0JqRixNQUFNelUsRUFBOUIsRUFBbUMyWixhQUFuQyxDQUFrREgsTUFBTXhaLEVBQXhELElBQTZEOzJDQUNqRHdaLEtBRGlEO2lEQUUzQ2xkLElBQUlpZDtpQ0FGdEI7NkJBREosTUFLTzs7Ozs7Ozs7b0JBUWZqZCxJQUFJaWQsV0FBSixJQUFtQixVQUF2QixFQUFrQzs7d0JBRTFCN2UsU0FBUzRCLElBQUk1QixNQUFqQjt3QkFDSStaLFFBQVFuWSxJQUFJaEMsR0FBSixDQUFRK00sUUFBUixFQUFaO3dCQUNJb04sU0FBVS9aLE9BQU9nRCxJQUFQLElBQWEsT0FBM0IsRUFBcUM7O2dDQUV6QitXLFNBQVMvWixNQUFqQjs0QkFDRyxDQUFDc0wsS0FBSytTLEdBQUwsQ0FBU1csYUFBVCxDQUF1QmpGLE1BQU16VSxFQUE3QixDQUFKLEVBQXNDO2lDQUM3QitZLEdBQUwsQ0FBU1csYUFBVCxDQUF1QmpGLE1BQU16VSxFQUE3QixJQUFpQzt1Q0FDckJ5VSxLQURxQjsrQ0FFYjs2QkFGcEI7Ozs7O29CQVFULENBQUNuWSxJQUFJaWQsV0FBUixFQUFvQjs7d0JBRVo5RSxRQUFRblksSUFBSW1ZLEtBQWhCO3dCQUNHLENBQUN6TyxLQUFLK1MsR0FBTCxDQUFTVyxhQUFULENBQXVCakYsTUFBTXpVLEVBQTdCLENBQUosRUFBc0M7NkJBQzdCK1ksR0FBTCxDQUFTVyxhQUFULENBQXVCakYsTUFBTXpVLEVBQTdCLElBQWlDO21DQUNyQnlVLEtBRHFCOzJDQUViO3lCQUZwQjs7O2FBckRaLE1BMkRPOztvQkFFRHpjLElBQUYsQ0FBUWdPLEtBQUsrUyxHQUFMLENBQVMvUixRQUFqQixFQUE0QixVQUFVeU4sS0FBVixFQUFrQi9jLENBQWxCLEVBQXFCO3lCQUN4Q3FoQixHQUFMLENBQVNXLGFBQVQsQ0FBd0JqRixNQUFNelUsRUFBOUIsSUFBcUM7K0JBQ3pCeVUsS0FEeUI7dUNBRWpCO3FCQUZwQjtpQkFESjs7Z0JBT0EsQ0FBQ3pPLEtBQUtrVCxVQUFWLEVBQXFCOztxQkFFYkEsVUFBTCxHQUFrQixJQUFsQjtxQkFDS1UsVUFBTDthQUhILE1BSU87O3FCQUVDVixVQUFMLEdBQWtCLElBQWxCOzs7Ozs7O0lDN0pVVztvQ0FHTEMsUUFBWixFQUNBOzs7YUFDU0EsUUFBTCxHQUFnQkEsUUFBaEI7Ozs7Ozs7Ozs7OytCQU9HQyxlQUFnQnRGLE9BQ3ZCOztnQkFFVXFDLFdBQVdpRCxjQUFjakQsUUFBL0I7Z0JBQ01nRCxXQUFXLEtBQUtBLFFBQXRCO2dCQUNNMUMsTUFBTTNDLE1BQU0yQyxHQUFsQjtnQkFDTWxmLFVBQVU2aEIsY0FBYzdoQixPQUE5Qjs7Z0JBRUk2aEIsY0FBY3BZLE1BQWxCLEVBQTBCO3dCQUNkb0IsV0FBUixJQUF1QmdYLGNBQWNwWSxNQUFkLENBQXFCekosT0FBckIsQ0FBNkI2SyxXQUFwRDs7O2lCQUdDLElBQUlyTCxJQUFJLENBQWIsRUFBZ0JBLElBQUlvZixTQUFTa0QsWUFBVCxDQUFzQnZpQixNQUExQyxFQUFrREMsR0FBbEQsRUFDQTtvQkFDVXVpQixPQUFPbkQsU0FBU2tELFlBQVQsQ0FBc0J0aUIsQ0FBdEIsQ0FBYjtvQkFDTThoQixRQUFRUyxLQUFLVCxLQUFuQjs7b0JBRU1VLFlBQVlELEtBQUtDLFNBQXZCO29CQUNNekQsY0FBY3dELEtBQUt4RCxXQUF6Qjs7b0JBRUlELFNBQUosR0FBZ0J5RCxLQUFLekQsU0FBckI7O29CQUVJeUQsS0FBS3ZjLElBQUwsS0FBYzBXLE9BQU8rRixJQUF6QixFQUNBO3dCQUNRQyxTQUFKOzt5QkFFS0MsYUFBTCxDQUFtQmIsTUFBTWMsTUFBekIsRUFBaUNkLE1BQU1lLE1BQXZDLEVBQStDbkQsR0FBL0M7O3dCQUVJNkMsS0FBS08sT0FBTCxFQUFKLEVBQ0E7NEJBQ1F6WCxXQUFKLEdBQWtCa1gsS0FBS1EsU0FBdkI7NEJBQ0lQLFNBQUosR0FBZ0JBLFNBQWhCOzRCQUNJUSxJQUFKOzt3QkFFQVQsS0FBS1UsT0FBTCxFQUFKLEVBQ0E7NEJBQ1E1WCxXQUFKLEdBQWtCa1gsS0FBS1csU0FBdkI7NEJBQ0luRSxXQUFKLEdBQWtCQSxXQUFsQjs0QkFDSW9FLE1BQUo7O2lCQWhCUixNQW1CSyxJQUFJWixLQUFLdmMsSUFBTCxLQUFjMFcsT0FBTzBHLElBQXpCLEVBQ0w7d0JBQ1NiLEtBQUtPLE9BQUwsRUFBTCxFQUNBOzRCQUNRelgsV0FBSixHQUFrQmtYLEtBQUtRLFNBQXZCOzRCQUNJUCxTQUFKLEdBQWdCQSxTQUFoQjs0QkFDSWEsUUFBSixDQUFhdkIsTUFBTXZjLENBQW5CLEVBQXNCdWMsTUFBTXRjLENBQTVCLEVBQStCc2MsTUFBTXJaLEtBQXJDLEVBQTRDcVosTUFBTXBaLE1BQWxEOzt3QkFFQTZaLEtBQUtVLE9BQUwsRUFBSixFQUNBOzRCQUNRNVgsV0FBSixHQUFrQmtYLEtBQUtXLFNBQXZCOzRCQUNJbkUsV0FBSixHQUFrQkEsV0FBbEI7NEJBQ0l1RSxVQUFKLENBQWV4QixNQUFNdmMsQ0FBckIsRUFBd0J1YyxNQUFNdGMsQ0FBOUIsRUFBaUNzYyxNQUFNclosS0FBdkMsRUFBOENxWixNQUFNcFosTUFBcEQ7O2lCQVpILE1BZUEsSUFBSTZaLEtBQUt2YyxJQUFMLEtBQWMwVyxPQUFPNkcsSUFBekIsRUFDTDs7O3dCQUdRYixTQUFKO3dCQUNJYyxHQUFKLENBQVExQixNQUFNdmMsQ0FBZCxFQUFpQnVjLE1BQU10YyxDQUF2QixFQUEwQnNjLE1BQU0yQixNQUFoQyxFQUF3QyxDQUF4QyxFQUEyQyxJQUFJemhCLEtBQUtpUCxFQUFwRDt3QkFDSXlTLFNBQUo7O3dCQUVJbkIsS0FBS08sT0FBTCxFQUFKLEVBQ0E7NEJBQ1F6WCxXQUFKLEdBQWtCa1gsS0FBS1EsU0FBdkI7NEJBQ0lQLFNBQUosR0FBZ0JBLFNBQWhCOzRCQUNJUSxJQUFKOzt3QkFFQVQsS0FBS1UsT0FBTCxFQUFKLEVBQ0E7NEJBQ1E1WCxXQUFKLEdBQWtCa1gsS0FBS1csU0FBdkI7NEJBQ0luRSxXQUFKLEdBQWtCQSxXQUFsQjs0QkFDSW9FLE1BQUo7O2lCQWxCSCxNQXFCQSxJQUFJWixLQUFLdmMsSUFBTCxLQUFjMFcsT0FBT2lILElBQXpCLEVBQ0w7d0JBQ1VDLElBQUk5QixNQUFNclosS0FBTixHQUFjLENBQXhCO3dCQUNNb2IsSUFBSS9CLE1BQU1wWixNQUFOLEdBQWUsQ0FBekI7O3dCQUVNbkQsSUFBSXVjLE1BQU12YyxDQUFOLEdBQVdxZSxJQUFJLENBQXpCO3dCQUNNcGUsSUFBSXNjLE1BQU10YyxDQUFOLEdBQVdxZSxJQUFJLENBQXpCOzt3QkFFSW5CLFNBQUo7O3dCQUVNb0IsUUFBUSxTQUFkO3dCQUNNQyxLQUFNSCxJQUFJLENBQUwsR0FBVUUsS0FBckIsQ0FWSjt3QkFXVUUsS0FBTUgsSUFBSSxDQUFMLEdBQVVDLEtBQXJCLENBWEo7d0JBWVVHLEtBQUsxZSxJQUFJcWUsQ0FBZixDQVpKO3dCQWFVTSxLQUFLMWUsSUFBSXFlLENBQWYsQ0FiSjt3QkFjVU0sS0FBSzVlLElBQUtxZSxJQUFJLENBQXBCLENBZEo7d0JBZVVRLEtBQUs1ZSxJQUFLcWUsSUFBSSxDQUFwQixDQWZKOzt3QkFpQlFRLE1BQUosQ0FBVzllLENBQVgsRUFBYzZlLEVBQWQ7d0JBQ0lFLGFBQUosQ0FBa0IvZSxDQUFsQixFQUFxQjZlLEtBQUtKLEVBQTFCLEVBQThCRyxLQUFLSixFQUFuQyxFQUF1Q3ZlLENBQXZDLEVBQTBDMmUsRUFBMUMsRUFBOEMzZSxDQUE5Qzt3QkFDSThlLGFBQUosQ0FBa0JILEtBQUtKLEVBQXZCLEVBQTJCdmUsQ0FBM0IsRUFBOEJ5ZSxFQUE5QixFQUFrQ0csS0FBS0osRUFBdkMsRUFBMkNDLEVBQTNDLEVBQStDRyxFQUEvQzt3QkFDSUUsYUFBSixDQUFrQkwsRUFBbEIsRUFBc0JHLEtBQUtKLEVBQTNCLEVBQStCRyxLQUFLSixFQUFwQyxFQUF3Q0csRUFBeEMsRUFBNENDLEVBQTVDLEVBQWdERCxFQUFoRDt3QkFDSUksYUFBSixDQUFrQkgsS0FBS0osRUFBdkIsRUFBMkJHLEVBQTNCLEVBQStCM2UsQ0FBL0IsRUFBa0M2ZSxLQUFLSixFQUF2QyxFQUEyQ3plLENBQTNDLEVBQThDNmUsRUFBOUM7O3dCQUVJVixTQUFKOzt3QkFFSW5CLEtBQUtPLE9BQUwsRUFBSixFQUNBOzRCQUNRelgsV0FBSixHQUFrQmtYLEtBQUtRLFNBQXZCOzRCQUNJUCxTQUFKLEdBQWdCQSxTQUFoQjs0QkFDSVEsSUFBSjs7d0JBRUFULEtBQUtVLE9BQUwsRUFBSixFQUNBOzRCQUNRNVgsV0FBSixHQUFrQmtYLEtBQUtXLFNBQXZCOzRCQUNJbkUsV0FBSixHQUFrQkEsV0FBbEI7NEJBQ0lvRSxNQUFKOzs7Ozs7O3NDQU1GUCxRQUFRMkIsT0FBTzdFLEtBQzdCO2dCQUNRMkUsTUFBSixDQUFXekIsT0FBTyxDQUFQLENBQVgsRUFBc0JBLE9BQU8sQ0FBUCxDQUF0Qjs7aUJBRUssSUFBSTRCLElBQUksQ0FBYixFQUFnQkEsSUFBSTVCLE9BQU83aUIsTUFBUCxHQUFnQixDQUFwQyxFQUF1QyxFQUFFeWtCLENBQXpDLEVBQ0E7b0JBQ1FDLE1BQUosQ0FBVzdCLE9BQU80QixJQUFJLENBQVgsQ0FBWCxFQUEwQjVCLE9BQVE0QixJQUFJLENBQUwsR0FBVSxDQUFqQixDQUExQjs7O2dCQUdBRCxLQUFKLEVBQ0E7b0JBQ1FiLFNBQUo7Ozs7Ozs7SUMxSVNnQjs7OzRCQUVMckQsR0FBWixFQUNBO1lBRGlCMWUsT0FDakIsdUVBRHlCLEVBQ3pCOzs7bUlBQ1U2WixjQUFjbUksTUFEeEIsRUFDZ0N0RCxHQURoQyxFQUNxQzFlLE9BRHJDOztjQUVTaWlCLEdBQUwsR0FBVyxJQUFJQSxzQkFBSixPQUFYOzs7Ozs7K0JBR0l2RCxLQUNSO2dCQUNLbFgsS0FBSyxJQUFUO2VBQ01rWCxHQUFILEdBQVNBLEdBQVQ7Z0JBQ0QvZ0IsSUFBRixDQUFPNUIsSUFBRW1CLE1BQUYsQ0FBVXdoQixJQUFJVyxhQUFkLENBQVAsRUFBdUMsVUFBUzZDLFlBQVQsRUFBc0I7bUJBQ25EQyxXQUFILENBQWdCRCxhQUFhOUgsS0FBN0I7YUFEUDtnQkFHT2lGLGFBQUosR0FBb0IsRUFBcEI7Ozs7b0NBR1NqRixPQUNiO2dCQUNPLENBQUNBLE1BQU0yQyxHQUFWLEVBQWM7c0JBQ0pBLEdBQU4sR0FBWTNDLE1BQU10WSxNQUFOLENBQWFiLFVBQWIsQ0FBd0IsSUFBeEIsQ0FBWjs7a0JBRUVvZCxZQUFOLEdBQXFCLElBQXJCO2lCQUNLK0QsTUFBTCxDQUFhaEksS0FBYjtpQkFDS2lJLE9BQUwsQ0FBY2pJLEtBQWQ7a0JBQ01pRSxZQUFOLEdBQXFCLEtBQXJCOzs7O2dDQUdLakUsT0FBUXNGLGVBQ2pCO2dCQUNRLENBQUNBLGFBQUwsRUFBb0I7Z0NBQ0F0RixLQUFoQjs7O2dCQUdBLENBQUNzRixjQUFjN2hCLE9BQWQsQ0FBc0JtZixPQUF2QixJQUFrQzBDLGNBQWM3aEIsT0FBZCxDQUFzQjZLLFdBQXRCLElBQXFDLENBQTNFLEVBQThFOzs7O2dCQUkxRXFVLE1BQU0zQyxNQUFNMkMsR0FBaEI7O2dCQUVJRSxJQUFKOztnQkFFSUMsWUFBWXdDLGNBQWM3VSxVQUE5QjtnQkFDSSxDQUFDcVMsU0FBTCxFQUFpQjs0QkFDRHdDLGNBQWNqRixnQkFBZCxFQUFaOzs7Z0JBR0EwQyxTQUFKLENBQWM1UCxLQUFkLENBQXFCd1AsR0FBckIsRUFBMkJHLFVBQVVFLE9BQVYsRUFBM0I7O2dCQUdJc0MsY0FBY2pELFFBQWxCLEVBQTRCO3FCQUNuQndGLEdBQUwsQ0FBUzVFLE1BQVQsQ0FBaUJxQyxhQUFqQixFQUFpQ3RGLEtBQWpDOzs7Z0JBR0FzRixjQUFjL1MsUUFBbEIsRUFBNEI7cUJBQ3ZCLElBQUl0UCxJQUFJLENBQVIsRUFBV3lnQixNQUFNNEIsY0FBYy9TLFFBQWQsQ0FBdUJ2UCxNQUE1QyxFQUFvREMsSUFBSXlnQixHQUF4RCxFQUE2RHpnQixHQUE3RCxFQUFrRTt5QkFDNURnbEIsT0FBTCxDQUFjakksS0FBZCxFQUFzQnNGLGNBQWMvUyxRQUFkLENBQXVCdFAsQ0FBdkIsQ0FBdEI7Ozs7Z0JBSUVpZ0IsT0FBSjs7OzsrQkFHSWxELE9BQ1I7O2tCQUVVMkMsR0FBTixDQUFVdUYsU0FBVixDQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixLQUFLNUQsR0FBTCxDQUFTNVksS0FBVCxHQUFleWMsU0FBU3JjLFVBQW5ELEVBQWdFLEtBQUt3WSxHQUFMLENBQVMzWSxNQUFULEdBQWdCd2MsU0FBU3JjLFVBQXpGOzs7O0VBbkVvQ3NZOztBQ041Qzs7Ozs7OztJQU9xQjdiOzs7OzttQkFPakI7UUFEWUMsQ0FDWix1RUFEZ0IsQ0FDaEI7UUFEbUJDLENBQ25CLHVFQUR1QixDQUN2Qjs7Ozs7OztTQUtTRCxDQUFMLEdBQVNBLENBQVQ7Ozs7OztTQU1LQyxDQUFMLEdBQVNBLENBQVQ7Ozs7Ozs7Ozs7Ozs0QkFTSjthQUNXLElBQUlGLEtBQUosQ0FBVSxLQUFLQyxDQUFmLEVBQWtCLEtBQUtDLENBQXZCLENBQVA7Ozs7Ozs7Ozs7O3lCQVFDRyxHQUNMO1dBQ1NrVyxHQUFMLENBQVNsVyxFQUFFSixDQUFYLEVBQWNJLEVBQUVILENBQWhCOzs7Ozs7Ozs7Ozs7MkJBU0dHLEdBQ1A7YUFDWUEsRUFBRUosQ0FBRixLQUFRLEtBQUtBLENBQWQsSUFBcUJJLEVBQUVILENBQUYsS0FBUSxLQUFLQSxDQUF6Qzs7Ozs7Ozs7Ozs7OzsyQkFVQUQsR0FBR0MsR0FDUDtXQUNTRCxDQUFMLEdBQVNBLEtBQUssQ0FBZDtXQUNLQyxDQUFMLEdBQVNBLE1BQU9BLE1BQU0sQ0FBUCxHQUFZLEtBQUtELENBQWpCLEdBQXFCLENBQTNCLENBQVQ7Ozs7OztBQ3BFUixJQUFJNGYscUJBQXFCLEVBQXpCO0lBQ0lDLHVCQUF1QixFQUQzQjtJQUVJQyxxQkFBcUIsRUFGekI7SUFHSUMsUUFBUXptQixNQUFNQyxTQUFOLENBQWdCcWQsSUFINUI7Ozs7OztBQVNBLFNBQVNvSixhQUFULENBQXVCQyxHQUF2QixFQUE0QkMsR0FBNUIsRUFBaUNDLEVBQWpDLEVBQXFDQyxFQUFyQyxFQUF5Q0MsS0FBekMsRUFBZ0RDLEtBQWhELEVBQXVEQyxPQUF2RCxFQUFnRTtNQUMxREMsYUFBYVQsTUFBTWpsQixJQUFOLENBQVc0QyxTQUFYLENBQWpCO01BQ0lraUIsbUJBQW1CWSxVQUFuQixDQUFKLEVBQW9DO1dBQzNCWixtQkFBbUJZLFVBQW5CLENBQVA7OztNQUdFOVUsS0FBS2pQLEtBQUtpUCxFQUFkO01BQWtCK1UsS0FBS0YsVUFBVTdVLEVBQVYsR0FBZSxHQUF0QztNQUNJZ1YsUUFBUWprQixLQUFLZ1AsR0FBTCxDQUFTZ1YsRUFBVCxDQURaO01BRUlFLFFBQVFsa0IsS0FBSytPLEdBQUwsQ0FBU2lWLEVBQVQsQ0FGWjtNQUdJRyxRQUFRLENBSFo7TUFHZUMsUUFBUSxDQUh2Qjs7T0FLS3BrQixLQUFLcVAsR0FBTCxDQUFTcVUsRUFBVCxDQUFMO09BQ0sxakIsS0FBS3FQLEdBQUwsQ0FBU3NVLEVBQVQsQ0FBTDs7TUFFSXZoQixLQUFLLENBQUM4aEIsS0FBRCxHQUFTVixHQUFULEdBQWUsR0FBZixHQUFxQlMsUUFBUVIsR0FBUixHQUFjLEdBQTVDO01BQ0lZLEtBQUssQ0FBQ0gsS0FBRCxHQUFTVCxHQUFULEdBQWUsR0FBZixHQUFxQlEsUUFBUVQsR0FBUixHQUFjLEdBRDVDO01BRUljLE1BQU1aLEtBQUtBLEVBRmY7TUFFbUJhLE1BQU1aLEtBQUtBLEVBRjlCO01BRWtDYSxNQUFNSCxLQUFLQSxFQUY3QztNQUVpREksTUFBTXJpQixLQUFLQSxFQUY1RDtNQUdJc2lCLEtBQUtKLE1BQU1DLEdBQU4sR0FBWUQsTUFBTUUsR0FBbEIsR0FBd0JELE1BQU1FLEdBSHZDO01BSUlqYyxPQUFPLENBSlg7O01BTUlrYyxLQUFLLENBQVQsRUFBWTtRQUNOdmlCLElBQUluQyxLQUFLMFUsSUFBTCxDQUFVLElBQUlnUSxNQUFNSixNQUFNQyxHQUFaLENBQWQsQ0FBUjtVQUNNcGlCLENBQU47VUFDTUEsQ0FBTjtHQUhGLE1BS0s7V0FDSSxDQUFDeWhCLFVBQVVDLEtBQVYsR0FBa0IsQ0FBQyxHQUFuQixHQUF5QixHQUExQixJQUNDN2pCLEtBQUswVSxJQUFMLENBQVdnUSxNQUFNSixNQUFNRSxHQUFOLEdBQVlELE1BQU1FLEdBQXhCLENBQVgsQ0FEUjs7O01BSUVFLEtBQUtuYyxPQUFPa2IsRUFBUCxHQUFZVyxFQUFaLEdBQWlCVixFQUExQjtNQUNJaUIsS0FBSyxDQUFDcGMsSUFBRCxHQUFRbWIsRUFBUixHQUFhdmhCLEVBQWIsR0FBa0JzaEIsRUFEM0I7TUFFSW1CLE1BQU1YLFFBQVFTLEVBQVIsR0FBYVYsUUFBUVcsRUFBckIsR0FBMEJwQixNQUFNLEdBRjFDO01BR0lzQixNQUFNYixRQUFRVSxFQUFSLEdBQWFULFFBQVFVLEVBQXJCLEdBQTBCbkIsTUFBTSxHQUgxQztNQUlJc0IsU0FBU0MsZ0JBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQUM1aUIsS0FBS3VpQixFQUFOLElBQVlqQixFQUFsQyxFQUFzQyxDQUFDVyxLQUFLTyxFQUFOLElBQVlqQixFQUFsRCxDQUpiO01BS0lzQixTQUFTRCxnQkFBZ0IsQ0FBQzVpQixLQUFLdWlCLEVBQU4sSUFBWWpCLEVBQTVCLEVBQWdDLENBQUNXLEtBQUtPLEVBQU4sSUFBWWpCLEVBQTVDLEVBQWdELENBQUMsQ0FBQ3ZoQixFQUFELEdBQU11aUIsRUFBUCxJQUFhakIsRUFBN0QsRUFBaUUsQ0FBQyxDQUFDVyxFQUFELEdBQU1PLEVBQVAsSUFBYWpCLEVBQTlFLENBTGI7O01BT0lFLFVBQVUsQ0FBVixJQUFlb0IsU0FBUyxDQUE1QixFQUErQjtjQUNuQixJQUFJaFcsRUFBZDtHQURGLE1BR0ssSUFBSTRVLFVBQVUsQ0FBVixJQUFlb0IsU0FBUyxDQUE1QixFQUErQjtjQUN4QixJQUFJaFcsRUFBZDs7OztNQUlFaVcsV0FBV2xsQixLQUFLbWxCLElBQUwsQ0FBVW5sQixLQUFLcVAsR0FBTCxDQUFTNFYsU0FBU2hXLEVBQVQsR0FBYyxDQUF2QixDQUFWLENBQWY7TUFDSStOLFNBQVMsRUFEYjtNQUNpQm9JLFNBQVNILFNBQVNDLFFBRG5DO01BRUlHLEtBQUssSUFBSSxDQUFKLEdBQVFybEIsS0FBS2dQLEdBQUwsQ0FBU29XLFNBQVMsQ0FBbEIsQ0FBUixHQUErQnBsQixLQUFLZ1AsR0FBTCxDQUFTb1csU0FBUyxDQUFsQixDQUEvQixHQUFzRHBsQixLQUFLZ1AsR0FBTCxDQUFTb1csU0FBUyxDQUFsQixDQUYvRDtNQUdJRSxNQUFNUCxTQUFTSyxNQUhuQjs7T0FLSyxJQUFJcG5CLElBQUksQ0FBYixFQUFnQkEsSUFBSWtuQixRQUFwQixFQUE4QmxuQixHQUE5QixFQUFtQztXQUMxQkEsQ0FBUCxJQUFZdW5CLGdCQUFnQlIsTUFBaEIsRUFBd0JPLEdBQXhCLEVBQTZCcEIsS0FBN0IsRUFBb0NELEtBQXBDLEVBQTJDUCxFQUEzQyxFQUErQ0MsRUFBL0MsRUFBbURrQixHQUFuRCxFQUF3REMsR0FBeEQsRUFBNkRPLEVBQTdELEVBQWlFbEIsS0FBakUsRUFBd0VDLEtBQXhFLENBQVo7WUFDUXBILE9BQU9oZixDQUFQLEVBQVUsQ0FBVixDQUFSO1lBQ1FnZixPQUFPaGYsQ0FBUCxFQUFVLENBQVYsQ0FBUjthQUNTc25CLEdBQVQ7V0FDT0YsTUFBUDs7cUJBRWlCckIsVUFBbkIsSUFBaUMvRyxNQUFqQztTQUNPQSxNQUFQOzs7QUFHRixTQUFTdUksZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJGLEdBQTlCLEVBQW1DcEIsS0FBbkMsRUFBMENELEtBQTFDLEVBQWlEUCxFQUFqRCxFQUFxREMsRUFBckQsRUFBeURrQixHQUF6RCxFQUE4REMsR0FBOUQsRUFBbUVPLEVBQW5FLEVBQXVFbEIsS0FBdkUsRUFBOEVDLEtBQTlFLEVBQXFGO01BQy9FcUIsY0FBY25DLE1BQU1qbEIsSUFBTixDQUFXNEMsU0FBWCxDQUFsQjtNQUNJbWlCLHFCQUFxQnFDLFdBQXJCLENBQUosRUFBdUM7V0FDOUJyQyxxQkFBcUJxQyxXQUFyQixDQUFQOzs7TUFHRUMsU0FBUzFsQixLQUFLK08sR0FBTCxDQUFTeVcsR0FBVCxDQUFiO01BQ0lHLFNBQVMzbEIsS0FBS2dQLEdBQUwsQ0FBU3dXLEdBQVQsQ0FEYjtNQUVJSSxTQUFTNWxCLEtBQUsrTyxHQUFMLENBQVN1VyxHQUFULENBRmI7TUFHSU8sU0FBUzdsQixLQUFLZ1AsR0FBTCxDQUFTc1csR0FBVCxDQUhiO01BSUk5QixNQUFNVSxRQUFRUixFQUFSLEdBQWFrQyxNQUFiLEdBQXNCM0IsUUFBUU4sRUFBUixHQUFha0MsTUFBbkMsR0FBNENoQixHQUp0RDtNQUtJcEIsTUFBTVEsUUFBUVAsRUFBUixHQUFha0MsTUFBYixHQUFzQjFCLFFBQVFQLEVBQVIsR0FBYWtDLE1BQW5DLEdBQTRDZixHQUx0RDtNQU1JZ0IsT0FBTzNCLFFBQVFrQixNQUFPLENBQUNuQixLQUFELEdBQVNSLEVBQVQsR0FBY2lDLE1BQWQsR0FBdUIxQixRQUFRTixFQUFSLEdBQWErQixNQUEzQyxDQU5uQjtNQU9JSyxPQUFPM0IsUUFBUWlCLE1BQU8sQ0FBQ3BCLEtBQUQsR0FBU1AsRUFBVCxHQUFjaUMsTUFBZCxHQUF1QnpCLFFBQVFQLEVBQVIsR0FBYStCLE1BQTNDLENBUG5CO01BUUlNLE9BQU94QyxNQUFNNkIsTUFBT25CLFFBQVFSLEVBQVIsR0FBYW1DLE1BQWIsR0FBc0I1QixRQUFRTixFQUFSLEdBQWFpQyxNQUExQyxDQVJqQjtNQVNJSyxPQUFPeEMsTUFBTTRCLE1BQU9wQixRQUFRUCxFQUFSLEdBQWFtQyxNQUFiLEdBQXNCM0IsUUFBUVAsRUFBUixHQUFhaUMsTUFBMUMsQ0FUakI7O3VCQVdxQkgsV0FBckIsSUFBb0MsQ0FDbENLLElBRGtDLEVBQzVCQyxJQUQ0QixFQUVsQ0MsSUFGa0MsRUFFNUJDLElBRjRCLEVBR2xDekMsR0FIa0MsRUFHN0JDLEdBSDZCLENBQXBDO1NBS09MLHFCQUFxQnFDLFdBQXJCLENBQVA7Ozs7OztBQU1GLFNBQVNULGVBQVQsQ0FBeUJrQixFQUF6QixFQUE2QkMsRUFBN0IsRUFBaUNDLEVBQWpDLEVBQXFDQyxFQUFyQyxFQUF5QztNQUNuQ0MsS0FBS3RtQixLQUFLdW1CLEtBQUwsQ0FBV0osRUFBWCxFQUFlRCxFQUFmLENBQVQ7TUFDSU0sS0FBS3htQixLQUFLdW1CLEtBQUwsQ0FBV0YsRUFBWCxFQUFlRCxFQUFmLENBRFQ7TUFFSUksTUFBTUYsRUFBVixFQUFjO1dBQ0xFLEtBQUtGLEVBQVo7R0FERixNQUdLO1dBQ0ksSUFBSXRtQixLQUFLaVAsRUFBVCxJQUFlcVgsS0FBS0UsRUFBcEIsQ0FBUDs7Ozs7Ozs7Ozs7QUFXSixJQUFJQyxVQUFVLFNBQVZBLE9BQVUsQ0FBU3JKLFFBQVQsRUFBb0JzSixFQUFwQixFQUF3QkMsRUFBeEIsRUFBNEJDLE1BQTVCLEVBQW9DO01BQzVDbEQsS0FBS2tELE9BQU8sQ0FBUCxDQUFUO01BQ0lqRCxLQUFLaUQsT0FBTyxDQUFQLENBRFQ7TUFFSUMsTUFBTUQsT0FBTyxDQUFQLENBRlY7TUFHSWhELFFBQVFnRCxPQUFPLENBQVAsQ0FIWjtNQUlJL0MsUUFBUStDLE9BQU8sQ0FBUCxDQUpaO01BS0luWSxLQUFLbVksT0FBTyxDQUFQLENBTFQ7TUFNSWxZLEtBQUtrWSxPQUFPLENBQVAsQ0FOVDtNQU9JRSxPQUFPLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULEVBQWEsRUFBYixDQVBYO01BUUlDLFdBQVd4RCxjQUFjOVUsS0FBS2lZLEVBQW5CLEVBQXVCaFksS0FBS2lZLEVBQTVCLEVBQWdDakQsRUFBaEMsRUFBb0NDLEVBQXBDLEVBQXdDQyxLQUF4QyxFQUErQ0MsS0FBL0MsRUFBc0RnRCxHQUF0RCxDQVJmOztPQVVLLElBQUk3b0IsSUFBSSxDQUFSLEVBQVd5Z0IsTUFBTXNJLFNBQVNocEIsTUFBL0IsRUFBdUNDLElBQUl5Z0IsR0FBM0MsRUFBZ0R6Z0IsR0FBaEQsRUFBcUQ7U0FDOUNBLENBQUwsRUFBUSxDQUFSLElBQWErb0IsU0FBUy9vQixDQUFULEVBQVksQ0FBWixJQUFpQjBvQixFQUE5QjtTQUNLMW9CLENBQUwsRUFBUSxDQUFSLElBQWErb0IsU0FBUy9vQixDQUFULEVBQVksQ0FBWixJQUFpQjJvQixFQUE5QjtTQUNLM29CLENBQUwsRUFBUSxDQUFSLElBQWErb0IsU0FBUy9vQixDQUFULEVBQVksQ0FBWixJQUFpQjBvQixFQUE5QjtTQUNLMW9CLENBQUwsRUFBUSxDQUFSLElBQWErb0IsU0FBUy9vQixDQUFULEVBQVksQ0FBWixJQUFpQjJvQixFQUE5QjtTQUNLM29CLENBQUwsRUFBUSxDQUFSLElBQWErb0IsU0FBUy9vQixDQUFULEVBQVksQ0FBWixJQUFpQjBvQixFQUE5QjtTQUNLMW9CLENBQUwsRUFBUSxDQUFSLElBQWErb0IsU0FBUy9vQixDQUFULEVBQVksQ0FBWixJQUFpQjJvQixFQUE5QjthQUNTckUsYUFBVCxDQUF1QnBVLEtBQXZCLENBQTZCa1AsUUFBN0IsRUFBdUMwSixLQUFLOW9CLENBQUwsQ0FBdkM7O0NBbEJKOzs7Ozs7Ozs7Ozs7OztBQWtDQSxJQUFJZ3BCLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBU04sRUFBVCxFQUFhQyxFQUFiLEVBQWlCakQsRUFBakIsRUFBcUJDLEVBQXJCLEVBQXlCa0QsR0FBekIsRUFBOEJqRCxLQUE5QixFQUFxQ0MsS0FBckMsRUFBNENwVixFQUE1QyxFQUFnREMsRUFBaEQsRUFBb0Q7O01BRW5FeVYsUUFBUSxDQUFaO01BQWVDLFFBQVEsQ0FBdkI7TUFBMEI5ZSxLQUExQjtNQUFpQzJoQixTQUFTLEVBQTFDO01BQ0lILE9BQU92RCxjQUFjOVUsS0FBS2lZLEVBQW5CLEVBQXVCaFksS0FBS2lZLEVBQTVCLEVBQWdDakQsRUFBaEMsRUFBb0NDLEVBQXBDLEVBQXdDQyxLQUF4QyxFQUErQ0MsS0FBL0MsRUFBc0RnRCxHQUF0RCxDQURYOztPQUdLLElBQUk3b0IsSUFBSSxDQUFSLEVBQVd5Z0IsTUFBTXFJLEtBQUsvb0IsTUFBM0IsRUFBbUNDLElBQUl5Z0IsR0FBdkMsRUFBNEN6Z0IsR0FBNUMsRUFBaUQ7WUFDdkNrcEIsaUJBQWlCL0MsS0FBakIsRUFBd0JDLEtBQXhCLEVBQStCMEMsS0FBSzlvQixDQUFMLEVBQVEsQ0FBUixDQUEvQixFQUEyQzhvQixLQUFLOW9CLENBQUwsRUFBUSxDQUFSLENBQTNDLEVBQXVEOG9CLEtBQUs5b0IsQ0FBTCxFQUFRLENBQVIsQ0FBdkQsRUFBbUU4b0IsS0FBSzlvQixDQUFMLEVBQVEsQ0FBUixDQUFuRSxFQUErRThvQixLQUFLOW9CLENBQUwsRUFBUSxDQUFSLENBQS9FLEVBQTJGOG9CLEtBQUs5b0IsQ0FBTCxFQUFRLENBQVIsQ0FBM0YsQ0FBUjtXQUNPSSxJQUFQLENBQVksRUFBRW1GLEdBQUcrQixNQUFNLENBQU4sRUFBUy9CLENBQVQsR0FBYW1qQixFQUFsQixFQUFzQmxqQixHQUFHOEIsTUFBTSxDQUFOLEVBQVM5QixDQUFULEdBQWFtakIsRUFBdEMsRUFBWjtXQUNPdm9CLElBQVAsQ0FBWSxFQUFFbUYsR0FBRytCLE1BQU0sQ0FBTixFQUFTL0IsQ0FBVCxHQUFhbWpCLEVBQWxCLEVBQXNCbGpCLEdBQUc4QixNQUFNLENBQU4sRUFBUzlCLENBQVQsR0FBYW1qQixFQUF0QyxFQUFaO1lBQ1FHLEtBQUs5b0IsQ0FBTCxFQUFRLENBQVIsQ0FBUjtZQUNROG9CLEtBQUs5b0IsQ0FBTCxFQUFRLENBQVIsQ0FBUjs7U0FFS2lwQixNQUFQO0NBWkY7Ozs7Ozs7Ozs7Ozs7O0FBMkJBLFNBQVNDLGdCQUFULENBQTBCQyxFQUExQixFQUE4QkMsRUFBOUIsRUFBa0NDLEVBQWxDLEVBQXNDQyxFQUF0QyxFQUEwQ0MsRUFBMUMsRUFBOENDLEVBQTlDLEVBQWtEQyxFQUFsRCxFQUFzREMsRUFBdEQsRUFBMEQ7TUFDcEQzRCxhQUFhVCxNQUFNamxCLElBQU4sQ0FBVzRDLFNBQVgsQ0FBakI7TUFDSW9pQixtQkFBbUJVLFVBQW5CLENBQUosRUFBb0M7V0FDM0JWLG1CQUFtQlUsVUFBbkIsQ0FBUDs7O01BR0VyUCxPQUFPMVUsS0FBSzBVLElBQWhCO01BQ0lpVCxNQUFNM25CLEtBQUsybkIsR0FEZjtNQUNvQjFuQixNQUFNRCxLQUFLQyxHQUQvQjtNQUVJb1AsTUFBTXJQLEtBQUtxUCxHQUZmO01BRW9CdVksVUFBVSxFQUY5QjtNQUdJWCxTQUFTLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FIYjtNQUlJNVksQ0FKSjtNQUlPQyxDQUpQO01BSVVDLENBSlY7TUFJYWlILENBSmI7TUFJZ0JxUyxFQUpoQjtNQUlvQjlSLEVBSnBCO01BSXdCK1IsSUFKeEI7TUFJOEJDLFFBSjlCOztNQU1JLElBQUlaLEVBQUosR0FBUyxLQUFLRSxFQUFkLEdBQW1CLElBQUlFLEVBQTNCO01BQ0ksQ0FBQyxDQUFELEdBQUtKLEVBQUwsR0FBVSxJQUFJRSxFQUFkLEdBQW1CLElBQUlFLEVBQXZCLEdBQTRCLElBQUlFLEVBQXBDO01BQ0ksSUFBSUosRUFBSixHQUFTLElBQUlGLEVBQWpCOztPQUVLLElBQUlucEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLENBQXBCLEVBQXVCLEVBQUVBLENBQXpCLEVBQTRCO1FBQ3RCQSxJQUFJLENBQVIsRUFBVztVQUNMLElBQUlvcEIsRUFBSixHQUFTLEtBQUtFLEVBQWQsR0FBbUIsSUFBSUUsRUFBM0I7VUFDSSxDQUFDLENBQUQsR0FBS0osRUFBTCxHQUFVLElBQUlFLEVBQWQsR0FBbUIsSUFBSUUsRUFBdkIsR0FBNEIsSUFBSUUsRUFBcEM7VUFDSSxJQUFJSixFQUFKLEdBQVMsSUFBSUYsRUFBakI7OztRQUdFL1gsSUFBSWhCLENBQUosSUFBUyxLQUFiLEVBQW9CO1VBQ2RnQixJQUFJZixDQUFKLElBQVMsS0FBYixFQUFvQjs7O1VBR2hCLENBQUNDLENBQUQsR0FBS0QsQ0FBVDtVQUNJLElBQUlrSCxDQUFKLElBQVNBLElBQUksQ0FBakIsRUFBb0I7Z0JBQ1ZwWCxJQUFSLENBQWFvWCxDQUFiOzs7O1dBSUdsSCxJQUFJQSxDQUFKLEdBQVEsSUFBSUMsQ0FBSixHQUFRRixDQUF2QjtRQUNJeVosT0FBTyxDQUFYLEVBQWM7OztlQUdIcFQsS0FBS29ULElBQUwsQ0FBWDtTQUNLLENBQUMsQ0FBQ3haLENBQUQsR0FBS3laLFFBQU4sS0FBbUIsSUFBSTFaLENBQXZCLENBQUw7UUFDSSxJQUFJd1osRUFBSixJQUFVQSxLQUFLLENBQW5CLEVBQXNCO2NBQ1p6cEIsSUFBUixDQUFheXBCLEVBQWI7O1NBRUcsQ0FBQyxDQUFDdlosQ0FBRCxHQUFLeVosUUFBTixLQUFtQixJQUFJMVosQ0FBdkIsQ0FBTDtRQUNJLElBQUkwSCxFQUFKLElBQVVBLEtBQUssQ0FBbkIsRUFBc0I7Y0FDWjNYLElBQVIsQ0FBYTJYLEVBQWI7Ozs7TUFJQXhTLENBQUo7TUFBT0MsQ0FBUDtNQUFVZ2YsSUFBSW9GLFFBQVE3cEIsTUFBdEI7TUFBOEJpcUIsT0FBT3hGLENBQXJDO01BQXdDeUYsRUFBeEM7U0FDT3pGLEdBQVAsRUFBWTtRQUNOb0YsUUFBUXBGLENBQVIsQ0FBSjtTQUNLLElBQUloTixDQUFUO1FBQ0t5UyxLQUFLQSxFQUFMLEdBQVVBLEVBQVYsR0FBZWQsRUFBaEIsR0FBdUIsSUFBSWMsRUFBSixHQUFTQSxFQUFULEdBQWN6UyxDQUFkLEdBQWtCNlIsRUFBekMsR0FBZ0QsSUFBSVksRUFBSixHQUFTelMsQ0FBVCxHQUFhQSxDQUFiLEdBQWlCK1IsRUFBakUsR0FBd0UvUixJQUFJQSxDQUFKLEdBQVFBLENBQVIsR0FBWWlTLEVBQXhGO1dBQ08sQ0FBUCxFQUFVakYsQ0FBVixJQUFlamYsQ0FBZjs7UUFFSzBrQixLQUFLQSxFQUFMLEdBQVVBLEVBQVYsR0FBZWIsRUFBaEIsR0FBdUIsSUFBSWEsRUFBSixHQUFTQSxFQUFULEdBQWN6UyxDQUFkLEdBQWtCOFIsRUFBekMsR0FBZ0QsSUFBSVcsRUFBSixHQUFTelMsQ0FBVCxHQUFhQSxDQUFiLEdBQWlCZ1MsRUFBakUsR0FBd0VoUyxJQUFJQSxDQUFKLEdBQVFBLENBQVIsR0FBWWtTLEVBQXhGO1dBQ08sQ0FBUCxFQUFVbEYsQ0FBVixJQUFlaGYsQ0FBZjs7O1NBR0ssQ0FBUCxFQUFVd2tCLElBQVYsSUFBa0JiLEVBQWxCO1NBQ08sQ0FBUCxFQUFVYSxJQUFWLElBQWtCWixFQUFsQjtTQUNPLENBQVAsRUFBVVksT0FBTyxDQUFqQixJQUFzQlAsRUFBdEI7U0FDTyxDQUFQLEVBQVVPLE9BQU8sQ0FBakIsSUFBc0JOLEVBQXRCO01BQ0kxSyxTQUFTLENBQ1g7T0FDSzJLLElBQUl6WixLQUFKLENBQVUsSUFBVixFQUFnQitZLE9BQU8sQ0FBUCxDQUFoQixDQURMO09BRUtVLElBQUl6WixLQUFKLENBQVUsSUFBVixFQUFnQitZLE9BQU8sQ0FBUCxDQUFoQjtHQUhNLEVBS1g7T0FDS2huQixJQUFJaU8sS0FBSixDQUFVLElBQVYsRUFBZ0IrWSxPQUFPLENBQVAsQ0FBaEIsQ0FETDtPQUVLaG5CLElBQUlpTyxLQUFKLENBQVUsSUFBVixFQUFnQitZLE9BQU8sQ0FBUCxDQUFoQjtHQVBNLENBQWI7cUJBVW1CbEQsVUFBbkIsSUFBaUMvRyxNQUFqQztTQUNPQSxNQUFQOzs7QUFJRixVQUFlO1dBQ0Z5SixPQURFO29CQUVPUyxnQkFGUDtrQkFHS0Y7Q0FIcEI7O0FDOVBBOzs7Ozs7OztJQU9xQmtCOzs7Ozs7O3lCQVNqQjtZQURZM2tCLENBQ1osdUVBRGdCLENBQ2hCO1lBRG1CQyxDQUNuQix1RUFEdUIsQ0FDdkI7WUFEMEJpRCxLQUMxQix1RUFEa0MsQ0FDbEM7WUFEcUNDLE1BQ3JDLHVFQUQ4QyxDQUM5Qzs7Ozs7OzthQUtTbkQsQ0FBTCxHQUFTQSxDQUFUOzs7Ozs7YUFNS0MsQ0FBTCxHQUFTQSxDQUFUOzs7Ozs7YUFNS2lELEtBQUwsR0FBYUEsS0FBYjs7Ozs7O2FBTUtDLE1BQUwsR0FBY0EsTUFBZDs7Ozs7Ozs7OzthQVVLMUMsSUFBTCxHQUFZMFcsT0FBTzBHLElBQW5COzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQTRESjttQkFDVyxJQUFJOEcsU0FBSixDQUFjLEtBQUsza0IsQ0FBbkIsRUFBc0IsS0FBS0MsQ0FBM0IsRUFBOEIsS0FBS2lELEtBQW5DLEVBQTBDLEtBQUtDLE1BQS9DLENBQVA7Ozs7Ozs7Ozs7Ozs2QkFTQ3loQixXQUNMO2lCQUNTNWtCLENBQUwsR0FBUzRrQixVQUFVNWtCLENBQW5CO2lCQUNLQyxDQUFMLEdBQVMya0IsVUFBVTNrQixDQUFuQjtpQkFDS2lELEtBQUwsR0FBYTBoQixVQUFVMWhCLEtBQXZCO2lCQUNLQyxNQUFMLEdBQWN5aEIsVUFBVXpoQixNQUF4Qjs7bUJBRU8sSUFBUDs7Ozs7Ozs7Ozs7OztpQ0FVS25ELEdBQUdDLEdBQ1o7Z0JBQ1EsS0FBS2lELEtBQUwsSUFBYyxDQUFkLElBQW1CLEtBQUtDLE1BQUwsSUFBZSxDQUF0QyxFQUNBO3VCQUNXLEtBQVA7OztnQkFHQW5ELEtBQUssS0FBS0EsQ0FBVixJQUFlQSxJQUFJLEtBQUtBLENBQUwsR0FBUyxLQUFLa0QsS0FBckMsRUFDQTtvQkFDUWpELEtBQUssS0FBS0EsQ0FBVixJQUFlQSxJQUFJLEtBQUtBLENBQUwsR0FBUyxLQUFLa0QsTUFBckMsRUFDQTsyQkFDVyxJQUFQOzs7O21CQUlELEtBQVA7Ozs7Ozs7Ozs7Ozs0QkFTQTBoQixVQUFVQyxVQUNkO3VCQUNlRCxZQUFZLENBQXZCO3VCQUNXQyxhQUFjQSxhQUFhLENBQWQsR0FBbUJELFFBQW5CLEdBQThCLENBQTNDLENBQVg7O2lCQUVLN2tCLENBQUwsSUFBVTZrQixRQUFWO2lCQUNLNWtCLENBQUwsSUFBVTZrQixRQUFWOztpQkFFSzVoQixLQUFMLElBQWMyaEIsV0FBVyxDQUF6QjtpQkFDSzFoQixNQUFMLElBQWUyaEIsV0FBVyxDQUExQjs7Ozs7Ozs7Ozs7NEJBUUFGLFdBQ0o7Z0JBQ1EsS0FBSzVrQixDQUFMLEdBQVM0a0IsVUFBVTVrQixDQUF2QixFQUNBO3FCQUNTa0QsS0FBTCxJQUFjLEtBQUtsRCxDQUFuQjtvQkFDSSxLQUFLa0QsS0FBTCxHQUFhLENBQWpCLEVBQ0E7eUJBQ1NBLEtBQUwsR0FBYSxDQUFiOzs7cUJBR0NsRCxDQUFMLEdBQVM0a0IsVUFBVTVrQixDQUFuQjs7O2dCQUdBLEtBQUtDLENBQUwsR0FBUzJrQixVQUFVM2tCLENBQXZCLEVBQ0E7cUJBQ1NrRCxNQUFMLElBQWUsS0FBS2xELENBQXBCO29CQUNJLEtBQUtrRCxNQUFMLEdBQWMsQ0FBbEIsRUFDQTt5QkFDU0EsTUFBTCxHQUFjLENBQWQ7O3FCQUVDbEQsQ0FBTCxHQUFTMmtCLFVBQVUza0IsQ0FBbkI7OztnQkFHQSxLQUFLRCxDQUFMLEdBQVMsS0FBS2tELEtBQWQsR0FBc0IwaEIsVUFBVTVrQixDQUFWLEdBQWM0a0IsVUFBVTFoQixLQUFsRCxFQUNBO3FCQUNTQSxLQUFMLEdBQWEwaEIsVUFBVTFoQixLQUFWLEdBQWtCLEtBQUtsRCxDQUFwQztvQkFDSSxLQUFLa0QsS0FBTCxHQUFhLENBQWpCLEVBQ0E7eUJBQ1NBLEtBQUwsR0FBYSxDQUFiOzs7O2dCQUlKLEtBQUtqRCxDQUFMLEdBQVMsS0FBS2tELE1BQWQsR0FBdUJ5aEIsVUFBVTNrQixDQUFWLEdBQWMya0IsVUFBVXpoQixNQUFuRCxFQUNBO3FCQUNTQSxNQUFMLEdBQWN5aEIsVUFBVXpoQixNQUFWLEdBQW1CLEtBQUtsRCxDQUF0QztvQkFDSSxLQUFLa0QsTUFBTCxHQUFjLENBQWxCLEVBQ0E7eUJBQ1NBLE1BQUwsR0FBYyxDQUFkOzs7Ozs7Ozs7Ozs7O2dDQVVKeWhCLFdBQ1I7Z0JBQ1VkLEtBQUtybkIsS0FBSzJuQixHQUFMLENBQVMsS0FBS3BrQixDQUFkLEVBQWlCNGtCLFVBQVU1a0IsQ0FBM0IsQ0FBWDtnQkFDTWdrQixLQUFLdm5CLEtBQUtDLEdBQUwsQ0FBUyxLQUFLc0QsQ0FBTCxHQUFTLEtBQUtrRCxLQUF2QixFQUE4QjBoQixVQUFVNWtCLENBQVYsR0FBYzRrQixVQUFVMWhCLEtBQXRELENBQVg7Z0JBQ002Z0IsS0FBS3RuQixLQUFLMm5CLEdBQUwsQ0FBUyxLQUFLbmtCLENBQWQsRUFBaUIya0IsVUFBVTNrQixDQUEzQixDQUFYO2dCQUNNZ2tCLEtBQUt4bkIsS0FBS0MsR0FBTCxDQUFTLEtBQUt1RCxDQUFMLEdBQVMsS0FBS2tELE1BQXZCLEVBQStCeWhCLFVBQVUza0IsQ0FBVixHQUFjMmtCLFVBQVV6aEIsTUFBdkQsQ0FBWDs7aUJBRUtuRCxDQUFMLEdBQVM4akIsRUFBVDtpQkFDSzVnQixLQUFMLEdBQWE4Z0IsS0FBS0YsRUFBbEI7aUJBQ0s3akIsQ0FBTCxHQUFTOGpCLEVBQVQ7aUJBQ0s1Z0IsTUFBTCxHQUFjOGdCLEtBQUtGLEVBQW5COzs7OytCQWhMSjttQkFDVyxLQUFLL2pCLENBQVo7Ozs7Ozs7Ozs7OytCQVNKO21CQUNXLEtBQUtBLENBQUwsR0FBUyxLQUFLa0QsS0FBckI7Ozs7Ozs7Ozs7OytCQVNKO21CQUNXLEtBQUtqRCxDQUFaOzs7Ozs7Ozs7OzsrQkFTSjttQkFDVyxLQUFLQSxDQUFMLEdBQVMsS0FBS2tELE1BQXJCOzs7Ozs7Ozs7Ozs7K0JBVUo7bUJBQ1csSUFBSXdoQixTQUFKLENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixDQUFQOzs7Ozs7QUNuR1I7Ozs7Ozs7SUFNcUJJOzs7Ozs7b0JBUWpCO1FBRFkva0IsQ0FDWix1RUFEZ0IsQ0FDaEI7UUFEbUJDLENBQ25CLHVFQUR1QixDQUN2QjtRQUQwQmllLE1BQzFCLHVFQURtQyxDQUNuQzs7Ozs7OztTQUtTbGUsQ0FBTCxHQUFTQSxDQUFUOzs7Ozs7U0FNS0MsQ0FBTCxHQUFTQSxDQUFUOzs7Ozs7U0FNS2llLE1BQUwsR0FBY0EsTUFBZDs7Ozs7Ozs7OztTQVVLemQsSUFBTCxHQUFZMFcsT0FBTzZHLElBQW5COztTQUVLVixNQUFMLEdBQWMsSUFBZDs7Ozs7Ozs7Ozs7OzRCQVNKO2FBQ1csSUFBSXlILE1BQUosQ0FBVyxLQUFLL2tCLENBQWhCLEVBQW1CLEtBQUtDLENBQXhCLEVBQTJCLEtBQUtpZSxNQUFoQyxDQUFQOzs7Ozs7Ozs7Ozs7OzZCQVVLbGUsR0FBR0MsR0FDWjtVQUNRLEtBQUtpZSxNQUFMLElBQWUsQ0FBbkIsRUFDQTtlQUNXLEtBQVA7OztVQUdFM2UsS0FBSyxLQUFLMmUsTUFBTCxHQUFjLEtBQUtBLE1BQTlCO1VBQ0loUyxLQUFNLEtBQUtsTSxDQUFMLEdBQVNBLENBQW5CO1VBQ0ltTSxLQUFNLEtBQUtsTSxDQUFMLEdBQVNBLENBQW5COztZQUVNaU0sRUFBTjtZQUNNQyxFQUFOOzthQUVRRCxLQUFLQyxFQUFMLElBQVc1TSxFQUFuQjs7Ozs7Ozs7Ozs7Z0NBU0o7YUFDVyxJQUFJb2xCLFNBQUosQ0FBYyxLQUFLM2tCLENBQUwsR0FBUyxLQUFLa2UsTUFBNUIsRUFBb0MsS0FBS2plLENBQUwsR0FBUyxLQUFLaWUsTUFBbEQsRUFBMEQsS0FBS0EsTUFBTCxHQUFjLENBQXhFLEVBQTJFLEtBQUtBLE1BQUwsR0FBYyxDQUF6RixDQUFQOzs7Ozs7QUN2RlI7Ozs7Ozs7SUFNcUI4Rzs7Ozs7OztxQkFTakI7UUFEWWhsQixDQUNaLHVFQURnQixDQUNoQjtRQURtQkMsQ0FDbkIsdUVBRHVCLENBQ3ZCO1FBRDBCaUQsS0FDMUIsdUVBRGtDLENBQ2xDO1FBRHFDQyxNQUNyQyx1RUFEOEMsQ0FDOUM7Ozs7Ozs7U0FLU25ELENBQUwsR0FBU0EsQ0FBVDs7Ozs7O1NBTUtDLENBQUwsR0FBU0EsQ0FBVDs7Ozs7O1NBTUtpRCxLQUFMLEdBQWFBLEtBQWI7Ozs7OztTQU1LQyxNQUFMLEdBQWNBLE1BQWQ7Ozs7Ozs7Ozs7U0FVSzFDLElBQUwsR0FBWTBXLE9BQU9pSCxJQUFuQjs7U0FFS2QsTUFBTCxHQUFjLElBQWQ7Ozs7Ozs7Ozs7Ozs0QkFTSjthQUNXLElBQUkwSCxPQUFKLENBQVksS0FBS2hsQixDQUFqQixFQUFvQixLQUFLQyxDQUF6QixFQUE0QixLQUFLaUQsS0FBakMsRUFBd0MsS0FBS0MsTUFBN0MsQ0FBUDs7Ozs7Ozs7Ozs7Ozs2QkFVS25ELEdBQUdDLEdBQ1o7VUFDUSxLQUFLaUQsS0FBTCxJQUFjLENBQWQsSUFBbUIsS0FBS0MsTUFBTCxJQUFlLENBQXRDLEVBQ0E7ZUFDVyxLQUFQOzs7O1VBSUE4aEIsUUFBUyxDQUFDamxCLElBQUksS0FBS0EsQ0FBVixJQUFlLEtBQUtrRCxLQUFqQztVQUNJZ2lCLFFBQVMsQ0FBQ2psQixJQUFJLEtBQUtBLENBQVYsSUFBZSxLQUFLa0QsTUFBakM7O2VBRVM4aEIsS0FBVDtlQUNTQyxLQUFUOzthQUVRRCxRQUFRQyxLQUFSLElBQWlCLENBQXpCOzs7Ozs7Ozs7OztnQ0FTSjthQUNXLElBQUlQLFNBQUosQ0FBYyxLQUFLM2tCLENBQUwsR0FBUyxLQUFLa0QsS0FBNUIsRUFBbUMsS0FBS2pELENBQUwsR0FBUyxLQUFLa0QsTUFBakQsRUFBeUQsS0FBS0QsS0FBOUQsRUFBcUUsS0FBS0MsTUFBMUUsQ0FBUDs7Ozs7O0FDOUZSOzs7OztJQUlxQmdpQjs7Ozs7Ozs7dUJBVWpCOzBDQURlOUgsTUFDZjtrQkFBQTs7Ozs7WUFDUS9qQixNQUFNYSxPQUFOLENBQWNrakIsT0FBTyxDQUFQLENBQWQsQ0FBSixFQUNBO3FCQUNhQSxPQUFPLENBQVAsQ0FBVDs7OztZQUlBQSxPQUFPLENBQVAsYUFBcUJ0ZCxPQUF6QixFQUNBO2dCQUNVSyxJQUFJLEVBQVY7O2lCQUVLLElBQUkzRixJQUFJLENBQVIsRUFBVzJxQixLQUFLL0gsT0FBTzdpQixNQUE1QixFQUFvQ0MsSUFBSTJxQixFQUF4QyxFQUE0QzNxQixHQUE1QyxFQUNBO2tCQUNNSSxJQUFGLENBQU93aUIsT0FBTzVpQixDQUFQLEVBQVV1RixDQUFqQixFQUFvQnFkLE9BQU81aUIsQ0FBUCxFQUFVd0YsQ0FBOUI7OztxQkFHS0csQ0FBVDs7O2FBR0NrZCxNQUFMLEdBQWMsSUFBZDs7Ozs7OzthQU9LRCxNQUFMLEdBQWNBLE1BQWQ7Ozs7Ozs7Ozs7YUFVSzVjLElBQUwsR0FBWTBXLE9BQU8rRixJQUFuQjs7Ozs7Ozs7Ozs7O2dDQVNKO21CQUNXLElBQUlpSSxPQUFKLENBQVksS0FBSzlILE1BQUwsQ0FBWXpmLEtBQVosRUFBWixDQUFQOzs7Ozs7Ozs7O2dDQVFKO2dCQUNVeWYsU0FBUyxLQUFLQSxNQUFwQjtnQkFDSUEsT0FBTyxDQUFQLE1BQWNBLE9BQU9BLE9BQU83aUIsTUFBUCxHQUFnQixDQUF2QixDQUFkLElBQTJDNmlCLE9BQU8sQ0FBUCxNQUFjQSxPQUFPQSxPQUFPN2lCLE1BQVAsR0FBZ0IsQ0FBdkIsQ0FBN0QsRUFDQTt1QkFDV0ssSUFBUCxDQUFZd2lCLE9BQU8sQ0FBUCxDQUFaLEVBQXVCQSxPQUFPLENBQVAsQ0FBdkI7O2lCQUVDQyxNQUFMLEdBQWMsSUFBZDs7OztpQ0FHS3RkLEdBQUdDLEdBQ1o7bUJBQ1csS0FBS29sQiw4QkFBTCxDQUFvQ3JsQixDQUFwQyxFQUFzQ0MsQ0FBdEMsQ0FBUDs7Ozs7Ozs7O3VEQU8yQkQsR0FBR0MsR0FDbEM7Z0JBQ1FvZCxTQUFTLEtBQUtBLE1BQWxCO2dCQUNJaUksS0FBSyxDQUFUO2lCQUNLLElBQUlDLE1BQUosRUFBWWpTLFFBQVErSixPQUFPLENBQVAsSUFBWXBkLENBQWhDLEVBQW1DeEYsSUFBSSxDQUE1QyxFQUErQ0EsSUFBSTRpQixPQUFPN2lCLE1BQTFELEVBQWtFQyxLQUFLLENBQXZFLEVBQTBFO3lCQUM3RDZZLEtBQVQ7d0JBQ1ErSixPQUFPNWlCLENBQVAsSUFBWXdGLENBQXBCO29CQUNJc2xCLFVBQVVqUyxLQUFkLEVBQXFCO3dCQUNiNUIsSUFBSSxDQUFDNlQsU0FBUyxDQUFULEdBQWEsQ0FBZCxLQUFvQmpTLFFBQVEsQ0FBUixHQUFZLENBQWhDLENBQVI7d0JBQ0k1QixLQUFLLENBQUMyTCxPQUFPNWlCLElBQUksQ0FBWCxJQUFnQnVGLENBQWpCLEtBQXVCcWQsT0FBTzVpQixJQUFJLENBQVgsSUFBZ0J3RixDQUF2QyxJQUE0QyxDQUFDb2QsT0FBTzVpQixJQUFJLENBQVgsSUFBZ0J3RixDQUFqQixLQUF1Qm9kLE9BQU81aUIsSUFBSSxDQUFYLElBQWdCdUYsQ0FBdkMsQ0FBakQsSUFBOEYsQ0FBbEcsRUFBcUc7OEJBQzNGMFIsQ0FBTjs7OzttQkFJTDRULEVBQVA7Ozs7OztBQ3ZHUjs7OztHQUtBLEFBQ0EsQUFFQSxBQUNBLEFBQ0EsQUFDQTs7Ozs7O0FDVkE7Ozs7Ozs7Ozs7QUFVQSxJQUFJLGFBQWEsR0FBRyxTQUFTLE1BQU0sRUFBRSxPQUFPO0FBQzVDO0lBQ0ksSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDO1NBQ3ZDLE1BQU0sQ0FBQyxVQUFVLENBQUMsb0JBQW9CLEVBQUUsT0FBTyxDQUFDLENBQUM7O0lBRXRELElBQUksQ0FBQyxFQUFFO0lBQ1A7O1FBRUksTUFBTSxJQUFJLEtBQUssQ0FBQyxvRUFBb0UsQ0FBQyxDQUFDO0tBQ3pGOztJQUVELE9BQU8sRUFBRSxDQUFDO0NBQ2IsQ0FBQzs7QUFFRixtQkFBYyxHQUFHLGFBQWEsQ0FBQzs7QUN6Qi9COzs7Ozs7O0FBT0EsSUFBSSxxQkFBcUIsR0FBRyxVQUFVLEVBQUUsRUFBRSxPQUFPLEVBQUUsS0FBSztBQUN4RDtJQUNJLElBQUksQ0FBQyxDQUFDO0lBQ04sR0FBRyxLQUFLO0lBQ1I7UUFDSSxJQUFJLGVBQWUsR0FBRyxLQUFLLENBQUMsZUFBZTtZQUN2QyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQzs7UUFFcEMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtRQUMzQztZQUNJLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7U0FDOUI7OztRQUdELEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7UUFDbkM7WUFDSSxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUM7U0FDekQ7O1FBRUQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtRQUN2QztZQUNJLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLGVBQWUsQ0FBQyxDQUFDLENBQUM7WUFDekM7Z0JBQ0ksV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Z0JBRXBDLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCO29CQUNJLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDakM7O2dCQUVEO29CQUNJLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbEM7YUFDSjtTQUNKOztLQUVKOztJQUVEO1FBQ0ksS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtRQUNuQztZQUNJLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QixFQUFFLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN6RDtLQUNKO0NBQ0osQ0FBQzs7QUFFRiwyQkFBYyxHQUFHLHFCQUFxQixDQUFDOztBQ3REdkMsSUFBSSxrQkFBa0IsR0FBRyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWTVDLElBQUksTUFBTSxHQUFHLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUTtBQUM5Qzs7Ozs7OztDQU9DLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDOzs7Ozs7O0NBT2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUM7Ozs7Ozs7Q0FPaEMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLFlBQVksQ0FBQzs7Ozs7OztDQU9wQyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDOzs7Ozs7O0NBTzNDLElBQUksQ0FBQyxJQUFJLEdBQUcsa0JBQWtCLENBQUM7O0NBRS9CLEdBQUcsSUFBSTtDQUNQO0VBQ0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUNsQjs7Q0FFRCxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztDQUNuQixDQUFDOzs7Ozs7OztBQVFGLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFNBQVMsSUFBSSxFQUFFLE1BQU0sRUFBRSxRQUFRO0FBQ3pEOztDQUVDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDOztDQUUxQixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDOztDQUVqQixJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUM7Q0FDekIsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUM7O0NBRXJCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVU7Q0FDMUM7RUFDQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0VBQzFDOztDQUVEO0VBQ0MsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7RUFDOUM7O0NBRUQsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7Q0FDakIsQ0FBQzs7Ozs7QUFLRixNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRztBQUN4QjtDQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7Q0FDakIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUN0QyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxTQUFTLEVBQUUsRUFBRSxJQUFJLEVBQUUsUUFBUTtBQUN2RDtDQUNDLE9BQU8sSUFBSSxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxZQUFZLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0NBQ3ZELENBQUM7O0FBRUYsTUFBTSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRO0FBQ3REO0NBQ0MsT0FBTyxJQUFJLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLG9CQUFvQixFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztDQUMvRCxDQUFDOztBQUVGLE1BQU0sQ0FBQyxNQUFNLEdBQUcsU0FBUyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxRQUFRO0FBQ2pEO0NBQ0MsT0FBTyxJQUFJLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztDQUM1QyxDQUFDOzs7Ozs7QUFNRixNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxVQUFVO0NBQ3BDLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUNsQyxDQUFDOztBQUVGLFlBQWMsR0FBRyxNQUFNLENBQUM7O0FDckh4Qjs7Ozs7Ozs7Ozs7QUFXQSxJQUFJLE9BQU8sR0FBRyxTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJO0FBQ3REOzs7Ozs7Q0FNQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQzs7Ozs7Ozs7Q0FRYixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQzs7Ozs7Ozs7Q0FRbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7Ozs7Ozs7O0NBUXBCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7Q0FPOUIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7Ozs7OztDQU16QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQzs7Ozs7OztDQU8zQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDOzs7Ozs7O0NBT2hDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUM7OztDQUdyQyxDQUFDOzs7Ozs7QUFNRixPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxTQUFTLE1BQU07QUFDMUM7Q0FDQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7O0NBRVosSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7O0NBR2pCLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLDhCQUE4QixFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOztDQUV6RSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsVUFBVSxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUM7Q0FDakQsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLFdBQVcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDOztDQUVwRCxHQUFHLFNBQVMsS0FBSyxJQUFJLENBQUMsTUFBTSxJQUFJLFFBQVEsS0FBSyxJQUFJLENBQUMsS0FBSztDQUN2RDtFQUNDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7RUFDN0U7O0NBRUQ7S0FDSSxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0VBQzVFOzs7Q0FHRCxJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztDQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQzs7Q0FFeEIsQ0FBQzs7QUFFRixJQUFJLHdCQUF3QixHQUFHLEtBQUssQ0FBQzs7Ozs7Ozs7QUFRckMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsU0FBUyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU07QUFDM0Q7Q0FDQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7O0NBRVosSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7O0NBR2pCLEdBQUcsSUFBSSxZQUFZLFlBQVk7Q0FDL0I7RUFDQyxHQUFHLENBQUMsd0JBQXdCO0VBQzVCO0dBQ0MsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDOztHQUUvQyxHQUFHLEdBQUc7R0FDTjtJQUNDLHdCQUF3QixHQUFHLElBQUksQ0FBQztJQUNoQzs7R0FFRDtJQUNDLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztJQUN6RDtHQUNEOztFQUVELElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQztFQUNyQjs7Q0FFRDs7RUFFQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLGFBQWEsQ0FBQztFQUMxQzs7O0NBR0QsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsOEJBQThCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7OztDQUd6RSxHQUFHLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJLENBQUMsTUFBTTtDQUNqRDtFQUNDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDO0VBQ3RHOztDQUVEO0VBQ0MsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQztFQUM5Rjs7Q0FFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztDQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQzs7OztDQUlyQixDQUFDOzs7Ozs7QUFNRixPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxTQUFTLFFBQVE7QUFDMUM7Q0FDQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDOztDQUVqQixHQUFHLFFBQVEsS0FBSyxTQUFTO0NBQ3pCO0VBQ0MsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxDQUFDO0VBQ3pDOztDQUVELEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDNUMsQ0FBQzs7Ozs7QUFLRixPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRztBQUMzQjtDQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7Q0FDakIsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0NBQ3BDLENBQUM7Ozs7O0FBS0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBVSxNQUFNO0FBQzlDO0NBQ0MsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7Q0FFakIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDOztDQUVaLEdBQUcsSUFBSSxDQUFDLE1BQU07Q0FDZDtFQUNDLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsTUFBTSxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLENBQUMsc0JBQXNCLENBQUMsQ0FBQztFQUNySDs7Q0FFRDtFQUNDLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsTUFBTSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0VBQ3hGO0NBQ0QsQ0FBQzs7Ozs7QUFLRixPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLE1BQU07QUFDOUM7Q0FDQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDOztDQUVqQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7O0NBRVosRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDeEYsQ0FBQzs7Ozs7QUFLRixPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRztBQUNqQztDQUNDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7O0NBRWpCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7Q0FFWixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQzs7Q0FFbkIsRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7Q0FDakMsQ0FBQzs7Ozs7QUFLRixPQUFPLENBQUMsU0FBUyxDQUFDLG1CQUFtQixHQUFHO0FBQ3hDO0NBQ0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNyQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3JCLENBQUM7Ozs7O0FBS0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRztBQUN6QztDQUNDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDdEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUN0QixDQUFDOzs7OztBQUtGLE9BQU8sQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHO0FBQ3BDO0NBQ0MsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7Q0FFakIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDOztDQUVaLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNsRSxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUM7Q0FDeEUsQ0FBQzs7Ozs7QUFLRixPQUFPLENBQUMsU0FBUyxDQUFDLGdCQUFnQixHQUFHO0FBQ3JDO0NBQ0MsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7Q0FFakIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDOztDQUVaLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDakUsQ0FBQzs7QUFFRixPQUFPLENBQUMsU0FBUyxDQUFDLHNCQUFzQixHQUFHO0FBQzNDO0NBQ0MsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7Q0FFakIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDOztDQUVaLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUNwRSxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLENBQUM7Q0FDMUUsQ0FBQzs7Ozs7O0FBTUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUc7QUFDNUI7Q0FDQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDOztDQUVqQixFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUMvQixDQUFDOzs7Ozs7OztBQVFGLE9BQU8sQ0FBQyxVQUFVLEdBQUcsU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLGdCQUFnQjtBQUMxRDtDQUNDLElBQUksT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQzlCLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsSUFBSSxLQUFLLENBQUM7Q0FDckQsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7Q0FFdkIsT0FBTyxPQUFPLENBQUM7Q0FDZixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsUUFBUSxHQUFHLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTTtBQUNuRDs7Q0FFQyxJQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUM5QixPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7O0NBRXhDLE9BQU8sT0FBTyxDQUFDO0NBQ2YsQ0FBQzs7O0FBR0YsYUFBYyxHQUFHLE9BQU8sQ0FBQzs7QUN6VXpCOzs7Ozs7Ozs7QUFTQSxJQUFJLFdBQVcsR0FBRyxTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTTtBQUM1Qzs7Ozs7O0lBTUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7Ozs7Ozs7SUFPYixJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDOzs7Ozs7O0lBTzFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDOzs7Ozs7O0lBT3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDOzs7Ozs7O0lBT3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxJQUFJLEdBQUcsQ0FBQzs7Ozs7O0lBTTFCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQztDQUMvQixDQUFDOzs7Ozs7QUFNRixXQUFXLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxTQUFTLE9BQU87QUFDdEQ7SUFDSSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDOztJQUVqQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sSUFBSSxJQUFJRSxTQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7O0lBRTFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7Ozs7SUFJcEIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDOztJQUVaLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ3pHLENBQUM7Ozs7O0FBS0YsV0FBVyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUc7QUFDdEM7SUFDSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTzs7SUFFdkIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7SUFFakIsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzs7SUFFdkMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7SUFHbkQsRUFBRSxDQUFDLHVCQUF1QixDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLHdCQUF3QixFQUFFLEVBQUUsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7OztDQUcxRixDQUFDOzs7Ozs7Ozs7QUFTRixXQUFXLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDbEQ7SUFDSSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7O0lBRVosSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7SUFFakIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxQixFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztDQUN2RCxDQUFDOzs7OztBQUtGLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHO0FBQzdCO0lBQ0ksSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUNqQixFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0NBQ3pELENBQUM7Ozs7O0FBS0YsV0FBVyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUc7QUFDL0I7SUFDSSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ2pCLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQztDQUM3QyxDQUFDOzs7Ozs7QUFNRixXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxTQUFTLEtBQUssRUFBRSxNQUFNO0FBQ3JEO0lBQ0ksSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7SUFFakIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7O0lBRXJCLEtBQUssSUFBSSxDQUFDLE9BQU87SUFDakI7UUFDSSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQ2hEOztJQUVELEtBQUssSUFBSSxDQUFDLE9BQU87SUFDakI7O1FBRUksRUFBRSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25ELEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxhQUFhLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQzVFO0NBQ0osQ0FBQzs7Ozs7QUFLRixXQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRztBQUNoQztJQUNJLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7OztJQUdqQixHQUFHLElBQUksQ0FBQyxPQUFPO0lBQ2Y7UUFDSSxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQzFCOztJQUVELEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7O0lBRXZDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDOztJQUVmLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0NBQ3ZCLENBQUM7Ozs7Ozs7Ozs7QUFVRixXQUFXLENBQUMsVUFBVSxHQUFHLFNBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSTtBQUN6RDtJQUNJLElBQUksT0FBTyxHQUFHQSxTQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3hELE9BQU8sQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0lBQy9CLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7O0lBRzFCLElBQUksR0FBRyxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDN0MsR0FBRyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7OztJQUkzQixHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7O0lBRWIsT0FBTyxHQUFHLENBQUM7Q0FDZCxDQUFDOzs7Ozs7Ozs7O0FBVUYsV0FBVyxDQUFDLGFBQWEsR0FBRyxTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUk7QUFDNUQ7O0lBRUksSUFBSSxPQUFPLEdBQUcsSUFBSUEsU0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM1RCxPQUFPLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUMvQixPQUFPLENBQUMsZUFBZSxFQUFFLENBQUM7OztJQUcxQixJQUFJLEdBQUcsR0FBRyxJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzdDLEdBQUcsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7O0lBRTNCLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7SUFFYixPQUFPLEdBQUcsQ0FBQztDQUNkLENBQUM7O0FBRUYsbUJBQWMsR0FBRyxXQUFXLENBQUM7O0FDL043Qjs7Ozs7Ozs7O0FBU0EsSUFBSSxjQUFjLEdBQUcsU0FBUyxFQUFFLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxrQkFBa0I7QUFDNUU7SUFDSSxJQUFJLFlBQVksR0FBRyxhQUFhLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDbEUsSUFBSSxZQUFZLEdBQUcsYUFBYSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsZUFBZSxFQUFFLFdBQVcsQ0FBQyxDQUFDOztJQUV0RSxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7O0lBRWpDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3ZDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDOzs7SUFHdkMsR0FBRyxrQkFBa0I7SUFDckI7UUFDSSxJQUFJLElBQUksQ0FBQyxJQUFJLGtCQUFrQjtRQUMvQjtZQUNJLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDNUQ7S0FDSjs7O0lBR0QsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0lBR3hCLElBQUksQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUM7SUFDcEQ7UUFDSSxPQUFPLENBQUMsS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7UUFDN0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBQ3pGLE9BQU8sQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDOzs7UUFHOUMsSUFBSSxFQUFFLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRTtRQUN4QztZQUNJLE9BQU8sQ0FBQyxJQUFJLENBQUMseUNBQXlDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDMUY7O1FBRUQsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMxQixPQUFPLEdBQUcsSUFBSSxDQUFDO0tBQ2xCOzs7SUFHRCxFQUFFLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlCLEVBQUUsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7O0lBRTlCLE9BQU8sT0FBTyxDQUFDO0NBQ2xCLENBQUM7Ozs7Ozs7OztBQVNGLElBQUksYUFBYSxHQUFHLFVBQVUsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHO0FBQzNDO0lBQ0ksSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7SUFFbkMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDN0IsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7SUFFekIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLGNBQWMsQ0FBQztJQUNyRDtRQUNJLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDekMsT0FBTyxJQUFJLENBQUM7S0FDZjs7SUFFRCxPQUFPLE1BQU0sQ0FBQztDQUNqQixDQUFDOztBQUVGLG9CQUFjLEdBQUcsY0FBYyxDQUFDOztBQzdFaEMsSUFBSSxPQUFPLEdBQUcsU0FBUyxFQUFFLEVBQUUsSUFBSTtBQUMvQjtJQUNJLEdBQUcsQ0FBQyxRQUFRO0lBQ1o7UUFDSSxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7O1FBRTlDLFFBQVEsR0FBRyxFQUFFLENBQUM7O1FBRWQsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO1FBQ3hDO1lBQ0ksSUFBSSxFQUFFLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUM3QztLQUNKOztFQUVILE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3ZCLENBQUM7O0FBRUYsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDOztBQUVwQixJQUFJLGdCQUFnQixHQUFHO0VBQ3JCLE9BQU8sUUFBUSxPQUFPO0VBQ3RCLFlBQVksR0FBRyxNQUFNO0VBQ3JCLFlBQVksR0FBRyxNQUFNO0VBQ3JCLFlBQVksR0FBRyxNQUFNOztFQUVyQixLQUFLLFVBQVUsS0FBSztFQUNwQixVQUFVLEtBQUssT0FBTztFQUN0QixVQUFVLEtBQUssT0FBTztFQUN0QixVQUFVLEtBQUssT0FBTzs7RUFFdEIsTUFBTSxTQUFTLE1BQU07RUFDckIsV0FBVyxJQUFJLE9BQU87RUFDdEIsV0FBVyxJQUFJLE9BQU87RUFDdEIsV0FBVyxJQUFJLE9BQU87O0VBRXRCLFlBQVksR0FBRyxNQUFNO0VBQ3JCLFlBQVksR0FBRyxNQUFNO0VBQ3JCLFlBQVksR0FBRyxNQUFNOztFQUVyQixZQUFZLEdBQUcsV0FBVztDQUMzQixDQUFDOztBQUVGLFdBQWMsR0FBRyxPQUFPLENBQUM7O0FDN0N6Qjs7Ozs7O0FBTUEsSUFBSUMsU0FBTyxHQUFHLFNBQVMsSUFBSTtBQUMzQjtJQUNJLE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQzdCLENBQUM7OztBQUdGLElBQUksWUFBWSxHQUFHO0lBQ2YsT0FBTyxLQUFLLENBQUM7SUFDYixNQUFNLE1BQU0sQ0FBQztJQUNiLE1BQU0sTUFBTSxDQUFDO0lBQ2IsTUFBTSxNQUFNLENBQUM7O0lBRWIsS0FBSyxPQUFPLENBQUM7SUFDYixPQUFPLEtBQUssQ0FBQztJQUNiLE9BQU8sS0FBSyxDQUFDO0lBQ2IsT0FBTyxLQUFLLENBQUM7O0lBRWIsTUFBTSxNQUFNLENBQUM7SUFDYixPQUFPLEtBQUssQ0FBQztJQUNiLE9BQU8sS0FBSyxDQUFDO0lBQ2IsT0FBTyxLQUFLLENBQUM7O0lBRWIsTUFBTSxNQUFNLENBQUM7SUFDYixNQUFNLE1BQU0sQ0FBQztJQUNiLE1BQU0sTUFBTSxFQUFFOztJQUVkLFdBQVcsR0FBRyxDQUFDO0NBQ2xCLENBQUM7O0FBRUYsYUFBYyxHQUFHQSxTQUFPLENBQUM7O0FDL0J6Qjs7Ozs7Ozs7QUFRQSxJQUFJLGlCQUFpQixHQUFHLFNBQVMsRUFBRSxFQUFFLE9BQU87QUFDNUM7SUFDSSxJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7O0lBRXBCLElBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLENBQUM7O0lBRTVFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlLEVBQUUsQ0FBQyxFQUFFO0lBQ3hDO1FBQ0ksSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEQsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBRXhDLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUc7WUFDMUIsSUFBSSxDQUFDLElBQUk7WUFDVCxJQUFJLENBQUNBLFNBQU8sQ0FBQyxJQUFJLENBQUM7WUFDbEIsUUFBUSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQzs7WUFFdkQsT0FBTyxFQUFFLE9BQU87U0FDbkIsQ0FBQztLQUNMOztJQUVELE9BQU8sVUFBVSxDQUFDO0NBQ3JCLENBQUM7O0FBRUYsSUFBSSxPQUFPLEdBQUcsU0FBUyxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUM7O0lBRW5ELEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsVUFBVSxJQUFJLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztDQUNuSCxDQUFDOztBQUVGLHVCQUFjLEdBQUcsaUJBQWlCLENBQUM7O0FDeENuQzs7Ozs7O0FBTUEsSUFBSSxZQUFZLEdBQUcsU0FBUyxJQUFJLEVBQUUsSUFBSTtBQUN0QztJQUNJLFFBQVEsSUFBSTs7UUFFUixLQUFLLE9BQU87WUFDUixPQUFPLENBQUMsQ0FBQzs7UUFFYixLQUFLLE1BQU07WUFDUCxPQUFPLElBQUksWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQzs7UUFFdEMsS0FBSyxNQUFNO1lBQ1AsT0FBTyxJQUFJLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7O1FBRXRDLEtBQUssTUFBTTtZQUNQLE9BQU8sSUFBSSxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDOztRQUV0QyxLQUFLLEtBQUssQ0FBQztRQUNYLEtBQUssV0FBVztZQUNaLE9BQU8sQ0FBQyxDQUFDOztRQUViLEtBQUssT0FBTztZQUNSLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDOztRQUVwQyxLQUFLLE9BQU87WUFDUixPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQzs7UUFFcEMsS0FBSyxPQUFPO1lBQ1IsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7O1FBRXBDLEtBQUssTUFBTTtZQUNQLE9BQU8sS0FBSyxDQUFDOztRQUVqQixLQUFLLE9BQU87O1lBRVIsT0FBTyxZQUFZLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDOztRQUVuQyxLQUFLLE9BQU87WUFDUixPQUFPLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7O1FBRWxDLEtBQUssT0FBTztZQUNSLE9BQU8sWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQzs7UUFFbEMsS0FBSyxNQUFNO1lBQ1AsT0FBTyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO3FDQUNKLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDOztRQUVwQyxLQUFLLE1BQU07WUFDUCxPQUFPLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO3FDQUNQLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztxQ0FDUCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7O1FBRXZDLEtBQUssTUFBTTtZQUNQLE9BQU8sSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO3FDQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7cUNBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztxQ0FDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzdDO0NBQ0osQ0FBQzs7QUFFRixJQUFJLFlBQVksR0FBRyxTQUFTLElBQUk7QUFDaEM7SUFDSSxJQUFJLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQzs7SUFFNUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO0lBQ3JDO1FBQ0ksS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztLQUNwQjs7SUFFRCxPQUFPLEtBQUssQ0FBQztDQUNoQixDQUFDOztBQUVGLGtCQUFjLEdBQUcsWUFBWSxDQUFDOztBQzFFOUI7Ozs7Ozs7O0FBUUEsSUFBSSxlQUFlLEdBQUcsU0FBUyxFQUFFLEVBQUUsT0FBTztBQUMxQztDQUNDLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQzs7SUFFZixJQUFJLGFBQWEsR0FBRyxFQUFFLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQzs7SUFFeEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsRUFBRSxDQUFDLEVBQUU7SUFDdEM7S0FDQyxJQUFJLFdBQVcsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ2xELElBQUksSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNoRCxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7S0FFN0MsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHO01BQ2hCLElBQUksQ0FBQyxJQUFJO01BQ1QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJO01BQ3JCLFFBQVEsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQztNQUM3QyxLQUFLLENBQUNDLGNBQVksQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQztNQUMxQyxDQUFDO0tBQ0Y7O0NBRUosT0FBTyxRQUFRLENBQUM7Q0FDaEIsQ0FBQzs7QUFFRixxQkFBYyxHQUFHLGVBQWUsQ0FBQzs7QUNsQ2pDOzs7Ozs7O0FBT0EsSUFBSSxZQUFZLEdBQUcsU0FBUyxHQUFHLEVBQUUsU0FBUztBQUMxQztJQUNJLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssV0FBVztJQUN0QztRQUNJLE9BQU8sWUFBWSxHQUFHLFNBQVMsR0FBRyxXQUFXLEdBQUcsR0FBRyxDQUFDO0tBQ3ZEOztJQUVELE9BQU8sR0FBRyxDQUFDO0NBQ2QsQ0FBQzs7QUFFRixrQkFBYyxHQUFHLFlBQVksQ0FBQzs7QUNqQjlCOzs7Ozs7OztBQVFBLElBQUksMkJBQTJCLEdBQUcsU0FBUyxFQUFFLEVBQUUsV0FBVztBQUMxRDs7O0lBR0ksSUFBSSxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7O0lBRXpCLFFBQVEsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDOztJQUVqQixJQUFJLFdBQVcsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOztJQUUxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7SUFDM0M7UUFDSSxJQUFJLFFBQVEsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7O1FBRTlCLElBQUksVUFBVSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDckMsSUFBSSxJQUFJLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7OztRQUc3QyxJQUFJLFlBQVksR0FBRyxlQUFlLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDOztRQUV6RCxJQUFJLE9BQU8sSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDckMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7O1FBRWxDLFlBQVksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDOztRQUVyQixNQUFNLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxJQUFJLEVBQUU7WUFDdEMsR0FBRyxFQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUM7WUFDekIsR0FBRyxFQUFFLGNBQWMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDO1NBQ3JDLENBQUMsQ0FBQztLQUNOOztJQUVELE9BQU8sUUFBUSxDQUFDO0NBQ25CLENBQUM7O0FBRUYsSUFBSSxjQUFjLEdBQUcsU0FBUyxJQUFJO0FBQ2xDO0NBQ0MsSUFBSSxRQUFRLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Q0FDbEQsT0FBTyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUM5QixDQUFDOztBQUVGLElBQUksY0FBYyxHQUFHLFNBQVMsSUFBSSxFQUFFLE9BQU87QUFDM0M7SUFDSSxJQUFJLFFBQVEsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuRCxJQUFJLFdBQVcsQ0FBQzs7SUFFaEIsR0FBRyxPQUFPLENBQUMsSUFBSSxLQUFLLENBQUM7SUFDckI7UUFDSSxXQUFXLEdBQUcsc0JBQXNCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3REOztJQUVEO1FBQ0ksV0FBVyxHQUFHLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNyRDs7SUFFRCxHQUFHLFdBQVc7SUFDZDtRQUNJLFFBQVEsSUFBSSxZQUFZLEdBQUcsV0FBVyxHQUFHLEdBQUcsQ0FBQztLQUNoRDs7R0FFRixPQUFPLElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztDQUN6QyxDQUFDOztBQUVGLElBQUksZUFBZSxHQUFHLFNBQVMsVUFBVSxFQUFFLE9BQU87QUFDbEQ7SUFDSSxJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUM7O0lBRWxCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDOUM7UUFDSSxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QixHQUFHLEdBQUcsQ0FBQyxDQUFDO0tBQ1g7O0lBRUQsT0FBTyxHQUFHLENBQUM7Q0FDZCxDQUFDOztBQUVGLElBQUksY0FBYyxHQUFHO0lBQ2pCLDRCQUE0QjtDQUMvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFYixJQUFJLGNBQWMsR0FBRztJQUNqQiw2QkFBNkI7SUFDN0IsdUNBQXVDO0NBQzFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOzs7QUFHYixJQUFJLHNCQUFzQixHQUFHOztJQUV6QixPQUFPLEtBQUssNEJBQTRCOztJQUV4QyxNQUFNLE1BQU0seUNBQXlDO0lBQ3JELE1BQU0sTUFBTSxtREFBbUQ7SUFDL0QsTUFBTSxNQUFNLDZEQUE2RDs7SUFFekUsS0FBSyxPQUFPLDRCQUE0QjtJQUN4QyxPQUFPLEtBQUsseUNBQXlDO0lBQ3JELE9BQU8sS0FBSyxtREFBbUQ7SUFDL0QsT0FBTyxLQUFLLDZEQUE2RDs7SUFFekUsTUFBTSxNQUFNLDRCQUE0QjtJQUN4QyxPQUFPLEtBQUsseUNBQXlDO0lBQ3JELE9BQU8sS0FBSyxtREFBbUQ7SUFDL0QsT0FBTyxLQUFLLDZEQUE2RDs7SUFFekUsTUFBTSxNQUFNLDBDQUEwQztJQUN0RCxNQUFNLE1BQU0sMENBQTBDO0lBQ3RELE1BQU0sTUFBTSwwQ0FBMEM7O0lBRXRELFdBQVcsQ0FBQyw0QkFBNEI7Q0FDM0MsQ0FBQzs7QUFFRixJQUFJLHFCQUFxQixHQUFHOztJQUV4QixPQUFPLEtBQUssNkJBQTZCOztJQUV6QyxNQUFNLE1BQU0sNkJBQTZCO0lBQ3pDLE1BQU0sTUFBTSw2QkFBNkI7SUFDekMsTUFBTSxNQUFNLDZCQUE2Qjs7SUFFekMsS0FBSyxPQUFPLDZCQUE2QjtJQUN6QyxPQUFPLEtBQUssNkJBQTZCO0lBQ3pDLE9BQU8sS0FBSyw2QkFBNkI7SUFDekMsT0FBTyxLQUFLLDZCQUE2Qjs7SUFFekMsTUFBTSxNQUFNLDZCQUE2QjtJQUN6QyxPQUFPLEtBQUssNkJBQTZCO0lBQ3pDLE9BQU8sS0FBSyw2QkFBNkI7SUFDekMsT0FBTyxLQUFLLDZCQUE2Qjs7SUFFekMsV0FBVyxDQUFDLDZCQUE2QjtDQUM1QyxDQUFDOztBQUVGLGlDQUFjLEdBQUcsMkJBQTJCLENBQUM7O0FDckk3Qzs7Ozs7Ozs7Ozs7QUFXQSxJQUFJLE1BQU0sR0FBRyxTQUFTLEVBQUUsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxrQkFBa0I7QUFDL0U7Ozs7OztDQU1DLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDOztDQUViLEdBQUcsU0FBUztDQUNaO0VBQ0MsU0FBUyxHQUFHQyxjQUFZLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0VBQy9DLFdBQVcsR0FBR0EsY0FBWSxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztFQUNuRDs7Ozs7Ozs7Q0FRRCxJQUFJLENBQUMsT0FBTyxHQUFHQyxnQkFBYyxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLGtCQUFrQixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Q0FhOUUsSUFBSSxDQUFDLFVBQVUsR0FBR0MsbUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7SUFFbkQsSUFBSSxDQUFDLFdBQVcsR0FBR0MsaUJBQWUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7Ozs7O0NBVXhELElBQUksQ0FBQyxRQUFRLEdBQUdDLDZCQUEyQixFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7O0NBRXBFLENBQUM7Ozs7QUFJRixNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRztBQUN4QjtDQUNDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUNqQyxDQUFDOzs7Ozs7QUFNRixNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRztBQUMzQjtDQUNDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0NBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0NBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDOztDQUVyQixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0NBQ2pCLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQy9CLENBQUM7OztBQUdGLFlBQWMsR0FBRyxNQUFNLENBQUM7O0FDekZ4Qjs7Ozs7Ozs7Ozs7QUFXQSxTQUFTLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxLQUFLO0FBQ3BDO0lBQ0ksSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQzs7SUFFL0IsR0FBRyxDQUFDLGlCQUFpQixDQUFDLFlBQVk7SUFDbEM7UUFDSSxJQUFJLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyx5QkFBeUIsQ0FBQztrQ0FDMUMsRUFBRSxDQUFDLFlBQVksQ0FBQyw2QkFBNkIsQ0FBQztrQ0FDOUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0tBQy9FOztJQUVELElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDOztJQUV6QixHQUFHLElBQUksQ0FBQyxrQkFBa0I7SUFDMUI7UUFDSSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDOztRQUVoRSxJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOzs7UUFHeEQsSUFBSSxDQUFDLFdBQVcsR0FBRztZQUNmLGVBQWUsRUFBRSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUM7WUFDdEMsV0FBVyxFQUFFLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQztTQUNyQyxDQUFDO0tBQ0w7Ozs7Ozs7SUFPRCxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQzs7Ozs7OztJQU9iLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDOzs7OztJQUtyQixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzs7Ozs7OztJQU94QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztDQUN0Qjs7QUFFRCxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLGlCQUFpQixDQUFDO0FBQzVELHVCQUFjLEdBQUcsaUJBQWlCLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFhbkMsaUJBQWlCLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQzs7Ozs7QUFLdkMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRztBQUNuQztJQUNJLEdBQUcsSUFBSSxDQUFDLFNBQVM7SUFDakI7UUFDSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztRQUUzRCxHQUFHLElBQUksQ0FBQyxLQUFLO1FBQ2I7WUFDSSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztZQUNuQixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDbkI7S0FDSjs7SUFFRDs7UUFFSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDbkI7O0lBRUQsT0FBTyxJQUFJLENBQUM7Q0FDZixDQUFDOzs7OztBQUtGLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUc7QUFDckM7SUFDSSxHQUFHLElBQUksQ0FBQyxTQUFTO0lBQ2pCO1FBQ0ksSUFBSSxDQUFDLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3BEOztJQUVELE9BQU8sSUFBSSxDQUFDO0NBQ2YsQ0FBQzs7Ozs7QUFLRixpQkFBaUIsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHO0FBQ3ZDOztJQUVJLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7SUFDakIsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDOztJQUV0QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO0lBQy9DO1FBQ0ksSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7UUFFaEMsR0FBRyxVQUFVLEtBQUssTUFBTSxDQUFDLE1BQU07UUFDL0I7WUFDSSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JCLFVBQVUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCOztRQUVELEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVE7K0JBQ3pCLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSTsrQkFDckIsTUFBTSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsS0FBSzsrQkFDdkIsTUFBTSxDQUFDLFVBQVUsSUFBSSxLQUFLOytCQUMxQixNQUFNLENBQUMsTUFBTSxJQUFJLENBQUM7K0JBQ2xCLE1BQU0sQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7S0FDN0M7O0lBRURDLHVCQUFxQixDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQzs7SUFFN0QsR0FBRyxJQUFJLENBQUMsV0FBVztJQUNuQjtRQUNJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDM0I7O0lBRUQsT0FBTyxJQUFJLENBQUM7Q0FDZixDQUFDOzs7Ozs7Ozs7OztBQVdGLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUs7QUFDdEc7SUFDSSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztRQUNqQixNQUFNLE1BQU0sTUFBTTtRQUNsQixTQUFTLEdBQUcsU0FBUzs7UUFFckIsUUFBUSxJQUFJLFNBQVMsQ0FBQyxRQUFRO1FBQzlCLElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLO1FBQ2pDLFVBQVUsRUFBRSxVQUFVLElBQUksS0FBSztRQUMvQixNQUFNLE1BQU0sTUFBTSxJQUFJLENBQUM7UUFDdkIsS0FBSyxPQUFPLEtBQUssSUFBSSxDQUFDO0tBQ3pCLENBQUMsQ0FBQzs7SUFFSCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7SUFFbEIsT0FBTyxJQUFJLENBQUM7Q0FDZixDQUFDOzs7Ozs7QUFNRixpQkFBaUIsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFNBQVMsTUFBTTtBQUN0RDtJQUNJLElBQUksQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDOztJQUUxQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7SUFFbEIsT0FBTyxJQUFJLENBQUM7Q0FDZixDQUFDOzs7OztBQUtGLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUc7QUFDcEM7Ozs7O0lBS0ksR0FBRyxJQUFJLENBQUMsU0FBUztJQUNqQjtRQUNJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDOUQ7O0lBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQzNCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDOztJQUV4QixPQUFPLElBQUksQ0FBQztDQUNmLENBQUM7Ozs7Ozs7QUFPRixpQkFBaUIsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFNBQVMsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLO0FBQzdEO0lBQ0ksSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7SUFFakIsR0FBRyxJQUFJLENBQUMsV0FBVztJQUNuQjtRQUNJLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7S0FDckc7O0lBRUQ7O1FBRUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUN0RDs7SUFFRCxPQUFPLElBQUksQ0FBQztDQUNmLENBQUM7Ozs7O0FBS0YsaUJBQWlCLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRztBQUN0Qzs7SUFFSSxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQztJQUNmLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0lBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDOztJQUV4QixHQUFHLElBQUksQ0FBQyxTQUFTO0lBQ2pCO1FBQ0ksSUFBSSxDQUFDLGtCQUFrQixDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUNoRTs7SUFFRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO0lBQy9CLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0NBQ3pCLENBQUM7O0FBRUYsaUJBQWlCLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRztBQUN0QztJQUNJLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3JGLENBQUM7O0FDclFGLFdBQWMsR0FBRztJQUNiLGNBQWMsRUFBRUMsZ0JBQTJCO0lBQzNDLFlBQVksRUFBRUMsY0FBeUI7SUFDdkMsaUJBQWlCLEVBQUVDLG1CQUE4QjtJQUNqRCxlQUFlLEVBQUVDLGlCQUE0QjtJQUM3QywyQkFBMkIsRUFBRUMsNkJBQXdDO0lBQ3JFLFlBQVksRUFBRUMsY0FBeUI7SUFDdkMsT0FBTyxFQUFFQyxTQUFvQjtJQUM3QixPQUFPLEVBQUVDLE9BQW9CO0NBQ2hDOzs7QUNURCxJQUFJLEVBQUUsR0FBRztJQUNMLGFBQWEsV0FBV1AsZUFBMEI7SUFDbEQscUJBQXFCLEdBQUdDLHVCQUFrQztJQUMxRCxRQUFRLGdCQUFnQkMsUUFBcUI7SUFDN0MsYUFBYSxXQUFXQyxlQUEwQjtJQUNsRCxRQUFRLGdCQUFnQkMsUUFBcUI7SUFDN0MsU0FBUyxlQUFlQyxTQUFzQjtJQUM5QyxpQkFBaUIsT0FBT0MsbUJBQThCO0lBQ3RELE1BQU0sa0JBQWtCQyxPQUFtQjtDQUM5QyxDQUFDOzs7QUFHRixJQUFJLFFBQWEsS0FBSyxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87QUFDbkQ7O0lBRUksY0FBYyxHQUFHLEVBQUUsQ0FBQztDQUN2Qjs7O0FBR0QsSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXO0FBQ2pDOztJQUVJLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7SUFDaEMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0NBQzNCOzs7QUNsQkQsSUFBTUMsZ0JBQWdCQyxNQUFPRCxhQUE3Qjs7SUFFcUJFOzBCQUdMOW1CLEVBQVosRUFBZ0JxRCxLQUFoQixFQUF1QkMsTUFBdkIsRUFBK0J5akIsVUFBL0IsRUFBMkMzaEIsSUFBM0MsRUFDQTs7OzthQUVTcEYsRUFBTCxHQUFVQSxFQUFWOzs7YUFHS2duQixXQUFMLEdBQW1CLElBQW5COzthQUVLQyxVQUFMLEdBQWtCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFsQjs7YUFFS0MsSUFBTCxHQUFZLElBQUlwQyxTQUFKLENBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixDQUFaOzs7OzthQUtLaUMsVUFBTCxHQUFrQkEsY0FBY3ZqQixTQUFTQyxVQUF6Qzs7O2FBR0swakIsZ0JBQUwsR0FBd0IsSUFBSW5jLE1BQUosRUFBeEI7O2FBRUtvYyxLQUFMLEdBQWEsSUFBYjs7YUFFS0MsWUFBTCxHQUFvQixJQUFJdkMsU0FBSixFQUFwQjthQUNLd0MsZ0JBQUwsR0FBd0IsSUFBeEI7YUFDS0MsV0FBTCxHQUFtQixJQUFuQjs7YUFFS25pQixJQUFMLEdBQVlBLElBQVo7O2FBRUs0aEIsV0FBTCxHQUFtQixJQUFJSixhQUFKLENBQWtCNW1CLEVBQWxCLEVBQXNCLEdBQXRCLEVBQTJCLEdBQTNCLENBQW5CO2FBQ0tnbkIsV0FBTCxDQUFpQlEsV0FBakIsR0FBK0IsSUFBL0I7O2FBRUtDLFFBQUw7O2FBRUtDLE1BQUwsQ0FBWXJrQixLQUFaLEVBQW1CQyxNQUFuQjs7Ozs7OEJBR0UyakIsWUFDTjtnQkFDVVUsS0FBS1YsY0FBYyxLQUFLQSxVQUE5Qjs7aUJBRUtELFdBQUwsQ0FBaUJZLEtBQWpCLENBQXVCRCxHQUFHLENBQUgsQ0FBdkIsRUFBOEJBLEdBQUcsQ0FBSCxDQUE5QixFQUFxQ0EsR0FBRyxDQUFILENBQXJDLEVBQTRDQSxHQUFHLENBQUgsQ0FBNUMsRUFISjs7OztpQ0FNU0wsa0JBQWtCQyxhQUMzQjtpQkFDU0QsZ0JBQUwsR0FBd0JBLG9CQUFvQixLQUFLQSxnQkFBekIsSUFBNkMsS0FBS0QsWUFBMUU7aUJBQ0tFLFdBQUwsR0FBbUJBLGVBQWUsS0FBS0EsV0FBcEIsSUFBbUNELGdCQUF0RDs7Ozs7OzttQ0FLSjtnQkFDVXRuQixLQUFLLEtBQUtBLEVBQWhCOztpQkFFS2duQixXQUFMLENBQWlCblosSUFBakI7O2lCQUVLZ2EsbUJBQUwsQ0FBeUIsS0FBS1AsZ0JBQTlCLEVBQWdELEtBQUtDLFdBQXJEOztnQkFFSSxLQUFLRCxnQkFBTCxLQUEwQixLQUFLQyxXQUFuQyxFQUNBO21CQUNPTyxNQUFILENBQVU5bkIsR0FBRytuQixZQUFiO21CQUNHQyxPQUFILENBQ0ksS0FBS1YsZ0JBQUwsQ0FBc0JubkIsQ0FBdEIsR0FBMEIsQ0FEOUIsRUFFSSxLQUFLbW5CLGdCQUFMLENBQXNCbG5CLENBQXRCLEdBQTBCLENBRjlCLEVBR0ssS0FBS2tuQixnQkFBTCxDQUFzQmprQixLQUF0QixHQUE4QixLQUFLMGpCLFVBQXBDLEdBQWtELENBSHRELEVBSUssS0FBS08sZ0JBQUwsQ0FBc0Joa0IsTUFBdEIsR0FBK0IsS0FBS3lqQixVQUFyQyxHQUFtRCxDQUp2RDthQUhKLE1BV0E7bUJBQ09rQixPQUFILENBQVdqb0IsR0FBRytuQixZQUFkOzs7ZUFHREcsUUFBSCxDQUNJLEtBQUtaLGdCQUFMLENBQXNCbm5CLENBQXRCLEdBQTBCLENBRDlCLEVBRUksS0FBS21uQixnQkFBTCxDQUFzQmxuQixDQUF0QixHQUEwQixDQUY5QixFQUdLLEtBQUtrbkIsZ0JBQUwsQ0FBc0Jqa0IsS0FBdEIsR0FBOEIsS0FBSzBqQixVQUFwQyxHQUFrRCxDQUh0RCxFQUlLLEtBQUtPLGdCQUFMLENBQXNCaGtCLE1BQXRCLEdBQStCLEtBQUt5akIsVUFBckMsR0FBbUQsQ0FKdkQ7Ozs7Ozs7NENBU2dCTyxrQkFBa0JDLGFBQ3RDO2dCQUNVWSxLQUFLLEtBQUtoQixnQkFBaEI7OzBCQUVjSSxlQUFlRCxnQkFBN0I7O2VBRUcvckIsUUFBSDs7ZUFFRzBQLENBQUgsR0FBTyxJQUFJcWMsaUJBQWlCamtCLEtBQXJCLEdBQTZCLENBQXBDO2VBQ0crSCxDQUFILEdBQU8sQ0FBQyxDQUFELEdBQUtrYyxpQkFBaUJoa0IsTUFBdEIsR0FBK0IsQ0FBdEM7O2VBRUcrSCxFQUFILEdBQVEsQ0FBQyxDQUFELEdBQU1rYyxZQUFZcG5CLENBQVosR0FBZ0Jnb0IsR0FBR2xkLENBQWpDO2VBQ0dLLEVBQUgsR0FBUSxJQUFLaWMsWUFBWW5uQixDQUFaLEdBQWdCK25CLEdBQUcvYyxDQUFoQzs7Ozs7OzsrQkFJRy9ILE9BQU9DLFFBQ2Q7b0JBQ1lELFFBQVEsQ0FBaEI7cUJBQ1NDLFNBQVMsQ0FBbEI7O2dCQUVJLEtBQUs0akIsSUFBTCxDQUFVN2pCLEtBQVYsS0FBb0JBLEtBQXBCLElBQTZCLEtBQUs2akIsSUFBTCxDQUFVNWpCLE1BQVYsS0FBcUJBLE1BQXRELEVBQ0E7Ozs7aUJBSUs0akIsSUFBTCxDQUFVN2pCLEtBQVYsR0FBa0JBLEtBQWxCO2lCQUNLNmpCLElBQUwsQ0FBVTVqQixNQUFWLEdBQW1CQSxNQUFuQjs7aUJBRUsrakIsWUFBTCxDQUFrQmhrQixLQUFsQixHQUEwQkEsS0FBMUI7aUJBQ0tna0IsWUFBTCxDQUFrQi9qQixNQUFsQixHQUEyQkEsTUFBM0I7O2lCQUVLMGpCLFdBQUwsQ0FBaUJVLE1BQWpCLENBQXdCcmtCLFFBQVEsS0FBSzBqQixVQUFyQyxFQUFpRHpqQixTQUFTLEtBQUt5akIsVUFBL0Q7O2dCQUVNcUIsa0JBQWtCLEtBQUtoQixLQUFMLElBQWMsS0FBS0YsSUFBM0M7O2lCQUVLVyxtQkFBTCxDQUF5Qk8sZUFBekI7Ozs7a0NBSUo7aUJBQ1NwQixXQUFMLENBQWlCbmUsT0FBakI7aUJBQ0ttZSxXQUFMLEdBQW1CLElBQW5COzs7Ozs7SUN0SWFxQjs0QkFFTHJMLFFBQVosRUFDQTs7O2FBQ1NBLFFBQUwsR0FBZ0JBLFFBQWhCOzs7OztnQ0FJSjs7OytCQUtBO2lCQUNTc0wsS0FBTDs7OztnQ0FJSjs7O2tDQUtBO2lCQUNTdEwsUUFBTCxDQUFjdUwsR0FBZCxDQUFrQixTQUFsQixFQUE2QixLQUFLQyxlQUFsQyxFQUFtRCxJQUFuRDs7aUJBRUt4TCxRQUFMLEdBQWdCLElBQWhCOzs7OytCQUdHL08sUUFDUDs7Ozs7QUM5QkosSUFBTXdhLGFBQWEsQ0FBbkI7QUFDQSxJQUFNQyxhQUFhLENBQW5CO0FBQ0EsSUFBTUMsWUFBWSxDQUFsQjs7Ozs7Ozs7O0lBUXFCQzs7Ozt3QkFLTDVvQixFQUFaLEVBQ0E7Ozs7Ozs7O2FBTVM2b0IsV0FBTCxHQUFtQixJQUFJQyxVQUFKLENBQWUsRUFBZixDQUFuQjs7Ozs7OzthQU9LQyxZQUFMLEdBQW9CLElBQUlELFVBQUosQ0FBZSxFQUFmLENBQXBCOzs7YUFHS0MsWUFBTCxDQUFrQixDQUFsQixJQUF1QixDQUF2Qjs7Ozs7Ozs7YUFRS0MsVUFBTCxHQUFrQixDQUFsQjs7Ozs7Ozs7YUFRS0MsS0FBTCxHQUFhLEVBQWI7Ozs7Ozs7YUFPS2pwQixFQUFMLEdBQVVBLEVBQVY7O2FBRUtrcEIsVUFBTCxHQUFrQmxwQixHQUFHbXBCLFlBQUgsQ0FBZ0JucEIsR0FBR29wQixrQkFBbkIsQ0FBbEI7O2FBRUtDLFdBQUwsR0FBbUI7NkJBQ0UsSUFBSTV2QixLQUFKLENBQVUsS0FBS3l2QixVQUFmLENBREY7eUJBRUYsSUFBSXp2QixLQUFKLENBQVUsS0FBS3l2QixVQUFmO1NBRmpCOzs7YUFPS0ksa0JBQUwsR0FDSXRwQixHQUFHdXBCLFlBQUgsQ0FBZ0IseUJBQWhCLEtBQ0d2cEIsR0FBR3VwQixZQUFILENBQWdCLDZCQUFoQixDQURILElBRUd2cEIsR0FBR3VwQixZQUFILENBQWdCLGdDQUFoQixDQUhQOzs7Ozs7Ozs7OytCQVdKOztnQkFFUUMsUUFBUSxLQUFLUCxLQUFMLENBQVcsRUFBRSxLQUFLRCxVQUFsQixDQUFaOztnQkFFSSxDQUFDUSxLQUFMLEVBQ0E7d0JBQ1ksS0FBS1AsS0FBTCxDQUFXLEtBQUtELFVBQWhCLElBQThCLElBQUlGLFVBQUosQ0FBZSxFQUFmLENBQXRDOzs7OztpQkFLQyxJQUFJbHVCLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLaXVCLFdBQUwsQ0FBaUJsdUIsTUFBckMsRUFBNkNDLEdBQTdDLEVBQ0E7cUJBQ1NpdUIsV0FBTCxDQUFpQmp1QixDQUFqQixJQUFzQjR1QixNQUFNNXVCLENBQU4sQ0FBdEI7Ozs7Ozs7Ozs7OEJBUVI7Z0JBQ1U0dUIsUUFBUSxLQUFLUCxLQUFMLENBQVcsRUFBRSxLQUFLRCxVQUFsQixDQUFkOztpQkFFS1MsUUFBTCxDQUFjRCxLQUFkOzs7Ozs7Ozs7OztpQ0FRS0EsT0FDVDtpQkFDU0UsWUFBTCxDQUFrQkYsTUFBTWYsVUFBTixDQUFsQjtpQkFDS2tCLFlBQUwsQ0FBa0JILE1BQU1kLFVBQU4sQ0FBbEI7aUJBQ0trQixXQUFMLENBQWlCSixNQUFNYixTQUFOLENBQWpCOzs7Ozs7Ozs7OztxQ0FTU2p0QixPQUNiO29CQUNZQSxRQUFRLENBQVIsR0FBWSxDQUFwQjs7Z0JBRUksS0FBS210QixXQUFMLENBQWlCSixVQUFqQixNQUFpQy9zQixLQUFyQyxFQUNBOzs7O2lCQUlLbXRCLFdBQUwsQ0FBaUJKLFVBQWpCLElBQStCL3NCLEtBQS9CO2lCQUNLc0UsRUFBTCxDQUFRdEUsUUFBUSxRQUFSLEdBQW1CLFNBQTNCLEVBQXNDLEtBQUtzRSxFQUFMLENBQVF5b0IsVUFBOUM7Ozs7Ozs7Ozs7O29DQVFRL3NCLE9BQ1o7b0JBQ1lBLFFBQVEsQ0FBUixHQUFZLENBQXBCOztnQkFFSSxLQUFLbXRCLFdBQUwsQ0FBaUJGLFNBQWpCLE1BQWdDanRCLEtBQXBDLEVBQ0E7Ozs7aUJBSUttdEIsV0FBTCxDQUFpQkYsU0FBakIsSUFBOEJqdEIsS0FBOUI7aUJBQ0tzRSxFQUFMLENBQVF0RSxRQUFRLFFBQVIsR0FBbUIsU0FBM0IsRUFBc0MsS0FBS3NFLEVBQUwsQ0FBUTJvQixTQUE5Qzs7Ozs7Ozs7Ozs7cUNBUVNqdEIsT0FDYjtvQkFDWUEsUUFBUSxDQUFSLEdBQVksQ0FBcEI7O2dCQUVJLEtBQUttdEIsV0FBTCxDQUFpQkgsVUFBakIsTUFBaUNodEIsS0FBckMsRUFDQTs7OztpQkFJS210QixXQUFMLENBQWlCSCxVQUFqQixJQUErQmh0QixLQUEvQjtpQkFDS3NFLEVBQUwsQ0FBUTZwQixTQUFSLENBQWtCLEtBQUs3cEIsRUFBTCxDQUFRdEUsUUFBUSxJQUFSLEdBQWUsS0FBdkIsQ0FBbEI7Ozs7Ozs7Ozs7MENBUUo7aUJBQ1MsSUFBSWQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUt5dUIsV0FBTCxDQUFpQlMsZUFBakIsQ0FBaUNudkIsTUFBckQsRUFBNkRDLEdBQTdELEVBQ0E7cUJBQ1N5dUIsV0FBTCxDQUFpQlMsZUFBakIsQ0FBaUNsdkIsQ0FBakMsSUFBc0MsQ0FBdEM7OztpQkFHQyxJQUFJQSxLQUFJLENBQWIsRUFBZ0JBLEtBQUksS0FBS3l1QixXQUFMLENBQWlCQSxXQUFqQixDQUE2QjF1QixNQUFqRCxFQUF5REMsSUFBekQsRUFDQTtxQkFDU3l1QixXQUFMLENBQWlCQSxXQUFqQixDQUE2Qnp1QixFQUE3QixJQUFrQyxDQUFsQzs7OztpQkFJQyxJQUFJQSxNQUFJLENBQWIsRUFBZ0JBLE1BQUksS0FBS3N1QixVQUF6QixFQUFxQ3R1QixLQUFyQyxFQUNBO3FCQUNTb0YsRUFBTCxDQUFRK3BCLHdCQUFSLENBQWlDbnZCLEdBQWpDOzs7Ozs7Ozs7Ozt5Q0FTUjs7Z0JBRVEsS0FBSzB1QixrQkFBVCxFQUNBO3FCQUNTQSxrQkFBTCxDQUF3QlUsa0JBQXhCLENBQTJDLElBQTNDOzs7O2lCQUlDQyxlQUFMOzs7aUJBR0ssSUFBSXJ2QixJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS2l1QixXQUFMLENBQWlCbHVCLE1BQXJDLEVBQTZDLEVBQUVDLENBQS9DLEVBQ0E7cUJBQ1NpdUIsV0FBTCxDQUFpQmp1QixDQUFqQixJQUFzQixFQUF0Qjs7O2lCQUdDb0YsRUFBTCxDQUFRa3FCLFdBQVIsQ0FBb0IsS0FBS2xxQixFQUFMLENBQVFtcUIsbUJBQTVCLEVBQWlELEtBQWpEOztpQkFFS1YsUUFBTCxDQUFjLEtBQUtWLFlBQW5COzs7Ozs7QUN6TkQsU0FBU3FCLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCN2QsR0FBdEIsRUFBMEI7VUFDdkJBLE9BQU8sRUFBYjs7UUFFSSxDQUFKLElBQVMsQ0FBRTZkLE9BQU8sRUFBUixHQUFjLElBQWYsSUFBdUIsR0FBaEM7UUFDSSxDQUFKLElBQVMsQ0FBRUEsT0FBTyxDQUFSLEdBQWEsSUFBZCxJQUFzQixHQUEvQjtRQUNJLENBQUosSUFBUyxDQUFDQSxNQUFNLElBQVAsSUFBZSxHQUF4Qjs7V0FFTzdkLEdBQVA7Q0FHSixBQUFPLEFBT1AsQUFBTzs7QUNoQlA7Ozs7Ozs7O0lBT3FCOGQ7Ozs7Ozs2QkFPTHRxQixFQUFaLEVBQWdCdXFCLE1BQWhCLEVBQXdCQyxZQUF4QixFQUNBOzs7Ozs7OztTQU1TeHFCLEVBQUwsR0FBVUEsRUFBVjs7Ozs7OztTQU9LeXFCLEtBQUwsR0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFiLENBYko7Ozs7OztTQW1CU2pOLE1BQUwsR0FBYyxFQUFkOzs7Ozs7U0FNS2tOLE9BQUwsR0FBZSxFQUFmOzs7OztTQUtLeFQsTUFBTCxHQUFjMlAsTUFBTzhELFFBQVAsQ0FBZ0JDLGtCQUFoQixDQUFtQzVxQixFQUFuQyxDQUFkOzs7Ozs7U0FNSzZxQixXQUFMLEdBQW1CaEUsTUFBTzhELFFBQVAsQ0FBZ0JHLGlCQUFoQixDQUFrQzlxQixFQUFsQyxDQUFuQjs7Ozs7O1NBTUsrcUIsS0FBTCxHQUFhLElBQWI7O1NBRUtDLFFBQUwsR0FBZ0IsSUFBaEI7U0FDS0MsU0FBTCxHQUFpQixJQUFqQjs7Ozs7O1NBTUtWLE1BQUwsR0FBY0EsTUFBZDs7U0FFS1csR0FBTCxHQUFXLElBQUlyRSxNQUFPc0UsaUJBQVgsQ0FBNkJuckIsRUFBN0IsRUFBaUN3cUIsWUFBakMsRUFDVlksUUFEVSxDQUNELEtBQUtQLFdBREosRUFFVlEsWUFGVSxDQUVHLEtBQUtuVSxNQUZSLEVBRWdCcVQsT0FBT2UsVUFBUCxDQUFrQkMsZUFGbEMsRUFFbUR2ckIsR0FBR3dyQixLQUZ0RCxFQUU2RCxLQUY3RCxFQUVvRSxJQUFJLENBRnhFLEVBRTJFLENBRjNFLEVBR1ZILFlBSFUsQ0FHRyxLQUFLblUsTUFIUixFQUdnQnFULE9BQU9lLFVBQVAsQ0FBa0JHLE1BSGxDLEVBRzBDenJCLEdBQUd3ckIsS0FIN0MsRUFHb0QsS0FIcEQsRUFHMkQsSUFBSSxDQUgvRCxFQUdrRSxJQUFJLENBSHRFLENBQVg7Ozs7Ozs7Ozs7NEJBVUo7V0FDU2hPLE1BQUwsQ0FBWTdpQixNQUFaLEdBQXFCLENBQXJCO1dBQ0srdkIsT0FBTCxDQUFhL3ZCLE1BQWIsR0FBc0IsQ0FBdEI7Ozs7Ozs7Ozs2QkFPSjtXQUNTcXdCLFFBQUwsR0FBZ0IsSUFBSXZlLFlBQUosQ0FBaUIsS0FBSytRLE1BQXRCLENBQWhCO1dBQ0t0RyxNQUFMLENBQVl3VSxNQUFaLENBQW1CLEtBQUtWLFFBQXhCOztXQUVLQyxTQUFMLEdBQWlCLElBQUlVLFdBQUosQ0FBZ0IsS0FBS2pCLE9BQXJCLENBQWpCO1dBQ0tHLFdBQUwsQ0FBaUJhLE1BQWpCLENBQXdCLEtBQUtULFNBQTdCOztXQUVLRixLQUFMLEdBQWEsS0FBYjs7Ozs7Ozs7OzhCQU9KO1dBQ1NOLEtBQUwsR0FBYSxJQUFiO1dBQ0tqTixNQUFMLEdBQWMsSUFBZDtXQUNLa04sT0FBTCxHQUFlLElBQWY7O1dBRUtRLEdBQUwsQ0FBU3JpQixPQUFUO1dBQ0txTyxNQUFMLENBQVlyTyxPQUFaO1dBQ0tnaUIsV0FBTCxDQUFpQmhpQixPQUFqQjs7V0FFSzdJLEVBQUwsR0FBVSxJQUFWOztXQUVLa1gsTUFBTCxHQUFjLElBQWQ7V0FDSzJULFdBQUwsR0FBbUIsSUFBbkI7O1dBRUtHLFFBQUwsR0FBZ0IsSUFBaEI7V0FDS0MsU0FBTCxHQUFpQixJQUFqQjs7Ozs7O0lDbkhBVyxZQUFjcG9CLFNBQWRvb0I7O0FBQ1IsSUFBTUMsYUFBV2hGLE1BQU9nRixRQUF4Qjs7QUFFQSxTQUFTQyxjQUFULENBQXdCdHVCLEdBQXhCLEVBQ0E7UUFDUUEsZUFBZS9ELEtBQW5CLEVBQ0E7WUFDUStELElBQUksQ0FBSixFQUFPdXVCLFNBQVAsQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsTUFBMkIsV0FBL0IsRUFDQTtnQkFDVXR1QixPQUFPRCxJQUFJTyxLQUFKLENBQVUsQ0FBVixDQUFiOztpQkFFS2l1QixPQUFMLGdCQUEwQkosU0FBMUI7O21CQUVPbnVCLElBQVA7O0tBUlIsTUFXSyxJQUFJRCxJQUFJdXVCLFNBQUosQ0FBYyxDQUFkLEVBQWlCLENBQWpCLE1BQXdCLFdBQTVCLEVBQ0w7OEJBQ3dCSCxTQUFwQixpQkFBeUNwdUIsR0FBekM7OztXQUdHQSxHQUFQOzs7Ozs7Ozs7Ozs7SUFXaUJ5dUI7Ozs7Ozs7OztvQkFRTGpzQixFQUFaLEVBQWdCa3NCLFNBQWhCLEVBQTJCQyxXQUEzQixFQUNBOzs4R0FDVW5zQixFQURWLEVBQ2M4ckIsZUFBZUksU0FBZixDQURkLEVBQ3lDSixlQUFlSyxXQUFmLENBRHpDOzs7O0VBVGdDTjs7QUNqQ3BDOzs7Ozs7OztJQU9xQk87Ozs7Ozs2QkFLTHBzQixFQUFaLEVBQ0E7O2dJQUNVQSxFQURWOztTQUlZLGlDQURKLEVBRUksd0JBRkosRUFJSSxpQ0FKSixFQUtJLGdDQUxKLEVBT0ksc0JBUEosRUFRSSxvQkFSSixFQVVJLHNCQVZKLEVBWUksa0JBWkosRUFhSSwwR0FiSixFQWNJLGlEQWRKLEVBZUksR0FmSixFQWdCRStXLElBaEJGLENBZ0JPLElBaEJQLENBSFI7O1NBc0JZLHNCQURKLEVBR0ksa0JBSEosRUFJSSwyQkFKSixFQUtJLEdBTEosRUFNRUEsSUFORixDQU1PLElBTlAsQ0FyQlI7Ozs7RUFOeUNrVjs7QUNON0M7Ozs7Ozs7Ozs7QUFVQSxBQUFlLFNBQVNJLFNBQVQsQ0FBbUJuUCxZQUFuQixFQUFpQ29QLFNBQWpDLEVBQ2Y7O1FBRVE5TyxTQUFTTixhQUFhTSxNQUExQjs7UUFFSUEsT0FBTzdpQixNQUFQLEtBQWtCLENBQXRCLEVBQ0E7Ozs7Ozs7Ozs7Ozs7O1FBY000eEIsYUFBYSxJQUFJcnNCLE9BQUosQ0FBVXNkLE9BQU8sQ0FBUCxDQUFWLEVBQXFCQSxPQUFPLENBQVAsQ0FBckIsQ0FBbkI7UUFDSWdQLFlBQVksSUFBSXRzQixPQUFKLENBQVVzZCxPQUFPQSxPQUFPN2lCLE1BQVAsR0FBZ0IsQ0FBdkIsQ0FBVixFQUFxQzZpQixPQUFPQSxPQUFPN2lCLE1BQVAsR0FBZ0IsQ0FBdkIsQ0FBckMsQ0FBaEI7OztRQUdJNHhCLFdBQVdwc0IsQ0FBWCxLQUFpQnFzQixVQUFVcnNCLENBQTNCLElBQWdDb3NCLFdBQVduc0IsQ0FBWCxLQUFpQm9zQixVQUFVcHNCLENBQS9ELEVBQ0E7O2lCQUVhb2QsT0FBT3pmLEtBQVAsRUFBVDs7ZUFFTzB1QixHQUFQO2VBQ09BLEdBQVA7O29CQUVZLElBQUl2c0IsT0FBSixDQUFVc2QsT0FBT0EsT0FBTzdpQixNQUFQLEdBQWdCLENBQXZCLENBQVYsRUFBcUM2aUIsT0FBT0EsT0FBTzdpQixNQUFQLEdBQWdCLENBQXZCLENBQXJDLENBQVo7O1lBRU0reEIsWUFBWUYsVUFBVXJzQixDQUFWLEdBQWUsQ0FBQ29zQixXQUFXcHNCLENBQVgsR0FBZXFzQixVQUFVcnNCLENBQTFCLElBQStCLEdBQWhFO1lBQ013c0IsWUFBWUgsVUFBVXBzQixDQUFWLEdBQWUsQ0FBQ21zQixXQUFXbnNCLENBQVgsR0FBZW9zQixVQUFVcHNCLENBQTFCLElBQStCLEdBQWhFOztlQUVPNHJCLE9BQVAsQ0FBZVUsU0FBZixFQUEwQkMsU0FBMUI7ZUFDTzN4QixJQUFQLENBQVkweEIsU0FBWixFQUF1QkMsU0FBdkI7OztRQUdFQyxRQUFRTixVQUFVOU8sTUFBeEI7UUFDTWtOLFVBQVU0QixVQUFVNUIsT0FBMUI7UUFDTS92QixTQUFTNmlCLE9BQU83aUIsTUFBUCxHQUFnQixDQUEvQjtRQUNJa3lCLGFBQWFyUCxPQUFPN2lCLE1BQXhCO1FBQ0lteUIsYUFBYUYsTUFBTWp5QixNQUFOLEdBQWUsQ0FBaEM7OztRQUdNMEksUUFBUTZaLGFBQWF4RCxTQUFiLEdBQXlCLENBQXZDOzs7UUFHTStRLFFBQVFMLFFBQVFsTixhQUFhdkQsV0FBckIsQ0FBZDtRQUNNb1QsUUFBUTdQLGFBQWFZLFNBQTNCO1FBQ01oZixJQUFJMnJCLE1BQU0sQ0FBTixJQUFXc0MsS0FBckI7UUFDTUMsSUFBSXZDLE1BQU0sQ0FBTixJQUFXc0MsS0FBckI7UUFDTTdoQixJQUFJdWYsTUFBTSxDQUFOLElBQVdzQyxLQUFyQjs7UUFFSUUsTUFBTXpQLE9BQU8sQ0FBUCxDQUFWO1FBQ0kwUCxNQUFNMVAsT0FBTyxDQUFQLENBQVY7UUFDSTJQLE1BQU0zUCxPQUFPLENBQVAsQ0FBVjtRQUNJNFAsTUFBTTVQLE9BQU8sQ0FBUCxDQUFWO1FBQ0k2UCxNQUFNLENBQVY7UUFDSUMsTUFBTSxDQUFWOztRQUVJQyxRQUFRLEVBQUVMLE1BQU1FLEdBQVIsQ0FBWjtRQUNJSSxRQUFRUCxNQUFNRSxHQUFsQjtRQUNJTSxTQUFTLENBQWI7UUFDSUMsU0FBUyxDQUFiO1FBQ0lDLFNBQVMsQ0FBYjtRQUNJQyxTQUFTLENBQWI7O1FBRUlDLE9BQU9qeEIsS0FBSzBVLElBQUwsQ0FBV2ljLFFBQVFBLEtBQVQsR0FBbUJDLFFBQVFBLEtBQXJDLENBQVg7O2FBRVNLLElBQVQ7YUFDU0EsSUFBVDthQUNTeHFCLEtBQVQ7YUFDU0EsS0FBVDs7O1VBR01ySSxJQUFOLENBQ0lpeUIsTUFBTU0sS0FEVixFQUVJTCxNQUFNTSxLQUZWLEVBR0kxdUIsQ0FISixFQUdPa3VCLENBSFAsRUFHVTloQixDQUhWLEVBR2E2aEIsS0FIYjs7VUFNTS94QixJQUFOLENBQ0lpeUIsTUFBTU0sS0FEVixFQUVJTCxNQUFNTSxLQUZWLEVBR0kxdUIsQ0FISixFQUdPa3VCLENBSFAsRUFHVTloQixDQUhWLEVBR2E2aEIsS0FIYjs7U0FNSyxJQUFJbnlCLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsU0FBUyxDQUE3QixFQUFnQyxFQUFFQyxDQUFsQyxFQUNBO2NBQ1U0aUIsT0FBTyxDQUFDNWlCLElBQUksQ0FBTCxJQUFVLENBQWpCLENBQU47Y0FDTTRpQixPQUFRLENBQUM1aUIsSUFBSSxDQUFMLElBQVUsQ0FBWCxHQUFnQixDQUF2QixDQUFOOztjQUVNNGlCLE9BQU81aUIsSUFBSSxDQUFYLENBQU47Y0FDTTRpQixPQUFRNWlCLElBQUksQ0FBTCxHQUFVLENBQWpCLENBQU47O2NBRU00aUIsT0FBTyxDQUFDNWlCLElBQUksQ0FBTCxJQUFVLENBQWpCLENBQU47Y0FDTTRpQixPQUFRLENBQUM1aUIsSUFBSSxDQUFMLElBQVUsQ0FBWCxHQUFnQixDQUF2QixDQUFOOztnQkFFUSxFQUFFc3lCLE1BQU1FLEdBQVIsQ0FBUjtnQkFDUUgsTUFBTUUsR0FBZDs7ZUFFT3Z3QixLQUFLMFUsSUFBTCxDQUFXaWMsUUFBUUEsS0FBVCxHQUFtQkMsUUFBUUEsS0FBckMsQ0FBUDtpQkFDU0ssSUFBVDtpQkFDU0EsSUFBVDtpQkFDU3hxQixLQUFUO2lCQUNTQSxLQUFUOztpQkFFUyxFQUFFK3BCLE1BQU1FLEdBQVIsQ0FBVDtpQkFDU0gsTUFBTUUsR0FBZjs7ZUFFT3p3QixLQUFLMFUsSUFBTCxDQUFXbWMsU0FBU0EsTUFBVixHQUFxQkMsU0FBU0EsTUFBeEMsQ0FBUDtrQkFDVUcsSUFBVjtrQkFDVUEsSUFBVjtrQkFDVXhxQixLQUFWO2tCQUNVQSxLQUFWOztZQUVNeXFCLEtBQU0sQ0FBQ04sS0FBRCxHQUFTTixHQUFWLElBQWtCLENBQUNNLEtBQUQsR0FBU0osR0FBM0IsQ0FBWDtZQUNNVyxLQUFNLENBQUNSLEtBQUQsR0FBU0osR0FBVixJQUFrQixDQUFDSSxLQUFELEdBQVNOLEdBQTNCLENBQVg7WUFDTWUsS0FBTSxDQUFDLENBQUNULEtBQUQsR0FBU04sR0FBVixLQUFrQixDQUFDTyxLQUFELEdBQVNKLEdBQTNCLENBQUQsR0FBcUMsQ0FBQyxDQUFDRyxLQUFELEdBQVNKLEdBQVYsS0FBa0IsQ0FBQ0ssS0FBRCxHQUFTTixHQUEzQixDQUFoRDtZQUNNZSxLQUFNLENBQUNQLE1BQUQsR0FBVUosR0FBWCxJQUFtQixDQUFDSSxNQUFELEdBQVVOLEdBQTdCLENBQVg7WUFDTWMsS0FBTSxDQUFDVCxNQUFELEdBQVVOLEdBQVgsSUFBbUIsQ0FBQ00sTUFBRCxHQUFVSixHQUE3QixDQUFYO1lBQ01jLEtBQU0sQ0FBQyxDQUFDVixNQUFELEdBQVVKLEdBQVgsS0FBbUIsQ0FBQ0ssTUFBRCxHQUFVTixHQUE3QixDQUFELEdBQXVDLENBQUMsQ0FBQ0ssTUFBRCxHQUFVTixHQUFYLEtBQW1CLENBQUNPLE1BQUQsR0FBVUosR0FBN0IsQ0FBbEQ7O1lBRUljLFFBQVNOLEtBQUtJLEVBQU4sR0FBYUQsS0FBS0YsRUFBOUI7O1lBRUlueEIsS0FBS3FQLEdBQUwsQ0FBU21pQixLQUFULElBQWtCLEdBQXRCLEVBQ0E7cUJBQ2EsSUFBVDtrQkFDTXB6QixJQUFOLENBQ0lteUIsTUFBTUksS0FEVixFQUVJSCxNQUFNSSxLQUZWLEVBR0kxdUIsQ0FISixFQUdPa3VCLENBSFAsRUFHVTloQixDQUhWLEVBR2E2aEIsS0FIYjs7a0JBTU0veEIsSUFBTixDQUNJbXlCLE1BQU1JLEtBRFYsRUFFSUgsTUFBTUksS0FGVixFQUdJMXVCLENBSEosRUFHT2t1QixDQUhQLEVBR1U5aEIsQ0FIVixFQUdhNmhCLEtBSGI7Ozs7O1lBU0UvdEIsS0FBSyxDQUFFK3VCLEtBQUtJLEVBQU4sR0FBYUQsS0FBS0YsRUFBbkIsSUFBMEJJLEtBQXJDO1lBQ01uTixLQUFLLENBQUVnTixLQUFLRCxFQUFOLEdBQWFGLEtBQUtLLEVBQW5CLElBQTBCQyxLQUFyQztZQUNNQyxRQUFTLENBQUNydkIsS0FBS211QixHQUFOLEtBQWNudUIsS0FBS211QixHQUFuQixDQUFELEdBQTZCLENBQUNsTSxLQUFLbU0sR0FBTixLQUFjbk0sS0FBS21NLEdBQW5CLENBQTNDOztZQUVJaUIsUUFBUyxNQUFNaHJCLEtBQU4sR0FBY0EsS0FBM0IsRUFDQTtxQkFDYWtxQixRQUFRRSxNQUFqQjtxQkFDU0QsUUFBUUUsTUFBakI7O21CQUVPOXdCLEtBQUswVSxJQUFMLENBQVdxYyxTQUFTQSxNQUFWLEdBQXFCQyxTQUFTQSxNQUF4QyxDQUFQO3NCQUNVQyxJQUFWO3NCQUNVQSxJQUFWO3NCQUNVeHFCLEtBQVY7c0JBQ1VBLEtBQVY7O2tCQUVNckksSUFBTixDQUFXbXlCLE1BQU1RLE1BQWpCLEVBQXlCUCxNQUFNUSxNQUEvQjtrQkFDTTV5QixJQUFOLENBQVc4RCxDQUFYLEVBQWNrdUIsQ0FBZCxFQUFpQjloQixDQUFqQixFQUFvQjZoQixLQUFwQjs7a0JBRU0veEIsSUFBTixDQUFXbXlCLE1BQU1RLE1BQWpCLEVBQXlCUCxNQUFNUSxNQUEvQjtrQkFDTTV5QixJQUFOLENBQVc4RCxDQUFYLEVBQWNrdUIsQ0FBZCxFQUFpQjloQixDQUFqQixFQUFvQjZoQixLQUFwQjs7a0JBRU0veEIsSUFBTixDQUFXbXlCLE1BQU1RLE1BQWpCLEVBQXlCUCxNQUFNUSxNQUEvQjtrQkFDTTV5QixJQUFOLENBQVc4RCxDQUFYLEVBQWNrdUIsQ0FBZCxFQUFpQjloQixDQUFqQixFQUFvQjZoQixLQUFwQjs7O1NBbEJKLE1BdUJBO2tCQUNVL3hCLElBQU4sQ0FBV2dFLEVBQVgsRUFBZWlpQixFQUFmO2tCQUNNam1CLElBQU4sQ0FBVzhELENBQVgsRUFBY2t1QixDQUFkLEVBQWlCOWhCLENBQWpCLEVBQW9CNmhCLEtBQXBCOztrQkFFTS94QixJQUFOLENBQVdteUIsT0FBT251QixLQUFLbXVCLEdBQVosQ0FBWCxFQUE2QkMsT0FBT25NLEtBQUttTSxHQUFaLENBQTdCO2tCQUNNcHlCLElBQU4sQ0FBVzhELENBQVgsRUFBY2t1QixDQUFkLEVBQWlCOWhCLENBQWpCLEVBQW9CNmhCLEtBQXBCOzs7O1VBSUZ2UCxPQUFPLENBQUM3aUIsU0FBUyxDQUFWLElBQWUsQ0FBdEIsQ0FBTjtVQUNNNmlCLE9BQVEsQ0FBQzdpQixTQUFTLENBQVYsSUFBZSxDQUFoQixHQUFxQixDQUE1QixDQUFOOztVQUVNNmlCLE9BQU8sQ0FBQzdpQixTQUFTLENBQVYsSUFBZSxDQUF0QixDQUFOO1VBQ002aUIsT0FBUSxDQUFDN2lCLFNBQVMsQ0FBVixJQUFlLENBQWhCLEdBQXFCLENBQTVCLENBQU47O1lBRVEsRUFBRXV5QixNQUFNRSxHQUFSLENBQVI7WUFDUUgsTUFBTUUsR0FBZDs7V0FFT3Z3QixLQUFLMFUsSUFBTCxDQUFXaWMsUUFBUUEsS0FBVCxHQUFtQkMsUUFBUUEsS0FBckMsQ0FBUDthQUNTSyxJQUFUO2FBQ1NBLElBQVQ7YUFDU3hxQixLQUFUO2FBQ1NBLEtBQVQ7O1VBRU1ySSxJQUFOLENBQVdteUIsTUFBTUksS0FBakIsRUFBd0JILE1BQU1JLEtBQTlCO1VBQ014eUIsSUFBTixDQUFXOEQsQ0FBWCxFQUFja3VCLENBQWQsRUFBaUI5aEIsQ0FBakIsRUFBb0I2aEIsS0FBcEI7O1VBRU0veEIsSUFBTixDQUFXbXlCLE1BQU1JLEtBQWpCLEVBQXdCSCxNQUFNSSxLQUE5QjtVQUNNeHlCLElBQU4sQ0FBVzhELENBQVgsRUFBY2t1QixDQUFkLEVBQWlCOWhCLENBQWpCLEVBQW9CNmhCLEtBQXBCOztZQUVRL3hCLElBQVIsQ0FBYTh4QixVQUFiOztTQUVLLElBQUlseUIsS0FBSSxDQUFiLEVBQWdCQSxLQUFJaXlCLFVBQXBCLEVBQWdDLEVBQUVqeUIsRUFBbEMsRUFDQTtnQkFDWUksSUFBUixDQUFhOHhCLFlBQWI7OztZQUdJOXhCLElBQVIsQ0FBYTh4QixhQUFhLENBQTFCOzs7QUM5TkosWUFBYyxHQUFHLE1BQU0sQ0FBQzs7QUFFeEIsU0FBUyxNQUFNLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUU7O0lBRXBDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDOztJQUVmLElBQUksUUFBUSxHQUFHLFdBQVcsSUFBSSxXQUFXLENBQUMsTUFBTTtRQUM1QyxRQUFRLEdBQUcsUUFBUSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU07UUFDeEQsU0FBUyxHQUFHLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDO1FBQ3BELFNBQVMsR0FBRyxFQUFFLENBQUM7O0lBRW5CLElBQUksQ0FBQyxTQUFTLEVBQUUsT0FBTyxTQUFTLENBQUM7O0lBRWpDLElBQUksSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDOztJQUV2QyxJQUFJLFFBQVEsRUFBRSxTQUFTLEdBQUcsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDOzs7SUFHNUUsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRyxHQUFHLEVBQUU7UUFDeEIsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7O1FBRXRCLEtBQUssSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxJQUFJLEdBQUcsRUFBRTtZQUN0QyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ1osQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDaEIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7U0FDMUI7OztRQUdELElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQzdDOztJQUVELFlBQVksQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDOztJQUUxRCxPQUFPLFNBQVMsQ0FBQztDQUNwQjs7O0FBR0QsU0FBUyxVQUFVLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRTtJQUNsRCxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUM7O0lBRVosSUFBSSxTQUFTLE1BQU0sVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ3ZELEtBQUssQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDdkYsTUFBTTtRQUNILEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLElBQUksR0FBRyxFQUFFLElBQUksR0FBRyxVQUFVLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzlGOztJQUVELElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ2pDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQixJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztLQUNwQjs7SUFFRCxPQUFPLElBQUksQ0FBQztDQUNmOzs7QUFHRCxTQUFTLFlBQVksQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFO0lBQzlCLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxLQUFLLENBQUM7SUFDekIsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDOztJQUV0QixJQUFJLENBQUMsR0FBRyxLQUFLO1FBQ1QsS0FBSyxDQUFDO0lBQ1YsR0FBRztRQUNDLEtBQUssR0FBRyxLQUFLLENBQUM7O1FBRWQsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUNwRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDZCxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxPQUFPLElBQUksQ0FBQztZQUM5QixLQUFLLEdBQUcsSUFBSSxDQUFDOztTQUVoQixNQUFNO1lBQ0gsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7U0FDZDtLQUNKLFFBQVEsS0FBSyxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUU7O0lBRTdCLE9BQU8sR0FBRyxDQUFDO0NBQ2Q7OztBQUdELFNBQVMsWUFBWSxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtJQUMvRCxJQUFJLENBQUMsR0FBRyxFQUFFLE9BQU87OztJQUdqQixJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7O0lBRXJELElBQUksSUFBSSxHQUFHLEdBQUc7UUFDVixJQUFJLEVBQUUsSUFBSSxDQUFDOzs7SUFHZixPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssR0FBRyxDQUFDLElBQUksRUFBRTtRQUMxQixJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUNoQixJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQzs7UUFFaEIsSUFBSSxJQUFJLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTs7WUFFeEQsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzdCLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUM1QixTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7O1lBRTdCLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7O1lBR2hCLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2hCLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDOztZQUVqQixTQUFTO1NBQ1o7O1FBRUQsR0FBRyxHQUFHLElBQUksQ0FBQzs7O1FBR1gsSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFOztZQUVkLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1AsWUFBWSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDOzs7YUFHeEUsTUFBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7Z0JBQ25CLEdBQUcsR0FBRyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNsRCxZQUFZLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7OzthQUcxRCxNQUFNLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtnQkFDbkIsV0FBVyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDdEQ7O1lBRUQsTUFBTTtTQUNUO0tBQ0o7Q0FDSjs7O0FBR0QsU0FBUyxLQUFLLENBQUMsR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJO1FBQ1osQ0FBQyxHQUFHLEdBQUc7UUFDUCxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQzs7SUFFakIsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7OztJQUdyQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzs7SUFFdEIsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksRUFBRTtRQUNuQixJQUFJLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7UUFDL0MsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7S0FDZDs7SUFFRCxPQUFPLElBQUksQ0FBQztDQUNmOztBQUVELFNBQVMsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtJQUN4QyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSTtRQUNaLENBQUMsR0FBRyxHQUFHO1FBQ1AsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7O0lBRWpCLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sS0FBSyxDQUFDOzs7SUFHckMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7SUFHMUUsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7UUFDN0MsSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7OztJQUdsRCxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDOztJQUVsQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRTtRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSTtZQUNoQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sS0FBSyxDQUFDO1FBQy9DLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO0tBQ2Y7OztJQUdELENBQUMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDOztJQUVkLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxFQUFFO1FBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJO1lBQ2hDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7UUFDL0MsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7S0FDZjs7SUFFRCxPQUFPLElBQUksQ0FBQztDQUNmOzs7QUFHRCxTQUFTLHNCQUFzQixDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFO0lBQ25ELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNkLEdBQUc7UUFDQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSTtZQUNWLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzs7UUFFcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7O1lBRTVGLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUMxQixTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDMUIsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDOzs7WUFHMUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2QsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7WUFFbkIsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7U0FDakI7UUFDRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUNkLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTs7SUFFdEIsT0FBTyxDQUFDLENBQUM7Q0FDWjs7O0FBR0QsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7O0lBRTFELElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNkLEdBQUc7UUFDQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNwQixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7O2dCQUV0QyxJQUFJLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOzs7Z0JBRzNCLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDNUIsQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDOzs7Z0JBRzVCLFlBQVksQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNsRCxZQUFZLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbEQsT0FBTzthQUNWO1lBQ0QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7U0FDZDtRQUNELENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO0tBQ2QsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFO0NBQ3pCOzs7QUFHRCxTQUFTLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUU7SUFDdkQsSUFBSSxLQUFLLEdBQUcsRUFBRTtRQUNWLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUM7O0lBRTdCLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2hELEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQzdCLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzNELElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2hELElBQUksSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDNUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUNqQzs7SUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7SUFHckIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQy9CLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDbkMsU0FBUyxHQUFHLFlBQVksQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3ZEOztJQUVELE9BQU8sU0FBUyxDQUFDO0NBQ3BCOztBQUVELFNBQVMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDcEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDcEI7OztBQUdELFNBQVMsYUFBYSxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUU7SUFDcEMsU0FBUyxHQUFHLGNBQWMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDNUMsSUFBSSxTQUFTLEVBQUU7UUFDWCxJQUFJLENBQUMsR0FBRyxZQUFZLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3RDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzNCO0NBQ0o7OztBQUdELFNBQVMsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUU7SUFDckMsSUFBSSxDQUFDLEdBQUcsU0FBUztRQUNiLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNYLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNYLEVBQUUsR0FBRyxDQUFDLFFBQVE7UUFDZCxDQUFDLENBQUM7Ozs7SUFJTixHQUFHO1FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDN0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUU7Z0JBQ25CLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ1AsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFO29CQUNWLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7b0JBQ3pCLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQztpQkFDdEM7Z0JBQ0QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7YUFDbkM7U0FDSjtRQUNELENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO0tBQ2QsUUFBUSxDQUFDLEtBQUssU0FBUyxFQUFFOztJQUUxQixJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sSUFBSSxDQUFDOztJQUVwQixJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDOzs7Ozs7SUFNN0IsSUFBSSxJQUFJLEdBQUcsQ0FBQztRQUNSLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNSLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNSLE1BQU0sR0FBRyxRQUFRO1FBQ2pCLEdBQUcsQ0FBQzs7SUFFUixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzs7SUFFWCxPQUFPLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRTtnQkFDbEIsZUFBZSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFOztZQUVyRixHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7O1lBRXRDLElBQUksQ0FBQyxHQUFHLEdBQUcsTUFBTSxLQUFLLEdBQUcsS0FBSyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssYUFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRTtnQkFDM0UsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDTixNQUFNLEdBQUcsR0FBRyxDQUFDO2FBQ2hCO1NBQ0o7O1FBRUQsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7S0FDZDs7SUFFRCxPQUFPLENBQUMsQ0FBQztDQUNaOzs7QUFHRCxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7SUFDekMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ2QsR0FBRztRQUNDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0QsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUNqQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUNkLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTs7SUFFdEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ3JCLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztJQUVmLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNqQjs7OztBQUlELFNBQVMsVUFBVSxDQUFDLElBQUksRUFBRTtJQUN0QixJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxLQUFLO1FBQ3pDLE1BQU0sR0FBRyxDQUFDLENBQUM7O0lBRWYsR0FBRztRQUNDLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDVCxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ1osSUFBSSxHQUFHLElBQUksQ0FBQztRQUNaLFNBQVMsR0FBRyxDQUFDLENBQUM7O1FBRWQsT0FBTyxDQUFDLEVBQUU7WUFDTixTQUFTLEVBQUUsQ0FBQztZQUNaLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDTixLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBQ1YsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3pCLEtBQUssRUFBRSxDQUFDO2dCQUNSLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO2dCQUNaLElBQUksQ0FBQyxDQUFDLEVBQUUsTUFBTTthQUNqQjs7WUFFRCxLQUFLLEdBQUcsTUFBTSxDQUFDOztZQUVmLE9BQU8sS0FBSyxHQUFHLENBQUMsS0FBSyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFOztnQkFFbEMsSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO29CQUNiLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ04sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7b0JBQ1osS0FBSyxFQUFFLENBQUM7aUJBQ1gsTUFBTSxJQUFJLEtBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7b0JBQzFCLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ04sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7b0JBQ1osS0FBSyxFQUFFLENBQUM7aUJBQ1gsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDbkIsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQztvQkFDWixLQUFLLEVBQUUsQ0FBQztpQkFDWCxNQUFNO29CQUNILENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ04sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7b0JBQ1osS0FBSyxFQUFFLENBQUM7aUJBQ1g7O2dCQUVELElBQUksSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO3FCQUNwQixJQUFJLEdBQUcsQ0FBQyxDQUFDOztnQkFFZCxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztnQkFDZixJQUFJLEdBQUcsQ0FBQyxDQUFDO2FBQ1o7O1lBRUQsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNUOztRQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE1BQU0sSUFBSSxDQUFDLENBQUM7O0tBRWYsUUFBUSxTQUFTLEdBQUcsQ0FBQyxFQUFFOztJQUV4QixPQUFPLElBQUksQ0FBQztDQUNmOzs7QUFHRCxTQUFTLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFOztJQUVwQyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDOUIsQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDOztJQUU5QixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQztJQUNoQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQztJQUNoQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQztJQUNoQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQzs7SUFFaEMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUM7SUFDaEMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUM7SUFDaEMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUM7SUFDaEMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUM7O0lBRWhDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztDQUN2Qjs7O0FBR0QsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFO0lBQ3hCLElBQUksQ0FBQyxHQUFHLEtBQUs7UUFDVCxRQUFRLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLEdBQUc7UUFDQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsRUFBRSxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ25DLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO0tBQ2QsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFOztJQUV0QixPQUFPLFFBQVEsQ0FBQztDQUNuQjs7O0FBR0QsU0FBUyxlQUFlLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtJQUNyRCxPQUFPLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO1dBQ2xELENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO1dBQ2xELENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDN0Q7OztBQUdELFNBQVMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDM0IsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1dBQ2hFLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQzNFOzs7QUFHRCxTQUFTLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNuQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ2hFOzs7QUFHRCxTQUFTLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFO0lBQ3BCLE9BQU8sRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztDQUN6Qzs7O0FBR0QsU0FBUyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0lBQ2hDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDO1NBQ2hDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLE9BQU8sSUFBSSxDQUFDO0lBQ3BELE9BQU8sSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUM7V0FDN0MsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUN4RDs7O0FBR0QsU0FBUyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBQzdCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNWLEdBQUc7UUFDQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxPQUFPLElBQUksQ0FBQztRQUNqRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUNkLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTs7SUFFbEIsT0FBTyxLQUFLLENBQUM7Q0FDaEI7OztBQUdELFNBQVMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDekIsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDOUIsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUNsRCxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDeEQ7OztBQUdELFNBQVMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNMLE1BQU0sR0FBRyxLQUFLO1FBQ2QsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDcEIsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QixHQUFHO1FBQ0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pHLE1BQU0sR0FBRyxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUNkLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTs7SUFFbEIsT0FBTyxNQUFNLENBQUM7Q0FDakI7Ozs7QUFJRCxTQUFTLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0lBQ3hCLElBQUksRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVCLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QixFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUk7UUFDWCxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzs7SUFFaEIsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7SUFDWCxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQzs7SUFFWCxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNiLEVBQUUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDOztJQUViLEVBQUUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2IsRUFBRSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7O0lBRWIsRUFBRSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDYixFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7SUFFYixPQUFPLEVBQUUsQ0FBQztDQUNiOzs7QUFHRCxTQUFTLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUU7SUFDL0IsSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs7SUFFMUIsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNQLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7O0tBRWQsTUFBTTtRQUNILENBQUMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNuQixDQUFDLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztLQUNqQjtJQUNELE9BQU8sQ0FBQyxDQUFDO0NBQ1o7O0FBRUQsU0FBUyxVQUFVLENBQUMsQ0FBQyxFQUFFO0lBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDckIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzs7SUFFckIsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDckMsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7Q0FDeEM7O0FBRUQsU0FBUyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7O0lBRW5CLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7SUFHWCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNYLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7SUFHWCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNqQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7O0lBR2pCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDOzs7SUFHZCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7O0lBR2xCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0NBQ3hCOzs7O0FBSUQsTUFBTSxDQUFDLFNBQVMsR0FBRyxVQUFVLElBQUksRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRTtJQUM1RCxJQUFJLFFBQVEsR0FBRyxXQUFXLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQztJQUNqRCxJQUFJLFFBQVEsR0FBRyxRQUFRLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDOztJQUU3RCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9ELElBQUksUUFBUSxFQUFFO1FBQ1YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwRCxJQUFJLEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ2pDLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDL0QsV0FBVyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDOUQ7S0FDSjs7SUFFRCxJQUFJLGFBQWEsR0FBRyxDQUFDLENBQUM7SUFDdEIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdEMsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUMzQixJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUMvQixJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUMvQixhQUFhLElBQUksSUFBSSxDQUFDLEdBQUc7WUFDckIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNqRCxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMxRDs7SUFFRCxPQUFPLFdBQVcsS0FBSyxDQUFDLElBQUksYUFBYSxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQy9DLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxhQUFhLEdBQUcsV0FBVyxJQUFJLFdBQVcsQ0FBQyxDQUFDO0NBQzdELENBQUM7O0FBRUYsU0FBUyxVQUFVLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0lBQ3ZDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNaLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEdBQUcsRUFBRTtRQUNsRCxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pELENBQUMsR0FBRyxDQUFDLENBQUM7S0FDVDtJQUNELE9BQU8sR0FBRyxDQUFDO0NBQ2Q7OztBQUdELE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVSxJQUFJLEVBQUU7SUFDN0IsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU07UUFDdkIsTUFBTSxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUM7UUFDbkQsU0FBUyxHQUFHLENBQUMsQ0FBQzs7SUFFbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDbEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDckMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyRTtRQUNELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNQLFNBQVMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztZQUNoQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNoQztLQUNKO0lBQ0QsT0FBTyxNQUFNLENBQUM7Q0FDakIsQ0FBQzs7QUMvbkJGOzs7Ozs7Ozs7O0FBVUEsQUFBZSxTQUFTd0IsU0FBVCxDQUFtQnBSLFlBQW5CLEVBQWlDb1AsU0FBakMsRUFDZjtpQkFDaUI5TyxNQUFiLEdBQXNCTixhQUFhUixLQUFiLENBQW1CYyxNQUFuQixDQUEwQnpmLEtBQTFCLEVBQXRCOztRQUVJeWYsU0FBU04sYUFBYU0sTUFBMUI7O1FBRUlOLGFBQWFVLElBQWIsSUFBcUJKLE9BQU83aUIsTUFBUCxJQUFpQixDQUExQyxFQUNBO1lBQ1U0ekIsWUFBWSxFQUFsQjs7WUFFTUMsUUFBUXRSLGFBQWFzUixLQUEzQjs7YUFFSyxJQUFJNXpCLElBQUksQ0FBYixFQUFnQkEsSUFBSTR6QixNQUFNN3pCLE1BQTFCLEVBQWtDQyxHQUFsQyxFQUNBO2dCQUNVNnpCLE9BQU9ELE1BQU01ekIsQ0FBTixDQUFiOztzQkFFVUksSUFBVixDQUFld2lCLE9BQU83aUIsTUFBUCxHQUFnQixDQUEvQjs7cUJBRVM2aUIsT0FBTzFSLE1BQVAsQ0FBYzJpQixLQUFLalIsTUFBbkIsQ0FBVDs7OztZQUlFb1AsUUFBUU4sVUFBVTlPLE1BQXhCO1lBQ01rTixVQUFVNEIsVUFBVTVCLE9BQTFCOztZQUVNL3ZCLFNBQVM2aUIsT0FBTzdpQixNQUFQLEdBQWdCLENBQS9COzs7WUFHTTh2QixRQUFRTCxRQUFRbE4sYUFBYUUsU0FBckIsQ0FBZDtZQUNNMlAsUUFBUTdQLGFBQWFTLFNBQTNCO1lBQ003ZSxJQUFJMnJCLE1BQU0sQ0FBTixJQUFXc0MsS0FBckI7WUFDTUMsSUFBSXZDLE1BQU0sQ0FBTixJQUFXc0MsS0FBckI7WUFDTTdoQixJQUFJdWYsTUFBTSxDQUFOLElBQVdzQyxLQUFyQjs7WUFFTTJCLFlBQVlDLFNBQU9uUixNQUFQLEVBQWUrUSxTQUFmLEVBQTBCLENBQTFCLENBQWxCOztZQUVJLENBQUNHLFNBQUwsRUFDQTs7OztZQUlNRSxVQUFVaEMsTUFBTWp5QixNQUFOLEdBQWUsQ0FBL0I7O2FBRUssSUFBSUMsS0FBSSxDQUFiLEVBQWdCQSxLQUFJOHpCLFVBQVUvekIsTUFBOUIsRUFBc0NDLE1BQUssQ0FBM0MsRUFDQTtvQkFDWUksSUFBUixDQUFhMHpCLFVBQVU5ekIsRUFBVixJQUFlZzBCLE9BQTVCO29CQUNRNXpCLElBQVIsQ0FBYTB6QixVQUFVOXpCLEVBQVYsSUFBZWcwQixPQUE1QjtvQkFDUTV6QixJQUFSLENBQWEwekIsVUFBVTl6QixLQUFJLENBQWQsSUFBbUJnMEIsT0FBaEM7b0JBQ1E1ekIsSUFBUixDQUFhMHpCLFVBQVU5ekIsS0FBSSxDQUFkLElBQW1CZzBCLE9BQWhDO29CQUNRNXpCLElBQVIsQ0FBYTB6QixVQUFVOXpCLEtBQUksQ0FBZCxJQUFtQmcwQixPQUFoQzs7O2FBR0MsSUFBSWgwQixNQUFJLENBQWIsRUFBZ0JBLE1BQUlELE1BQXBCLEVBQTRCQyxLQUE1QixFQUNBO2tCQUNVSSxJQUFOLENBQVd3aUIsT0FBTzVpQixNQUFJLENBQVgsQ0FBWCxFQUEwQjRpQixPQUFRNWlCLE1BQUksQ0FBTCxHQUFVLENBQWpCLENBQTFCLEVBQ0lrRSxDQURKLEVBQ09rdUIsQ0FEUCxFQUNVOWhCLENBRFYsRUFDYTZoQixLQURiOzs7O1FBS0o3UCxhQUFheEQsU0FBYixHQUF5QixDQUE3QixFQUNBO2tCQUNjd0QsWUFBVixFQUF3Qm9QLFNBQXhCOzs7O0FDeEVSOzs7Ozs7Ozs7O0FBVUEsQUFBZSxTQUFTdUMsY0FBVCxDQUF3QjNSLFlBQXhCLEVBQXNDb1AsU0FBdEMsRUFDZjs7OztRQUlVd0MsV0FBVzVSLGFBQWFSLEtBQTlCO1FBQ012YyxJQUFJMnVCLFNBQVMzdUIsQ0FBbkI7UUFDTUMsSUFBSTB1QixTQUFTMXVCLENBQW5CO1FBQ01pRCxRQUFReXJCLFNBQVN6ckIsS0FBdkI7UUFDTUMsU0FBU3dyQixTQUFTeHJCLE1BQXhCOztRQUVJNFosYUFBYVUsSUFBakIsRUFDQTtZQUNVNk0sUUFBUUwsUUFBUWxOLGFBQWFFLFNBQXJCLENBQWQ7WUFDTTJQLFFBQVE3UCxhQUFhUyxTQUEzQjs7WUFFTTdlLElBQUkyckIsTUFBTSxDQUFOLElBQVdzQyxLQUFyQjtZQUNNQyxJQUFJdkMsTUFBTSxDQUFOLElBQVdzQyxLQUFyQjtZQUNNN2hCLElBQUl1ZixNQUFNLENBQU4sSUFBV3NDLEtBQXJCOztZQUVNSCxRQUFRTixVQUFVOU8sTUFBeEI7WUFDTWtOLFVBQVU0QixVQUFVNUIsT0FBMUI7O1lBRU1rRSxVQUFVaEMsTUFBTWp5QixNQUFOLEdBQWUsQ0FBL0I7OztjQUdNSyxJQUFOLENBQVdtRixDQUFYLEVBQWNDLENBQWQ7Y0FDTXBGLElBQU4sQ0FBVzhELENBQVgsRUFBY2t1QixDQUFkLEVBQWlCOWhCLENBQWpCLEVBQW9CNmhCLEtBQXBCOztjQUVNL3hCLElBQU4sQ0FBV21GLElBQUlrRCxLQUFmLEVBQXNCakQsQ0FBdEI7Y0FDTXBGLElBQU4sQ0FBVzhELENBQVgsRUFBY2t1QixDQUFkLEVBQWlCOWhCLENBQWpCLEVBQW9CNmhCLEtBQXBCOztjQUVNL3hCLElBQU4sQ0FBV21GLENBQVgsRUFBY0MsSUFBSWtELE1BQWxCO2NBQ010SSxJQUFOLENBQVc4RCxDQUFYLEVBQWNrdUIsQ0FBZCxFQUFpQjloQixDQUFqQixFQUFvQjZoQixLQUFwQjs7Y0FFTS94QixJQUFOLENBQVdtRixJQUFJa0QsS0FBZixFQUFzQmpELElBQUlrRCxNQUExQjtjQUNNdEksSUFBTixDQUFXOEQsQ0FBWCxFQUFja3VCLENBQWQsRUFBaUI5aEIsQ0FBakIsRUFBb0I2aEIsS0FBcEI7OztnQkFHUS94QixJQUFSLENBQWE0ekIsT0FBYixFQUFzQkEsT0FBdEIsRUFBK0JBLFVBQVUsQ0FBekMsRUFBNENBLFVBQVUsQ0FBdEQsRUFBeURBLFVBQVUsQ0FBbkUsRUFBc0VBLFVBQVUsQ0FBaEY7OztRQUdBMVIsYUFBYXhELFNBQWpCLEVBQ0E7WUFDVXFWLGFBQWE3UixhQUFhTSxNQUFoQzs7cUJBRWFBLE1BQWIsR0FBc0IsQ0FBQ3JkLENBQUQsRUFBSUMsQ0FBSixFQUNsQkQsSUFBSWtELEtBRGMsRUFDUGpELENBRE8sRUFFbEJELElBQUlrRCxLQUZjLEVBRVBqRCxJQUFJa0QsTUFGRyxFQUdsQm5ELENBSGtCLEVBR2ZDLElBQUlrRCxNQUhXLEVBSWxCbkQsQ0FKa0IsRUFJZkMsQ0FKZSxDQUF0Qjs7a0JBTVU4YyxZQUFWLEVBQXdCb1AsU0FBeEI7O3FCQUVhOU8sTUFBYixHQUFzQnVSLFVBQXRCOzs7O0FDL0RSOzs7Ozs7Ozs7O0FBVUEsQUFBZSxTQUFTQyxxQkFBVCxDQUErQjlSLFlBQS9CLEVBQTZDb1AsU0FBN0MsRUFDZjtRQUNVMkMsWUFBWS9SLGFBQWFSLEtBQS9CO1FBQ012YyxJQUFJOHVCLFVBQVU5dUIsQ0FBcEI7UUFDTUMsSUFBSTZ1QixVQUFVN3VCLENBQXBCO1FBQ01pRCxRQUFRNHJCLFVBQVU1ckIsS0FBeEI7UUFDTUMsU0FBUzJyQixVQUFVM3JCLE1BQXpCOztRQUVNK2EsU0FBUzRRLFVBQVU1USxNQUF6Qjs7UUFFTTZRLFlBQVksRUFBbEI7O2NBRVVsMEIsSUFBVixDQUFlbUYsQ0FBZixFQUFrQkMsSUFBSWllLE1BQXRCO3lCQUNxQmxlLENBQXJCLEVBQXdCQyxJQUFJa0QsTUFBSixHQUFhK2EsTUFBckMsRUFBNkNsZSxDQUE3QyxFQUFnREMsSUFBSWtELE1BQXBELEVBQTREbkQsSUFBSWtlLE1BQWhFLEVBQXdFamUsSUFBSWtELE1BQTVFLEVBQW9GNHJCLFNBQXBGO3lCQUNxQi91QixJQUFJa0QsS0FBSixHQUFZZ2IsTUFBakMsRUFBeUNqZSxJQUFJa0QsTUFBN0MsRUFBcURuRCxJQUFJa0QsS0FBekQsRUFBZ0VqRCxJQUFJa0QsTUFBcEUsRUFBNEVuRCxJQUFJa0QsS0FBaEYsRUFBdUZqRCxJQUFJa0QsTUFBSixHQUFhK2EsTUFBcEcsRUFBNEc2USxTQUE1Rzt5QkFDcUIvdUIsSUFBSWtELEtBQXpCLEVBQWdDakQsSUFBSWllLE1BQXBDLEVBQTRDbGUsSUFBSWtELEtBQWhELEVBQXVEakQsQ0FBdkQsRUFBMERELElBQUlrRCxLQUFKLEdBQVlnYixNQUF0RSxFQUE4RWplLENBQTlFLEVBQWlGOHVCLFNBQWpGO3lCQUNxQi91QixJQUFJa2UsTUFBekIsRUFBaUNqZSxDQUFqQyxFQUFvQ0QsQ0FBcEMsRUFBdUNDLENBQXZDLEVBQTBDRCxDQUExQyxFQUE2Q0MsSUFBSWllLE1BQUosR0FBYSxZQUExRCxFQUF3RTZRLFNBQXhFOzs7OztRQUtJaFMsYUFBYVUsSUFBakIsRUFDQTtZQUNVNk0sUUFBUUwsUUFBUWxOLGFBQWFFLFNBQXJCLENBQWQ7WUFDTTJQLFFBQVE3UCxhQUFhUyxTQUEzQjs7WUFFTTdlLElBQUkyckIsTUFBTSxDQUFOLElBQVdzQyxLQUFyQjtZQUNNQyxJQUFJdkMsTUFBTSxDQUFOLElBQVdzQyxLQUFyQjtZQUNNN2hCLElBQUl1ZixNQUFNLENBQU4sSUFBV3NDLEtBQXJCOztZQUVNSCxRQUFRTixVQUFVOU8sTUFBeEI7WUFDTWtOLFVBQVU0QixVQUFVNUIsT0FBMUI7O1lBRU15RSxTQUFTdkMsTUFBTWp5QixNQUFOLEdBQWUsQ0FBOUI7O1lBRU0rekIsWUFBWUMsU0FBT08sU0FBUCxFQUFrQixJQUFsQixFQUF3QixDQUF4QixDQUFsQjs7YUFFSyxJQUFJdDBCLElBQUksQ0FBUixFQUFXd2tCLElBQUlzUCxVQUFVL3pCLE1BQTlCLEVBQXNDQyxJQUFJd2tCLENBQTFDLEVBQTZDeGtCLEtBQUssQ0FBbEQsRUFDQTtvQkFDWUksSUFBUixDQUFhMHpCLFVBQVU5ekIsQ0FBVixJQUFldTBCLE1BQTVCO29CQUNRbjBCLElBQVIsQ0FBYTB6QixVQUFVOXpCLENBQVYsSUFBZXUwQixNQUE1QjtvQkFDUW4wQixJQUFSLENBQWEwekIsVUFBVTl6QixJQUFJLENBQWQsSUFBbUJ1MEIsTUFBaEM7b0JBQ1FuMEIsSUFBUixDQUFhMHpCLFVBQVU5ekIsSUFBSSxDQUFkLElBQW1CdTBCLE1BQWhDO29CQUNRbjBCLElBQVIsQ0FBYTB6QixVQUFVOXpCLElBQUksQ0FBZCxJQUFtQnUwQixNQUFoQzs7O2FBR0MsSUFBSXYwQixLQUFJLENBQVIsRUFBV3drQixLQUFJOFAsVUFBVXYwQixNQUE5QixFQUFzQ0MsS0FBSXdrQixFQUExQyxFQUE2Q3hrQixJQUE3QyxFQUNBO2tCQUNVSSxJQUFOLENBQVdrMEIsVUFBVXQwQixFQUFWLENBQVgsRUFBeUJzMEIsVUFBVSxFQUFFdDBCLEVBQVosQ0FBekIsRUFBeUNrRSxDQUF6QyxFQUE0Q2t1QixDQUE1QyxFQUErQzloQixDQUEvQyxFQUFrRDZoQixLQUFsRDs7OztRQUlKN1AsYUFBYXhELFNBQWpCLEVBQ0E7WUFDVXFWLGFBQWE3UixhQUFhTSxNQUFoQzs7cUJBRWFBLE1BQWIsR0FBc0IwUixTQUF0Qjs7a0JBRVVoUyxZQUFWLEVBQXdCb1AsU0FBeEI7O3FCQUVhOU8sTUFBYixHQUFzQnVSLFVBQXRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQlIsU0FBU0ssb0JBQVQsQ0FBOEJyTyxLQUE5QixFQUFxQ0MsS0FBckMsRUFBNENxTyxHQUE1QyxFQUFpREMsR0FBakQsRUFBc0RsUCxHQUF0RCxFQUEyREMsR0FBM0QsRUFDQTtRQURnRTdULEdBQ2hFLHVFQURzRSxFQUN0RTs7UUFDVXFGLElBQUksRUFBVjtRQUNNMkwsU0FBU2hSLEdBQWY7O1FBRUkraUIsS0FBSyxDQUFUO1FBQ0lDLEtBQUssQ0FBVDtRQUNJQyxLQUFLLENBQVQ7UUFDSUMsS0FBSyxDQUFUO1FBQ0l2dkIsSUFBSSxDQUFSO1FBQ0lDLElBQUksQ0FBUjs7YUFFU3V2QixLQUFULENBQWVDLEVBQWYsRUFBbUJDLEVBQW5CLEVBQXVCQyxJQUF2QixFQUNBO1lBQ1VDLE9BQU9GLEtBQUtELEVBQWxCOztlQUVPQSxLQUFNRyxPQUFPRCxJQUFwQjs7O1NBR0MsSUFBSWwxQixJQUFJLENBQVIsRUFBV3drQixJQUFJLENBQXBCLEVBQXVCeGtCLEtBQUtpWCxDQUE1QixFQUErQixFQUFFalgsQ0FBakMsRUFDQTtZQUNRQSxJQUFJaVgsQ0FBUjs7O2FBR0s4ZCxNQUFNNU8sS0FBTixFQUFhc08sR0FBYixFQUFrQmpRLENBQWxCLENBQUw7YUFDS3VRLE1BQU0zTyxLQUFOLEVBQWFzTyxHQUFiLEVBQWtCbFEsQ0FBbEIsQ0FBTDthQUNLdVEsTUFBTU4sR0FBTixFQUFXalAsR0FBWCxFQUFnQmhCLENBQWhCLENBQUw7YUFDS3VRLE1BQU1MLEdBQU4sRUFBV2pQLEdBQVgsRUFBZ0JqQixDQUFoQixDQUFMOzs7WUFHSXVRLE1BQU1KLEVBQU4sRUFBVUUsRUFBVixFQUFjclEsQ0FBZCxDQUFKO1lBQ0l1USxNQUFNSCxFQUFOLEVBQVVFLEVBQVYsRUFBY3RRLENBQWQsQ0FBSjs7ZUFFT3BrQixJQUFQLENBQVltRixDQUFaLEVBQWVDLENBQWY7OztXQUdHb2QsTUFBUDs7O0FDL0hKOzs7Ozs7Ozs7O0FBVUEsQUFBZSxTQUFTd1MsV0FBVCxDQUFxQjlTLFlBQXJCLEVBQW1Db1AsU0FBbkMsRUFDZjs7O1FBR1UyRCxhQUFhL1MsYUFBYVIsS0FBaEM7UUFDTXZjLElBQUk4dkIsV0FBVzl2QixDQUFyQjtRQUNNQyxJQUFJNnZCLFdBQVc3dkIsQ0FBckI7UUFDSWlELGNBQUo7UUFDSUMsZUFBSjs7O1FBR0k0WixhQUFhdGMsSUFBYixLQUFzQjBXLE9BQU82RyxJQUFqQyxFQUNBO2dCQUNZOFIsV0FBVzVSLE1BQW5CO2lCQUNTNFIsV0FBVzVSLE1BQXBCO0tBSEosTUFNQTtnQkFDWTRSLFdBQVc1c0IsS0FBbkI7aUJBQ1M0c0IsV0FBVzNzQixNQUFwQjs7O1FBR0U0c0IsWUFBWXR6QixLQUFLZ1YsS0FBTCxDQUFXLEtBQUtoVixLQUFLMFUsSUFBTCxDQUFVMmUsV0FBVzVSLE1BQXJCLENBQWhCLEtBQ1h6aEIsS0FBS2dWLEtBQUwsQ0FBVyxLQUFLaFYsS0FBSzBVLElBQUwsQ0FBVTJlLFdBQVc1c0IsS0FBWCxHQUFtQjRzQixXQUFXM3NCLE1BQXhDLENBQWhCLENBRFA7O1FBR002c0IsTUFBT3Z6QixLQUFLaVAsRUFBTCxHQUFVLENBQVgsR0FBZ0Jxa0IsU0FBNUI7O1FBRUloVCxhQUFhVSxJQUFqQixFQUNBO1lBQ1U2TSxRQUFRTCxRQUFRbE4sYUFBYUUsU0FBckIsQ0FBZDtZQUNNMlAsUUFBUTdQLGFBQWFTLFNBQTNCOztZQUVNN2UsSUFBSTJyQixNQUFNLENBQU4sSUFBV3NDLEtBQXJCO1lBQ01DLElBQUl2QyxNQUFNLENBQU4sSUFBV3NDLEtBQXJCO1lBQ003aEIsSUFBSXVmLE1BQU0sQ0FBTixJQUFXc0MsS0FBckI7O1lBRU1ILFFBQVFOLFVBQVU5TyxNQUF4QjtZQUNNa04sVUFBVTRCLFVBQVU1QixPQUExQjs7WUFFSXlFLFNBQVN2QyxNQUFNanlCLE1BQU4sR0FBZSxDQUE1Qjs7Z0JBRVFLLElBQVIsQ0FBYW0wQixNQUFiOzthQUVLLElBQUl2MEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJczFCLFlBQVksQ0FBaEMsRUFBbUN0MUIsR0FBbkMsRUFDQTtrQkFDVUksSUFBTixDQUFXbUYsQ0FBWCxFQUFjQyxDQUFkLEVBQWlCdEIsQ0FBakIsRUFBb0JrdUIsQ0FBcEIsRUFBdUI5aEIsQ0FBdkIsRUFBMEI2aEIsS0FBMUI7O2tCQUVNL3hCLElBQU4sQ0FDSW1GLElBQUt2RCxLQUFLZ1AsR0FBTCxDQUFTdWtCLE1BQU12MUIsQ0FBZixJQUFvQnlJLEtBRDdCLEVBRUlqRCxJQUFLeEQsS0FBSytPLEdBQUwsQ0FBU3drQixNQUFNdjFCLENBQWYsSUFBb0IwSSxNQUY3QixFQUdJeEUsQ0FISixFQUdPa3VCLENBSFAsRUFHVTloQixDQUhWLEVBR2E2aEIsS0FIYjs7b0JBTVEveEIsSUFBUixDQUFhbTBCLFFBQWIsRUFBdUJBLFFBQXZCOzs7Z0JBR0luMEIsSUFBUixDQUFhbTBCLFNBQVMsQ0FBdEI7OztRQUdBalMsYUFBYXhELFNBQWpCLEVBQ0E7WUFDVXFWLGFBQWE3UixhQUFhTSxNQUFoQzs7cUJBRWFBLE1BQWIsR0FBc0IsRUFBdEI7O2FBRUssSUFBSTVpQixLQUFJLENBQWIsRUFBZ0JBLEtBQUlzMUIsWUFBWSxDQUFoQyxFQUFtQ3QxQixJQUFuQyxFQUNBO3lCQUNpQjRpQixNQUFiLENBQW9CeGlCLElBQXBCLENBQ0ltRixJQUFLdkQsS0FBS2dQLEdBQUwsQ0FBU3VrQixNQUFNdjFCLEVBQWYsSUFBb0J5SSxLQUQ3QixFQUVJakQsSUFBS3hELEtBQUsrTyxHQUFMLENBQVN3a0IsTUFBTXYxQixFQUFmLElBQW9CMEksTUFGN0I7OztrQkFNTTRaLFlBQVYsRUFBd0JvUCxTQUF4Qjs7cUJBRWE5TyxNQUFiLEdBQXNCdVIsVUFBdEI7Ozs7SUM1RWFxQjs7Ozs7OzhCQUtMcFQsUUFBWixFQUNBOzs7dUlBQ1VBLFFBRFY7O2NBR1NxVCxnQkFBTCxHQUF3QixFQUF4Qjs7Y0FFS0MsZUFBTCxHQUF1QixJQUF2Qjs7Y0FFS3R3QixFQUFMLEdBQVVnZCxTQUFTaGQsRUFBbkI7OztjQUdLdXdCLFdBQUwsR0FBbUIsQ0FBbkI7Ozs7Ozs7Ozs7Ozs7OzBDQVVKO2lCQUNTdndCLEVBQUwsR0FBVSxLQUFLZ2QsUUFBTCxDQUFjaGQsRUFBeEI7aUJBQ0t1d0IsV0FBTCxHQUFtQixLQUFLdlQsUUFBTCxDQUFjdVQsV0FBakM7aUJBQ0tELGVBQUwsR0FBdUIsSUFBSWxFLGVBQUosQ0FBb0IsS0FBS3BzQixFQUF6QixDQUF2Qjs7Ozs7Ozs7OztrQ0FRSjsyQkFDbUJ0RyxTQUFmLENBQXlCbVAsT0FBekIsQ0FBaUM1TixJQUFqQyxDQUFzQyxJQUF0Qzs7aUJBRUssSUFBSUwsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUt5MUIsZ0JBQUwsQ0FBc0IxMUIsTUFBMUMsRUFBa0QsRUFBRUMsQ0FBcEQsRUFDQTtxQkFDU3kxQixnQkFBTCxDQUFzQnoxQixDQUF0QixFQUF5QmlPLE9BQXpCOzs7aUJBR0N3bkIsZ0JBQUwsR0FBd0IsSUFBeEI7Ozs7Ozs7Ozs7OytCQVFJcFQsZUFDUjtnQkFDVWpELFdBQVdpRCxjQUFjakQsUUFBL0I7Z0JBQ01nRCxXQUFXLEtBQUtBLFFBQXRCO2dCQUNNaGQsS0FBS2dkLFNBQVNoZCxFQUFwQjs7Z0JBRUlzc0Isa0JBQUo7Z0JBQ0lrRSxRQUFReFcsU0FBU3lXLE1BQVQsQ0FBZ0IsS0FBS0YsV0FBckIsQ0FBWjs7Z0JBRUksQ0FBQ0MsS0FBRCxJQUFVeFcsU0FBUytRLEtBQVQsS0FBbUJ5RixNQUFNekYsS0FBdkMsRUFDQTtxQkFDUzJGLGNBQUwsQ0FBb0IxVyxRQUFwQjs7d0JBRVFBLFNBQVN5VyxNQUFULENBQWdCLEtBQUtGLFdBQXJCLENBQVI7Ozs7Z0JBSUVoRyxTQUFTLEtBQUsrRixlQUFwQjs7cUJBRVNLLFVBQVQsQ0FBb0JwRyxNQUFwQjs7aUJBRUssSUFBSTN2QixJQUFJLENBQVIsRUFBV2lYLElBQUkyZSxNQUFNclQsSUFBTixDQUFXeGlCLE1BQS9CLEVBQXVDQyxJQUFJaVgsQ0FBM0MsRUFBOENqWCxHQUE5QyxFQUNBOzRCQUNnQjQxQixNQUFNclQsSUFBTixDQUFXdmlCLENBQVgsQ0FBWjtvQkFDTWcyQixhQUFhdEUsVUFBVS9CLE1BQTdCOzt5QkFFU29HLFVBQVQsQ0FBb0JDLFVBQXBCOztvQkFFSUMsZUFBZTVULGNBQWM1VSxxQkFBZCxHQUFzQ3NTLE9BQXRDLENBQThDLElBQTlDLENBQW5COzJCQUNXbVcsUUFBWCxDQUFvQkMsaUJBQXBCLEdBQXdDRixZQUF4QzsyQkFDV0MsUUFBWCxDQUFvQkUsSUFBcEIsR0FBMkI1RyxRQUFRcFEsU0FBU2dYLElBQWpCLENBQTNCOzJCQUNXRixRQUFYLENBQW9CL0QsS0FBcEIsR0FBNEIvUyxTQUFTaVgsVUFBckM7O3lCQUVTQyxPQUFULENBQWlCNUUsVUFBVXBCLEdBQTNCOzBCQUNVQSxHQUFWLENBQWNpRyxJQUFkLENBQW1CbnhCLEdBQUdveEIsY0FBdEIsRUFBc0M5RSxVQUFVNUIsT0FBVixDQUFrQi92QixNQUF4RDs7Ozs7Ozs7Ozs7Ozt1Q0FVT3FmLFVBQ2Y7Z0JBQ1VoYSxLQUFLLEtBQUtnZCxRQUFMLENBQWNoZCxFQUF6Qjs7O2dCQUdJd3dCLFFBQVF4VyxTQUFTeVcsTUFBVCxDQUFnQixLQUFLRixXQUFyQixDQUFaOzs7Z0JBR0ksQ0FBQ0MsS0FBTCxFQUNBO3dCQUNZeFcsU0FBU3lXLE1BQVQsQ0FBZ0IsS0FBS0YsV0FBckIsSUFBb0MsRUFBRWMsV0FBVyxDQUFiLEVBQWdCbFUsTUFBTSxFQUF0QixFQUEwQm5kLE1BQTFCLEVBQThCc3hCLFlBQVksQ0FBQyxDQUEzQyxFQUE4Q3ZHLE9BQU8sQ0FBQyxDQUF0RCxFQUE1Qzs7OztrQkFJRUEsS0FBTixHQUFjL1EsU0FBUytRLEtBQXZCOzs7Z0JBR0kvUSxTQUFTc1gsVUFBVCxLQUF3QmQsTUFBTWMsVUFBbEMsRUFDQTtzQkFDVUEsVUFBTixHQUFtQnRYLFNBQVNzWCxVQUE1Qjs7O3FCQUdLLElBQUkxMkIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNDFCLE1BQU1yVCxJQUFOLENBQVd4aUIsTUFBL0IsRUFBdUNDLEdBQXZDLEVBQ0E7eUJBQ1N5MUIsZ0JBQUwsQ0FBc0JyMUIsSUFBdEIsQ0FBMkJ3MUIsTUFBTXJULElBQU4sQ0FBV3ZpQixDQUFYLENBQTNCOzs7O3NCQUlFdWlCLElBQU4sQ0FBV3hpQixNQUFYLEdBQW9CLENBQXBCO3NCQUNNMDJCLFNBQU4sR0FBa0IsQ0FBbEI7OztnQkFHQS9FLGtCQUFKOzs7OztpQkFLSyxJQUFJMXhCLEtBQUk0MUIsTUFBTWEsU0FBbkIsRUFBOEJ6MkIsS0FBSW9mLFNBQVNrRCxZQUFULENBQXNCdmlCLE1BQXhELEVBQWdFQyxJQUFoRSxFQUNBO29CQUNVdWlCLE9BQU9uRCxTQUFTa0QsWUFBVCxDQUFzQnRpQixFQUF0QixDQUFiOzs7NEJBR1ksS0FBSzIyQixZQUFMLENBQWtCZixLQUFsQixFQUF5QixDQUF6QixDQUFaOztvQkFFSXJULEtBQUt2YyxJQUFMLEtBQWMwVyxPQUFPK0YsSUFBekIsRUFDQTs4QkFDY0YsSUFBVixFQUFnQm1QLFNBQWhCOztvQkFFQW5QLEtBQUt2YyxJQUFMLEtBQWMwVyxPQUFPMEcsSUFBekIsRUFDQTttQ0FDbUJiLElBQWYsRUFBcUJtUCxTQUFyQjtpQkFGSixNQUlLLElBQUluUCxLQUFLdmMsSUFBTCxLQUFjMFcsT0FBTzZHLElBQXJCLElBQTZCaEIsS0FBS3ZjLElBQUwsS0FBYzBXLE9BQU9pSCxJQUF0RCxFQUNMO2dDQUNnQnBCLElBQVosRUFBa0JtUCxTQUFsQjtpQkFGQyxNQUlBLElBQUluUCxLQUFLdmMsSUFBTCxLQUFjMFcsT0FBT2thLElBQXpCLEVBQ0w7MENBQzBCclUsSUFBdEIsRUFBNEJtUCxTQUE1Qjs7O3NCQUdFK0UsU0FBTjs7O2lCQUdDclUsUUFBTCxDQUFja1UsT0FBZCxDQUFzQixJQUF0Qjs7O2lCQUdLLElBQUl0MkIsTUFBSSxDQUFiLEVBQWdCQSxNQUFJNDFCLE1BQU1yVCxJQUFOLENBQVd4aUIsTUFBL0IsRUFBdUNDLEtBQXZDLEVBQ0E7NEJBQ2dCNDFCLE1BQU1yVCxJQUFOLENBQVd2aUIsR0FBWCxDQUFaOztvQkFFSTB4QixVQUFVdkIsS0FBZCxFQUNBOzhCQUNjVyxNQUFWOzs7Ozs7Ozs7Ozs7Ozs7cUNBWUMxckIsSUFBSVksTUFDakI7Z0JBQ1EwckIsWUFBWXRzQixHQUFHbWQsSUFBSCxDQUFRbmQsR0FBR21kLElBQUgsQ0FBUXhpQixNQUFSLEdBQWlCLENBQXpCLENBQWhCOztnQkFFSSxDQUFDMnhCLFNBQUQsSUFBY0EsVUFBVTlPLE1BQVYsQ0FBaUI3aUIsTUFBakIsR0FBMEIsTUFBNUMsRUFDQTs0QkFDZ0IsS0FBSzAxQixnQkFBTCxDQUFzQjVELEdBQXRCLE1BQ0wsSUFBSW5DLGlCQUFKLENBQXNCLEtBQUt0TixRQUFMLENBQWNoZCxFQUFwQyxFQUF3QyxLQUFLc3dCLGVBQTdDLEVBQThELEtBQUt0VCxRQUFMLENBQWN3TSxLQUFkLENBQW9CZ0IsWUFBbEYsQ0FEUDs7MEJBR1VpSCxLQUFWLENBQWdCN3dCLElBQWhCO21CQUNHdWMsSUFBSCxDQUFRbmlCLElBQVIsQ0FBYXN4QixTQUFiOzs7c0JBR012QixLQUFWLEdBQWtCLElBQWxCOzttQkFFT3VCLFNBQVA7Ozs7RUFyTXNDakU7O0FDTDlDLElBQUlrSSxjQUFjLENBQWxCOztJQUdxQm1CO2dDQUdKL1osS0FBYixFQUFxQnNFLEdBQXJCLEVBQ0E7WUFEMkIxZSxPQUMzQix1RUFEcUMsRUFDckM7OzthQUNTcUQsSUFBTCxHQUFZd1csY0FBY3VhLEtBQTFCO2FBQ0t0dUIsS0FBTCxHQUFhNFksSUFBSTVZLEtBQWpCO2FBQ0tDLE1BQUwsR0FBYzJZLElBQUkzWSxNQUFsQjthQUNLakUsTUFBTCxHQUFjc1ksTUFBTXRZLE1BQXBCOzs7Ozs7Ozs7OzthQVdLdXlCLGlCQUFMLEdBQXlCLEtBQUtBLGlCQUFMLENBQXVCL2pCLElBQXZCLENBQTRCLElBQTVCLENBQXpCO2FBQ0tna0IscUJBQUwsR0FBNkIsS0FBS0EscUJBQUwsQ0FBMkJoa0IsSUFBM0IsQ0FBZ0MsSUFBaEMsQ0FBN0I7YUFDS3hPLE1BQUwsQ0FBWXl5QixnQkFBWixDQUE2QixrQkFBN0IsRUFBaUQsS0FBS0YsaUJBQXRELEVBQXlFLEtBQXpFO2FBQ0t2eUIsTUFBTCxDQUFZeXlCLGdCQUFaLENBQTZCLHNCQUE3QixFQUFxRCxLQUFLRCxxQkFBMUQsRUFBaUYsS0FBakY7O2FBR0tFLGdCQUFMLEdBQXdCLFFBQXhCO2FBQ0tDLG9CQUFMLEdBQTRCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUE1QjthQUNLQyxzQkFBTCxHQUE4QixTQUE5QjthQUNLQyxlQUFMLEdBQXVCMzBCLFFBQVEyMEIsZUFBUixJQUEyQixLQUFLSCxnQkFBdkQ7O2FBRUtJLGVBQUwsR0FBdUI7bUJBQ1o1MEIsUUFBUTYwQixXQURJO3VCQUVSNzBCLFFBQVE4MEIsU0FGQTtnQ0FHQzkwQixRQUFRNjBCLFdBQVIsSUFBdUI3MEIsUUFBUTYwQixXQUFSLEtBQXdCLGVBSGhEO3FCQUlWLElBSlU7bUNBS0k3MEIsUUFBUSswQjtTQUxuQzs7YUFRS0MsYUFBTCxHQUFxQixJQUFJbEssY0FBSixDQUFtQixJQUFuQixDQUFyQjs7YUFFS21LLGVBQUwsR0FBdUIsS0FBS0QsYUFBNUI7O2FBRUt2eUIsRUFBTCxHQUFVekMsUUFBUW5DLE9BQVIsSUFBbUJ5ckIsTUFBTzRMLGFBQVAsQ0FBc0IsS0FBS3B6QixNQUEzQixFQUFvQyxLQUFLOHlCLGVBQXpDLENBQTdCOzthQUVLNUIsV0FBTCxHQUFtQkEsYUFBbkI7O2FBRUsvRyxLQUFMLEdBQWEsSUFBSVosVUFBSixDQUFlLEtBQUs1b0IsRUFBcEIsQ0FBYjs7YUFFSzB5QixhQUFMLEdBQXFCLElBQXJCOzthQUVLQyxVQUFMLEdBQWtCLElBQWxCOzthQUdLQyxtQkFBTCxHQUEyQixJQUEzQjs7O2FBS0tDLFNBQUwsR0FBaUIsS0FBS0MsaUJBQUwsRUFBakI7O2FBRUtDLE9BQUwsR0FBZSxJQUFJM0MsZ0JBQUosQ0FBcUIsSUFBckIsQ0FBZjs7YUFFSzRDLFlBQUw7Ozs7Ozs7Ozs7Ozt1Q0FVSjtnQkFDVWh6QixLQUFLLEtBQUtBLEVBQWhCOzs7Z0JBR0lBLEdBQUdpekIsYUFBSCxNQUFzQmp6QixHQUFHdXBCLFlBQUgsQ0FBZ0Isb0JBQWhCLENBQTFCLEVBQ0E7bUJBQ09BLFlBQUgsQ0FBZ0Isb0JBQWhCLEVBQXNDMkosY0FBdEM7OztpQkFHQzFKLEtBQUwsQ0FBVzJKLGNBQVg7O2lCQUVLQyxnQkFBTCxHQUF3QixJQUFJdE0sWUFBSixDQUFpQjltQixFQUFqQixFQUFxQixLQUFLcUQsS0FBMUIsRUFBaUMsS0FBS0MsTUFBdEMsRUFBOENFLFNBQVNDLFVBQXZELEVBQW1FLElBQW5FLENBQXhCO2lCQUNLMnZCLGdCQUFMLENBQXNCbk0sVUFBdEIsR0FBbUMsS0FBSytLLG9CQUF4Qzs7aUJBRUtxQixnQkFBTCxDQUFzQixLQUFLRCxnQkFBM0I7O2lCQUVLTCxPQUFMLENBQWF2SyxlQUFiOzs7OytCQUlHdkwsZUFDUDs7Z0JBRVEsQ0FBQyxLQUFLamQsRUFBTixJQUFZLEtBQUtBLEVBQUwsQ0FBUWl6QixhQUFSLEVBQWhCLEVBQ0E7Ozs7aUJBSUtULGVBQUwsQ0FBcUJsckIsS0FBckI7O2lCQUVLc3JCLG1CQUFMLENBQXlCaEwsS0FBekI7O2lCQUVLbUwsT0FBTCxDQUFhblksTUFBYixDQUFxQnFDLGFBQXJCOzs7O2lCQUlLdVYsZUFBTCxDQUFxQmxLLEtBQXJCOzs7Ozs7Ozs7OzswQ0FRY2dMLGdCQUNsQjtnQkFDUSxLQUFLZCxlQUFMLEtBQXlCYyxjQUE3QixFQUNBOzs7O2lCQUlLZCxlQUFMLENBQXFCemlCLElBQXJCO2lCQUNLeWlCLGVBQUwsR0FBdUJjLGNBQXZCO2lCQUNLZCxlQUFMLENBQXFCbHJCLEtBQXJCOzs7Ozs7Ozs7OztnQ0FTSjtpQkFDU2lzQixpQkFBTCxDQUF1QixLQUFLaEIsYUFBNUI7Ozs7Ozs7Ozs7OzsrQkFTR2x2QixPQUFPQyxRQUNkOzs7aUJBR1M4dkIsZ0JBQUwsQ0FBc0IxTCxNQUF0QixDQUE2QnJrQixLQUE3QixFQUFvQ0MsTUFBcEM7O2dCQUVJLEtBQUtzdkIsbUJBQUwsS0FBNkIsS0FBS1EsZ0JBQXRDLEVBQ0E7cUJBQ1NBLGdCQUFMLENBQXNCSSxRQUF0Qjs7b0JBRUksS0FBS2QsYUFBVCxFQUNBO3lCQUNTQSxhQUFMLENBQW1CNUIsUUFBbkIsQ0FBNEIzSixnQkFBNUIsR0FBK0MsS0FBS2lNLGdCQUFMLENBQXNCak0sZ0JBQXRCLENBQXVDeE0sT0FBdkMsQ0FBK0MsSUFBL0MsQ0FBL0M7Ozs7Ozs7Ozs7Ozs7OEJBV05zTSxZQUNOO2lCQUNTMkwsbUJBQUwsQ0FBeUJoTCxLQUF6QixDQUErQlgsVUFBL0I7Ozs7Ozs7Ozs7Ozt5Q0FTYXdNLGNBQ2pCO2dCQUNRQSxpQkFBaUIsS0FBS2IsbUJBQTFCLEVBQ0E7cUJBQ1NBLG1CQUFMLEdBQTJCYSxZQUEzQjs2QkFDYUQsUUFBYjs7b0JBRUksS0FBS2QsYUFBVCxFQUNBO3lCQUNTQSxhQUFMLENBQW1CNUIsUUFBbkIsQ0FBNEIzSixnQkFBNUIsR0FBK0NzTSxhQUFhdE0sZ0JBQWIsQ0FBOEJ4TSxPQUE5QixDQUFzQyxJQUF0QyxDQUEvQzs7O21CQUdELElBQVA7Ozs7Ozs7Ozs7OzttQ0FTTzRQLFFBQ1g7O2dCQUVRLEtBQUttSSxhQUFMLEtBQXVCbkksTUFBM0IsRUFDQTtxQkFDU21JLGFBQUwsR0FBcUJuSSxNQUFyQjt1QkFDTzFjLElBQVA7O3VCQUVPaWpCLFFBQVAsQ0FBZ0IzSixnQkFBaEIsR0FBbUMsS0FBS3lMLG1CQUFMLENBQXlCekwsZ0JBQXpCLENBQTBDeE0sT0FBMUMsQ0FBa0QsSUFBbEQsQ0FBbkM7OzttQkFHRyxJQUFQOzs7Ozs7Ozs7OztvQ0FTSjttQkFDVyxJQUFJa00sTUFBT3NFLGlCQUFYLENBQTZCLEtBQUtuckIsRUFBbEMsRUFBc0MsS0FBS3dwQixLQUFMLENBQVdILFdBQWpELENBQVA7Ozs7Ozs7Ozs7OztnQ0FTSTZCLEtBQ1I7Z0JBQ1EsS0FBS3lILFVBQUwsS0FBb0J6SCxHQUF4QixFQUNBO3VCQUNXLElBQVA7OztnQkFHQUEsR0FBSixFQUNBO29CQUNRcmQsSUFBSjthQUZKLE1BSUssSUFBSSxLQUFLOGtCLFVBQVQsRUFDTDs7cUJBRVNBLFVBQUwsQ0FBZ0JlLE1BQWhCOzs7aUJBR0NmLFVBQUwsR0FBa0J6SCxHQUFsQjs7bUJBRU8sSUFBUDs7Ozs7Ozs7Ozs7Z0NBU0o7aUJBQ1NxSSxpQkFBTCxDQUF1QixLQUFLaEIsYUFBNUI7O2lCQUVLRyxhQUFMLEdBQXFCLElBQXJCO2lCQUNLRSxtQkFBTCxHQUEyQixLQUFLUSxnQkFBaEM7OztpQkFHS0EsZ0JBQUwsQ0FBc0JJLFFBQXRCOztpQkFFS2hLLEtBQUwsQ0FBVzJKLGNBQVg7O21CQUVPLElBQVA7Ozs7Ozs7Ozs7OzswQ0FTYzV4QixPQUNsQjtrQkFDVWlGLGNBQU47Ozs7Ozs7Ozs7O2dEQVNKO2lCQUNTd3NCLFlBQUw7aUJBQ0tXLGNBQUwsQ0FBb0JDLFNBQXBCOzs7OzRDQUlKO2dCQURtQjNsQixNQUNuQix1RUFEMEIsRUFDMUI7O21CQUNXb0osV0FBV3djLE1BQWxCLElBQTRCLEtBQUs3ekIsRUFBTCxDQUFRNnpCLE1BQXBDO21CQUNPeGMsV0FBV3ljLEtBQWxCLElBQTJCLEtBQUs5ekIsRUFBTCxDQUFROHpCLEtBQW5DO21CQUNPemMsV0FBVzBjLFNBQWxCLElBQStCLEtBQUsvekIsRUFBTCxDQUFRK3pCLFNBQXZDO21CQUNPMWMsV0FBVzJjLFVBQWxCLElBQWdDLEtBQUtoMEIsRUFBTCxDQUFRZzBCLFVBQXhDO21CQUNPM2MsV0FBVzRjLFNBQWxCLElBQStCLEtBQUtqMEIsRUFBTCxDQUFRaTBCLFNBQXZDO21CQUNPNWMsV0FBVytaLGNBQWxCLElBQW9DLEtBQUtweEIsRUFBTCxDQUFRb3hCLGNBQTVDO21CQUNPL1osV0FBVzZjLFlBQWxCLElBQWtDLEtBQUtsMEIsRUFBTCxDQUFRazBCLFlBQTFDOzttQkFFT2ptQixNQUFQOzs7Ozs7Ozs7Ozs7Z0NBVUlrbUIsWUFDUjtpQkFDU0MsY0FBTDs7O2lCQUdLMXdCLElBQUwsQ0FBVTJ3QixtQkFBVixDQUE4QixrQkFBOUIsRUFBa0QsS0FBS3pDLGlCQUF2RDtpQkFDS2x1QixJQUFMLENBQVUyd0IsbUJBQVYsQ0FBOEIsc0JBQTlCLEVBQXNELEtBQUt4QyxxQkFBM0Q7OzsySUFHY3NDLFVBQWQ7O2lCQUVLRyxHQUFMLEdBQVcsQ0FBWDs7aUJBRUs5QixlQUFMLEdBQXVCLElBQXZCOztpQkFFS1osaUJBQUwsR0FBeUIsSUFBekI7aUJBQ0tDLHFCQUFMLEdBQTZCLElBQTdCOztpQkFFS00sZUFBTCxHQUF1QixJQUF2QjtpQkFDS255QixFQUFMLENBQVF1MEIsVUFBUixDQUFtQixJQUFuQjs7Z0JBRUksS0FBS3YwQixFQUFMLENBQVF1cEIsWUFBUixDQUFxQixvQkFBckIsQ0FBSixFQUNBO3FCQUNTdnBCLEVBQUwsQ0FBUXVwQixZQUFSLENBQXFCLG9CQUFyQixFQUEyQ2lMLFdBQTNDOzs7aUJBR0N4MEIsRUFBTCxHQUFVLElBQVY7Ozs7OztJQ3hWYXkwQjs7OzJCQUVMeFksR0FBWixFQUNBO1lBRGtCMWUsT0FDbEIsdUVBRDRCLEVBQzVCOzs0SEFDVTZaLGNBQWNtSSxNQUR4QixFQUNnQ3RELEdBRGhDLEVBQ3FDMWUsT0FEckM7Ozs7OytCQUlRMGUsS0FDUjtnQkFEYzFlLE9BQ2QsdUVBRHdCLEVBQ3hCOztnQkFDUXdILEtBQUssSUFBVDs7ZUFFR2tYLEdBQUgsR0FBU0EsR0FBVDtnQkFDRTNlLE1BQUYsQ0FBVSxLQUFLQyxPQUFmLEVBQXlCQSxPQUF6Qjs7Z0JBRUVyQyxJQUFGLENBQU81QixJQUFFbUIsTUFBRixDQUFVd2hCLElBQUlXLGFBQWQsQ0FBUCxFQUF1QyxVQUFTNkMsWUFBVCxFQUFzQjttQkFDdERDLFdBQUgsQ0FBZ0JELGFBQWE5SCxLQUE3QjthQURKOztnQkFJSWlGLGFBQUosR0FBb0IsRUFBcEI7Ozs7b0NBR1NqRixPQUNiO2dCQUNPLENBQUNBLE1BQU0rYyxrQkFBVixFQUE2QjtzQkFDbkJBLGtCQUFOLEdBQTJCLElBQUloRCxrQkFBSixDQUF3Qi9aLEtBQXhCLEVBQWdDc0UsR0FBaEMsRUFBc0MsS0FBSzFlLE9BQTNDLENBQTNCOztrQkFFRXFlLFlBQU4sR0FBcUIsSUFBckI7aUJBQ0srRCxNQUFMLENBQWFoSSxLQUFiO2lCQUNLaUksT0FBTCxDQUFjakksS0FBZDtrQkFDTWlFLFlBQU4sR0FBcUIsS0FBckI7Ozs7Z0NBR0tqRSxPQUFRc0YsZUFDakI7Z0JBQ1EsQ0FBQ0EsYUFBTCxFQUFvQjtnQ0FDQXRGLEtBQWhCOzs7Z0JBR0EsQ0FBQ3NGLGNBQWM3aEIsT0FBZCxDQUFzQm1mLE9BQXZCLElBQWtDMEMsY0FBYzdoQixPQUFkLENBQXNCNkssV0FBdEIsSUFBcUMsQ0FBM0UsRUFBOEU7Ozs7Z0JBSTFFZ1gsY0FBY2pELFFBQWxCLEVBQTRCO3NCQUNsQjBhLGtCQUFOLENBQXlCOVosTUFBekIsQ0FBaUNxQyxhQUFqQzs7O2dCQUdBQSxjQUFjL1MsUUFBbEIsRUFBNEI7cUJBQ3BCLElBQUl0UCxJQUFJLENBQVIsRUFBV3lnQixNQUFNNEIsY0FBYy9TLFFBQWQsQ0FBdUJ2UCxNQUE1QyxFQUFvREMsSUFBSXlnQixHQUF4RCxFQUE2RHpnQixHQUE3RCxFQUFrRTt5QkFDekRnbEIsT0FBTCxDQUFjakksS0FBZCxFQUFzQnNGLGNBQWMvUyxRQUFkLENBQXVCdFAsQ0FBdkIsQ0FBdEI7Ozs7OzsrQkFLSitjLE9BQ1I7a0JBQ1UrYyxrQkFBTixDQUF5QjlNLEtBQXpCOzs7O0VBdkRtQzdMOztBQ0Y1QixTQUFTNFksWUFBVCxDQUF1QjFZLEdBQXZCLEVBQTZCMWUsT0FBN0IsRUFDZjtRQUNRLENBQUMwZSxJQUFJMlksT0FBTCxJQUFnQkMsTUFBTUMsZ0JBQU4sRUFBcEIsRUFDQTtlQUNXLElBQUlMLGFBQUosQ0FBbUJ4WSxHQUFuQixFQUF5QjFlLE9BQXpCLENBQVA7OztXQUdHLElBQUkraEIsY0FBSixDQUFvQnJELEdBQXBCLEVBQTBCMWUsT0FBMUIsQ0FBUDs7O0FDWEo7Ozs7Ozs7Ozs7Ozs7QUFhQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBR0E7QUFDQSxBQUNBLEFBR0EsSUFBSXczQixjQUFjLFNBQWRBLFdBQWMsQ0FBVXYxQixHQUFWLEVBQTZCO1FBQWJqQyxPQUFhLHVFQUFILEVBQUc7O1NBQ3RDcUQsSUFBTCxHQUFZLFFBQVo7U0FDS28wQixJQUFMLEdBQVksSUFBSWxuQixJQUFKLEdBQVdDLE9BQVgsS0FBdUIsR0FBdkIsR0FBNkJuUixLQUFLZ1YsS0FBTCxDQUFXaFYsS0FBS3E0QixNQUFMLEtBQWMsR0FBekIsQ0FBekM7O1NBRUs3ekIsRUFBTCxHQUFVa0UsRUFBRTR2QixLQUFGLENBQVExMUIsSUFBSTRCLEVBQVosQ0FBVjs7U0FFS2lDLEtBQUwsR0FBYW9XLFNBQVMsV0FBWWphLEdBQVosSUFBbUIsS0FBSzRCLEVBQUwsQ0FBUSt6QixXQUFwQyxFQUFtRCxFQUFuRCxDQUFiO1NBQ0s3eEIsTUFBTCxHQUFjbVcsU0FBUyxZQUFZamEsR0FBWixJQUFtQixLQUFLNEIsRUFBTCxDQUFRZzBCLFlBQXBDLEVBQW1ELEVBQW5ELENBQWQ7O1FBRUlDLFVBQVUvdkIsRUFBRWd3QixVQUFGLENBQWEsS0FBS2p5QixLQUFsQixFQUEwQixLQUFLQyxNQUEvQixFQUF1QyxLQUFLMHhCLElBQTVDLENBQWQ7U0FDS3R4QixJQUFMLEdBQVkyeEIsUUFBUTN4QixJQUFwQjtTQUNLRyxPQUFMLEdBQWV3eEIsUUFBUXh4QixPQUF2QjtTQUNLQyxLQUFMLEdBQWF1eEIsUUFBUXZ4QixLQUFyQjs7U0FFSzFDLEVBQUwsQ0FBUW0wQixTQUFSLEdBQW9CLEVBQXBCO1NBQ0tuMEIsRUFBTCxDQUFRMkMsV0FBUixDQUFxQixLQUFLTCxJQUExQjs7U0FFSzZCLFVBQUwsR0FBa0JELEVBQUVrd0IsTUFBRixDQUFTLEtBQUs5eEIsSUFBZCxDQUFsQjtTQUNLK3hCLFNBQUwsR0FBaUIsQ0FBakIsQ0FsQjJDOztTQW9CdENiLE9BQUwsR0FBZ0JwMUIsSUFBSW8xQixPQUFwQjtTQUNLNVgsUUFBTCxHQUFnQjJYLGFBQWEsSUFBYixFQUFvQnAzQixPQUFwQixDQUFoQjs7U0FFS2dFLEtBQUwsR0FBYSxJQUFiOztTQUVLMkcsWUFBTCxHQUFvQixJQUFwQjs7O1NBR0sxQixjQUFMLEdBQXNCLElBQXRCO1FBQ0loSCxJQUFJZ0gsY0FBSixLQUF1QixLQUEzQixFQUFrQzthQUN6QkEsY0FBTCxHQUFzQixLQUF0Qjs7OztTQUlDb1csYUFBTCxHQUFxQixFQUFyQjs7Z0JBRVl4ZCxVQUFaLENBQXVCbEMsV0FBdkIsQ0FBbUM0TixLQUFuQyxDQUF5QyxJQUF6QyxFQUErQ2pOLFNBQS9DO0NBcENKOztBQXVDQUcsTUFBTTJMLFVBQU4sQ0FBaUJvckIsV0FBakIsRUFBK0JoYSxzQkFBL0IsRUFBd0Q7VUFDN0MsZ0JBQVU7YUFDUjNmLE9BQUwsQ0FBYWlJLEtBQWIsR0FBc0IsS0FBS0EsS0FBM0I7YUFDS2pJLE9BQUwsQ0FBYWtJLE1BQWIsR0FBc0IsS0FBS0EsTUFBM0I7OzthQUdLb3lCLGdCQUFMOzs7YUFHS0MsbUJBQUw7S0FUZ0Q7aUJBWXRDLHFCQUFTbjJCLEdBQVQsRUFBYTs7YUFFbEIrQixLQUFMLEdBQWEsSUFBSTJDLFlBQUosQ0FBa0IsSUFBbEIsRUFBeUIxRSxHQUF6QixDQUFiLENBQTJDO2FBQ3RDK0IsS0FBTCxDQUFXd1csSUFBWDtlQUNPLEtBQUt4VyxLQUFaO0tBaEJnRDtZQWtCM0MsZ0JBQVUvQixHQUFWLEVBQWU7O2FBRWY2RCxLQUFMLEdBQWtCb1csU0FBVWphLE9BQU8sV0FBV0EsR0FBbkIsSUFBMkIsS0FBSzRCLEVBQUwsQ0FBUSt6QixXQUE1QyxFQUEyRCxFQUEzRCxDQUFsQjthQUNLN3hCLE1BQUwsR0FBa0JtVyxTQUFVamEsT0FBTyxZQUFZQSxHQUFwQixJQUE0QixLQUFLNEIsRUFBTCxDQUFRZzBCLFlBQTdDLEVBQTRELEVBQTVELENBQWxCOzthQUVLMXhCLElBQUwsQ0FBVVAsS0FBVixDQUFnQkUsS0FBaEIsR0FBeUIsS0FBS0EsS0FBTCxHQUFZLElBQXJDO2FBQ0tLLElBQUwsQ0FBVVAsS0FBVixDQUFnQkcsTUFBaEIsR0FBeUIsS0FBS0EsTUFBTCxHQUFZLElBQXJDOzthQUVLaUMsVUFBTCxHQUFzQkQsRUFBRWt3QixNQUFGLENBQVMsS0FBSzl4QixJQUFkLENBQXRCO2FBQ0srRSxTQUFMLEdBQXNCLElBQXRCO2FBQ0tyTixPQUFMLENBQWFpSSxLQUFiLEdBQXNCLEtBQUtBLEtBQTNCO2FBQ0tqSSxPQUFMLENBQWFrSSxNQUFiLEdBQXNCLEtBQUtBLE1BQTNCO2FBQ0ttRixTQUFMLEdBQXNCLEtBQXRCOztZQUVJMUQsS0FBSyxJQUFUO1lBQ0k2d0IsZUFBa0IsU0FBbEJBLFlBQWtCLENBQVN0YixHQUFULEVBQWE7Z0JBQzNCamIsU0FBU2liLElBQUlqYixNQUFqQjttQkFDTzhELEtBQVAsQ0FBYUUsS0FBYixHQUFxQjBCLEdBQUcxQixLQUFILEdBQVcsSUFBaEM7bUJBQ09GLEtBQVAsQ0FBYUcsTUFBYixHQUFxQnlCLEdBQUd6QixNQUFILEdBQVcsSUFBaEM7bUJBQ09DLFlBQVAsQ0FBb0IsT0FBcEIsRUFBK0J3QixHQUFHMUIsS0FBSCxHQUFXckYsTUFBTThkLGlCQUFoRDttQkFDT3ZZLFlBQVAsQ0FBb0IsUUFBcEIsRUFBK0J3QixHQUFHekIsTUFBSCxHQUFXdEYsTUFBTThkLGlCQUFoRDs7O2dCQUdJeEIsSUFBSW9OLE1BQVIsRUFBZ0I7b0JBQ1JBLE1BQUosQ0FBVzNpQixHQUFHMUIsS0FBZCxFQUFzQjBCLEdBQUd6QixNQUF6Qjs7U0FUUjtZQVlFcEksSUFBRixDQUFPLEtBQUtnUCxRQUFaLEVBQXVCLFVBQVNuTCxDQUFULEVBQWFuRSxDQUFiLEVBQWU7Y0FDaEM2TixTQUFGLEdBQWtCLElBQWxCO2NBQ0VyTixPQUFGLENBQVVpSSxLQUFWLEdBQWtCMEIsR0FBRzFCLEtBQXJCO2NBQ0VqSSxPQUFGLENBQVVrSSxNQUFWLEdBQWtCeUIsR0FBR3pCLE1BQXJCO3lCQUNhdkUsRUFBRU0sTUFBZjtjQUNFb0osU0FBRixHQUFrQixLQUFsQjtTQUxKOzthQVFLM0UsS0FBTCxDQUFXWCxLQUFYLENBQWlCRSxLQUFqQixHQUEwQixLQUFLQSxLQUFMLEdBQWMsSUFBeEM7YUFDS1MsS0FBTCxDQUFXWCxLQUFYLENBQWlCRyxNQUFqQixHQUEwQixLQUFLQSxNQUFMLEdBQWMsSUFBeEM7O2FBRUtzRixTQUFMO0tBeERnRDttQkEyRHBDLHlCQUFVO2VBQ2YsS0FBS1YsWUFBWjtLQTVEZ0Q7c0JBOERqQyw0QkFBVTs7YUFFcEJBLFlBQUwsR0FBb0IsSUFBSXlULEtBQUosQ0FBVztnQkFDdEIsZ0JBQWUsSUFBSTdOLElBQUosRUFBRCxDQUFhQyxPQUFiLEVBRFE7cUJBRWpCO3VCQUNFLEtBQUszUyxPQUFMLENBQWFpSSxLQURmO3dCQUVFLEtBQUtqSSxPQUFMLENBQWFrSTs7U0FKVCxDQUFwQjs7YUFRSzRFLFlBQUwsQ0FBa0JtQixhQUFsQixHQUFrQyxLQUFsQzthQUNLd3NCLFFBQUwsQ0FBZSxLQUFLM3RCLFlBQXBCO0tBekVnRDs7Ozs7eUJBK0U5QiwrQkFBVztZQUN6QjR0QixlQUFleHdCLEVBQUU0dkIsS0FBRixDQUFRLGNBQVIsQ0FBbkI7WUFDRyxDQUFDWSxZQUFKLEVBQWlCOzJCQUNFeHdCLEVBQUV5d0IsWUFBRixDQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIsY0FBckIsQ0FBZjtTQURKLE1BRU87Ozs7aUJBSUVsMEIsSUFBVCxDQUFja0MsV0FBZCxDQUEyQit4QixZQUEzQjtjQUNNdjJCLFdBQU4sQ0FBbUJ1MkIsWUFBbkI7WUFDSTkzQixNQUFNZzRCLGFBQU4sRUFBSixFQUEyQjs7eUJBRVY3eUIsS0FBYixDQUFtQjh5QixPQUFuQixHQUFnQyxNQUFoQztTQUZKLE1BR087O3lCQUVVOXlCLEtBQWIsQ0FBbUIreUIsTUFBbkIsR0FBZ0MsQ0FBQyxDQUFqQzt5QkFDYS95QixLQUFiLENBQW1CQyxRQUFuQixHQUFnQyxVQUFoQzt5QkFDYUQsS0FBYixDQUFtQmYsSUFBbkIsR0FBZ0MsQ0FBQyxLQUFLaEgsT0FBTCxDQUFhaUksS0FBZCxHQUF1QixJQUF2RDt5QkFDYUYsS0FBYixDQUFtQlosR0FBbkIsR0FBZ0MsQ0FBQyxLQUFLbkgsT0FBTCxDQUFha0ksTUFBZCxHQUF1QixJQUF2RDt5QkFDYUgsS0FBYixDQUFtQmd6QixVQUFuQixHQUFnQyxRQUFoQzs7Y0FFRUMsU0FBTixHQUFrQk4sYUFBYXQzQixVQUFiLENBQXdCLElBQXhCLENBQWxCO0tBcEdnRDs7c0JBdUdqQyw0QkFBVTtZQUNyQjhPLE1BQU0sSUFBSVEsSUFBSixHQUFXQyxPQUFYLEVBQVY7WUFDSVQsTUFBTSxLQUFLbW9CLFNBQVgsR0FBdUIsSUFBM0IsRUFBaUM7aUJBQ3hCbHdCLFVBQUwsR0FBdUJELEVBQUVrd0IsTUFBRixDQUFTLEtBQUs5eEIsSUFBZCxDQUF2QjtpQkFDSyt4QixTQUFMLEdBQXVCbm9CLEdBQXZCOztLQTNHNEM7O29CQStHbkMsd0JBQVVxSyxLQUFWLEVBQWtCaGMsS0FBbEIsRUFBeUI7WUFDbEMwRCxNQUFKOztZQUVHLENBQUNzWSxNQUFNdFksTUFBVixFQUFpQjtxQkFDSmlHLEVBQUV5d0IsWUFBRixDQUFnQixLQUFLMzZCLE9BQUwsQ0FBYWlJLEtBQTdCLEVBQXFDLEtBQUtqSSxPQUFMLENBQWFrSSxNQUFsRCxFQUEwRHFVLE1BQU16VSxFQUFoRSxDQUFUO1NBREosTUFFTztxQkFDTXlVLE1BQU10WSxNQUFmOzs7WUFHRCxLQUFLNkssUUFBTCxDQUFjdlAsTUFBZCxJQUF3QixDQUEzQixFQUE2QjtpQkFDcEJrSixPQUFMLENBQWFFLFdBQWIsQ0FBMEIxRSxNQUExQjtTQURKLE1BRU8sSUFBRyxLQUFLNkssUUFBTCxDQUFjdlAsTUFBZCxHQUFxQixDQUF4QixFQUEyQjtnQkFDMUJnQixTQUFTMEIsU0FBYixFQUF5Qjs7cUJBRWhCd0csT0FBTCxDQUFhd3lCLFlBQWIsQ0FBMkJoM0IsTUFBM0IsRUFBb0MsS0FBSzZJLFlBQUwsQ0FBa0I3SSxNQUF0RDthQUZKLE1BR087O29CQUVDMUQsU0FBUyxLQUFLdU8sUUFBTCxDQUFjdlAsTUFBZCxHQUFxQixDQUFsQyxFQUFxQzt5QkFDN0JrSixPQUFMLENBQWFFLFdBQWIsQ0FBMEIxRSxNQUExQjtpQkFESCxNQUVPO3lCQUNDd0UsT0FBTCxDQUFhd3lCLFlBQWIsQ0FBMkJoM0IsTUFBM0IsRUFBb0MsS0FBSzZLLFFBQUwsQ0FBZXZPLEtBQWYsRUFBdUIwRCxNQUEzRDs7Ozs7Y0FLTEUsV0FBTixDQUFtQkYsTUFBbkI7Y0FDTWkzQixTQUFOLENBQWlCajNCLE1BQWpCLEVBQTBCLEtBQUtqRSxPQUFMLENBQWFpSSxLQUF2QyxFQUErQyxLQUFLakksT0FBTCxDQUFha0ksTUFBNUQ7S0F6SWdEO29CQTJJbkMsd0JBQVNxVSxLQUFULEVBQWU7YUFDdkI5VCxPQUFMLENBQWFpWCxXQUFiLENBQTBCbkQsTUFBTXRZLE1BQWhDO0tBNUlnRDs7ZUErSXhDLG1CQUFTRyxHQUFULEVBQWE7YUFDaEJ3ZCxRQUFMLENBQWNwVSxTQUFkLENBQXdCcEosR0FBeEI7O0NBaEpSLEVBb0pBOztBQ3BOQTs7Ozs7OztBQU9BLEFBQ0EsQUFFQSxJQUFJKzJCLFNBQVMsU0FBVEEsTUFBUyxHQUFVO1NBQ2QzMUIsSUFBTCxHQUFZLFFBQVo7V0FDT3hCLFVBQVAsQ0FBa0JsQyxXQUFsQixDQUE4QjROLEtBQTlCLENBQW9DLElBQXBDLEVBQTBDak4sU0FBMUM7Q0FGSjs7QUFLQUcsTUFBTTJMLFVBQU4sQ0FBaUI0c0IsTUFBakIsRUFBMEJ4YixzQkFBMUIsRUFBbUQ7VUFDeEMsZ0JBQVU7Q0FEckIsRUFNQTs7SUNyQnFCeWI7MEJBRUw5YyxTQUFaLEVBQXVCQyxXQUF2QixFQUFvQ21FLFNBQXBDLEVBQStDVixTQUEvQyxFQUEwRE8sU0FBMUQsRUFBcUVqQixLQUFyRSxFQUNBOzs7YUFDU2hELFNBQUwsR0FBaUJBLFNBQWpCO2FBQ0tDLFdBQUwsR0FBbUJBLFdBQW5CO2FBQ0ttRSxTQUFMLEdBQWlCQSxTQUFqQjs7YUFFS1YsU0FBTCxHQUFpQkEsU0FBakI7YUFDS08sU0FBTCxHQUFpQkEsU0FBakI7O2FBRUtqQixLQUFMLEdBQWFBLEtBQWI7YUFDSzliLElBQUwsR0FBWThiLE1BQU05YixJQUFsQjs7YUFFSzR0QixLQUFMLEdBQWEsRUFBYjs7OzthQUlLNVEsSUFBTCxHQUFZLElBQVo7YUFDSzZZLElBQUwsR0FBWSxJQUFaOzs7OztnQ0FLSjttQkFDVyxJQUFJRCxZQUFKLENBQ0gsS0FBSzljLFNBREYsRUFFSCxLQUFLQyxXQUZGLEVBR0gsS0FBS21FLFNBSEYsRUFJSCxLQUFLVixTQUpGLEVBS0gsS0FBS08sU0FMRixFQU1ILEtBQUtqQixLQU5GLENBQVA7Ozs7Z0NBVUlBLE9BQ1I7aUJBQ1M4UixLQUFMLENBQVd4ekIsSUFBWCxDQUFnQjBoQixLQUFoQjs7Ozs7OztrQ0FJTzFDLFVBQ1g7O2lCQUVTTixTQUFMLEdBQWlCTSxTQUFTTixTQUExQjtpQkFDS0MsV0FBTCxHQUFtQkssU0FBU0wsV0FBNUI7aUJBQ0ttRSxTQUFMLEdBQWlCOUQsU0FBUzhELFNBQTFCOztpQkFFS1YsU0FBTCxHQUFpQnBELFNBQVNvRCxTQUExQjtpQkFDS08sU0FBTCxHQUFpQjNELFNBQVMyRCxTQUExQjs7OztrQ0FLSjttQkFDVyxLQUFLUCxTQUFMLElBQ0EsS0FBS1EsSUFETCxJQUVFLEtBQUtsQixLQUFMLENBQVdlLE1BQVgsS0FBc0JwZ0IsU0FBdEIsSUFBbUMsS0FBS3FmLEtBQUwsQ0FBV2UsTUFGaEQsSUFHQSxLQUFLRSxTQUhaOzs7O2tDQU9KO21CQUNXLEtBQUtoRSxXQUFMLElBQW9CLEtBQUtELFNBQXpCLElBQXNDLEtBQUtvRSxTQUEzQyxJQUF3RCxLQUFLMlksSUFBcEU7Ozs7a0NBSUo7aUJBQ1MvWixLQUFMLEdBQWEsSUFBYjtpQkFDSzhSLEtBQUwsR0FBYSxJQUFiOzs7Ozs7QUNyRVI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBQWUsU0FBU3RQLGFBQVQsQ0FBdUI2QixLQUF2QixFQUE4QkMsS0FBOUIsRUFBcUNxTyxHQUFyQyxFQUEwQ0MsR0FBMUMsRUFBK0NvSCxJQUEvQyxFQUFxREMsSUFBckQsRUFBMkR2VyxHQUEzRCxFQUFnRUMsR0FBaEUsRUFDZjtRQURvRnVXLElBQ3BGLHVFQUQyRixFQUMzRjs7UUFDVS9rQixJQUFJLEVBQVY7UUFDSWdsQixLQUFLLENBQVQ7UUFDSUMsTUFBTSxDQUFWO1FBQ0lDLE1BQU0sQ0FBVjtRQUNJcGtCLEtBQUssQ0FBVDtRQUNJQyxLQUFLLENBQVQ7O1NBRUs1WCxJQUFMLENBQVUrbEIsS0FBVixFQUFpQkMsS0FBakI7O1NBRUssSUFBSXBtQixJQUFJLENBQVIsRUFBV3drQixJQUFJLENBQXBCLEVBQXVCeGtCLEtBQUtpWCxDQUE1QixFQUErQixFQUFFalgsQ0FBakMsRUFDQTtZQUNRQSxJQUFJaVgsQ0FBUjs7YUFFTSxJQUFJdU4sQ0FBVjtjQUNNeVgsS0FBS0EsRUFBWDtjQUNNQyxNQUFNRCxFQUFaOzthQUVLelgsSUFBSUEsQ0FBVDthQUNLek0sS0FBS3lNLENBQVY7O2FBRUtwa0IsSUFBTCxDQUNLKzdCLE1BQU1oVyxLQUFQLEdBQWlCLElBQUkrVixHQUFKLEdBQVUxWCxDQUFWLEdBQWNpUSxHQUEvQixHQUF1QyxJQUFJd0gsRUFBSixHQUFTbGtCLEVBQVQsR0FBYytqQixJQUFyRCxHQUE4RDlqQixLQUFLd04sR0FEdkUsRUFFSzJXLE1BQU0vVixLQUFQLEdBQWlCLElBQUk4VixHQUFKLEdBQVUxWCxDQUFWLEdBQWNrUSxHQUEvQixHQUF1QyxJQUFJdUgsRUFBSixHQUFTbGtCLEVBQVQsR0FBY2drQixJQUFyRCxHQUE4RC9qQixLQUFLeU4sR0FGdkU7OztXQU1HdVcsSUFBUDs7O0FDM0NKOzs7O0FBSUEsSUFBSUksZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFVeFosTUFBVixFQUFrQnJkLENBQWxCLEVBQXFCQyxDQUFyQixFQUF3QnNaLFNBQXhCLEVBQ3BCO1FBQ1FxSyxLQUFLdkcsT0FBTyxDQUFQLENBQVQ7UUFDSXdHLEtBQUt4RyxPQUFPLENBQVAsQ0FBVDtRQUNJeUcsS0FBS3pHLE9BQU8sQ0FBUCxDQUFUO1FBQ0kwRyxLQUFLMUcsT0FBTyxDQUFQLENBQVQ7UUFDSXlaLEtBQUtyNkIsS0FBS0MsR0FBTCxDQUFTNmMsU0FBVCxFQUFxQixDQUFyQixDQUFUO1FBQ0l3ZCxLQUFLLENBQVQ7UUFDSUMsS0FBS3BULEVBQVQ7O1FBR0szakIsSUFBSTRqQixLQUFLaVQsRUFBVCxJQUFlNzJCLElBQUk4akIsS0FBSytTLEVBQXpCLElBQ0k3MkIsSUFBSTRqQixLQUFLaVQsRUFBVCxJQUFlNzJCLElBQUk4akIsS0FBSytTLEVBRDVCLElBRUk5MkIsSUFBSTRqQixLQUFLa1QsRUFBVCxJQUFlOTJCLElBQUk4akIsS0FBS2dULEVBRjVCLElBR0k5MkIsSUFBSTRqQixLQUFLa1QsRUFBVCxJQUFlOTJCLElBQUk4akIsS0FBS2dULEVBSmhDLEVBS0M7ZUFDVSxLQUFQOzs7UUFHQWxULE9BQU9FLEVBQVgsRUFBZTthQUNOLENBQUNELEtBQUtFLEVBQU4sS0FBYUgsS0FBS0UsRUFBbEIsQ0FBTDthQUNLLENBQUNGLEtBQUtHLEVBQUwsR0FBVUQsS0FBS0QsRUFBaEIsS0FBdUJELEtBQUtFLEVBQTVCLENBQUw7S0FGSixNQUdPO2VBQ0lybkIsS0FBS3FQLEdBQUwsQ0FBUzlMLElBQUk0akIsRUFBYixLQUFvQmtULEtBQUssQ0FBaEM7OztRQUdBRyxLQUFLLENBQUNGLEtBQUsvMkIsQ0FBTCxHQUFTQyxDQUFULEdBQWErMkIsRUFBZCxLQUFxQkQsS0FBSy8yQixDQUFMLEdBQVNDLENBQVQsR0FBYSsyQixFQUFsQyxLQUF5Q0QsS0FBS0EsRUFBTCxHQUFVLENBQW5ELENBQVQ7V0FDT0UsTUFBTUgsS0FBSyxDQUFMLEdBQVNBLEVBQVQsR0FBYyxDQUEzQjtDQTNCSjs7QUE4QkEsQUFBZSxTQUFTSSxVQUFULENBQW9CbGEsSUFBcEIsRUFBMEJoZCxDQUExQixFQUE2QkMsQ0FBN0IsRUFBZ0NxMkIsSUFBaEMsRUFDZjtRQUNRalosU0FBU0wsS0FBS1QsS0FBTCxDQUFXYyxNQUF4QjtRQUNJOUQsWUFBWXlELEtBQUt6RCxTQUFyQjtRQUNJNGQsY0FBYyxLQUFsQjtTQUNJLElBQUkxOEIsSUFBSSxDQUFaLEVBQWVBLElBQUk0aUIsT0FBTzdpQixNQUExQixFQUFrQyxFQUFFQyxDQUFwQyxFQUFzQztzQkFDcEJvOEIsY0FBZXhaLE9BQU96ZixLQUFQLENBQWFuRCxDQUFiLEVBQWlCQSxJQUFFLENBQW5CLENBQWYsRUFBdUN1RixDQUF2QyxFQUEyQ0MsQ0FBM0MsRUFBK0NzWixTQUEvQyxDQUFkO1lBQ0k0ZCxXQUFKLEVBQWlCOzs7YUFHWixDQUFMOztXQUVHQSxXQUFQOzs7QUNoREo7Ozs7OztBQU1BLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxJQUVxQkM7c0JBRUo3YSxLQUFiLEVBQ0E7OzthQUNTQSxLQUFMLEdBQWFBLEtBQWI7O2FBRUtoRCxTQUFMLEdBQWlCLENBQWpCO2FBQ0tDLFdBQUwsR0FBbUIsSUFBbkI7YUFDS21FLFNBQUwsR0FBaUIsQ0FBakI7YUFDS1YsU0FBTCxHQUFpQixJQUFqQjthQUNLTyxTQUFMLEdBQWlCLENBQWpCOzthQUVLVCxZQUFMLEdBQW9CLEVBQXBCO2FBQ0tzYSxXQUFMLEdBQW1CLElBQW5COzthQUVLQyxTQUFMOzthQUVLMU0sS0FBTCxHQUFhLENBQWIsQ0FkSjthQWVTMEYsTUFBTCxHQUFjLEVBQWQ7YUFDS1EsVUFBTCxHQUFrQixDQUFsQjthQUNLRCxJQUFMLEdBQVksUUFBWixDQWpCSjs7Ozs7b0NBcUJBOztnQkFFUTBHLE9BQU8sS0FBS2hiLEtBQUwsQ0FBV3RoQixPQUF0QjtpQkFDS3NlLFNBQUwsR0FBaUJnZSxLQUFLaGUsU0FBdEI7aUJBQ0tDLFdBQUwsR0FBbUIrZCxLQUFLL2QsV0FBeEI7aUJBQ0ttRSxTQUFMLEdBQWlCNFosS0FBSzVaLFNBQUwsR0FBaUI0WixLQUFLenhCLFdBQXZDOztpQkFFS21YLFNBQUwsR0FBaUJzYSxLQUFLdGEsU0FBdEI7aUJBQ0tPLFNBQUwsR0FBaUIrWixLQUFLL1osU0FBTCxHQUFpQitaLEtBQUt6eEIsV0FBdkM7Ozs7aUJBT0ssSUFBSXJMLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLc2lCLFlBQUwsQ0FBa0J2aUIsTUFBdEMsRUFBOEMsRUFBRUMsQ0FBaEQsRUFDQTtxQkFDU3NpQixZQUFMLENBQWtCdGlCLENBQWxCLEVBQXFCNjhCLFNBQXJCLENBQStCLElBQS9COzs7OztnQ0FLUjtnQkFDVTk1QixRQUFRLElBQUk0NUIsUUFBSixFQUFkOztrQkFFTXhNLEtBQU4sR0FBYyxDQUFkOzs7aUJBR0ssSUFBSW53QixJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS3NpQixZQUFMLENBQWtCdmlCLE1BQXRDLEVBQThDLEVBQUVDLENBQWhELEVBQ0E7c0JBQ1VzaUIsWUFBTixDQUFtQmxpQixJQUFuQixDQUF3QixLQUFLa2lCLFlBQUwsQ0FBa0J0aUIsQ0FBbEIsRUFBcUIrQyxLQUFyQixFQUF4Qjs7O2tCQUdFNjVCLFdBQU4sR0FBb0I3NUIsTUFBTXVmLFlBQU4sQ0FBbUJ2ZixNQUFNdWYsWUFBTixDQUFtQnZpQixNQUFuQixHQUE0QixDQUEvQyxDQUFwQjttQkFDT2dELEtBQVA7Ozs7K0JBSUd3QyxHQUFHQyxHQUNWO2dCQUNVc2MsUUFBUSxJQUFJNEksT0FBSixDQUFZLENBQUNubEIsQ0FBRCxFQUFJQyxDQUFKLENBQVosQ0FBZDs7a0JBRU1xZCxNQUFOLEdBQWUsS0FBZjtpQkFDS2thLFNBQUwsQ0FBZWpiLEtBQWY7O21CQUVPLElBQVA7Ozs7K0JBR0d2YyxHQUFHQyxHQUNWO2dCQUNRLEtBQUtvM0IsV0FBVCxFQUFzQjtxQkFDYkEsV0FBTCxDQUFpQjlhLEtBQWpCLENBQXVCYyxNQUF2QixDQUE4QnhpQixJQUE5QixDQUFtQ21GLENBQW5DLEVBQXNDQyxDQUF0QztxQkFDSzJxQixLQUFMO2FBRkosTUFHTztxQkFDRTlMLE1BQUwsQ0FBWSxDQUFaLEVBQWMsQ0FBZDs7bUJBRUcsSUFBUDs7Ozt5Q0FHYW9RLEtBQUtDLEtBQUtsUCxLQUFLQyxLQUNoQztnQkFDUSxLQUFLbVgsV0FBVCxFQUNBO29CQUNRLEtBQUtBLFdBQUwsQ0FBaUI5YSxLQUFqQixDQUF1QmMsTUFBdkIsQ0FBOEI3aUIsTUFBOUIsS0FBeUMsQ0FBN0MsRUFDQTt5QkFDUzY4QixXQUFMLENBQWlCOWEsS0FBakIsQ0FBdUJjLE1BQXZCLEdBQWdDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEM7O2FBSlIsTUFRQTtxQkFDU3lCLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZjs7O2dCQUdFcE4sSUFBSSxFQUFWO2dCQUNNMkwsU0FBUyxLQUFLZ2EsV0FBTCxDQUFpQjlhLEtBQWpCLENBQXVCYyxNQUF0QztnQkFDSStSLEtBQUssQ0FBVDtnQkFDSUMsS0FBSyxDQUFUOztnQkFFSWhTLE9BQU83aUIsTUFBUCxLQUFrQixDQUF0QixFQUNBO3FCQUNTc2tCLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZjs7O2dCQUdFOEIsUUFBUXZELE9BQU9BLE9BQU83aUIsTUFBUCxHQUFnQixDQUF2QixDQUFkO2dCQUNNcW1CLFFBQVF4RCxPQUFPQSxPQUFPN2lCLE1BQVAsR0FBZ0IsQ0FBdkIsQ0FBZDs7aUJBRUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxLQUFLaVgsQ0FBckIsRUFBd0IsRUFBRWpYLENBQTFCLEVBQ0E7b0JBQ1V3a0IsSUFBSXhrQixJQUFJaVgsQ0FBZDs7cUJBRUtrUCxRQUFTLENBQUNzTyxNQUFNdE8sS0FBUCxJQUFnQjNCLENBQTlCO3FCQUNLNEIsUUFBUyxDQUFDc08sTUFBTXRPLEtBQVAsSUFBZ0I1QixDQUE5Qjs7dUJBRU9wa0IsSUFBUCxDQUFZdTBCLEtBQU0sQ0FBRUYsTUFBTyxDQUFDalAsTUFBTWlQLEdBQVAsSUFBY2pRLENBQXRCLEdBQTRCbVEsRUFBN0IsSUFBbUNuUSxDQUFyRCxFQUNJb1EsS0FBTSxDQUFFRixNQUFPLENBQUNqUCxNQUFNaVAsR0FBUCxJQUFjbFEsQ0FBdEIsR0FBNEJvUSxFQUE3QixJQUFtQ3BRLENBRDdDOzs7aUJBSUMyTCxLQUFMOzttQkFFTyxJQUFQOzs7O3lDQUdVc0UsS0FBS0MsS0FBS29ILE1BQU1DLE1BQU12VyxLQUFLQyxLQUN6QztnQkFDUSxLQUFLbVgsV0FBVCxFQUNBO29CQUNRLEtBQUtBLFdBQUwsQ0FBaUI5YSxLQUFqQixDQUF1QmMsTUFBdkIsQ0FBOEI3aUIsTUFBOUIsS0FBeUMsQ0FBN0MsRUFDQTt5QkFDUzY4QixXQUFMLENBQWlCOWEsS0FBakIsQ0FBdUJjLE1BQXZCLEdBQWdDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEM7O2FBSlIsTUFRQTtxQkFDU3lCLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZjs7O2dCQUdFekIsU0FBUyxLQUFLZ2EsV0FBTCxDQUFpQjlhLEtBQWpCLENBQXVCYyxNQUF0Qzs7Z0JBRU11RCxRQUFRdkQsT0FBT0EsT0FBTzdpQixNQUFQLEdBQWdCLENBQXZCLENBQWQ7Z0JBQ01xbUIsUUFBUXhELE9BQU9BLE9BQU83aUIsTUFBUCxHQUFnQixDQUF2QixDQUFkOzttQkFFT0EsTUFBUCxJQUFpQixDQUFqQjs7MEJBRWNvbUIsS0FBZCxFQUFxQkMsS0FBckIsRUFBNEJxTyxHQUE1QixFQUFpQ0MsR0FBakMsRUFBc0NvSCxJQUF0QyxFQUE0Q0MsSUFBNUMsRUFBa0R2VyxHQUFsRCxFQUF1REMsR0FBdkQsRUFBNEQ3QyxNQUE1RDs7aUJBRUt1TixLQUFMOzttQkFFTyxJQUFQOzs7OzhCQUdFOUcsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSS9GLFFBQ3RCO2dCQUNRLEtBQUttWixXQUFULEVBQ0E7b0JBQ1EsS0FBS0EsV0FBTCxDQUFpQjlhLEtBQWpCLENBQXVCYyxNQUF2QixDQUE4QjdpQixNQUE5QixLQUF5QyxDQUE3QyxFQUNBO3lCQUNTNjhCLFdBQUwsQ0FBaUI5YSxLQUFqQixDQUF1QmMsTUFBdkIsQ0FBOEJ4aUIsSUFBOUIsQ0FBbUNpcEIsRUFBbkMsRUFBdUNDLEVBQXZDOzthQUpSLE1BUUE7cUJBQ1NqRixNQUFMLENBQVlnRixFQUFaLEVBQWdCQyxFQUFoQjs7O2dCQUdFMUcsU0FBUyxLQUFLZ2EsV0FBTCxDQUFpQjlhLEtBQWpCLENBQXVCYyxNQUF0QztnQkFDTXVELFFBQVF2RCxPQUFPQSxPQUFPN2lCLE1BQVAsR0FBZ0IsQ0FBdkIsQ0FBZDtnQkFDTXFtQixRQUFReEQsT0FBT0EsT0FBTzdpQixNQUFQLEdBQWdCLENBQXZCLENBQWQ7Z0JBQ01tekIsS0FBSzlNLFFBQVFrRCxFQUFuQjtnQkFDTTZKLEtBQUtoTixRQUFRa0QsRUFBbkI7Z0JBQ01nSyxLQUFLN0osS0FBS0YsRUFBaEI7Z0JBQ01nSyxLQUFLL0osS0FBS0YsRUFBaEI7Z0JBQ00yVCxLQUFLaDdCLEtBQUtxUCxHQUFMLENBQVU2aEIsS0FBS0ksRUFBTixHQUFhSCxLQUFLRSxFQUEzQixDQUFYOztnQkFFSTJKLEtBQUssTUFBTCxJQUFldlosV0FBVyxDQUE5QixFQUNBO29CQUNRYixPQUFPQSxPQUFPN2lCLE1BQVAsR0FBZ0IsQ0FBdkIsTUFBOEJzcEIsRUFBOUIsSUFBb0N6RyxPQUFPQSxPQUFPN2lCLE1BQVAsR0FBZ0IsQ0FBdkIsTUFBOEJ1cEIsRUFBdEUsRUFDQTsyQkFDV2xwQixJQUFQLENBQVlpcEIsRUFBWixFQUFnQkMsRUFBaEI7O2FBSlIsTUFRQTtvQkFDVTJULEtBQU0vSixLQUFLQSxFQUFOLEdBQWFDLEtBQUtBLEVBQTdCO29CQUNNcEcsS0FBTXNHLEtBQUtBLEVBQU4sR0FBYUMsS0FBS0EsRUFBN0I7b0JBQ000SixLQUFNaEssS0FBS0csRUFBTixHQUFhRixLQUFLRyxFQUE3QjtvQkFDTTZKLEtBQUsxWixTQUFTemhCLEtBQUswVSxJQUFMLENBQVV1bUIsRUFBVixDQUFULEdBQXlCRCxFQUFwQztvQkFDTUksS0FBSzNaLFNBQVN6aEIsS0FBSzBVLElBQUwsQ0FBVXFXLEVBQVYsQ0FBVCxHQUF5QmlRLEVBQXBDO29CQUNNSyxLQUFLRixLQUFLRCxFQUFMLEdBQVVELEVBQXJCO29CQUNNSyxLQUFLRixLQUFLRixFQUFMLEdBQVVuUSxFQUFyQjtvQkFDTXBHLEtBQU13VyxLQUFLN0osRUFBTixHQUFhOEosS0FBS2pLLEVBQTdCO29CQUNNdk0sS0FBTXVXLEtBQUs5SixFQUFOLEdBQWErSixLQUFLbEssRUFBN0I7b0JBQ005dUIsS0FBSyt1QixNQUFNaUssS0FBS0MsRUFBWCxDQUFYO29CQUNNaFgsS0FBSzZNLE1BQU1rSyxLQUFLQyxFQUFYLENBQVg7b0JBQ01FLEtBQUtqSyxNQUFNNkosS0FBS0csRUFBWCxDQUFYO29CQUNNRSxLQUFLbkssTUFBTThKLEtBQUtHLEVBQVgsQ0FBWDtvQkFDTUcsYUFBYXo3QixLQUFLdW1CLEtBQUwsQ0FBV2xDLEtBQUtPLEVBQWhCLEVBQW9CeGlCLEtBQUt1aUIsRUFBekIsQ0FBbkI7b0JBQ00rVyxXQUFXMTdCLEtBQUt1bUIsS0FBTCxDQUFXaVYsS0FBSzVXLEVBQWhCLEVBQW9CMlcsS0FBSzVXLEVBQXpCLENBQWpCOztxQkFFS25ELEdBQUwsQ0FBU21ELEtBQUswQyxFQUFkLEVBQWtCekMsS0FBSzBDLEVBQXZCLEVBQTJCN0YsTUFBM0IsRUFBbUNnYSxVQUFuQyxFQUErQ0MsUUFBL0MsRUFBeUR2SyxLQUFLRSxFQUFMLEdBQVVDLEtBQUtKLEVBQXhFOzs7aUJBR0MvQyxLQUFMOzttQkFFTyxJQUFQOzs7OzRCQUdBeEosSUFBSUMsSUFBSW5ELFFBQVFnYSxZQUFZQyxVQUNoQztnQkFEMENDLGFBQzFDLHVFQUQwRCxLQUMxRDs7Z0JBQ1FGLGVBQWVDLFFBQW5CLEVBQ0E7dUJBQ1csSUFBUDs7O2dCQUdBLENBQUNDLGFBQUQsSUFBa0JELFlBQVlELFVBQWxDLEVBQ0E7NEJBQ2dCejdCLEtBQUtpUCxFQUFMLEdBQVUsQ0FBdEI7YUFGSixNQUlLLElBQUkwc0IsaUJBQWlCRixjQUFjQyxRQUFuQyxFQUNMOzhCQUNrQjE3QixLQUFLaVAsRUFBTCxHQUFVLENBQXhCOzs7Z0JBR0U0VSxRQUFRNlgsV0FBV0QsVUFBekI7Z0JBQ00zVSxPQUFPOW1CLEtBQUttbEIsSUFBTCxDQUFVbmxCLEtBQUtxUCxHQUFMLENBQVN3VSxLQUFULEtBQW1CN2pCLEtBQUtpUCxFQUFMLEdBQVUsQ0FBN0IsQ0FBVixJQUE2QyxFQUExRDs7Z0JBRUk0VSxVQUFVLENBQWQsRUFDQTt1QkFDVyxJQUFQOzs7Z0JBR0UrWCxTQUFTalgsS0FBTTNrQixLQUFLK08sR0FBTCxDQUFTMHNCLFVBQVQsSUFBdUJoYSxNQUE1QztnQkFDTW9hLFNBQVNqWCxLQUFNNWtCLEtBQUtnUCxHQUFMLENBQVN5c0IsVUFBVCxJQUF1QmhhLE1BQTVDOzs7Z0JBR0liLFNBQVMsS0FBS2dhLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQjlhLEtBQWpCLENBQXVCYyxNQUExQyxHQUFtRCxJQUFoRTs7Z0JBRUlBLE1BQUosRUFDQTtvQkFDUUEsT0FBT0EsT0FBTzdpQixNQUFQLEdBQWdCLENBQXZCLE1BQThCNjlCLE1BQTlCLElBQXdDaGIsT0FBT0EsT0FBTzdpQixNQUFQLEdBQWdCLENBQXZCLE1BQThCODlCLE1BQTFFLEVBQ0E7MkJBQ1d6OUIsSUFBUCxDQUFZdzlCLE1BQVosRUFBb0JDLE1BQXBCOzthQUpSLE1BUUE7cUJBQ1N4WixNQUFMLENBQVl1WixNQUFaLEVBQW9CQyxNQUFwQjt5QkFDUyxLQUFLakIsV0FBTCxDQUFpQjlhLEtBQWpCLENBQXVCYyxNQUFoQzs7O2dCQUdFa2IsUUFBUWpZLFNBQVNpRCxPQUFPLENBQWhCLENBQWQ7Z0JBQ01pVixTQUFTRCxRQUFRLENBQXZCOztnQkFFTUUsU0FBU2g4QixLQUFLK08sR0FBTCxDQUFTK3NCLEtBQVQsQ0FBZjtnQkFDTUcsU0FBU2o4QixLQUFLZ1AsR0FBTCxDQUFTOHNCLEtBQVQsQ0FBZjs7Z0JBRU1JLFdBQVdwVixPQUFPLENBQXhCOztnQkFFTXFWLFlBQWFELFdBQVcsQ0FBWixHQUFpQkEsUUFBbkM7O2lCQUVLLElBQUlsK0IsSUFBSSxDQUFiLEVBQWdCQSxLQUFLaytCLFFBQXJCLEVBQStCLEVBQUVsK0IsQ0FBakMsRUFDQTtvQkFDVW8rQixPQUFPcCtCLElBQUttK0IsWUFBWW4rQixDQUE5Qjs7b0JBRU1tUixRQUFVMnNCLEtBQUQsR0FBVUwsVUFBVixHQUF3Qk0sU0FBU0ssSUFBaEQ7O29CQUVNN3RCLElBQUl2TyxLQUFLK08sR0FBTCxDQUFTSSxLQUFULENBQVY7b0JBQ01oTixJQUFJLENBQUNuQyxLQUFLZ1AsR0FBTCxDQUFTRyxLQUFULENBQVg7O3VCQUVPL1EsSUFBUCxDQUNLLENBQUU0OUIsU0FBU3p0QixDQUFWLEdBQWdCMHRCLFNBQVM5NUIsQ0FBMUIsSUFBZ0NzZixNQUFqQyxHQUEyQ2tELEVBRC9DLEVBRUssQ0FBRXFYLFNBQVMsQ0FBQzc1QixDQUFYLEdBQWlCODVCLFNBQVMxdEIsQ0FBM0IsSUFBaUNrVCxNQUFsQyxHQUE0Q21ELEVBRmhEOzs7aUJBTUN1SixLQUFMOzttQkFFTyxJQUFQOzs7O2lDQUdLNXFCLEdBQUdDLEdBQUdpRCxPQUFPQyxRQUN0QjtpQkFDU3EwQixTQUFMLENBQWUsSUFBSTdTLFNBQUosQ0FBYzNrQixDQUFkLEVBQWlCQyxDQUFqQixFQUFvQmlELEtBQXBCLEVBQTJCQyxNQUEzQixDQUFmO21CQUNPLElBQVA7Ozs7bUNBR09uRCxHQUFHQyxHQUFHaWUsUUFDakI7aUJBQ1NzWixTQUFMLENBQWUsSUFBSXpTLE1BQUosQ0FBVy9rQixDQUFYLEVBQWNDLENBQWQsRUFBaUJpZSxNQUFqQixDQUFmOzttQkFFTyxJQUFQOzs7O29DQUdRbGUsR0FBR0MsR0FBR2lELE9BQU9DLFFBQ3pCO2lCQUNTcTBCLFNBQUwsQ0FBZSxJQUFJeFMsT0FBSixDQUFZaGxCLENBQVosRUFBZUMsQ0FBZixFQUFrQmlELEtBQWxCLEVBQXlCQyxNQUF6QixDQUFmOzttQkFFTyxJQUFQOzs7O29DQUdRc3pCLE1BQ1o7OztnQkFHUXBaLFNBQVNvWixJQUFiOztnQkFFSW5aLFNBQVMsSUFBYjs7Z0JBRUlELGtCQUFrQjhILE9BQXRCLEVBQ0E7eUJBQ2E5SCxPQUFPQyxNQUFoQjt5QkFDU0QsT0FBT0EsTUFBaEI7OztnQkFHQSxDQUFDL2pCLE1BQU1hLE9BQU4sQ0FBY2tqQixNQUFkLENBQUwsRUFDQTs7O3lCQUdhLElBQUkvakIsS0FBSixDQUFVb0UsVUFBVWxELE1BQXBCLENBQVQ7O3FCQUVLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSTRpQixPQUFPN2lCLE1BQTNCLEVBQW1DLEVBQUVDLENBQXJDLEVBQ0E7MkJBQ1dBLENBQVAsSUFBWWlELFVBQVVqRCxDQUFWLENBQVosQ0FESjs7OztnQkFLRThoQixRQUFRLElBQUk0SSxPQUFKLENBQVk5SCxNQUFaLENBQWQ7O2tCQUVNQyxNQUFOLEdBQWVBLE1BQWY7O2lCQUVLa2EsU0FBTCxDQUFlamIsS0FBZjs7bUJBRU8sSUFBUDs7OztnQ0FJSjtnQkFDUSxLQUFLUSxZQUFMLENBQWtCdmlCLE1BQWxCLEdBQTJCLENBQS9CLEVBQ0E7cUJBQ1Nvd0IsS0FBTDtxQkFDSzdOLFlBQUwsQ0FBa0J2aUIsTUFBbEIsR0FBMkIsQ0FBM0I7OztpQkFHQzY4QixXQUFMLEdBQW1CLElBQW5COzttQkFFTyxJQUFQOzs7O2tDQUdNOWEsT0FDVjtnQkFDUSxLQUFLOGEsV0FBVCxFQUNBO29CQUNRLEtBQUtBLFdBQUwsQ0FBaUI5YSxLQUFqQixDQUF1QmMsTUFBdkIsQ0FBOEI3aUIsTUFBOUIsSUFBd0MsQ0FBNUMsRUFDQTt5QkFDU3VpQixZQUFMLENBQWtCdVAsR0FBbEI7Ozs7aUJBSUgrSyxXQUFMLEdBQW1CLElBQW5COztnQkFFTXJhLE9BQU8sSUFBSXFaLFlBQUosQ0FDVCxLQUFLOWMsU0FESSxFQUVULEtBQUtDLFdBRkksRUFHVCxLQUFLbUUsU0FISSxFQUlULEtBQUtWLFNBSkksRUFLVCxLQUFLTyxTQUxJLEVBTVRqQixLQU5TLENBQWI7O2lCQVNLUSxZQUFMLENBQWtCbGlCLElBQWxCLENBQXVCbWlCLElBQXZCOztnQkFFSUEsS0FBS3ZjLElBQUwsS0FBYzBXLE9BQU8rRixJQUF6QixFQUNBO3FCQUNTWCxLQUFMLENBQVdlLE1BQVgsR0FBb0JOLEtBQUtULEtBQUwsQ0FBV2UsTUFBL0I7cUJBQ0srWixXQUFMLEdBQW1CcmEsSUFBbkI7OztpQkFHQzROLEtBQUw7O21CQUVPNU4sSUFBUDs7OztvQ0FLSjtnQkFDVXFhLGNBQWMsS0FBS0EsV0FBekI7O2dCQUVJQSxlQUFlQSxZQUFZOWEsS0FBL0IsRUFDQTs0QkFDZ0JBLEtBQVosQ0FBa0J5QyxLQUFsQjs7O21CQUdHLElBQVA7Ozs7Ozs7Ozs7OztzQ0FTVXJlLE9BQ2Q7Z0JBQ1VvYyxlQUFlLEtBQUtBLFlBQTFCO2dCQUNJK2IsU0FBUyxLQUFiO2lCQUNLLElBQUlyK0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc2lCLGFBQWF2aUIsTUFBakMsRUFBeUMsRUFBRUMsQ0FBM0MsRUFDQTtvQkFDVXVpQixPQUFPRCxhQUFhdGlCLENBQWIsQ0FBYjtvQkFDSXVpQixLQUFLVCxLQUFULEVBQ0E7Ozt3QkFHU1MsS0FBS08sT0FBTCxNQUFrQlAsS0FBS1QsS0FBTCxDQUFXL1gsUUFBWCxDQUFvQjdELE1BQU1YLENBQTFCLEVBQTZCVyxNQUFNVixDQUFuQyxDQUF2QixFQUNBO2lDQUNhLElBQVQ7NEJBQ0k2NEIsTUFBSixFQUFZOzs7Ozs7d0JBTVo5YixLQUFLVSxPQUFMLE1BQWtCVixLQUFLVCxLQUFMLENBQVdjLE1BQWpDLEVBQ0E7O2lDQUVhMGIsV0FBWS9iLElBQVosRUFBbUJyYyxNQUFNWCxDQUF6QixFQUE2QlcsTUFBTVYsQ0FBbkMsQ0FBVDs0QkFDSTY0QixNQUFKLEVBQVk7Ozs7Ozs7bUJBUWpCQSxNQUFQOzs7Ozs7Ozs7OzRDQVVKO2dCQUNRRSxPQUFPQyxRQUFYO2dCQUNJQyxPQUFPLENBQUNELFFBQVo7O2dCQUVJRSxPQUFPRixRQUFYO2dCQUNJRyxPQUFPLENBQUNILFFBQVo7O2dCQUVJLEtBQUtsYyxZQUFMLENBQWtCdmlCLE1BQXRCLEVBQ0E7b0JBQ1EraEIsUUFBUSxDQUFaO29CQUNJdmMsSUFBSSxDQUFSO29CQUNJQyxJQUFJLENBQVI7b0JBQ0lvZSxJQUFJLENBQVI7b0JBQ0lDLElBQUksQ0FBUjs7cUJBRUssSUFBSTdqQixJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS3NpQixZQUFMLENBQWtCdmlCLE1BQXRDLEVBQThDQyxHQUE5QyxFQUNBO3dCQUNVdWlCLE9BQU8sS0FBS0QsWUFBTCxDQUFrQnRpQixDQUFsQixDQUFiO3dCQUNNZ0csT0FBT3VjLEtBQUt2YyxJQUFsQjt3QkFDTThZLFlBQVl5RCxLQUFLekQsU0FBdkI7OzRCQUVReUQsS0FBS1QsS0FBYjs7d0JBRUk5YixTQUFTMFcsT0FBTzBHLElBQWhCLElBQXdCcGQsU0FBUzBXLE9BQU9rYSxJQUE1QyxFQUNBOzRCQUNROVUsTUFBTXZjLENBQU4sR0FBV3VaLFlBQVksQ0FBM0I7NEJBQ0lnRCxNQUFNdGMsQ0FBTixHQUFXc1osWUFBWSxDQUEzQjs0QkFDSWdELE1BQU1yWixLQUFOLEdBQWNxVyxTQUFsQjs0QkFDSWdELE1BQU1wWixNQUFOLEdBQWVvVyxTQUFuQjs7K0JBRU92WixJQUFJZzVCLElBQUosR0FBV2g1QixDQUFYLEdBQWVnNUIsSUFBdEI7K0JBQ09oNUIsSUFBSXFlLENBQUosR0FBUTZhLElBQVIsR0FBZWw1QixJQUFJcWUsQ0FBbkIsR0FBdUI2YSxJQUE5Qjs7K0JBRU9qNUIsSUFBSWs1QixJQUFKLEdBQVdsNUIsQ0FBWCxHQUFlazVCLElBQXRCOytCQUNPbDVCLElBQUlxZSxDQUFKLEdBQVE4YSxJQUFSLEdBQWVuNUIsSUFBSXFlLENBQW5CLEdBQXVCOGEsSUFBOUI7cUJBWEosTUFhSyxJQUFJMzRCLFNBQVMwVyxPQUFPNkcsSUFBcEIsRUFDTDs0QkFDUXpCLE1BQU12YyxDQUFWOzRCQUNJdWMsTUFBTXRjLENBQVY7NEJBQ0lzYyxNQUFNMkIsTUFBTixHQUFnQjNFLFlBQVksQ0FBaEM7NEJBQ0lnRCxNQUFNMkIsTUFBTixHQUFnQjNFLFlBQVksQ0FBaEM7OytCQUVPdlosSUFBSXFlLENBQUosR0FBUTJhLElBQVIsR0FBZWg1QixJQUFJcWUsQ0FBbkIsR0FBdUIyYSxJQUE5QjsrQkFDT2g1QixJQUFJcWUsQ0FBSixHQUFRNmEsSUFBUixHQUFlbDVCLElBQUlxZSxDQUFuQixHQUF1QjZhLElBQTlCOzsrQkFFT2o1QixJQUFJcWUsQ0FBSixHQUFRNmEsSUFBUixHQUFlbDVCLElBQUlxZSxDQUFuQixHQUF1QjZhLElBQTlCOytCQUNPbDVCLElBQUlxZSxDQUFKLEdBQVE4YSxJQUFSLEdBQWVuNUIsSUFBSXFlLENBQW5CLEdBQXVCOGEsSUFBOUI7cUJBWEMsTUFhQSxJQUFJMzRCLFNBQVMwVyxPQUFPaUgsSUFBcEIsRUFDTDs0QkFDUTdCLE1BQU12YyxDQUFWOzRCQUNJdWMsTUFBTXRjLENBQVY7NEJBQ0lzYyxNQUFNclosS0FBTixHQUFlcVcsWUFBWSxDQUEvQjs0QkFDSWdELE1BQU1wWixNQUFOLEdBQWdCb1csWUFBWSxDQUFoQzs7K0JBRU92WixJQUFJcWUsQ0FBSixHQUFRMmEsSUFBUixHQUFlaDVCLElBQUlxZSxDQUFuQixHQUF1QjJhLElBQTlCOytCQUNPaDVCLElBQUlxZSxDQUFKLEdBQVE2YSxJQUFSLEdBQWVsNUIsSUFBSXFlLENBQW5CLEdBQXVCNmEsSUFBOUI7OytCQUVPajVCLElBQUlxZSxDQUFKLEdBQVE2YSxJQUFSLEdBQWVsNUIsSUFBSXFlLENBQW5CLEdBQXVCNmEsSUFBOUI7K0JBQ09sNUIsSUFBSXFlLENBQUosR0FBUThhLElBQVIsR0FBZW41QixJQUFJcWUsQ0FBbkIsR0FBdUI4YSxJQUE5QjtxQkFYQyxNQWNMOzs0QkFFVS9iLFNBQVNkLE1BQU1jLE1BQXJCOzRCQUNJMkcsS0FBSyxDQUFUOzRCQUNJQyxLQUFLLENBQVQ7NEJBQ0kvWCxLQUFLLENBQVQ7NEJBQ0lDLEtBQUssQ0FBVDs0QkFDSWt0QixLQUFLLENBQVQ7NEJBQ0lDLEtBQUssQ0FBVDs0QkFDSWxZLEtBQUssQ0FBVDs0QkFDSUMsS0FBSyxDQUFUOzs2QkFFSyxJQUFJcEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLENBQUosR0FBUTVCLE9BQU83aUIsTUFBL0IsRUFBdUN5a0IsS0FBSyxDQUE1QyxFQUNBO2dDQUNRNUIsT0FBTzRCLENBQVAsQ0FBSjtnQ0FDSTVCLE9BQU80QixJQUFJLENBQVgsQ0FBSjtpQ0FDSzVCLE9BQU80QixJQUFJLENBQVgsQ0FBTDtpQ0FDSzVCLE9BQU80QixJQUFJLENBQVgsQ0FBTDtpQ0FDS3hpQixLQUFLcVAsR0FBTCxDQUFTa1ksS0FBS2hrQixDQUFkLENBQUw7aUNBQ0t2RCxLQUFLcVAsR0FBTCxDQUFTbVksS0FBS2hrQixDQUFkLENBQUw7Z0NBQ0lzWixTQUFKO2dDQUNJOWMsS0FBSzBVLElBQUwsQ0FBV2pGLEtBQUtBLEVBQU4sR0FBYUMsS0FBS0EsRUFBNUIsQ0FBSjs7Z0NBRUlrUyxJQUFJLElBQVIsRUFDQTs7OztpQ0FJSyxDQUFFQyxJQUFJRCxDQUFKLEdBQVFsUyxFQUFULEdBQWVELEVBQWhCLElBQXNCLENBQTNCO2lDQUNLLENBQUVvUyxJQUFJRCxDQUFKLEdBQVFuUyxFQUFULEdBQWVDLEVBQWhCLElBQXNCLENBQTNCO2lDQUNLLENBQUM2WCxLQUFLaGtCLENBQU4sSUFBVyxDQUFoQjtpQ0FDSyxDQUFDaWtCLEtBQUtoa0IsQ0FBTixJQUFXLENBQWhCOzttQ0FFT21oQixLQUFLaVksRUFBTCxHQUFVTCxJQUFWLEdBQWlCNVgsS0FBS2lZLEVBQXRCLEdBQTJCTCxJQUFsQzttQ0FDTzVYLEtBQUtpWSxFQUFMLEdBQVVILElBQVYsR0FBaUI5WCxLQUFLaVksRUFBdEIsR0FBMkJILElBQWxDOzttQ0FFTzdYLEtBQUtpWSxFQUFMLEdBQVVILElBQVYsR0FBaUI5WCxLQUFLaVksRUFBdEIsR0FBMkJILElBQWxDO21DQUNPOVgsS0FBS2lZLEVBQUwsR0FBVUYsSUFBVixHQUFpQi9YLEtBQUtpWSxFQUF0QixHQUEyQkYsSUFBbEM7Ozs7YUE3RmhCLE1BbUdBO3VCQUNXLENBQVA7dUJBQ08sQ0FBUDt1QkFDTyxDQUFQO3VCQUNPLENBQVA7OztpQkFJQ0csS0FBTCxDQUFXUCxJQUFYLEdBQWtCQSxJQUFsQjtpQkFDS08sS0FBTCxDQUFXTCxJQUFYLEdBQWtCQSxJQUFsQjs7aUJBRUtLLEtBQUwsQ0FBV0osSUFBWCxHQUFrQkEsSUFBbEI7aUJBQ0tJLEtBQUwsQ0FBV0gsSUFBWCxHQUFrQkEsSUFBbEI7Ozs7Z0NBR0loOEIsU0FDUjt1SEFDa0JBLE9BQWQ7O2lCQUVLLElBQUkzQyxJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS3NpQixZQUFMLENBQWtCdmlCLE1BQXRDLEVBQThDLEVBQUVDLENBQWhELEVBQ0E7cUJBQ1NzaUIsWUFBTCxDQUFrQnRpQixDQUFsQixFQUFxQmlPLE9BQXJCOztpQkFFQyxJQUFNM0YsRUFBWCxJQUFpQixLQUFLeTJCLE1BQXRCLEVBQ0E7cUJBQ1MsSUFBSXZhLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLdWEsTUFBTCxDQUFZejJCLEVBQVosRUFBZ0JpYSxJQUFoQixDQUFxQnhpQixNQUF6QyxFQUFpRCxFQUFFeWtCLENBQW5ELEVBQ0E7eUJBQ1N1YSxNQUFMLENBQVl6MkIsRUFBWixFQUFnQmlhLElBQWhCLENBQXFCaUMsQ0FBckIsRUFBd0J2VyxPQUF4Qjs7OztpQkFJSHFVLFlBQUwsR0FBb0IsSUFBcEI7aUJBQ0tzYSxXQUFMLEdBQW1CLElBQW5CO2lCQUNLbUMsTUFBTCxHQUFjLElBQWQ7Ozs7OztBQ3RsQlI7Ozs7Ozs7QUFPQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLElBRXFCQzs7O21CQUVMcDZCLEdBQVosRUFBZ0I7Ozs7Y0FFTnhCLE1BQU0wWixRQUFOLENBQWVsWSxHQUFmLENBQU47WUFDSXE2QixXQUFXdmdDLElBQUVnRSxNQUFGLENBQVVoRSxJQUFFcUUsS0FBRixDQUFRNloscUJBQVIsQ0FBVixFQUEyQ2hZLElBQUlwRSxPQUEvQyxDQUFmO1lBQ0lBLE9BQUosR0FBY3krQixRQUFkOztpSEFFT3I2QixHQU5LOztjQVFQd2EsUUFBTCxHQUFnQixJQUFJdWQsUUFBSixPQUFoQjs7O2NBR0t1QyxVQUFMLEdBQW1CLEtBQW5CO2NBQ0tDLFVBQUwsR0FBbUIsS0FBbkI7OztjQUdLcHpCLFdBQUwsR0FBbUIsS0FBbkI7Y0FDSzJELFVBQUwsR0FBbUIsSUFBbkIsQ0FoQlk7Y0FpQlAxRCxnQkFBTCxHQUF3QixJQUF4QixDQWpCWTs7O2NBb0JQcUIsY0FBTCxHQUFzQixJQUF0Qjs7Ozs7Y0FLS3JILElBQUwsR0FBWSxNQUFLQSxJQUFMLElBQWEsT0FBekI7WUFDSXV3QixJQUFKLEtBQWEsTUFBS0EsSUFBTCxHQUFVM3hCLElBQUkyeEIsSUFBM0I7OztjQUdLNkksZ0JBQUwsQ0FBc0J4NkIsR0FBdEI7O2NBRUt5NkIsS0FBTCxHQUFhLElBQWI7Ozs7OzsrQkFJSjs7OytCQUdBOzs7eUNBRWlCejZCLEtBQ2pCO2lCQUNTLElBQUk1RSxDQUFULElBQWM0RSxHQUFkLEVBQW1CO29CQUNaNUUsS0FBSyxJQUFMLElBQWFBLEtBQUssU0FBdEIsRUFBZ0M7eUJBQ3ZCQSxDQUFMLElBQVU0RSxJQUFJNUUsQ0FBSixDQUFWOzs7Ozs7Ozs7OztxQ0FRRXFwQixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJOFYsWUFDOUI7eUJBQ21CLE9BQU9BLFVBQVAsSUFBcUIsV0FBckIsR0FDRSxDQURGLEdBQ01BLFVBRG5CO3lCQUVhdDlCLEtBQUtDLEdBQUwsQ0FBVXE5QixVQUFWLEVBQXVCLEtBQUs5K0IsT0FBTCxDQUFhc2UsU0FBcEMsQ0FBYjtnQkFDSXlnQixTQUFTaFcsS0FBS0YsRUFBbEI7Z0JBQ0ltVyxTQUFTaFcsS0FBS0YsRUFBbEI7Z0JBQ0ltVyxZQUFZejlCLEtBQUtnVixLQUFMLENBQ1poVixLQUFLMFUsSUFBTCxDQUFVNm9CLFNBQVNBLE1BQVQsR0FBa0JDLFNBQVNBLE1BQXJDLElBQStDRixVQURuQyxDQUFoQjtpQkFHSyxJQUFJdC9CLElBQUksQ0FBYixFQUFnQkEsSUFBSXkvQixTQUFwQixFQUErQixFQUFFei9CLENBQWpDLEVBQW9DO29CQUM1QnVGLElBQUlzWixTQUFTd0ssS0FBTWtXLFNBQVNFLFNBQVYsR0FBdUJ6L0IsQ0FBckMsQ0FBUjtvQkFDSXdGLElBQUlxWixTQUFTeUssS0FBTWtXLFNBQVNDLFNBQVYsR0FBdUJ6L0IsQ0FBckMsQ0FBUjtxQkFDS29mLFFBQUwsQ0FBY3BmLElBQUksQ0FBSixLQUFVLENBQVYsR0FBYyxRQUFkLEdBQXlCLFFBQXZDLEVBQWtEdUYsQ0FBbEQsRUFBc0RDLENBQXREO29CQUNJeEYsS0FBTXkvQixZQUFVLENBQWhCLElBQXNCei9CLElBQUUsQ0FBRixLQUFRLENBQWxDLEVBQW9DO3lCQUMzQm9mLFFBQUwsQ0FBY3FGLE1BQWQsQ0FBc0I4RSxFQUF0QixFQUEyQkMsRUFBM0I7Ozs7Ozs7Ozs7Ozs7NkNBVVFocEIsU0FDdEI7Z0JBQ1ErOUIsT0FBUW1CLE9BQU9DLFNBQW5CO2dCQUNJbEIsT0FBUWlCLE9BQU9FLFNBQW5CO2dCQUNJbEIsT0FBUWdCLE9BQU9DLFNBQW5CO2dCQUNJaEIsT0FBUWUsT0FBT0UsU0FBbkI7O2dCQUVJQyxNQUFNci9CLFFBQVFzL0IsU0FBbEIsQ0FOSjtpQkFPUSxJQUFJOS9CLElBQUksQ0FBUixFQUFXbVosSUFBSTBtQixJQUFJOS9CLE1BQXZCLEVBQStCQyxJQUFJbVosQ0FBbkMsRUFBc0NuWixHQUF0QyxFQUEyQztvQkFDbkM2L0IsSUFBSTcvQixDQUFKLEVBQU8sQ0FBUCxJQUFZdStCLElBQWhCLEVBQXNCOzJCQUNYc0IsSUFBSTcvQixDQUFKLEVBQU8sQ0FBUCxDQUFQOztvQkFFQTYvQixJQUFJNy9CLENBQUosRUFBTyxDQUFQLElBQVl5K0IsSUFBaEIsRUFBc0I7MkJBQ1hvQixJQUFJNy9CLENBQUosRUFBTyxDQUFQLENBQVA7O29CQUVBNi9CLElBQUk3L0IsQ0FBSixFQUFPLENBQVAsSUFBWTArQixJQUFoQixFQUFzQjsyQkFDWG1CLElBQUk3L0IsQ0FBSixFQUFPLENBQVAsQ0FBUDs7b0JBRUE2L0IsSUFBSTcvQixDQUFKLEVBQU8sQ0FBUCxJQUFZMitCLElBQWhCLEVBQXNCOzJCQUNYa0IsSUFBSTcvQixDQUFKLEVBQU8sQ0FBUCxDQUFQOzs7O2dCQUlKOGUsU0FBSjtnQkFDSXRlLFFBQVF1ZSxXQUFSLElBQXVCdmUsUUFBUWdpQixTQUFuQyxFQUFnRDs0QkFDaENoaUIsUUFBUXNlLFNBQVIsSUFBcUIsQ0FBakM7YUFESixNQUVPOzRCQUNTLENBQVo7O21CQUVHO21CQUNNOWMsS0FBSys5QixLQUFMLENBQVd4QixPQUFPemYsWUFBWSxDQUE5QixDQUROO21CQUVNOWMsS0FBSys5QixLQUFMLENBQVdyQixPQUFPNWYsWUFBWSxDQUE5QixDQUZOO3VCQUdNMmYsT0FBT0YsSUFBUCxHQUFjemYsU0FIcEI7d0JBSU02ZixPQUFPRCxJQUFQLEdBQWM1ZjthQUozQjs7OztFQTVHNEJqQzs7QUNibkM7Ozs7Ozs7QUFPQSxBQUNBLEFBQ0EsQUFFQSxJQUFJbWpCLE9BQU8sU0FBUEEsSUFBTyxDQUFTcmlCLElBQVQsRUFBZS9ZLEdBQWYsRUFBb0I7UUFDdkIwSixPQUFPLElBQVg7U0FDS3RJLElBQUwsR0FBWSxNQUFaO1NBQ0tpNkIsVUFBTCxHQUFrQixPQUFsQjtTQUNLQyxZQUFMLEdBQW9CLENBQUMsV0FBRCxFQUFjLGFBQWQsRUFBNkIsWUFBN0IsRUFBMkMsVUFBM0MsRUFBdUQsWUFBdkQsQ0FBcEI7OztVQUdNOThCLE1BQU0wWixRQUFOLENBQWVsWSxHQUFmLENBQU47O1NBRUtxNkIsUUFBTCxHQUFnQnZnQyxJQUFFZ0UsTUFBRixDQUFTO2tCQUNYLEVBRFc7b0JBRVQsUUFGUztvQkFHVCxpQkFIUzt3QkFJTCxJQUpLO21CQUtWLE9BTFU7cUJBTVIsSUFOUTttQkFPVixDQVBVO29CQVFULEdBUlM7eUJBU0osSUFUSTs2QkFVQTtLQVZULEVBV2JrQyxJQUFJcEUsT0FYUyxDQUFoQjs7U0FhS3krQixRQUFMLENBQWNrQixJQUFkLEdBQXFCN3hCLEtBQUs4eEIsbUJBQUwsRUFBckI7O1NBRUt6aUIsSUFBTCxHQUFZQSxLQUFLMWUsUUFBTCxFQUFaOztTQUVLdUYsVUFBTCxDQUFnQmxDLFdBQWhCLENBQTRCNE4sS0FBNUIsQ0FBa0MsSUFBbEMsRUFBd0MsQ0FBQ3RMLEdBQUQsQ0FBeEM7Q0ExQko7O0FBNkJBeEIsTUFBTTJMLFVBQU4sQ0FBaUJpeEIsSUFBakIsRUFBdUJuakIsYUFBdkIsRUFBc0M7WUFDMUIsZ0JBQVM1YixJQUFULEVBQWVILEtBQWYsRUFBc0I2WixRQUF0QixFQUFnQzs7WUFFaENqYyxJQUFFYyxPQUFGLENBQVUsS0FBSzBnQyxZQUFmLEVBQTZCai9CLElBQTdCLEtBQXNDLENBQTFDLEVBQTZDO2lCQUNwQ2crQixRQUFMLENBQWNoK0IsSUFBZCxJQUFzQkgsS0FBdEI7OztpQkFHSytNLFNBQUwsR0FBaUIsS0FBakI7aUJBQ0tyTixPQUFMLENBQWEyL0IsSUFBYixHQUFvQixLQUFLQyxtQkFBTCxFQUFwQjtpQkFDSzUvQixPQUFMLENBQWFpSSxLQUFiLEdBQXFCLEtBQUs0M0IsWUFBTCxFQUFyQjtpQkFDSzcvQixPQUFMLENBQWFrSSxNQUFiLEdBQXNCLEtBQUs0M0IsYUFBTCxFQUF0Qjs7S0FWMEI7VUFhNUIsY0FBUzNpQixJQUFULEVBQWUvWSxHQUFmLEVBQW9CO1lBQ2xCMEosT0FBTyxJQUFYO1lBQ0lpQyxJQUFJLEtBQUsvUCxPQUFiO1VBQ0VpSSxLQUFGLEdBQVUsS0FBSzQzQixZQUFMLEVBQVY7VUFDRTMzQixNQUFGLEdBQVcsS0FBSzQzQixhQUFMLEVBQVg7S0FqQjhCO1lBbUIxQixnQkFBUzVnQixHQUFULEVBQWM7YUFDYixJQUFJL1osQ0FBVCxJQUFjLEtBQUtuRixPQUFMLENBQWF1YSxNQUEzQixFQUFtQztnQkFDM0JwVixLQUFLK1osR0FBVCxFQUFjO29CQUNOL1osS0FBSyxjQUFMLElBQXVCLEtBQUtuRixPQUFMLENBQWF1YSxNQUFiLENBQW9CcFYsQ0FBcEIsQ0FBM0IsRUFBbUQ7d0JBQzNDQSxDQUFKLElBQVMsS0FBS25GLE9BQUwsQ0FBYXVhLE1BQWIsQ0FBb0JwVixDQUFwQixDQUFUOzs7O2FBSVA0NkIsV0FBTCxDQUFpQjdnQixHQUFqQixFQUFzQixLQUFLOGdCLGFBQUwsRUFBdEI7S0EzQjhCO2VBNkJ2QixtQkFBUzdpQixJQUFULEVBQWU7YUFDakJBLElBQUwsR0FBWUEsS0FBSzFlLFFBQUwsRUFBWjthQUNLK08sU0FBTDtLQS9COEI7a0JBaUNwQix3QkFBVztZQUNqQnZGLFFBQVEsQ0FBWjtjQUNNK3lCLFNBQU4sQ0FBZ0I1YixJQUFoQjtjQUNNNGIsU0FBTixDQUFnQjJFLElBQWhCLEdBQXVCLEtBQUszL0IsT0FBTCxDQUFhMi9CLElBQXBDO2dCQUNRLEtBQUtNLGFBQUwsQ0FBbUJyOUIsTUFBTW80QixTQUF6QixFQUFvQyxLQUFLZ0YsYUFBTCxFQUFwQyxDQUFSO2NBQ01oRixTQUFOLENBQWdCdmIsT0FBaEI7ZUFDT3hYLEtBQVA7S0F2QzhCO21CQXlDbkIseUJBQVc7ZUFDZixLQUFLaTRCLGNBQUwsQ0FBb0J0OUIsTUFBTW80QixTQUExQixFQUFxQyxLQUFLZ0YsYUFBTCxFQUFyQyxDQUFQO0tBMUM4QjttQkE0Q25CLHlCQUFXO2VBQ2YsS0FBSzdpQixJQUFMLENBQVVwUCxLQUFWLENBQWdCLEtBQUsweEIsVUFBckIsQ0FBUDtLQTdDOEI7aUJBK0NyQixxQkFBU3ZnQixHQUFULEVBQWNpaEIsU0FBZCxFQUF5QjtZQUM5Qi9nQixJQUFKO2FBQ0tnaEIsaUJBQUwsQ0FBdUJsaEIsR0FBdkIsRUFBNEJpaEIsU0FBNUI7YUFDS0UsZUFBTCxDQUFxQm5oQixHQUFyQixFQUEwQmloQixTQUExQjtZQUNJMWdCLE9BQUo7S0FuRDhCO3lCQXFEYiwrQkFBVztZQUN4QjNSLE9BQU8sSUFBWDtZQUNJd3lCLFVBQVUsRUFBZDs7WUFFRXhnQyxJQUFGLENBQU8sS0FBSzQvQixZQUFaLEVBQTBCLFVBQVN2NkIsQ0FBVCxFQUFZO2dCQUM5Qm83QixRQUFRenlCLEtBQUsyd0IsUUFBTCxDQUFjdDVCLENBQWQsQ0FBWjtnQkFDSUEsS0FBSyxVQUFULEVBQXFCO3dCQUNUdEUsV0FBVzAvQixLQUFYLElBQW9CLElBQTVCOztxQkFFS0QsUUFBUTFnQyxJQUFSLENBQWEyZ0MsS0FBYixDQUFUO1NBTEo7O2VBUU9ELFFBQVEza0IsSUFBUixDQUFhLEdBQWIsQ0FBUDtLQWpFOEI7cUJBb0VqQix5QkFBU3VELEdBQVQsRUFBY2loQixTQUFkLEVBQXlCO1lBQ2xDLENBQUMsS0FBS25nQyxPQUFMLENBQWFnaUIsU0FBbEIsRUFBNkI7O2FBRXhCd2UsV0FBTCxHQUFtQixFQUFuQjtZQUNJQyxjQUFjLENBQWxCOzthQUVLLElBQUlqaEMsSUFBSSxDQUFSLEVBQVd5Z0IsTUFBTWtnQixVQUFVNWdDLE1BQWhDLEVBQXdDQyxJQUFJeWdCLEdBQTVDLEVBQWlEemdCLEdBQWpELEVBQXNEO2dCQUM5Q2toQyxlQUFlLEtBQUtDLGdCQUFMLENBQXNCemhCLEdBQXRCLEVBQTJCMWYsQ0FBM0IsRUFBOEIyZ0MsU0FBOUIsQ0FBbkI7MkJBQ2VPLFlBQWY7O2lCQUVLRSxlQUFMLENBQ0ksVUFESixFQUVJMWhCLEdBRkosRUFHSWloQixVQUFVM2dDLENBQVYsQ0FISixFQUlJLENBSko7aUJBS1NxaEMsYUFBTCxLQUF1QkosV0FMM0IsRUFNSWpoQyxDQU5KOztLQTlFMEI7dUJBd0ZmLDJCQUFTMGYsR0FBVCxFQUFjaWhCLFNBQWQsRUFBeUI7WUFDcEMsQ0FBQyxLQUFLbmdDLE9BQUwsQ0FBYXVlLFdBQWQsSUFBNkIsQ0FBQyxLQUFLdmUsT0FBTCxDQUFhc2UsU0FBL0MsRUFBMEQ7O1lBRXREbWlCLGNBQWMsQ0FBbEI7O1lBRUlyaEIsSUFBSjtZQUNJLEtBQUswaEIsZUFBVCxFQUEwQjtnQkFDbEIsSUFBSSxLQUFLQSxlQUFMLENBQXFCdmhDLE1BQTdCLEVBQXFDO3FCQUM1QnVoQyxlQUFMLENBQXFCbGhDLElBQXJCLENBQTBCOFAsS0FBMUIsQ0FBZ0MsS0FBS294QixlQUFyQyxFQUFzRCxLQUFLQSxlQUEzRDs7Z0NBRWdCNWhCLElBQUk2aEIsV0FBSixDQUFnQixLQUFLRCxlQUFyQixDQUFwQjs7O1lBR0E1ZSxTQUFKO2FBQ0ssSUFBSTFpQixJQUFJLENBQVIsRUFBV3lnQixNQUFNa2dCLFVBQVU1Z0MsTUFBaEMsRUFBd0NDLElBQUl5Z0IsR0FBNUMsRUFBaUR6Z0IsR0FBakQsRUFBc0Q7Z0JBQzlDa2hDLGVBQWUsS0FBS0MsZ0JBQUwsQ0FBc0J6aEIsR0FBdEIsRUFBMkIxZixDQUEzQixFQUE4QjJnQyxTQUE5QixDQUFuQjsyQkFDZU8sWUFBZjs7aUJBRUtFLGVBQUwsQ0FDSSxZQURKLEVBRUkxaEIsR0FGSixFQUdJaWhCLFVBQVUzZ0MsQ0FBVixDQUhKLEVBSUksQ0FKSjtpQkFLU3FoQyxhQUFMLEtBQXVCSixXQUwzQixFQU1JamhDLENBTko7O1lBU0EwakIsU0FBSjtZQUNJekQsT0FBSjtLQXBIOEI7cUJBc0hqQix5QkFBU3VoQixNQUFULEVBQWlCOWhCLEdBQWpCLEVBQXNCbWMsSUFBdEIsRUFBNEJyMEIsSUFBNUIsRUFBa0NHLEdBQWxDLEVBQXVDODVCLFNBQXZDLEVBQWtEO2VBQ3hELEtBQUtOLGdCQUFMLEtBQTBCLENBQWpDO1lBQ0ksS0FBSzNnQyxPQUFMLENBQWFraEMsU0FBYixLQUEyQixTQUEvQixFQUEwQztpQkFDakNDLFlBQUwsQ0FBa0JILE1BQWxCLEVBQTBCOWhCLEdBQTFCLEVBQStCbWMsSUFBL0IsRUFBcUNyMEIsSUFBckMsRUFBMkNHLEdBQTNDLEVBQWdEODVCLFNBQWhEOzs7WUFHQTNpQixZQUFZWSxJQUFJa2lCLFdBQUosQ0FBZ0IvRixJQUFoQixFQUFzQnB6QixLQUF0QztZQUNJbzVCLGFBQWEsS0FBS3JoQyxPQUFMLENBQWFpSSxLQUE5Qjs7WUFFSW81QixhQUFhL2lCLFNBQWpCLEVBQTRCO2dCQUNwQmdqQixRQUFRakcsS0FBS3R0QixLQUFMLENBQVcsS0FBWCxDQUFaO2dCQUNJd3pCLGFBQWFyaUIsSUFBSWtpQixXQUFKLENBQWdCL0YsS0FBS21HLE9BQUwsQ0FBYSxNQUFiLEVBQXFCLEVBQXJCLENBQWhCLEVBQTBDdjVCLEtBQTNEO2dCQUNJdzVCLFlBQVlKLGFBQWFFLFVBQTdCO2dCQUNJRyxZQUFZSixNQUFNL2hDLE1BQU4sR0FBZSxDQUEvQjtnQkFDSW9pQyxhQUFhRixZQUFZQyxTQUE3Qjs7Z0JBRUlFLGFBQWEsQ0FBakI7aUJBQ0ssSUFBSXBpQyxJQUFJLENBQVIsRUFBV3lnQixNQUFNcWhCLE1BQU0vaEMsTUFBNUIsRUFBb0NDLElBQUl5Z0IsR0FBeEMsRUFBNkN6Z0IsR0FBN0MsRUFBa0Q7cUJBQ3pDMmhDLFlBQUwsQ0FBa0JILE1BQWxCLEVBQTBCOWhCLEdBQTFCLEVBQStCb2lCLE1BQU05aEMsQ0FBTixDQUEvQixFQUF5Q3dILE9BQU80NkIsVUFBaEQsRUFBNER6NkIsR0FBNUQsRUFBaUU4NUIsU0FBakU7OEJBQ2MvaEIsSUFBSWtpQixXQUFKLENBQWdCRSxNQUFNOWhDLENBQU4sQ0FBaEIsRUFBMEJ5SSxLQUExQixHQUFrQzA1QixVQUFoRDs7U0FWUixNQVlPO2lCQUNFUixZQUFMLENBQWtCSCxNQUFsQixFQUEwQjloQixHQUExQixFQUErQm1jLElBQS9CLEVBQXFDcjBCLElBQXJDLEVBQTJDRyxHQUEzQyxFQUFnRDg1QixTQUFoRDs7S0E1STBCO2tCQStJcEIsc0JBQVNELE1BQVQsRUFBaUI5aEIsR0FBakIsRUFBc0IyaUIsS0FBdEIsRUFBNkI3NkIsSUFBN0IsRUFBbUNHLEdBQW5DLEVBQXdDO1lBQzlDNjVCLE1BQUosRUFBWWEsS0FBWixFQUFtQixDQUFuQixFQUFzQjE2QixHQUF0QjtLQWhKOEI7c0JBa0poQiw0QkFBVztlQUNsQixLQUFLbkgsT0FBTCxDQUFhOGhDLFFBQWIsR0FBd0IsS0FBSzloQyxPQUFMLENBQWEraEMsVUFBNUM7S0FuSjhCO21CQXFKbkIsdUJBQVM3aUIsR0FBVCxFQUFjaWhCLFNBQWQsRUFBeUI7WUFDaEM2QixXQUFXOWlCLElBQUlraUIsV0FBSixDQUFnQmpCLFVBQVUsQ0FBVixLQUFnQixHQUFoQyxFQUFxQ2w0QixLQUFwRDthQUNLLElBQUl6SSxJQUFJLENBQVIsRUFBV3lnQixNQUFNa2dCLFVBQVU1Z0MsTUFBaEMsRUFBd0NDLElBQUl5Z0IsR0FBNUMsRUFBaUR6Z0IsR0FBakQsRUFBc0Q7Z0JBQzlDeWlDLG1CQUFtQi9pQixJQUFJa2lCLFdBQUosQ0FBZ0JqQixVQUFVM2dDLENBQVYsQ0FBaEIsRUFBOEJ5SSxLQUFyRDtnQkFDSWc2QixtQkFBbUJELFFBQXZCLEVBQWlDOzJCQUNsQkMsZ0JBQVg7OztlQUdERCxRQUFQO0tBN0o4QjtvQkErSmxCLHdCQUFTOWlCLEdBQVQsRUFBY2loQixTQUFkLEVBQXlCO2VBQzlCLEtBQUtuZ0MsT0FBTCxDQUFhOGhDLFFBQWIsR0FBd0IzQixVQUFVNWdDLE1BQWxDLEdBQTJDLEtBQUtTLE9BQUwsQ0FBYStoQyxVQUEvRDtLQWhLOEI7Ozs7OzttQkF1S25CLHlCQUFXO1lBQ2xCL3FCLElBQUksQ0FBUjtnQkFDUSxLQUFLaFgsT0FBTCxDQUFha2lDLFlBQXJCO2lCQUNTLEtBQUw7b0JBQ1EsQ0FBSjs7aUJBRUMsUUFBTDtvQkFDUSxDQUFDLEtBQUtsaUMsT0FBTCxDQUFha0ksTUFBZCxHQUF1QixDQUEzQjs7aUJBRUMsUUFBTDtvQkFDUSxDQUFDLEtBQUtsSSxPQUFMLENBQWFrSSxNQUFsQjs7O2VBR0Q4TyxDQUFQO0tBcEw4QjthQXNMekIsbUJBQVc7WUFDWmpILElBQUksS0FBSy9QLE9BQWI7WUFDSStFLElBQUksQ0FBUjtZQUNJQyxJQUFJLENBQVI7O1lBRUkrSyxFQUFFbXhCLFNBQUYsSUFBZSxRQUFuQixFQUE2QjtnQkFDckIsQ0FBQ254QixFQUFFOUgsS0FBSCxHQUFXLENBQWY7O1lBRUE4SCxFQUFFbXhCLFNBQUYsSUFBZSxPQUFuQixFQUE0QjtnQkFDcEIsQ0FBQ254QixFQUFFOUgsS0FBUDs7WUFFQThILEVBQUVteUIsWUFBRixJQUFrQixRQUF0QixFQUFnQztnQkFDeEIsQ0FBQ255QixFQUFFN0gsTUFBSCxHQUFZLENBQWhCOztZQUVBNkgsRUFBRW15QixZQUFGLElBQWtCLFFBQXRCLEVBQWdDO2dCQUN4QixDQUFDbnlCLEVBQUU3SCxNQUFQOzs7ZUFHRztlQUNBbkQsQ0FEQTtlQUVBQyxDQUZBO21CQUdJK0ssRUFBRTlILEtBSE47b0JBSUs4SCxFQUFFN0g7U0FKZDs7Q0F4TVIsRUFnTkE7O0FDdlBBOzs7Ozs7O0FBT0EsQUFFQSxTQUFTaTZCLE1BQVQsQ0FBZ0JwOUIsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCO1FBQ2Q0aUIsS0FBSyxDQUFUO1FBQVdDLEtBQUssQ0FBaEI7UUFDS3BsQixVQUFVbEQsTUFBVixJQUFvQixDQUFwQixJQUF5QnJCLElBQUVtRCxRQUFGLENBQVkwRCxDQUFaLENBQTlCLEVBQStDO1lBQ3ZDRyxNQUFNekMsVUFBVSxDQUFWLENBQVY7WUFDSXZFLElBQUVnQixPQUFGLENBQVdnRyxHQUFYLENBQUosRUFBc0I7aUJBQ2RBLElBQUksQ0FBSixDQUFMO2lCQUNLQSxJQUFJLENBQUosQ0FBTDtTQUZILE1BR08sSUFBSUEsSUFBSXhHLGNBQUosQ0FBbUIsR0FBbkIsS0FBMkJ3RyxJQUFJeEcsY0FBSixDQUFtQixHQUFuQixDQUEvQixFQUF5RDtpQkFDeER3RyxJQUFJSCxDQUFUO2lCQUNLRyxJQUFJRixDQUFUOzs7U0FHRm85QixLQUFMLEdBQWEsQ0FBQ3hhLEVBQUQsRUFBS0MsRUFBTCxDQUFiOztBQUVKc2EsT0FBTzdqQyxTQUFQLEdBQW1CO2NBQ0wsa0JBQVVnVCxDQUFWLEVBQWE7WUFDZnZNLElBQUksS0FBS3E5QixLQUFMLENBQVcsQ0FBWCxJQUFnQjl3QixFQUFFOHdCLEtBQUYsQ0FBUSxDQUFSLENBQXhCO1lBQ0lwOUIsSUFBSSxLQUFLbzlCLEtBQUwsQ0FBVyxDQUFYLElBQWdCOXdCLEVBQUU4d0IsS0FBRixDQUFRLENBQVIsQ0FBeEI7O2VBRU81Z0MsS0FBSzBVLElBQUwsQ0FBV25SLElBQUlBLENBQUwsR0FBV0MsSUFBSUEsQ0FBekIsQ0FBUDs7Q0FMUixDQVFBOztBQ2hDQTs7Ozs7OztBQU9BLEFBQ0EsQUFFQTs7O0FBR0EsU0FBU3E5QixXQUFULENBQXFCdnJCLEVBQXJCLEVBQXlCQyxFQUF6QixFQUE2QkksRUFBN0IsRUFBaUNDLEVBQWpDLEVBQXFDSixDQUFyQyxFQUF3Q08sRUFBeEMsRUFBNENDLEVBQTVDLEVBQWdEO1FBQ3hDSCxLQUFLLENBQUNGLEtBQUtMLEVBQU4sSUFBWSxJQUFyQjtRQUNJUSxLQUFLLENBQUNGLEtBQUtMLEVBQU4sSUFBWSxJQUFyQjtXQUNPLENBQUMsS0FBS0EsS0FBS0ksRUFBVixJQUFnQkUsRUFBaEIsR0FBcUJDLEVBQXRCLElBQTRCRSxFQUE1QixHQUNFLENBQUMsQ0FBRSxDQUFGLElBQU9ULEtBQUtJLEVBQVosSUFBa0IsSUFBSUUsRUFBdEIsR0FBMkJDLEVBQTVCLElBQWtDQyxFQURwQyxHQUVFRixLQUFLTCxDQUZQLEdBRVdELEVBRmxCOzs7Ozs7QUFRSixtQkFBZSxVQUFXM1MsR0FBWCxFQUFpQjtRQUN4QmdlLFNBQVNoZSxJQUFJZ2UsTUFBakI7UUFDSWtnQixTQUFTbCtCLElBQUlrK0IsTUFBakI7UUFDSUMsZUFBZW4rQixJQUFJbStCLFlBQXZCOztRQUVJdGlCLE1BQU1tQyxPQUFPN2lCLE1BQWpCO1FBQ0kwZ0IsT0FBTyxDQUFYLEVBQWM7ZUFDSG1DLE1BQVA7O1FBRUFvZ0IsTUFBTSxFQUFWO1FBQ0lDLFdBQVksQ0FBaEI7UUFDSUMsWUFBWSxJQUFJUCxNQUFKLENBQVkvZixPQUFPLENBQVAsQ0FBWixDQUFoQjtRQUNJdWdCLFFBQVksSUFBaEI7U0FDSyxJQUFJbmpDLElBQUksQ0FBYixFQUFnQkEsSUFBSXlnQixHQUFwQixFQUF5QnpnQixHQUF6QixFQUE4QjtnQkFDbEIsSUFBSTJpQyxNQUFKLENBQVcvZixPQUFPNWlCLENBQVAsQ0FBWCxDQUFSO29CQUNZa2pDLFVBQVVELFFBQVYsQ0FBb0JFLEtBQXBCLENBQVo7b0JBQ1lBLEtBQVo7OztnQkFHUSxJQUFaO1lBQ1ksSUFBWjs7O1FBSUlyYSxPQUFPbWEsV0FBVyxDQUF0Qjs7V0FFT25hLE9BQU9ySSxHQUFQLEdBQWFBLEdBQWIsR0FBbUJxSSxJQUExQjtTQUNLLElBQUk5b0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJOG9CLElBQXBCLEVBQTBCOW9CLEdBQTFCLEVBQStCO1lBQ3ZCb2pDLE1BQU1wakMsS0FBSzhvQixPQUFLLENBQVYsS0FBZ0JnYSxTQUFTcmlCLEdBQVQsR0FBZUEsTUFBTSxDQUFyQyxDQUFWO1lBQ0k0aUIsTUFBTXJoQyxLQUFLZ1YsS0FBTCxDQUFXb3NCLEdBQVgsQ0FBVjs7WUFFSXhmLElBQUl3ZixNQUFNQyxHQUFkOztZQUVJL3JCLEVBQUo7WUFDSUMsS0FBS3FMLE9BQU95Z0IsTUFBTTVpQixHQUFiLENBQVQ7WUFDSTlJLEVBQUo7WUFDSUMsRUFBSjtZQUNJLENBQUNrckIsTUFBTCxFQUFhO2lCQUNKbGdCLE9BQU95Z0IsUUFBUSxDQUFSLEdBQVlBLEdBQVosR0FBa0JBLE1BQU0sQ0FBL0IsQ0FBTDtpQkFDS3pnQixPQUFPeWdCLE1BQU01aUIsTUFBTSxDQUFaLEdBQWdCQSxNQUFNLENBQXRCLEdBQTBCNGlCLE1BQU0sQ0FBdkMsQ0FBTDtpQkFDS3pnQixPQUFPeWdCLE1BQU01aUIsTUFBTSxDQUFaLEdBQWdCQSxNQUFNLENBQXRCLEdBQTBCNGlCLE1BQU0sQ0FBdkMsQ0FBTDtTQUhKLE1BSU87aUJBQ0V6Z0IsT0FBTyxDQUFDeWdCLE1BQUssQ0FBTCxHQUFTNWlCLEdBQVYsSUFBaUJBLEdBQXhCLENBQUw7aUJBQ0ttQyxPQUFPLENBQUN5Z0IsTUFBTSxDQUFQLElBQVk1aUIsR0FBbkIsQ0FBTDtpQkFDS21DLE9BQU8sQ0FBQ3lnQixNQUFNLENBQVAsSUFBWTVpQixHQUFuQixDQUFMOzs7WUFHQTZpQixLQUFLMWYsSUFBSUEsQ0FBYjtZQUNJMmYsS0FBSzNmLElBQUkwZixFQUFiOztZQUVJaC9CLEtBQUssQ0FDRHUrQixZQUFZdnJCLEdBQUcsQ0FBSCxDQUFaLEVBQW1CQyxHQUFHLENBQUgsQ0FBbkIsRUFBMEJJLEdBQUcsQ0FBSCxDQUExQixFQUFpQ0MsR0FBRyxDQUFILENBQWpDLEVBQXdDZ00sQ0FBeEMsRUFBMkMwZixFQUEzQyxFQUErQ0MsRUFBL0MsQ0FEQyxFQUVEVixZQUFZdnJCLEdBQUcsQ0FBSCxDQUFaLEVBQW1CQyxHQUFHLENBQUgsQ0FBbkIsRUFBMEJJLEdBQUcsQ0FBSCxDQUExQixFQUFpQ0MsR0FBRyxDQUFILENBQWpDLEVBQXdDZ00sQ0FBeEMsRUFBMkMwZixFQUEzQyxFQUErQ0MsRUFBL0MsQ0FGQyxDQUFUOztZQUtFcmlDLFVBQUYsQ0FBYTZoQyxZQUFiLEtBQThCQSxhQUFjeitCLEVBQWQsQ0FBOUI7O1lBRUlsRSxJQUFKLENBQVVrRSxFQUFWOztXQUVHMCtCLEdBQVA7OztBQ25GSjs7Ozs7Ozs7O0FBU0EsQUFHQSxJQUFJUSxTQUFTO1NBQ0gsRUFERztTQUVILEVBRkc7Q0FBYjtBQUlBLElBQUlDLFdBQVd6aEMsS0FBS2lQLEVBQUwsR0FBVSxHQUF6Qjs7Ozs7O0FBTUEsU0FBU0QsR0FBVCxDQUFhRyxLQUFiLEVBQW9CdXlCLFNBQXBCLEVBQStCO1lBQ25CLENBQUNBLFlBQVl2eUIsUUFBUXN5QixRQUFwQixHQUErQnR5QixLQUFoQyxFQUF1Q3d5QixPQUF2QyxDQUErQyxDQUEvQyxDQUFSO1FBQ0csT0FBT0gsT0FBT3h5QixHQUFQLENBQVdHLEtBQVgsQ0FBUCxJQUE0QixXQUEvQixFQUE0QztlQUNqQ0gsR0FBUCxDQUFXRyxLQUFYLElBQW9CblAsS0FBS2dQLEdBQUwsQ0FBU0csS0FBVCxDQUFwQjs7V0FFR3F5QixPQUFPeHlCLEdBQVAsQ0FBV0csS0FBWCxDQUFQOzs7Ozs7QUFNSixTQUFTSixHQUFULENBQWFJLEtBQWIsRUFBb0J1eUIsU0FBcEIsRUFBK0I7WUFDbkIsQ0FBQ0EsWUFBWXZ5QixRQUFRc3lCLFFBQXBCLEdBQStCdHlCLEtBQWhDLEVBQXVDd3lCLE9BQXZDLENBQStDLENBQS9DLENBQVI7UUFDRyxPQUFPSCxPQUFPenlCLEdBQVAsQ0FBV0ksS0FBWCxDQUFQLElBQTRCLFdBQS9CLEVBQTRDO2VBQ2pDSixHQUFQLENBQVdJLEtBQVgsSUFBb0JuUCxLQUFLK08sR0FBTCxDQUFTSSxLQUFULENBQXBCOztXQUVHcXlCLE9BQU96eUIsR0FBUCxDQUFXSSxLQUFYLENBQVA7Ozs7Ozs7QUFPSixTQUFTeXlCLGNBQVQsQ0FBd0J6eUIsS0FBeEIsRUFBK0I7V0FDcEJBLFFBQVFzeUIsUUFBZjs7Ozs7OztBQU9KLFNBQVNJLGNBQVQsQ0FBd0IxeUIsS0FBeEIsRUFBK0I7V0FDcEJBLFFBQVFzeUIsUUFBZjs7Ozs7OztBQU9KLFNBQVNLLFdBQVQsQ0FBc0IzeUIsS0FBdEIsRUFBOEI7UUFDdEI0eUIsUUFBUSxDQUFDLE1BQU81eUIsUUFBUyxHQUFqQixJQUF3QixHQUFwQyxDQUQwQjtRQUV0QjR5QixTQUFTLENBQVQsSUFBYzV5QixVQUFVLENBQTVCLEVBQStCO2dCQUNuQixHQUFSOztXQUVHNHlCLEtBQVA7OztBQUdKLFNBQVNDLGlCQUFULENBQTRCL3NCLENBQTVCLEVBQWdDL1MsQ0FBaEMsRUFBbUM7UUFDM0I0N0IsWUFBWSxFQUFoQjtRQUNJbUUsUUFBUSxJQUFJamlDLEtBQUtpUCxFQUFULEdBQWNnRyxDQUExQjtRQUNJaXRCLFdBQVcsQ0FBQ2xpQyxLQUFLaVAsRUFBTixHQUFXLENBQTFCO1FBQ0lrekIsTUFBTUQsUUFBVjtTQUNLLElBQUlsa0MsSUFBSSxDQUFSLEVBQVc0TSxNQUFNcUssQ0FBdEIsRUFBeUJqWCxJQUFJNE0sR0FBN0IsRUFBa0M1TSxHQUFsQyxFQUF1QztrQkFDekJJLElBQVYsQ0FBZSxDQUFDOEQsSUFBSWxDLEtBQUsrTyxHQUFMLENBQVNvekIsR0FBVCxDQUFMLEVBQW9CamdDLElBQUlsQyxLQUFLZ1AsR0FBTCxDQUFTbXpCLEdBQVQsQ0FBeEIsQ0FBZjtlQUNPRixLQUFQOztXQUVHbkUsU0FBUDs7O0FBR0osU0FBU3NFLGtCQUFULENBQTZCQyxLQUE3QixFQUFvQ3RCLFlBQXBDLEVBQWtEOzs7UUFHMUNqakMsTUFBTTtnQkFDRXVrQztLQURaO1FBR0kzbEMsRUFBRXdDLFVBQUYsQ0FBYTZoQyxZQUFiLENBQUosRUFBZ0M7WUFDeEJBLFlBQUosR0FBbUJBLFlBQW5COzs7UUFHQXVCLFFBQVFDLGFBQWF6a0MsR0FBYixDQUFaO1FBQ0l1a0MsU0FBU0EsTUFBTXRrQyxNQUFOLEdBQWEsQ0FBMUIsRUFBNkI7Y0FDbkJLLElBQU4sQ0FBWWlrQyxNQUFNQSxNQUFNdGtDLE1BQU4sR0FBZSxDQUFyQixDQUFaOzs7V0FHR3VrQyxLQUFQOzs7QUFHSixhQUFlO1FBQ0x0aUMsS0FBS2lQLEVBREE7U0FFTEQsR0FGSztTQUdMRCxHQUhLO29CQUlNNnlCLGNBSk47b0JBS01DLGNBTE47aUJBTU1DLFdBTk47dUJBT1NFLGlCQVBUO3dCQVFTSTtDQVJ4Qjs7QUNuR0E7Ozs7Ozs7Ozs7QUFVQSxBQUNBLEFBQ0EsQUFDQSxJQUVxQkk7Ozt3QkFFTDUvQixHQUFaLEVBQWtCNi9CLEtBQWxCLEVBQXdCOzs7Y0FDZHJoQyxNQUFNMFosUUFBTixDQUFlbFksR0FBZixDQUFOO1lBQ0lxNkIsV0FBV3ZnQyxJQUFFZ0UsTUFBRixDQUFTO3NCQUNWLElBRFU7b0JBRVosS0FGWTt1QkFHVCxFQUhTOzBCQUlOVSxNQUFNYTtTQUpULEVBS1pXLElBQUlwRSxPQUxRLENBQWY7O1lBT0lpa0MsVUFBVSxPQUFWLElBQXFCeEYsU0FBU3lGLE1BQWxDLEVBQTBDO3FCQUM3QjVFLFNBQVQsR0FBcUI2RSxPQUFNUCxrQkFBTixDQUEwQm5GLFNBQVNhLFNBQW5DLENBQXJCOzs7WUFHQXQvQixPQUFKLEdBQWN5K0IsUUFBZDs7MkhBRU1yNkIsR0FmYzs7Y0FpQmZvQixJQUFMLEdBQVksWUFBWjtjQUNLc0MsRUFBTCxHQUFVbEYsTUFBTThaLFFBQU4sQ0FBZSxNQUFLbFgsSUFBcEIsQ0FBVjs7Y0FFSzQrQixXQUFMOzs7Ozs7K0JBR0czakMsTUFBTUgsT0FBTzZaLFVBQ3BCO2dCQUNRMVosUUFBUSxXQUFSLElBQXVCQSxRQUFRLFFBQS9CLElBQTJDQSxRQUFRLFVBQXZELEVBQW1FO3FCQUMxRDJqQyxXQUFMOzs7OztzQ0FNUjtpQkFDU3hsQixRQUFMLENBQWM0TixLQUFkOztnQkFFTXhzQixVQUFVLEtBQUtBLE9BQXJCO2dCQUNNcy9CLFlBQVl0L0IsUUFBUXMvQixTQUExQjtnQkFDSUEsVUFBVS8vQixNQUFWLEdBQW1CLENBQXZCLEVBQTBCOzt1QkFFZixJQUFQOztnQkFFQSxDQUFDUyxRQUFRcWtDLFFBQVQsSUFBcUJya0MsUUFBUXFrQyxRQUFSLElBQW9CLE9BQTdDLEVBQXNEOzs7cUJBRzdDemxCLFFBQUwsQ0FBY2lGLE1BQWQsQ0FBcUJ5YixVQUFVLENBQVYsRUFBYSxDQUFiLENBQXJCLEVBQXNDQSxVQUFVLENBQVYsRUFBYSxDQUFiLENBQXRDO3FCQUNLLElBQUk5L0IsSUFBSSxDQUFSLEVBQVdtWixJQUFJMm1CLFVBQVUvL0IsTUFBOUIsRUFBc0NDLElBQUltWixDQUExQyxFQUE2Q25aLEdBQTdDLEVBQWtEO3lCQUN6Q29mLFFBQUwsQ0FBY3FGLE1BQWQsQ0FBcUJxYixVQUFVOS9CLENBQVYsRUFBYSxDQUFiLENBQXJCLEVBQXNDOC9CLFVBQVU5L0IsQ0FBVixFQUFhLENBQWIsQ0FBdEM7O2FBTFIsTUFPTyxJQUFJUSxRQUFRcWtDLFFBQVIsSUFBb0IsUUFBcEIsSUFBZ0Nya0MsUUFBUXFrQyxRQUFSLElBQW9CLFFBQXhELEVBQWtFO29CQUNqRXJrQyxRQUFRa2tDLE1BQVosRUFBb0I7eUJBQ1gsSUFBSUksS0FBSyxDQUFULEVBQVlDLEtBQUtqRixVQUFVLy9CLE1BQWhDLEVBQXdDK2tDLEtBQUtDLEVBQTdDLEVBQWlERCxJQUFqRCxFQUF1RDs0QkFDL0NBLE1BQU1DLEtBQUcsQ0FBYixFQUFnQjs7OzZCQUdYM2xCLFFBQUwsQ0FBY2lGLE1BQWQsQ0FBc0J5YixVQUFVZ0YsRUFBVixFQUFjLENBQWQsQ0FBdEIsRUFBeUNoRixVQUFVZ0YsRUFBVixFQUFjLENBQWQsQ0FBekM7NkJBQ0sxbEIsUUFBTCxDQUFjcUYsTUFBZCxDQUFzQnFiLFVBQVVnRixLQUFHLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBdEIsRUFBMkNoRixVQUFVZ0YsS0FBRyxDQUFiLEVBQWdCLENBQWhCLENBQTNDOzhCQUNJLENBQUo7O2lCQVBSLE1BU087O3lCQUVFMWxCLFFBQUwsQ0FBY2lGLE1BQWQsQ0FBcUJ5YixVQUFVLENBQVYsRUFBYSxDQUFiLENBQXJCLEVBQXNDQSxVQUFVLENBQVYsRUFBYSxDQUFiLENBQXRDO3lCQUNLLElBQUk5L0IsSUFBSSxDQUFSLEVBQVdtWixJQUFJMm1CLFVBQVUvL0IsTUFBOUIsRUFBc0NDLElBQUltWixDQUExQyxFQUE2Q25aLEdBQTdDLEVBQWtEOzRCQUMxQ21tQixRQUFRMlosVUFBVTkvQixJQUFJLENBQWQsRUFBaUIsQ0FBakIsQ0FBWjs0QkFDSXdsQixNQUFNc2EsVUFBVTkvQixDQUFWLEVBQWEsQ0FBYixDQUFWOzRCQUNJb21CLFFBQVEwWixVQUFVOS9CLElBQUksQ0FBZCxFQUFpQixDQUFqQixDQUFaOzRCQUNJeWxCLE1BQU1xYSxVQUFVOS9CLENBQVYsRUFBYSxDQUFiLENBQVY7NkJBQ0tnbEMsWUFBTCxDQUFrQjdlLEtBQWxCLEVBQXlCQyxLQUF6QixFQUFnQ1osR0FBaEMsRUFBcUNDLEdBQXJDLEVBQTBDLENBQTFDOzs7O21CQUlMLElBQVA7Ozs7RUF4RWdDdVo7O0FDZnhDOzs7Ozs7Ozs7Ozs7QUFZQSxBQUNBLEFBQ0EsSUFFcUIxVTs7O29CQUVKMWxCLEdBQWIsRUFDQTs7O2NBQ1V4QixNQUFNMFosUUFBTixDQUFnQmxZLEdBQWhCLENBQU47O3FCQUVlQSxHQUFmLEtBQTBCQSxJQUFJb1ksT0FBSixHQUFjLEtBQXhDO1lBQ0lpaUIsV0FBV3ZnQyxJQUFFZ0UsTUFBRixDQUFTO2VBQ2hCLENBRGdCO1NBQVQsRUFFWGtDLElBQUlwRSxPQUZPLENBQWY7O1lBSUlBLE9BQUosR0FBY3krQixRQUFkOzttSEFFT3I2QixHQVZYOztjQVlTb0IsSUFBTCxHQUFZLFFBQVo7Y0FDS3NDLEVBQUwsR0FBVWxGLE1BQU04WixRQUFOLENBQWUsTUFBS2xYLElBQXBCLENBQVY7O2NBRUs0K0IsV0FBTDs7Ozs7OytCQUdHM2pDLE1BQU1ILE9BQU82WixVQUNwQjtnQkFDUzFaLFFBQVEsR0FBYixFQUFtQjtxQkFDVjJqQyxXQUFMOzs7OztzQ0FLUjtpQkFDU3hsQixRQUFMLENBQWM0TixLQUFkOztpQkFFSzVOLFFBQUwsQ0FBYzZsQixVQUFkLENBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLEtBQUt6a0MsT0FBTCxDQUFhMEQsQ0FBNUM7Ozs7RUFoQzRCODZCOztBQ2hCcEM7Ozs7Ozs7Ozs7QUFVQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsSUFFcUJrRzs7O2tCQUVMdGdDLEdBQVosRUFBZ0I7Ozs7Y0FFTnhCLE1BQU0wWixRQUFOLENBQWVsWSxHQUFmLENBQU47WUFDSXE2QixXQUFXdmdDLElBQUVnRSxNQUFGLENBQVM7dUJBQ1QsRUFEUztrQkFFZCxFQUZjOzs7Ozs7Ozs7O1NBQVQsRUFZWGtDLElBQUlwRSxPQVpPLENBQWY7WUFhSUEsT0FBSixHQUFjeStCLFFBQWQ7OytHQUVPcjZCLEdBbEJLOztZQXFCUixrQkFBa0JBLEdBQXRCLEVBQTJCO2tCQUNsQnVnQyxZQUFMLEdBQW9CdmdDLElBQUl1Z0MsWUFBeEI7OztjQUdDQyxlQUFMLEdBQXVCLElBQXZCOztjQUdLcC9CLElBQUwsR0FBWSxNQUFaO2NBQ0tzQyxFQUFMLEdBQVVsRixNQUFNOFosUUFBTixDQUFlLE1BQUtsWCxJQUFwQixDQUFWOztjQUVLNCtCLFdBQUw7Ozs7Ozs7K0JBSUczakMsTUFBTUgsT0FBTzZaLFVBQ3BCO2dCQUNRMVosUUFBUSxNQUFaLEVBQW9COztxQkFDWDJqQyxXQUFMOzs7Ozt1Q0FHT3JpQixNQUNmO2dCQUNRLEtBQUs2aUIsZUFBVCxFQUEwQjt1QkFDZixLQUFLQSxlQUFaOztnQkFFQSxDQUFDN2lCLElBQUwsRUFBVzt1QkFDQSxFQUFQOzs7aUJBR0M2aUIsZUFBTCxHQUF1QixFQUF2QjtnQkFDSUMsUUFBUTNtQyxJQUFFK0IsT0FBRixDQUFVOGhCLEtBQUt5ZixPQUFMLENBQWEsT0FBYixFQUFzQixPQUF0QixFQUErQnp6QixLQUEvQixDQUFxQyxLQUFyQyxDQUFWLENBQVo7Z0JBQ0lwRSxLQUFLLElBQVQ7Z0JBQ0U3SixJQUFGLENBQU8ra0MsS0FBUCxFQUFjLFVBQVNDLE9BQVQsRUFBa0I7bUJBQ3pCRixlQUFILENBQW1CaGxDLElBQW5CLENBQXdCK0osR0FBR283QixtQkFBSCxDQUF1QkQsT0FBdkIsQ0FBeEI7YUFESjttQkFHTyxLQUFLRixlQUFaOzs7OzRDQUdnQjdpQixNQUNwQjs7Z0JBRVFpakIsS0FBS2pqQixJQUFUOztnQkFFSXdLLEtBQUssQ0FDTCxHQURLLEVBQ0EsR0FEQSxFQUNLLEdBREwsRUFDVSxHQURWLEVBQ2UsR0FEZixFQUNvQixHQURwQixFQUN5QixHQUR6QixFQUM4QixHQUQ5QixFQUNtQyxHQURuQyxFQUN3QyxHQUR4QyxFQUVMLEdBRkssRUFFQSxHQUZBLEVBRUssR0FGTCxFQUVVLEdBRlYsRUFFZSxHQUZmLEVBRW9CLEdBRnBCLEVBRXlCLEdBRnpCLEVBRThCLEdBRjlCLEVBRW1DLEdBRm5DLEVBRXdDLEdBRnhDLENBQVQ7aUJBSUt5WSxHQUFHeEQsT0FBSCxDQUFXLEtBQVgsRUFBa0IsR0FBbEIsQ0FBTDtpQkFDS3dELEdBQUd4RCxPQUFILENBQVcsSUFBWCxFQUFpQixHQUFqQixDQUFMOztpQkFFS3dELEdBQUd4RCxPQUFILENBQVcsUUFBWCxFQUFxQixNQUFyQixDQUFMO2lCQUNLd0QsR0FBR3hELE9BQUgsQ0FBVyxLQUFYLEVBQWtCLEdBQWxCLENBQUw7Z0JBQ0kvcUIsQ0FBSjs7aUJBRUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJOFYsR0FBR2h0QixNQUFuQixFQUEyQmtYLEdBQTNCLEVBQWdDO3FCQUN2QnV1QixHQUFHeEQsT0FBSCxDQUFXLElBQUl5RCxNQUFKLENBQVcxWSxHQUFHOVYsQ0FBSCxDQUFYLEVBQWtCLEdBQWxCLENBQVgsRUFBbUMsTUFBTThWLEdBQUc5VixDQUFILENBQXpDLENBQUw7OztnQkFHQXl1QixNQUFNRixHQUFHajNCLEtBQUgsQ0FBUyxHQUFULENBQVY7Z0JBQ0lvM0IsS0FBSyxFQUFUOztnQkFFSUMsTUFBTSxDQUFWO2dCQUNJQyxNQUFNLENBQVY7aUJBQ0s1dUIsSUFBSSxDQUFULEVBQVlBLElBQUl5dUIsSUFBSTNsQyxNQUFwQixFQUE0QmtYLEdBQTVCLEVBQWlDO29CQUN6QjZ1QixNQUFNSixJQUFJenVCLENBQUosQ0FBVjtvQkFDSTFHLElBQUl1MUIsSUFBSXh2QixNQUFKLENBQVcsQ0FBWCxDQUFSO3NCQUNNd3ZCLElBQUkzaUMsS0FBSixDQUFVLENBQVYsQ0FBTjtzQkFDTTJpQyxJQUFJOUQsT0FBSixDQUFZLElBQUl5RCxNQUFKLENBQVcsS0FBWCxFQUFrQixHQUFsQixDQUFaLEVBQW9DLElBQXBDLENBQU47Ozs7O29CQUtJOS9CLElBQUltZ0MsSUFBSXYzQixLQUFKLENBQVUsR0FBVixDQUFSOztvQkFFSTVJLEVBQUU1RixNQUFGLEdBQVcsQ0FBWCxJQUFnQjRGLEVBQUUsQ0FBRixNQUFTLEVBQTdCLEVBQWlDO3NCQUMzQmtULEtBQUY7OztxQkFHQyxJQUFJN1ksSUFBSSxDQUFiLEVBQWdCQSxJQUFJMkYsRUFBRTVGLE1BQXRCLEVBQThCQyxHQUE5QixFQUFtQztzQkFDN0JBLENBQUYsSUFBT3FCLFdBQVdzRSxFQUFFM0YsQ0FBRixDQUFYLENBQVA7O3VCQUVHMkYsRUFBRTVGLE1BQUYsR0FBVyxDQUFsQixFQUFxQjt3QkFDYnFCLE1BQU11RSxFQUFFLENBQUYsQ0FBTixDQUFKLEVBQWlCOzs7d0JBR2JvZ0MsTUFBTSxJQUFWO3dCQUNJbmpCLFNBQVMsRUFBYjs7d0JBRUlvakIsTUFBSjt3QkFDSUMsTUFBSjt3QkFDSUMsT0FBSjs7d0JBRUl4Z0IsRUFBSjt3QkFDSUMsRUFBSjt3QkFDSXdnQixHQUFKO3dCQUNJQyxFQUFKO3dCQUNJQyxFQUFKOzt3QkFFSWhkLEtBQUt1YyxHQUFUO3dCQUNJdGMsS0FBS3VjLEdBQVQ7Ozs0QkFHUXQxQixDQUFSOzZCQUNTLEdBQUw7bUNBQ1c1SyxFQUFFa1QsS0FBRixFQUFQO21DQUNPbFQsRUFBRWtULEtBQUYsRUFBUDtrQ0FDTSxHQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCOzs2QkFFQyxHQUFMO2tDQUNVbGdDLEVBQUVrVCxLQUFGLEVBQU47a0NBQ01sVCxFQUFFa1QsS0FBRixFQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCOzs2QkFFQyxHQUFMO21DQUNXbGdDLEVBQUVrVCxLQUFGLEVBQVA7bUNBQ09sVCxFQUFFa1QsS0FBRixFQUFQO2tDQUNNLEdBQU47bUNBQ096WSxJQUFQLENBQVl3bEMsR0FBWixFQUFpQkMsR0FBakI7Z0NBQ0ksR0FBSjs7NkJBRUMsR0FBTDtrQ0FDVWxnQyxFQUFFa1QsS0FBRixFQUFOO2tDQUNNbFQsRUFBRWtULEtBQUYsRUFBTjtrQ0FDTSxHQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCO2dDQUNJLEdBQUo7Ozs2QkFHQyxHQUFMO21DQUNXbGdDLEVBQUVrVCxLQUFGLEVBQVA7a0NBQ00sR0FBTjttQ0FDT3pZLElBQVAsQ0FBWXdsQyxHQUFaLEVBQWlCQyxHQUFqQjs7NkJBRUMsR0FBTDtrQ0FDVWxnQyxFQUFFa1QsS0FBRixFQUFOO2tDQUNNLEdBQU47bUNBQ096WSxJQUFQLENBQVl3bEMsR0FBWixFQUFpQkMsR0FBakI7OzZCQUVDLEdBQUw7bUNBQ1dsZ0MsRUFBRWtULEtBQUYsRUFBUDtrQ0FDTSxHQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCOzs2QkFFQyxHQUFMO2tDQUNVbGdDLEVBQUVrVCxLQUFGLEVBQU47a0NBQ00sR0FBTjttQ0FDT3pZLElBQVAsQ0FBWXdsQyxHQUFaLEVBQWlCQyxHQUFqQjs7NkJBRUMsR0FBTDttQ0FDV3psQyxJQUFQLENBQVl1RixFQUFFa1QsS0FBRixFQUFaLEVBQXVCbFQsRUFBRWtULEtBQUYsRUFBdkIsRUFBa0NsVCxFQUFFa1QsS0FBRixFQUFsQyxFQUE2Q2xULEVBQUVrVCxLQUFGLEVBQTdDO2tDQUNNbFQsRUFBRWtULEtBQUYsRUFBTjtrQ0FDTWxULEVBQUVrVCxLQUFGLEVBQU47bUNBQ096WSxJQUFQLENBQVl3bEMsR0FBWixFQUFpQkMsR0FBakI7OzZCQUVDLEdBQUw7bUNBQ1d6bEMsSUFBUCxDQUNJd2xDLE1BQU1qZ0MsRUFBRWtULEtBQUYsRUFEVixFQUNxQmd0QixNQUFNbGdDLEVBQUVrVCxLQUFGLEVBRDNCLEVBRUkrc0IsTUFBTWpnQyxFQUFFa1QsS0FBRixFQUZWLEVBRXFCZ3RCLE1BQU1sZ0MsRUFBRWtULEtBQUYsRUFGM0I7bUNBSU9sVCxFQUFFa1QsS0FBRixFQUFQO21DQUNPbFQsRUFBRWtULEtBQUYsRUFBUDtrQ0FDTSxHQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCOzs2QkFFQyxHQUFMO3FDQUNhRCxHQUFUO3FDQUNTQyxHQUFUO3NDQUNVRixHQUFHQSxHQUFHNWxDLE1BQUgsR0FBWSxDQUFmLENBQVY7Z0NBQ0ltbUMsUUFBUUksT0FBUixLQUFvQixHQUF4QixFQUE2Qjt5Q0FDaEJWLE9BQU9BLE1BQU1NLFFBQVF0akIsTUFBUixDQUFlLENBQWYsQ0FBYixDQUFUO3lDQUNTaWpCLE9BQU9BLE1BQU1LLFFBQVF0akIsTUFBUixDQUFlLENBQWYsQ0FBYixDQUFUOzttQ0FFR3hpQixJQUFQLENBQVk0bEMsTUFBWixFQUFvQkMsTUFBcEIsRUFBNEJ0Z0MsRUFBRWtULEtBQUYsRUFBNUIsRUFBdUNsVCxFQUFFa1QsS0FBRixFQUF2QztrQ0FDTWxULEVBQUVrVCxLQUFGLEVBQU47a0NBQ01sVCxFQUFFa1QsS0FBRixFQUFOO2tDQUNNLEdBQU47bUNBQ096WSxJQUFQLENBQVl3bEMsR0FBWixFQUFpQkMsR0FBakI7OzZCQUVDLEdBQUw7cUNBQ2FELEdBQVQsRUFBY0ssU0FBU0osR0FBdkI7c0NBQ1VGLEdBQUdBLEdBQUc1bEMsTUFBSCxHQUFZLENBQWYsQ0FBVjtnQ0FDSW1tQyxRQUFRSSxPQUFSLEtBQW9CLEdBQXhCLEVBQTZCO3lDQUNoQlYsT0FBT0EsTUFBTU0sUUFBUXRqQixNQUFSLENBQWUsQ0FBZixDQUFiLENBQVQ7eUNBQ1NpakIsT0FBT0EsTUFBTUssUUFBUXRqQixNQUFSLENBQWUsQ0FBZixDQUFiLENBQVQ7O21DQUVHeGlCLElBQVAsQ0FDSTRsQyxNQURKLEVBQ1lDLE1BRFosRUFFSUwsTUFBTWpnQyxFQUFFa1QsS0FBRixFQUZWLEVBRXFCZ3RCLE1BQU1sZ0MsRUFBRWtULEtBQUYsRUFGM0I7bUNBSU9sVCxFQUFFa1QsS0FBRixFQUFQO21DQUNPbFQsRUFBRWtULEtBQUYsRUFBUDtrQ0FDTSxHQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCOzs2QkFFQyxHQUFMO21DQUNXemxDLElBQVAsQ0FBWXVGLEVBQUVrVCxLQUFGLEVBQVosRUFBdUJsVCxFQUFFa1QsS0FBRixFQUF2QjtrQ0FDTWxULEVBQUVrVCxLQUFGLEVBQU47a0NBQ01sVCxFQUFFa1QsS0FBRixFQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCOzs2QkFFQyxHQUFMO21DQUNXemxDLElBQVAsQ0FBWXdsQyxNQUFNamdDLEVBQUVrVCxLQUFGLEVBQWxCLEVBQTZCZ3RCLE1BQU1sZ0MsRUFBRWtULEtBQUYsRUFBbkM7bUNBQ09sVCxFQUFFa1QsS0FBRixFQUFQO21DQUNPbFQsRUFBRWtULEtBQUYsRUFBUDtrQ0FDTSxHQUFOO21DQUNPelksSUFBUCxDQUFZd2xDLEdBQVosRUFBaUJDLEdBQWpCOzs2QkFFQyxHQUFMO3FDQUNhRCxHQUFULEVBQWNLLFNBQVNKLEdBQXZCO3NDQUNVRixHQUFHQSxHQUFHNWxDLE1BQUgsR0FBWSxDQUFmLENBQVY7Z0NBQ0ltbUMsUUFBUUksT0FBUixLQUFvQixHQUF4QixFQUE2Qjt5Q0FDaEJWLE9BQU9BLE1BQU1NLFFBQVF0akIsTUFBUixDQUFlLENBQWYsQ0FBYixDQUFUO3lDQUNTaWpCLE9BQU9BLE1BQU1LLFFBQVF0akIsTUFBUixDQUFlLENBQWYsQ0FBYixDQUFUOztrQ0FFRWpkLEVBQUVrVCxLQUFGLEVBQU47a0NBQ01sVCxFQUFFa1QsS0FBRixFQUFOO2tDQUNNLEdBQU47bUNBQ096WSxJQUFQLENBQVk0bEMsTUFBWixFQUFvQkMsTUFBcEIsRUFBNEJMLEdBQTVCLEVBQWlDQyxHQUFqQzs7NkJBRUMsR0FBTDtxQ0FDYUQsR0FBVCxFQUFjSyxTQUFTSixHQUF2QjtzQ0FDVUYsR0FBR0EsR0FBRzVsQyxNQUFILEdBQVksQ0FBZixDQUFWO2dDQUNJbW1DLFFBQVFJLE9BQVIsS0FBb0IsR0FBeEIsRUFBNkI7eUNBQ2hCVixPQUFPQSxNQUFNTSxRQUFRdGpCLE1BQVIsQ0FBZSxDQUFmLENBQWIsQ0FBVDt5Q0FDU2lqQixPQUFPQSxNQUFNSyxRQUFRdGpCLE1BQVIsQ0FBZSxDQUFmLENBQWIsQ0FBVDs7bUNBRUdqZCxFQUFFa1QsS0FBRixFQUFQO21DQUNPbFQsRUFBRWtULEtBQUYsRUFBUDtrQ0FDTSxHQUFOO21DQUNPelksSUFBUCxDQUFZNGxDLE1BQVosRUFBb0JDLE1BQXBCLEVBQTRCTCxHQUE1QixFQUFpQ0MsR0FBakM7OzZCQUVDLEdBQUw7aUNBQ1NsZ0MsRUFBRWtULEtBQUYsRUFBTCxDQURKO2lDQUVTbFQsRUFBRWtULEtBQUYsRUFBTCxDQUZKO2tDQUdVbFQsRUFBRWtULEtBQUYsRUFBTixDQUhKO2lDQUlTbFQsRUFBRWtULEtBQUYsRUFBTCxDQUpKO2lDQUtTbFQsRUFBRWtULEtBQUYsRUFBTCxDQUxKOztpQ0FPUytzQixHQUFMLEVBQVV0YyxLQUFLdWMsR0FBZjtrQ0FDTWxnQyxFQUFFa1QsS0FBRixFQUFOLEVBQWlCZ3RCLE1BQU1sZ0MsRUFBRWtULEtBQUYsRUFBdkI7a0NBQ00sR0FBTjtxQ0FDUyxDQUFFNk0sRUFBRixFQUFPQyxFQUFQLEVBQVd3Z0IsR0FBWCxFQUFpQkMsRUFBakIsRUFBcUJDLEVBQXJCLEVBQXlCVCxHQUF6QixFQUErQkMsR0FBL0IsRUFBcUN4YyxFQUFyQyxFQUEwQ0MsRUFBMUMsQ0FBVDs7NkJBRUMsR0FBTDtpQ0FDUzNqQixFQUFFa1QsS0FBRixFQUFMO2lDQUNLbFQsRUFBRWtULEtBQUYsRUFBTDtrQ0FDTWxULEVBQUVrVCxLQUFGLEVBQU47aUNBQ0tsVCxFQUFFa1QsS0FBRixFQUFMO2lDQUNLbFQsRUFBRWtULEtBQUYsRUFBTDs7aUNBRUsrc0IsR0FBTCxFQUFVdGMsS0FBS3VjLEdBQWY7bUNBQ09sZ0MsRUFBRWtULEtBQUYsRUFBUDttQ0FDT2xULEVBQUVrVCxLQUFGLEVBQVA7a0NBQ00sR0FBTjtxQ0FDUyxDQUFFNk0sRUFBRixFQUFPQyxFQUFQLEVBQVd3Z0IsR0FBWCxFQUFpQkMsRUFBakIsRUFBcUJDLEVBQXJCLEVBQXlCVCxHQUF6QixFQUErQkMsR0FBL0IsRUFBcUN4YyxFQUFyQyxFQUEwQ0MsRUFBMUMsQ0FBVDs7Ozs7dUJBS0xscEIsSUFBSCxDQUFRO2lDQUNLMmxDLE9BQU94MUIsQ0FEWjtnQ0FFSXFTO3FCQUZaOzs7b0JBTUFyUyxNQUFNLEdBQU4sSUFBYUEsTUFBTSxHQUF2QixFQUE0Qjt1QkFDckJuUSxJQUFILENBQVE7aUNBQ0ssR0FETDtnQ0FFSTtxQkFGWjs7O21CQU1EdWxDLEVBQVA7Ozs7Ozs7c0NBS0o7O2lCQUVTdm1CLFFBQUwsQ0FBYzROLEtBQWQ7aUJBQ0tvWSxlQUFMLEdBQXVCLElBQXZCO2lCQUNLNWtDLE9BQUwsQ0FBYXMvQixTQUFiLEdBQXlCLEVBQXpCOztnQkFFSXlHLFlBQVksS0FBS0MsY0FBTCxDQUFvQixLQUFLaG1DLE9BQUwsQ0FBYXc3QixJQUFqQyxDQUFoQjs7aUJBRUssSUFBSTVKLElBQUksQ0FBUixFQUFXaHRCLEtBQUttaEMsVUFBVXhtQyxNQUEvQixFQUF1Q3F5QixJQUFJaHRCLEVBQTNDLEVBQStDZ3RCLEdBQS9DLEVBQW9EO3FCQUMzQyxJQUFJcHlCLElBQUksQ0FBUixFQUFXbVosSUFBSW90QixVQUFVblUsQ0FBVixFQUFhcnlCLE1BQWpDLEVBQXlDQyxJQUFJbVosQ0FBN0MsRUFBZ0RuWixHQUFoRCxFQUFxRDt3QkFDN0N1USxJQUFJZzJCLFVBQVVuVSxDQUFWLEVBQWFweUIsQ0FBYixFQUFnQnNtQyxPQUF4Qjt3QkFBaUMzZ0MsSUFBSTRnQyxVQUFVblUsQ0FBVixFQUFhcHlCLENBQWIsRUFBZ0I0aUIsTUFBckQ7NEJBQ1FyUyxDQUFSOzZCQUNTLEdBQUw7aUNBQ1M2TyxRQUFMLENBQWNxRixNQUFkLENBQXFCOWUsRUFBRSxDQUFGLENBQXJCLEVBQTJCQSxFQUFFLENBQUYsQ0FBM0I7OzZCQUVDLEdBQUw7aUNBQ1N5WixRQUFMLENBQWNpRixNQUFkLENBQXFCMWUsRUFBRSxDQUFGLENBQXJCLEVBQTJCQSxFQUFFLENBQUYsQ0FBM0I7OzZCQUVDLEdBQUw7aUNBQ1N5WixRQUFMLENBQWNrRixhQUFkLENBQTRCM2UsRUFBRSxDQUFGLENBQTVCLEVBQWtDQSxFQUFFLENBQUYsQ0FBbEMsRUFBd0NBLEVBQUUsQ0FBRixDQUF4QyxFQUE4Q0EsRUFBRSxDQUFGLENBQTlDLEVBQW9EQSxFQUFFLENBQUYsQ0FBcEQsRUFBMERBLEVBQUUsQ0FBRixDQUExRDs7NkJBRUMsR0FBTDtpQ0FDU3laLFFBQUwsQ0FBY3FuQixnQkFBZCxDQUErQjlnQyxFQUFFLENBQUYsQ0FBL0IsRUFBcUNBLEVBQUUsQ0FBRixDQUFyQyxFQUEyQ0EsRUFBRSxDQUFGLENBQTNDLEVBQWlEQSxFQUFFLENBQUYsQ0FBakQ7OzZCQUVDLEdBQUw7O2dDQUVROGlCLE9BQUosQ0FBYSxLQUFLckosUUFBbEIsRUFBNkJ6WixFQUFFLENBQUYsQ0FBN0IsRUFBb0NBLEVBQUUsQ0FBRixDQUFwQyxFQUEyQ0EsQ0FBM0M7OzZCQUVDLEdBQUw7aUNBQ1N5WixRQUFMLENBQWNzRSxTQUFkOzs7OzttQkFLVCxJQUFQOzs7O0VBL1UwQnNiOztBQ2pCbEM7Ozs7Ozs7Ozs7O0FBV0EsQUFDQSxBQUNBLElBRXFCMEg7OztxQkFFTDloQyxHQUFaLEVBQ0E7Ozs7O2NBQ1V4QixNQUFNMFosUUFBTixDQUFnQmxZLEdBQWhCLENBQU47WUFDSXE2QixXQUFXdmdDLElBQUVnRSxNQUFGLENBQVM7Z0JBQ2YsQ0FEZTtnQkFFZixDQUZlO1NBQVQsRUFHWGtDLElBQUlwRSxPQUhPLENBQWY7O1lBS0lBLE9BQUosR0FBY3krQixRQUFkOztZQUVJMEgsK0dBQVcvaEMsR0FBWCxVQUFKOztjQUVLb0IsSUFBTCxHQUFZLFNBQVo7Y0FDS3NDLEVBQUwsR0FBVWxGLE1BQU04WixRQUFOLENBQWUsTUFBS2xYLElBQXBCLENBQVY7O2NBRUt4RixPQUFMLENBQWF3N0IsSUFBYixHQUFvQixNQUFLNEssV0FBTCxFQUFwQjs7Ozs7OytCQUdHM2xDLE1BQU1ILE9BQU82WixVQUNwQjtnQkFDUzFaLFFBQVEsSUFBUixJQUFnQkEsUUFBUSxJQUE3QixFQUFvQztxQkFDM0JULE9BQUwsQ0FBYXc3QixJQUFiLEdBQW9CLEtBQUs0SyxXQUFMLEVBQXBCOzs7Z0JBR0EzbEMsUUFBUSxNQUFaLEVBQW9CO3FCQUNYMmpDLFdBQUw7Ozs7O3NDQUtSO2dCQUNPcGtDLFVBQVUsS0FBS0EsT0FBbkI7Z0JBQ0lxbUMsS0FBSyxTQUFPcm1DLFFBQVFzbUMsRUFBZixHQUFrQixLQUFsQixHQUF3QnRtQyxRQUFRc21DLEVBQWhDLEdBQW1DLEdBQW5DLEdBQXVDdG1DLFFBQVFzbUMsRUFBL0MsR0FBa0QsR0FBbEQsR0FBd0R0bUMsUUFBUXNtQyxFQUFSLEdBQVcsQ0FBWCxHQUFhLENBQXJFLEdBQTBFLEdBQTFFLEdBQStFLENBQUN0bUMsUUFBUXNtQyxFQUFULEdBQVksQ0FBM0YsR0FBOEYsS0FBOUYsR0FBcUcsQ0FBQ3RtQyxRQUFRdW1DLEVBQXZIO2tCQUNNLFFBQU8sQ0FBQ3ZtQyxRQUFRc21DLEVBQVQsR0FBYyxDQUFkLEdBQWlCLENBQXhCLEdBQTJCLEdBQTNCLEdBQWdDLENBQUN0bUMsUUFBUXNtQyxFQUFULEdBQWMsQ0FBOUMsR0FBaUQsR0FBakQsR0FBc0QsQ0FBQ3RtQyxRQUFRc21DLEVBQS9ELEdBQW1FLEdBQW5FLEdBQXVFdG1DLFFBQVFzbUMsRUFBL0UsR0FBa0YsS0FBbEYsR0FBeUZ0bUMsUUFBUXNtQyxFQUFqRyxHQUFxRyxHQUEzRzttQkFDT0QsRUFBUDs7OztFQXBDOEIzQjs7QUNkckM7Ozs7Ozs7Ozs7OztBQVlBLEFBQ0EsQUFDQSxJQUVxQjNhOzs7cUJBRUwzbEIsR0FBWixFQUNBOzs7Y0FDVXhCLE1BQU0wWixRQUFOLENBQWdCbFksR0FBaEIsQ0FBTjtZQUNJcTZCLFdBQVd2Z0MsSUFBRWdFLE1BQUYsQ0FBUzs7O2dCQUdmLENBSGU7Z0JBSWYsQ0FKZTtTQUFULEVBS1hrQyxJQUFJcEUsT0FMTyxDQUFmOztZQU9JQSxPQUFKLEdBQWN5K0IsUUFBZDs7cUhBRU9yNkIsR0FYWDs7Y0FhU29CLElBQUwsR0FBWSxTQUFaO2NBQ0tzQyxFQUFMLEdBQVVsRixNQUFNOFosUUFBTixDQUFlLE1BQUtsWCxJQUFwQixDQUFWOztjQUVLNCtCLFdBQUw7Ozs7OzsrQkFHRzNqQyxNQUFNSCxPQUFPNlosVUFDcEI7Z0JBQ1MxWixRQUFRLElBQVIsSUFBZ0JBLFFBQVEsSUFBN0IsRUFBb0M7cUJBQzNCMmpDLFdBQUw7Ozs7O3NDQUtSO2lCQUNTeGxCLFFBQUwsQ0FBYzROLEtBQWQ7aUJBQ0s1TixRQUFMLENBQWM0bkIsV0FBZCxDQUEwQixDQUExQixFQUE0QixDQUE1QixFQUErQixLQUFLeG1DLE9BQUwsQ0FBYXNtQyxFQUFiLEdBQWdCLENBQS9DLEVBQW1ELEtBQUt0bUMsT0FBTCxDQUFhdW1DLEVBQWIsR0FBZ0IsQ0FBbkU7Ozs7RUFoQzZCL0gsT0FrQ3BDOztBQ25ERDs7Ozs7Ozs7OztBQVVBLEFBQ0EsQUFDQSxBQUNBLElBRXFCdFU7OztxQkFFTDlsQixHQUFaLEVBQWlCNi9CLEtBQWpCLEVBQ0E7OztjQUNVcmhDLE1BQU0wWixRQUFOLENBQWVsWSxHQUFmLENBQU47WUFDSXE2QixXQUFXdmdDLElBQUVnRSxNQUFGLENBQVM7c0JBQ1YsSUFEVTtvQkFFWixLQUZZO3VCQUdULEVBSFM7MEJBSU5VLE1BQU1hO1NBSlQsRUFLWlcsSUFBSXBFLE9BTFEsQ0FBZjs7WUFPR2lrQyxVQUFVLE9BQWIsRUFBcUI7Z0JBQ2IvM0IsUUFBUXV5QixTQUFTYSxTQUFULENBQW1CLENBQW5CLENBQVo7Z0JBQ0lsekIsTUFBUXF5QixTQUFTYSxTQUFULENBQW1CMzhCLEtBQW5CLENBQTBCLENBQUUsQ0FBNUIsRUFBZ0MsQ0FBaEMsQ0FBWjtnQkFDSTg3QixTQUFTeUYsTUFBYixFQUFxQjt5QkFDUjVFLFNBQVQsQ0FBbUIxTyxPQUFuQixDQUE0QnhrQixHQUE1Qjt5QkFDU2t6QixTQUFULEdBQXFCNkUsT0FBTVAsa0JBQU4sQ0FBMEJuRixTQUFTYSxTQUFuQyxDQUFyQjs7Ozs7OztZQU9KdC9CLE9BQUosR0FBY3krQixRQUFkOztxSEFFTXI2QixHQXZCVixFQXVCZTYvQixLQXZCZjs7Y0F5QlN3QyxhQUFMLEdBQXFCLElBQXJCO2NBQ0tqaEMsSUFBTCxHQUFZLFNBQVo7Y0FDS3NDLEVBQUwsR0FBVWxGLE1BQU04WixRQUFOLENBQWUsTUFBS2xYLElBQXBCLENBQVY7O2NBRUs0K0IsV0FBTDs7Ozs7OytCQUdHM2pDLE1BQU1ILE9BQU82WixVQUNwQjs7Z0JBRVExWixRQUFRLFdBQVIsSUFBdUJBLFFBQVEsUUFBL0IsSUFBMkNBLFFBQVEsVUFBdkQsRUFBbUU7cUJBQzFEMmpDLFdBQUw7Ozs7O3NDQUtSO2lCQUNTeGxCLFFBQUwsQ0FBYzROLEtBQWQ7O2dCQUVNeHNCLFVBQVUsS0FBS0EsT0FBckI7Z0JBQ01zL0IsWUFBWXQvQixRQUFRcy9CLFNBQTFCO2dCQUNJQSxVQUFVLy9CLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7Ozs7O2lCQUtyQnFmLFFBQUwsQ0FBY2lGLE1BQWQsQ0FBcUJ5YixVQUFVLENBQVYsRUFBYSxDQUFiLENBQXJCLEVBQXNDQSxVQUFVLENBQVYsRUFBYSxDQUFiLENBQXRDO2lCQUNLLElBQUk5L0IsSUFBSSxDQUFSLEVBQVdtWixJQUFJMm1CLFVBQVUvL0IsTUFBOUIsRUFBc0NDLElBQUltWixDQUExQyxFQUE2Q25aLEdBQTdDLEVBQWtEO3FCQUN6Q29mLFFBQUwsQ0FBY3FGLE1BQWQsQ0FBcUJxYixVQUFVOS9CLENBQVYsRUFBYSxDQUFiLENBQXJCLEVBQXNDOC9CLFVBQVU5L0IsQ0FBVixFQUFhLENBQWIsQ0FBdEM7O2lCQUVDb2YsUUFBTCxDQUFjc0UsU0FBZDs7O2dCQUdJbGpCLFFBQVFxa0MsUUFBUixJQUFvQixRQUFwQixJQUFnQ3JrQyxRQUFRcWtDLFFBQVIsSUFBb0IsUUFBeEQsRUFBa0U7OztxQkFHekR6bEIsUUFBTCxDQUFjd2QsV0FBZCxDQUEwQmYsSUFBMUIsR0FBaUMsS0FBakM7O29CQUVJcjdCLFFBQVFra0MsTUFBWixFQUFvQjs7eUJBRVgsSUFBSUksS0FBSyxDQUFULEVBQVlDLEtBQUtqRixVQUFVLy9CLE1BQWhDLEVBQXdDK2tDLEtBQUtDLEVBQTdDLEVBQWlERCxJQUFqRCxFQUF1RDs0QkFDL0NBLE1BQU1DLEtBQUcsQ0FBYixFQUFnQjs7OzZCQUdYM2xCLFFBQUwsQ0FBY2lGLE1BQWQsQ0FBc0J5YixVQUFVZ0YsRUFBVixFQUFjLENBQWQsQ0FBdEIsRUFBeUNoRixVQUFVZ0YsRUFBVixFQUFjLENBQWQsQ0FBekM7NkJBQ0sxbEIsUUFBTCxDQUFjcUYsTUFBZCxDQUFzQnFiLFVBQVVnRixLQUFHLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBdEIsRUFBMkNoRixVQUFVZ0YsS0FBRyxDQUFiLEVBQWdCLENBQWhCLENBQTNDOzhCQUNJLENBQUo7O2lCQVJSLE1BVU87O3lCQUVFMWxCLFFBQUwsQ0FBY2lGLE1BQWQsQ0FBcUJ5YixVQUFVLENBQVYsRUFBYSxDQUFiLENBQXJCLEVBQXNDQSxVQUFVLENBQVYsRUFBYSxDQUFiLENBQXRDO3lCQUNLLElBQUk5L0IsSUFBSSxDQUFSLEVBQVdtWixJQUFJMm1CLFVBQVUvL0IsTUFBOUIsRUFBc0NDLElBQUltWixDQUExQyxFQUE2Q25aLEdBQTdDLEVBQWtEOzRCQUMxQ21tQixRQUFRMlosVUFBVTkvQixJQUFJLENBQWQsRUFBaUIsQ0FBakIsQ0FBWjs0QkFDSXdsQixNQUFNc2EsVUFBVTkvQixDQUFWLEVBQWEsQ0FBYixDQUFWOzRCQUNJb21CLFFBQVEwWixVQUFVOS9CLElBQUksQ0FBZCxFQUFpQixDQUFqQixDQUFaOzRCQUNJeWxCLE1BQU1xYSxVQUFVOS9CLENBQVYsRUFBYSxDQUFiLENBQVY7NkJBQ0tnbEMsWUFBTCxDQUFrQjdlLEtBQWxCLEVBQXlCQyxLQUF6QixFQUFnQ1osR0FBaEMsRUFBcUNDLEdBQXJDLEVBQTBDLENBQTFDOzs7Ozs7OztFQXBGaUJ1WixPQTZGcEM7O0FDNUdEOzs7Ozs7Ozs7Ozs7OztBQWNBLEFBQ0EsQUFDQSxBQUNBLElBRXFCa0k7OztvQkFFTHRpQyxHQUFaLEVBQ0E7OztjQUNVeEIsTUFBTTBaLFFBQU4sQ0FBZWxZLEdBQWYsQ0FBTjtZQUNJcTZCLFdBQVd2Z0MsSUFBRWdFLE1BQUYsQ0FBUzt1QkFDVCxFQURTO2VBRWpCLENBRmlCO2VBR2pCLENBSGlCO1NBQVQsRUFJWGtDLElBQUlwRSxPQUpPLENBQWY7aUJBS1NzL0IsU0FBVCxHQUFxQjZFLE9BQU1YLGlCQUFOLENBQXlCL0UsU0FBU2hvQixDQUFsQyxFQUFzQ2dvQixTQUFTLzZCLENBQS9DLENBQXJCOztZQUVJMUQsT0FBSixHQUFjeStCLFFBQWQ7O21IQUVPcjZCLEdBWFg7O2NBYVNvQixJQUFMLEdBQVksUUFBWjtjQUNLc0MsRUFBTCxHQUFVbEYsTUFBTThaLFFBQU4sQ0FBZSxNQUFLbFgsSUFBcEIsQ0FBVjs7Ozs7OytCQUdHL0UsTUFBTUgsT0FBTzZaLFVBQ3BCO2dCQUNRMVosUUFBUSxHQUFSLElBQWVBLFFBQVEsR0FBM0IsRUFBK0I7O3FCQUN0QlQsT0FBTCxDQUFhcy9CLFNBQWIsR0FBeUI2RSxPQUFNWCxpQkFBTixDQUF5Qno3QixNQUFNME8sQ0FBL0IsRUFBbUMxTyxNQUFNckUsQ0FBekMsQ0FBekI7OztnQkFHQWpELFFBQVEsV0FBUixJQUF1QkEsUUFBUSxRQUEvQixJQUEyQ0EsUUFBUSxVQUF2RCxFQUFtRTtxQkFDMUQyakMsV0FBTDtxQkFDS3hsQixRQUFMLENBQWNzRSxTQUFkOzs7OztFQTVCd0JnSCxXQStCbkM7O0FDbEREOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxBQUNBLEFBQ0EsSUFFcUJ5Yzs7O2tCQUVMdmlDLEdBQVosRUFDQTs7O2NBQ1V4QixNQUFNMFosUUFBTixDQUFlbFksR0FBZixDQUFOO1lBQ0lxNkIsV0FBV3ZnQyxJQUFFZ0UsTUFBRixDQUFTO3NCQUNWLElBRFU7bUJBRWI7bUJBQ0MsQ0FERDttQkFFQyxDQUZEO2FBRmE7aUJBTWY7bUJBQ0csQ0FESDttQkFFRyxDQUZIO2FBTmU7d0JBVVIsQ0FWUTtTQUFULEVBV1hrQyxJQUFJcEUsT0FYTyxDQUFmO1lBWUlBLE9BQUosR0FBY3krQixRQUFkOzsrR0FFT3I2QixHQWhCWDs7Y0FrQlNnZ0MsV0FBTDs7Y0FFSzUrQixJQUFMLEdBQVksTUFBWjtjQUNLc0MsRUFBTCxHQUFVbEYsTUFBTThaLFFBQU4sQ0FBZSxNQUFLbFgsSUFBcEIsQ0FBVjs7Ozs7OytCQUdHL0UsTUFBTUgsT0FBTzZaLFVBQ3BCOztnQkFFUTFaLFFBQVEsR0FBUixJQUFlQSxRQUFRLEdBQTNCLEVBQStCO3FCQUN0QjJqQyxXQUFMOzs7OztzQ0FLUjtpQkFDU3hsQixRQUFMLENBQWM0TixLQUFkO2dCQUNNeHNCLFVBQVUsS0FBS0EsT0FBckI7Z0JBQ0ksQ0FBQ0EsUUFBUXFrQyxRQUFULElBQXFCcmtDLFFBQVFxa0MsUUFBUixJQUFvQixPQUE3QyxFQUFzRDtxQkFDN0N6bEIsUUFBTCxDQUFjaUYsTUFBZCxDQUFzQjdqQixRQUFRa00sS0FBUixDQUFjbkgsQ0FBcEMsRUFBd0MvRSxRQUFRa00sS0FBUixDQUFjbEgsQ0FBdEQ7cUJBQ0s0WixRQUFMLENBQWNxRixNQUFkLENBQXNCamtCLFFBQVFvTSxHQUFSLENBQVlySCxDQUFsQyxFQUF3Qy9FLFFBQVFvTSxHQUFSLENBQVlwSCxDQUFwRDthQUZKLE1BR08sSUFBSWhGLFFBQVFxa0MsUUFBUixJQUFvQixRQUFwQixJQUFnQ3JrQyxRQUFRcWtDLFFBQVIsSUFBb0IsUUFBeEQsRUFBa0U7cUJBQ2hFRyxZQUFMLENBQ0l4a0MsUUFBUWtNLEtBQVIsQ0FBY25ILENBRGxCLEVBQ3FCL0UsUUFBUWtNLEtBQVIsQ0FBY2xILENBRG5DLEVBRUloRixRQUFRb00sR0FBUixDQUFZckgsQ0FGaEIsRUFFcUIvRSxRQUFRb00sR0FBUixDQUFZcEgsQ0FGakMsRUFHSSxLQUFLaEYsT0FBTCxDQUFhOCtCLFVBSGpCOzttQkFNRyxJQUFQOzs7O0VBakQwQk4sT0FxRGpDOztBQ3hFRDs7Ozs7Ozs7Ozs7OztBQWFBLEFBQ0EsQUFDQSxJQUVxQm9JOzs7a0JBRUx4aUMsR0FBWixFQUNBOzs7Y0FDVXhCLE1BQU0wWixRQUFOLENBQWdCbFksR0FBaEIsQ0FBTjtZQUNJcTZCLFdBQVd2Z0MsSUFBRWdFLE1BQUYsQ0FBUzttQkFDWixDQURZO29CQUVaLENBRlk7b0JBR1o7U0FIRyxFQUlYa0MsSUFBSXBFLE9BSk8sQ0FBZjtZQUtJQSxPQUFKLEdBQWN5K0IsUUFBZDs7K0dBRU9yNkIsR0FUWDs7Y0FXU29CLElBQUwsR0FBWSxNQUFaO2NBQ0tzQyxFQUFMLEdBQVVsRixNQUFNOFosUUFBTixDQUFlLE1BQUtsWCxJQUFwQixDQUFWOztjQUVLNCtCLFdBQUw7Ozs7OzsrQkFHRzNqQyxNQUFNSCxPQUFPNlosVUFDcEI7Z0JBQ1MxWixRQUFRLE9BQVIsSUFBbUJBLFFBQVEsUUFBM0IsSUFBdUNBLFFBQVEsUUFBcEQsRUFBK0Q7cUJBQ3REMmpDLFdBQUw7Ozs7Ozs7Ozs7MkNBUVI7Z0JBQ1Fwa0MsVUFBVSxLQUFLQSxPQUFuQjs7Ozs7O2dCQU1JK0UsSUFBSSxDQUFSO2dCQUNJQyxJQUFJLENBQVI7Z0JBQ0lpRCxRQUFRLEtBQUtqSSxPQUFMLENBQWFpSSxLQUF6QjtnQkFDSUMsU0FBUyxLQUFLbEksT0FBTCxDQUFha0ksTUFBMUI7O2dCQUVJeEUsSUFBSWQsTUFBTWlrQyxjQUFOLENBQXFCN21DLFFBQVFpakIsTUFBN0IsQ0FBUjtnQkFDSTZqQixJQUFJLEtBQUtsb0IsUUFBYjs7Y0FFRWlGLE1BQUYsQ0FBVXhGLFNBQVN0WixJQUFJckIsRUFBRSxDQUFGLENBQWIsQ0FBVixFQUE4QjJhLFNBQVNyWixDQUFULENBQTlCO2NBQ0VpZixNQUFGLENBQVU1RixTQUFTdFosSUFBSWtELEtBQUosR0FBWXZFLEVBQUUsQ0FBRixDQUFyQixDQUFWLEVBQXNDMmEsU0FBU3JaLENBQVQsQ0FBdEM7Y0FDRSxDQUFGLE1BQVMsQ0FBVCxJQUFjOGhDLEVBQUViLGdCQUFGLENBQ05saEMsSUFBSWtELEtBREUsRUFDS2pELENBREwsRUFDUUQsSUFBSWtELEtBRFosRUFDbUJqRCxJQUFJdEIsRUFBRSxDQUFGLENBRHZCLENBQWQ7Y0FHRXVnQixNQUFGLENBQVU1RixTQUFTdFosSUFBSWtELEtBQWIsQ0FBVixFQUErQm9XLFNBQVNyWixJQUFJa0QsTUFBSixHQUFheEUsRUFBRSxDQUFGLENBQXRCLENBQS9CO2NBQ0UsQ0FBRixNQUFTLENBQVQsSUFBY29qQyxFQUFFYixnQkFBRixDQUNObGhDLElBQUlrRCxLQURFLEVBQ0tqRCxJQUFJa0QsTUFEVCxFQUNpQm5ELElBQUlrRCxLQUFKLEdBQVl2RSxFQUFFLENBQUYsQ0FEN0IsRUFDbUNzQixJQUFJa0QsTUFEdkMsQ0FBZDtjQUdFK2IsTUFBRixDQUFVNUYsU0FBU3RaLElBQUlyQixFQUFFLENBQUYsQ0FBYixDQUFWLEVBQThCMmEsU0FBU3JaLElBQUlrRCxNQUFiLENBQTlCO2NBQ0UsQ0FBRixNQUFTLENBQVQsSUFBYzQrQixFQUFFYixnQkFBRixDQUNObGhDLENBRE0sRUFDSEMsSUFBSWtELE1BREQsRUFDU25ELENBRFQsRUFDWUMsSUFBSWtELE1BQUosR0FBYXhFLEVBQUUsQ0FBRixDQUR6QixDQUFkO2NBR0V1Z0IsTUFBRixDQUFVNUYsU0FBU3RaLENBQVQsQ0FBVixFQUF1QnNaLFNBQVNyWixJQUFJdEIsRUFBRSxDQUFGLENBQWIsQ0FBdkI7Y0FDRSxDQUFGLE1BQVMsQ0FBVCxJQUFjb2pDLEVBQUViLGdCQUFGLENBQW1CbGhDLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QkQsSUFBSXJCLEVBQUUsQ0FBRixDQUE3QixFQUFtQ3NCLENBQW5DLENBQWQ7Ozs7Ozs7Ozs7c0NBUUo7aUJBQ1M0WixRQUFMLENBQWM0TixLQUFkO2dCQUNHLENBQUMsS0FBS3hzQixPQUFMLENBQWFpakIsTUFBYixDQUFvQjFqQixNQUF4QixFQUFnQztxQkFDdkJxZixRQUFMLENBQWNtb0IsUUFBZCxDQUF1QixDQUF2QixFQUF5QixDQUF6QixFQUEyQixLQUFLL21DLE9BQUwsQ0FBYWlJLEtBQXhDLEVBQWdELEtBQUtqSSxPQUFMLENBQWFrSSxNQUE3RDthQURKLE1BRU87cUJBQ0U4K0IsZ0JBQUw7O2lCQUVDcG9CLFFBQUwsQ0FBY3NFLFNBQWQ7Ozs7O0VBM0UwQnNiOztBQ2pCbEM7Ozs7Ozs7Ozs7Ozs7OztBQWVBLEFBQ0EsQUFDQSxBQUNBLElBRXFCeUk7OztvQkFFTDdpQyxHQUFaLEVBQ0E7OztjQUNVeEIsTUFBTTBaLFFBQU4sQ0FBZ0JsWSxHQUFoQixDQUFOO1lBQ0lxNkIsV0FBV3ZnQyxJQUFFZ0UsTUFBRixDQUFTO3VCQUNQLEVBRE87Z0JBRVAsQ0FGTztlQUdQLENBSE87d0JBSVAsQ0FKTztzQkFLUCxDQUxPO3VCQU1QLEtBTk87U0FBVCxFQU9Ya0MsSUFBSXBFLE9BUE8sQ0FBZjs7WUFTSUEsT0FBSixHQUFjeStCLFFBQWQ7O21IQUVNcjZCLEdBYlY7O2NBZ0JTOGlDLFFBQUwsR0FBaUIsRUFBakI7Y0FDS0MsTUFBTCxHQUFpQixLQUFqQixDQWpCSjtjQWtCUzNoQyxJQUFMLEdBQVksUUFBWjtjQUNLc0MsRUFBTCxHQUFVbEYsTUFBTThaLFFBQU4sQ0FBZSxNQUFLbFgsSUFBcEIsQ0FBVjs7Y0FFSzQrQixXQUFMOzs7Ozs7K0JBR0czakMsTUFBTUgsT0FBTzZaLFVBQ3BCO2dCQUNTMVosUUFBUSxJQUFSLElBQWdCQSxRQUFRLEdBQXhCLElBQStCQSxRQUFRLFlBQXZDLElBQXVEQSxRQUFPLFVBQTlELElBQTRFQSxRQUFPLFdBQXhGLEVBQXNHO3FCQUM3RjJqQyxXQUFMOzs7OztzQ0FLUjtnQkFDUXBrQyxVQUFVLEtBQUtBLE9BQW5COztnQkFFSW9uQyxLQUFLLE9BQU9wbkMsUUFBUW9uQyxFQUFmLElBQXFCLFdBQXJCLEdBQW1DLENBQW5DLEdBQXVDcG5DLFFBQVFvbkMsRUFBeEQ7Z0JBQ0kxakMsSUFBSzFELFFBQVEwRCxDQUFqQixDQUpKO2dCQUtRdTVCLGFBQWFvSyxPQUFPL0QsV0FBUCxDQUFtQnRqQyxRQUFRaTlCLFVBQTNCLENBQWpCLENBTEo7Z0JBTVFDLFdBQWFtSyxPQUFPL0QsV0FBUCxDQUFtQnRqQyxRQUFRazlCLFFBQTNCLENBQWpCLENBTko7Ozs7O2dCQVdRRCxjQUFjQyxRQUFkLElBQTBCbDlCLFFBQVFpOUIsVUFBUixJQUFzQmo5QixRQUFRazlCLFFBQTVELEVBQXVFOztxQkFFOURpSyxNQUFMLEdBQWtCLElBQWxCOzZCQUNhLENBQWI7MkJBQ2EsR0FBYjs7O3lCQUdTRSxPQUFPakUsY0FBUCxDQUFzQm5HLFVBQXRCLENBQWI7dUJBQ2FvSyxPQUFPakUsY0FBUCxDQUFzQmxHLFFBQXRCLENBQWI7OztnQkFHSUEsV0FBV0QsVUFBWCxHQUF3QixLQUE1QixFQUFtQzs4QkFDakIsS0FBZDs7O2dCQUdBNkosSUFBSSxLQUFLbG9CLFFBQWI7O2NBRUVvRSxHQUFGLENBQU8sQ0FBUCxFQUFXLENBQVgsRUFBZXRmLENBQWYsRUFBa0J1NUIsVUFBbEIsRUFBOEJDLFFBQTlCLEVBQXdDLEtBQUtsOUIsT0FBTCxDQUFhc25DLFNBQXJEO2dCQUNJRixPQUFPLENBQVgsRUFBYztvQkFDTixLQUFLRCxNQUFULEVBQWlCOzs7c0JBR1h0akIsTUFBRixDQUFVdWpCLEVBQVYsRUFBZSxDQUFmO3NCQUNFcGtCLEdBQUYsQ0FBTyxDQUFQLEVBQVcsQ0FBWCxFQUFlb2tCLEVBQWYsRUFBb0JuSyxVQUFwQixFQUFpQ0MsUUFBakMsRUFBNEMsQ0FBQyxLQUFLbDlCLE9BQUwsQ0FBYXNuQyxTQUExRDtpQkFKSixNQUtPO3NCQUNEdGtCLEdBQUYsQ0FBTyxDQUFQLEVBQVcsQ0FBWCxFQUFlb2tCLEVBQWYsRUFBb0JsSyxRQUFwQixFQUErQkQsVUFBL0IsRUFBNEMsQ0FBQyxLQUFLajlCLE9BQUwsQ0FBYXNuQyxTQUExRDs7YUFQUixNQVNPOzs7a0JBR0RyakIsTUFBRixDQUFTLENBQVQsRUFBVyxDQUFYOzs7Y0FHRmYsU0FBRjs7OztzQ0FJSDtpQkFDU3FrQixLQUFMLEdBQWtCLElBQWxCLENBREo7Z0JBRVF4M0IsSUFBYyxLQUFLL1AsT0FBdkI7Z0JBQ0lpOUIsYUFBYW9LLE9BQU8vRCxXQUFQLENBQW1CdnpCLEVBQUVrdEIsVUFBckIsQ0FBakIsQ0FISjtnQkFJUUMsV0FBYW1LLE9BQU8vRCxXQUFQLENBQW1CdnpCLEVBQUVtdEIsUUFBckIsQ0FBakIsQ0FKSjs7Z0JBTVdELGFBQWFDLFFBQWIsSUFBeUIsQ0FBQ250QixFQUFFdTNCLFNBQTlCLElBQStDckssYUFBYUMsUUFBYixJQUF5Qm50QixFQUFFdTNCLFNBQS9FLEVBQTZGO3FCQUNwRkMsS0FBTCxHQUFjLEtBQWQsQ0FEeUY7OztpQkFJeEZMLFFBQUwsR0FBa0IsQ0FDZDFsQyxLQUFLMm5CLEdBQUwsQ0FBVThULFVBQVYsRUFBdUJDLFFBQXZCLENBRGMsRUFFZDE3QixLQUFLQyxHQUFMLENBQVV3N0IsVUFBVixFQUF1QkMsUUFBdkIsQ0FGYyxDQUFsQjs7OztnQ0FNSWw5QixTQUNSO2dCQUNRQSxVQUFVQSxVQUFVQSxPQUFWLEdBQW9CLEtBQUtBLE9BQXZDO2dCQUNJb25DLEtBQUssT0FBT3BuQyxRQUFRb25DLEVBQWYsSUFBcUIsV0FBckI7Y0FDSCxDQURHLEdBQ0NwbkMsUUFBUW9uQyxFQURsQjtnQkFFSTFqQyxJQUFJMUQsUUFBUTBELENBQWhCLENBSko7O2lCQU1TOGpDLFdBQUw7O2dCQUVJdkssYUFBYW9LLE9BQU8vRCxXQUFQLENBQW1CdGpDLFFBQVFpOUIsVUFBM0IsQ0FBakIsQ0FSSjtnQkFTUUMsV0FBYW1LLE9BQU8vRCxXQUFQLENBQW1CdGpDLFFBQVFrOUIsUUFBM0IsQ0FBakIsQ0FUSjs7Z0JBV1FvQyxZQUFhLEVBQWpCOztnQkFFSW1JLGNBQWE7c0JBQ04sQ0FBRSxDQUFGLEVBQU0vakMsQ0FBTixDQURNO3VCQUVOLENBQUUsQ0FBQ0EsQ0FBSCxFQUFNLENBQU4sQ0FGTTt1QkFHTixDQUFFLENBQUYsRUFBTSxDQUFDQSxDQUFQLENBSE07dUJBSU4sQ0FBRUEsQ0FBRixFQUFNLENBQU47YUFKWDs7aUJBT00sSUFBSXNNLENBQVYsSUFBZXkzQixXQUFmLEVBQTRCO29CQUNwQkMsYUFBYXJwQixTQUFTck8sQ0FBVCxJQUFjLEtBQUtrM0IsUUFBTCxDQUFjLENBQWQsQ0FBZCxJQUFrQzdvQixTQUFTck8sQ0FBVCxJQUFjLEtBQUtrM0IsUUFBTCxDQUFjLENBQWQsQ0FBakU7b0JBQ0ksS0FBS0MsTUFBTCxJQUFnQk8sY0FBYyxLQUFLSCxLQUFuQyxJQUE4QyxDQUFDRyxVQUFELElBQWUsQ0FBQyxLQUFLSCxLQUF2RSxFQUErRTs4QkFDakUzbkMsSUFBVixDQUFnQjZuQyxZQUFhejNCLENBQWIsQ0FBaEI7Ozs7Z0JBSUosQ0FBQyxLQUFLbTNCLE1BQVYsRUFBbUI7NkJBQ0ZFLE9BQU9qRSxjQUFQLENBQXVCbkcsVUFBdkIsQ0FBYjsyQkFDYW9LLE9BQU9qRSxjQUFQLENBQXVCbEcsUUFBdkIsQ0FBYjs7MEJBRVV0OUIsSUFBVixDQUFlLENBQ1B5bkMsT0FBTzkyQixHQUFQLENBQVcwc0IsVUFBWCxJQUF5Qm1LLEVBRGxCLEVBQ3VCQyxPQUFPNzJCLEdBQVAsQ0FBV3lzQixVQUFYLElBQXlCbUssRUFEaEQsQ0FBZjs7MEJBSVV4bkMsSUFBVixDQUFlLENBQ1B5bkMsT0FBTzkyQixHQUFQLENBQVcwc0IsVUFBWCxJQUF5QnY1QixDQURsQixFQUN1QjJqQyxPQUFPNzJCLEdBQVAsQ0FBV3lzQixVQUFYLElBQXlCdjVCLENBRGhELENBQWY7OzBCQUlVOUQsSUFBVixDQUFlLENBQ1B5bkMsT0FBTzkyQixHQUFQLENBQVcyc0IsUUFBWCxJQUF5Qng1QixDQURsQixFQUN3QjJqQyxPQUFPNzJCLEdBQVAsQ0FBVzBzQixRQUFYLElBQXdCeDVCLENBRGhELENBQWY7OzBCQUlVOUQsSUFBVixDQUFlLENBQ1B5bkMsT0FBTzkyQixHQUFQLENBQVcyc0IsUUFBWCxJQUF5QmtLLEVBRGxCLEVBQ3dCQyxPQUFPNzJCLEdBQVAsQ0FBVzBzQixRQUFYLElBQXdCa0ssRUFEaEQsQ0FBZjs7O29CQUtJOUgsU0FBUixHQUFvQkEsU0FBcEI7bUJBQ08sS0FBS3FJLG9CQUFMLENBQTJCM25DLE9BQTNCLENBQVA7Ozs7RUFySjJCdytCOztBQ1JwQztBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBRUEsSUFBSW9KLFNBQVM7U0FDSmpPO0NBRFQ7O0FBSUFpTyxPQUFPQyxPQUFQLEdBQWlCO21CQUNHeHJCLGFBREg7NEJBRVlzRCxzQkFGWjtXQUdKWSxLQUhJO1lBSUo0YSxNQUpJO1dBS0pxRCxLQUxJO1dBTUoxNUIsS0FOSTtVQU9KMDZCO0NBUGI7O0FBVUFvSSxPQUFPRSxNQUFQLEdBQWdCO2dCQUNDOUQsVUFERDtZQUVIbGEsUUFGRzthQUdGb2MsT0FIRTthQUlGbmMsU0FKRTtZQUtIMmMsTUFMRztVQU1MQyxJQU5LO1VBT0xqQyxJQVBLO2FBUUZ4YSxTQVJFO1VBU0wwYyxJQVRLO1lBVUhLO0NBVmI7O0FBYUFXLE9BQU9HLEtBQVAsR0FBZTtxQkFDT3o1QixlQURQO2tCQUVPWjtDQUZ0QixDQUtBOzs7OyJ9

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var _$1 = {};
var breaker = {};
var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var toString = ObjProto.toString;
var hasOwnProperty = ObjProto.hasOwnProperty;

var nativeForEach = ArrayProto.forEach;
var nativeFilter = ArrayProto.filter;
var nativeIndexOf = ArrayProto.indexOf;
var nativeIsArray = Array.isArray;
var nativeKeys = Object.keys;

_$1.values = function (obj) {
  var keys = _$1.keys(obj);
  var length = keys.length;
  var values = new Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[keys[i]];
  }
  return values;
};

_$1.keys = nativeKeys || function (obj) {
  if (obj !== Object(obj)) throw new TypeError('Invalid object');
  var keys = [];
  for (var key in obj) {
    if (_$1.has(obj, key)) keys.push(key);
  }return keys;
};

_$1.has = function (obj, key) {
  return hasOwnProperty.call(obj, key);
};

var each = _$1.each = _$1.forEach = function (obj, iterator, context) {
  if (obj == null) return;
  if (nativeForEach && obj.forEach === nativeForEach) {
    obj.forEach(iterator, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, length = obj.length; i < length; i++) {
      if (iterator.call(context, obj[i], i, obj) === breaker) return;
    }
  } else {
    var keys = _$1.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
    }
  }
};

_$1.compact = function (array) {
  return _$1.filter(array, _$1.identity);
};

_$1.filter = _$1.select = function (obj, iterator, context) {
  var results = [];
  if (obj == null) return results;
  if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
  each(obj, function (value, index, list) {
    if (iterator.call(context, value, index, list)) results.push(value);
  });
  return results;
};

each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {
  _$1['is' + name] = function (obj) {
    return toString.call(obj) == '[object ' + name + ']';
  };
});

{
  _$1.isFunction = function (obj) {
    return typeof obj === 'function';
  };
}

_$1.isFinite = function (obj) {
  return isFinite(obj) && !isNaN(parseFloat(obj));
};

_$1.isNaN = function (obj) {
  return _$1.isNumber(obj) && obj != +obj;
};

_$1.isBoolean = function (obj) {
  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
};

_$1.isNull = function (obj) {
  return obj === null;
};

_$1.isEmpty = function (obj) {
  if (obj == null) return true;
  if (_$1.isArray(obj) || _$1.isString(obj)) return obj.length === 0;
  for (var key in obj) {
    if (_$1.has(obj, key)) return false;
  }return true;
};

_$1.isElement = function (obj) {
  return !!(obj && obj.nodeType === 1);
};

_$1.isArray = nativeIsArray || function (obj) {
  return toString.call(obj) == '[object Array]';
};

_$1.isObject = function (obj) {
  return obj === Object(obj);
};

_$1.identity = function (value) {
  return value;
};

_$1.indexOf = function (array, item, isSorted) {
  if (array == null) return -1;
  var i = 0,
      length = array.length;
  if (isSorted) {
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else {
      i = _$1.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
  }
  if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
  for (; i < length; i++) {
    if (array[i] === item) return i;
  }return -1;
};

_$1.isWindow = function (obj) {
  return obj != null && obj == obj.window;
};
_$1.isPlainObject = function (obj) {
  // Because of IE, we also have to check the presence of the constructor property.
  // Make sure that DOM nodes and window objects don't pass through, as well
  if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== "object" || obj.nodeType || _$1.isWindow(obj)) {
    return false;
  }
  try {
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
      return false;
    }
  } catch (e) {
    // IE8,9 Will throw exceptions on certain host objects #9897
    return false;
  }
  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) {}

  return key === undefined || hasOwn.call(obj, key);
};

/**
*
*如果是深度extend，第一个参数就设置为true
*/
_$1.extend = function () {
  var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== "object" && !_$1.isFunction(target)) {
    target = {};
  }
  if (length === i) {
    target = this;
    --i;
  }
  for (; i < length; i++) {
    if ((options = arguments[i]) != null) {
      for (name in options) {
        src = target[name];
        copy = options[name];
        if (target === copy) {
          continue;
        }
        if (deep && copy && (_$1.isPlainObject(copy) || (copyIsArray = _$1.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && _$1.isArray(src) ? src : [];
          } else {
            clone = src && _$1.isPlainObject(src) ? src : {};
          }
          target[name] = _$1.extend(deep, clone, copy);
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }
  return target;
};
_$1.clone = function (obj) {
  if (!_$1.isObject(obj)) return obj;
  return _$1.isArray(obj) ? obj.slice() : _$1.extend(true, {}, obj);
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com 
*/
var Utils = {
    mainFrameRate: 60, //默认主帧率
    now: 0,
    /*像素检测专用*/
    _pixelCtx: null,
    __emptyFunc: function __emptyFunc() {},
    //retina 屏幕优化
    _devicePixelRatio: window.devicePixelRatio || 1,
    _UID: 0, //该值为向上的自增长整数值
    getUID: function getUID() {
        return this._UID++;
    },
    createId: function createId(name) {
        if (!name) {}
        //if end with a digit, then append an undersBase before appending
        var charCode = name.charCodeAt(name.length - 1);
        if (charCode >= 48 && charCode <= 57) name += "_";
        return name + Utils.getUID();
    },
    canvasSupport: function canvasSupport() {
        return !!document.createElement('canvas').getContext;
    },
    createObject: function createObject(proto, constructor) {
        var newProto;
        var ObjectCreate = Object.create;
        if (ObjectCreate) {
            newProto = ObjectCreate(proto);
        } else {
            Utils.__emptyFunc.prototype = proto;
            newProto = new Utils.__emptyFunc();
        }
        newProto.constructor = constructor;
        return newProto;
    },
    creatClass: function creatClass(r, s, px) {
        if (!s || !r) {
            return r;
        }
        var sp = s.prototype,
            rp;
        // add prototype chain
        rp = Utils.createObject(sp, r);
        r.prototype = _$1.extend(rp, r.prototype);
        r.superclass = Utils.createObject(sp, s);
        // add prototype overrides
        if (px) {
            _$1.extend(rp, px);
        }
        return r;
    },
    initElement: function initElement(canvas) {
        if (window.FlashCanvas && FlashCanvas.initElement) {
            FlashCanvas.initElement(canvas);
        }
    },
    //做一次简单的opt参数校验，保证在用户不传opt的时候 或者传了opt但是里面没有context的时候报错
    checkOpt: function checkOpt(opt) {
        if (!opt) {
            return {
                context: {}
            };
        } else if (opt && !opt.context) {
            opt.context = {};
            return opt;
        } else {
            return opt;
        }
    },

    /**
     * 按照css的顺序，返回一个[上,右,下,左]
     */
    getCssOrderArr: function getCssOrderArr(r) {
        var r1;
        var r2;
        var r3;
        var r4;

        if (typeof r === 'number') {
            r1 = r2 = r3 = r4 = r;
        } else if (r instanceof Array) {
            if (r.length === 1) {
                r1 = r2 = r3 = r4 = r[0];
            } else if (r.length === 2) {
                r1 = r3 = r[0];
                r2 = r4 = r[1];
            } else if (r.length === 3) {
                r1 = r[0];
                r2 = r4 = r[1];
                r3 = r[2];
            } else {
                r1 = r[0];
                r2 = r[1];
                r3 = r[2];
                r4 = r[3];
            }
        } else {
            r1 = r2 = r3 = r4 = 0;
        }
        return [r1, r2, r3, r4];
    },

    isWebGLSupported: function isWebGLSupported() {
        var contextOptions = { stencil: true };
        try {
            if (!window.WebGLRenderingContext) //不存在直接return
                {
                    return false;
                }
            var canvas = document.createElement('canvas'),
                gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
            return !!(gl && gl.getContextAttributes().stencil); //还要确实检测是否支持webGL模式
        } catch (e) {
            return false;
        }
    }
};

/**
 * Point
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 */
var Point = function () {
    function Point() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        classCallCheck(this, Point);

        if (arguments.length == 1 && _typeof(arguments[0]) == 'object') {
            var arg = arguments[0];
            if ("x" in arg && "y" in arg) {
                this.x = arg.x * 1;
                this.y = arg.y * 1;
            } else {
                var i = 0;
                for (var p in arg) {
                    if (i == 0) {
                        this.x = arg[p] * 1;
                    } else {
                        this.y = arg[p] * 1;
                        break;
                    }
                    i++;
                }
            }
        } else {
            this.x = x * 1;
            this.y = y * 1;
        }
    }

    createClass(Point, [{
        key: "toArray",
        value: function toArray$$1() {
            return [this.x, this.y];
        }
    }]);
    return Point;
}();

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * canvas 上委托的事件管理
 */
var CanvaxEvent = function CanvaxEvent(evt, params) {

    var eventType = "CanvaxEvent";
    if (_$1.isString(evt)) {
        eventType = evt;
    }
    if (_$1.isObject(evt) && evt.type) {
        eventType = evt.type;
    }

    this.target = null;
    this.currentTarget = null;
    this.type = eventType;
    this.point = null;

    this._stopPropagation = false; //默认不阻止事件冒泡
};
CanvaxEvent.prototype = {
    stopPropagation: function stopPropagation() {
        this._stopPropagation = true;
    }
};

var settings = {
  //设备分辨率
  RESOLUTION: window.devicePixelRatio || 1,

  /**
   * Target frames per millisecond.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 0.06
   */
  TARGET_FPMS: 0.06,

  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   *
   * @static
   * @memberof PIXI.settings
   * @type {boolean}
   * @default true
   */
  MIPMAP_TEXTURES: true,

  /**
   * Default filter resolution.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,

  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000

  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,

  /**
   * The prefix that denotes a URL is for a retina asset.
   *
   * @static
   * @memberof PIXI.settings
   * @type {RegExp|string}
   * @example `@2x`
   * @default /@(.+)x/
   */
  RETINA_PREFIX: /@(.+)x/,

  /**
   * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
   * or {@link PIXI.CanvasRenderer}.
   *
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {object}
   * @property {HTMLCanvasElement} view=null
   * @property {number} resolution=1
   * @property {boolean} antialias=false
   * @property {boolean} forceFXAA=false
   * @property {boolean} autoResize=false
   * @property {boolean} transparent=false
   * @property {number} backgroundColor=0x000000
   * @property {boolean} clearBeforeRender=true
   * @property {boolean} preserveDrawingBuffer=false
   * @property {boolean} roundPixels=false
   */
  RENDER_OPTIONS: {
    view: null,
    antialias: true,
    forceFXAA: false,
    autoResize: false,
    transparent: true,
    backgroundColor: 0x000000,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    roundPixels: false
  },

  /**
   * Default transform type.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.TRANSFORM_MODE}
   * @default PIXI.TRANSFORM_MODE.STATIC
   */
  TRANSFORM_MODE: 0,

  /**
   * Default Garbage Collection mode.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: 0,

  /**
   * Default Garbage Collection max idle.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,

  /**
   * Default Garbage Collection maximum check count.
   *
   * @static
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,

  /**
   * Default wrap modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: 0,

  /**
   * The scale modes that are supported by pixi.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: 0,

  /**
   * Default specify float precision in shaders.
   *
   * @static
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION: 'mediump'

};

var addOrRmoveEventHand = function addOrRmoveEventHand(domHand, ieHand) {
    if (document[domHand]) {
        var _ret = function () {
            var eventDomFn = function eventDomFn(el, type, fn) {
                if (el.length) {
                    for (var i = 0; i < el.length; i++) {
                        eventDomFn(el[i], type, fn);
                    }
                } else {
                    el[domHand](type, fn, false);
                }
            };

            
            return {
                v: eventDomFn
            };
        }();

        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
    } else {
        var _ret2 = function () {
            var eventFn = function eventFn(el, type, fn) {
                if (el.length) {
                    for (var i = 0; i < el.length; i++) {
                        eventFn(el[i], type, fn);
                    }
                } else {
                    el[ieHand]("on" + type, function () {
                        return fn.call(el, window.event);
                    });
                }
            };

            
            return {
                v: eventFn
            };
        }();

        if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
    }
};

var $ = {
    // dom操作相关代码
    query: function query(el) {
        if (_$1.isString(el)) {
            return document.getElementById(el);
        }
        if (el.nodeType == 1) {
            //则为一个element本身
            return el;
        }
        if (el.length) {
            return el[0];
        }
        return null;
    },
    offset: function offset(el) {
        var box = el.getBoundingClientRect(),
            doc = el.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,


        // for ie  
        clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,


        // In Internet Explorer 7 getBoundingClientRect property is treated as physical, 
        // while others are logical. Make all logical, like in IE8. 
        zoom = 1;
        if (body.getBoundingClientRect) {
            var bound = body.getBoundingClientRect();
            zoom = (bound.right - bound.left) / body.clientWidth;
        }
        if (zoom > 1) {
            clientTop = 0;
            clientLeft = 0;
        }
        var top = box.top / zoom + (window.pageYOffset || docElem && docElem.scrollTop / zoom || body.scrollTop / zoom) - clientTop,
            left = box.left / zoom + (window.pageXOffset || docElem && docElem.scrollLeft / zoom || body.scrollLeft / zoom) - clientLeft;

        return {
            top: top,
            left: left
        };
    },
    addEvent: addOrRmoveEventHand("addEventListener", "attachEvent"),
    removeEvent: addOrRmoveEventHand("removeEventListener", "detachEvent"),
    pageX: function pageX(e) {
        if (e.pageX) return e.pageX;else if (e.clientX) return e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);else return null;
    },
    pageY: function pageY(e) {
        if (e.pageY) return e.pageY;else if (e.clientY) return e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);else return null;
    },
    /**
     * 创建dom
     * @param {string} id dom id 待用
     * @param {string} type : dom type， such as canvas, div etc.
     */
    createCanvas: function createCanvas(_width, _height, id) {
        var canvas = document.createElement("canvas");
        canvas.style.position = 'absolute';
        canvas.style.width = _width + 'px';
        canvas.style.height = _height + 'px';
        canvas.style.left = 0;
        canvas.style.top = 0;
        canvas.setAttribute('width', _width * settings.RESOLUTION);
        canvas.setAttribute('height', _height * settings.RESOLUTION);
        canvas.setAttribute('id', id);
        return canvas;
    },
    createView: function createView(_width, _height, id) {
        var view = document.createElement("div");
        view.className = "canvax-view";
        view.style.cssText += "position:relative;width:" + _width + "px;height:" + _height + "px;";

        var stage_c = document.createElement("div");
        view.style.cssText += "position:absolute;width:" + _width + "px;height:" + _height + "px;";

        //用来存放一些dom元素
        var dom_c = document.createElement("div");
        view.style.cssText += "position:absolute;width:" + _width + "px;height:" + _height + "px;";

        view.appendChild(stage_c);
        view.appendChild(dom_c);

        return {
            view: view,
            stage_c: stage_c,
            dom_c: dom_c
        };
    }
    //dom相关代码结束
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 */
var _mouseEventTypes = ["click", "dblclick", "mousedown", "mousemove", "mouseup", "mouseout"];
var _hammerEventTypes = ["pan", "panstart", "panmove", "panend", "pancancel", "panleft", "panright", "panup", "pandown", "press", "pressup", "swipe", "swipeleft", "swiperight", "swipeup", "swipedown", "tap"];

var EventHandler = function EventHandler(canvax, opt) {
    this.canvax = canvax;

    this.curPoints = [new Point(0, 0)]; //X,Y 的 point 集合, 在touch下面则为 touch的集合，只是这个touch被添加了对应的x，y
    //当前激活的点对应的obj，在touch下可以是个数组,和上面的 curPoints 对应
    this.curPointsTarget = [];

    this._touching = false;
    //正在拖动，前提是_touching=true
    this._draging = false;

    //当前的鼠标状态
    this._cursor = "default";

    this.target = this.canvax.view;
    this.types = [];

    //mouse体统中不需要配置drag,touch中会用到第三方的touch库，每个库的事件名称可能不一样，
    //就要这里配置，默认实现的是hammerjs的,所以默认可以在项目里引入hammerjs http://hammerjs.github.io/
    this.drag = {
        start: "panstart",
        move: "panmove",
        end: "panend"
    };

    _$1.extend(true, this, opt);
};

//这样的好处是document.compareDocumentPosition只会在定义的时候执行一次。
var contains = document.compareDocumentPosition ? function (parent, child) {
    if (!child) {
        return false;
    }
    return !!(parent.compareDocumentPosition(child) & 16);
} : function (parent, child) {
    if (!child) {
        return false;
    }
    return child !== child && (parent.contains ? parent.contains(child) : true);
};

EventHandler.prototype = {
    init: function init() {

        //依次添加上浏览器的自带事件侦听
        var me = this;
        if (me.target.nodeType == undefined) {
            //如果target.nodeType没有的话， 说明该target为一个jQuery对象 or kissy 对象or hammer对象
            //即为第三方库，那么就要对接第三方库的事件系统。默认实现hammer的大部分事件系统
            if (!me.types || me.types.length == 0) {
                me.types = _hammerEventTypes;
            }
        } else if (me.target.nodeType == 1) {
            me.types = _mouseEventTypes;
        }

        _$1.each(me.types, function (type) {
            //不再关心浏览器环境是否 'ontouchstart' in window 
            //而是直接只管传给事件模块的是一个原生dom还是 jq对象 or hammer对象等
            if (me.target.nodeType == 1) {
                $.addEvent(me.target, type, function (e) {
                    me.__mouseHandler(e);
                });
            } else {
                me.target.on(type, function (e) {
                    me.__libHandler(e);
                });
            }
        });
    },
    /*
    * 原生事件系统------------------------------------------------begin
    * 鼠标事件处理函数
    **/
    __mouseHandler: function __mouseHandler(e) {
        var me = this;
        var root = me.canvax;

        root.updateViewOffset();

        me.curPoints = [new Point($.pageX(e) - root.viewOffset.left, $.pageY(e) - root.viewOffset.top)];

        //理论上来说，这里拿到point了后，就要计算这个point对应的target来push到curPointsTarget里，
        //但是因为在drag的时候其实是可以不用计算对应target的。
        //所以放在了下面的me.__getcurPointsTarget( e , curMousePoint );常规mousemove中执行

        var curMousePoint = me.curPoints[0];
        var curMouseTarget = me.curPointsTarget[0];

        //模拟drag,mouseover,mouseout 部分代码 begin-------------------------------------------------

        //mousedown的时候 如果 curMouseTarget.dragEnabled 为true。就要开始准备drag了
        if (e.type == "mousedown") {
            //如果curTarget 的数组为空或者第一个为false ，，，
            if (!curMouseTarget) {
                var obj = root.getObjectsUnderPoint(curMousePoint, 1)[0];
                if (obj) {
                    me.curPointsTarget = [obj];
                }
            }
            curMouseTarget = me.curPointsTarget[0];
            if (curMouseTarget && curMouseTarget.dragEnabled) {
                //鼠标事件已经摸到了一个
                me._touching = true;
            }
        }

        if (e.type == "mouseup" || e.type == "mouseout" && !contains(root.view, e.toElement || e.relatedTarget)) {
            if (me._draging == true) {
                //说明刚刚在拖动
                me._dragEnd(e, curMouseTarget, 0);
                curMouseTarget.fire("dragend");
            }
            me._draging = false;
            me._touching = false;
        }

        if (e.type == "mouseout") {
            if (!contains(root.view, e.toElement || e.relatedTarget)) {
                me.__getcurPointsTarget(e, curMousePoint);
            }
        } else if (e.type == "mousemove") {
            //|| e.type == "mousedown" ){
            //拖动过程中就不在做其他的mouseover检测，drag优先
            if (me._touching && e.type == "mousemove" && curMouseTarget) {
                //说明正在拖动啊
                if (!me._draging) {
                    //begin drag
                    curMouseTarget.fire("dragstart");
                    //先把本尊给隐藏了
                    curMouseTarget.context.globalAlpha = 0;
                    //然后克隆一个副本到activeStage

                    var cloneObject = me._clone2hoverStage(curMouseTarget, 0);
                    cloneObject.context.globalAlpha = curMouseTarget._globalAlpha;
                } else {
                    //drag move ing
                    me._dragMoveHander(e, curMouseTarget, 0);
                }
                me._draging = true;
            } else {
                //常规mousemove检测
                //move事件中，需要不停的搜索target，这个开销挺大，
                //后续可以优化，加上和帧率相当的延迟处理
                me.__getcurPointsTarget(e, curMousePoint);
            }
        } else {
            //其他的事件就直接在target上面派发事件
            var child = curMouseTarget;
            if (!child) {
                child = root;
            }
            me.__dispatchEventInChilds(e, [child]);
            me._cursorHander(child);
        }

        if (root.preventDefault) {
            //阻止默认浏览器动作(W3C) 
            if (e && e.preventDefault) {
                e.preventDefault();
            } else {
                window.event.returnValue = false;
            }
        }
    },
    __getcurPointsTarget: function __getcurPointsTarget(e, point) {
        var me = this;
        var root = me.canvax;
        var oldObj = me.curPointsTarget[0];

        if (oldObj && !oldObj.context) {
            oldObj = null;
        }

        var e = new CanvaxEvent(e);

        if (e.type == "mousemove" && oldObj && oldObj._hoverClass && oldObj.pointChkPriority && oldObj.getChildInPoint(point)) {
            //小优化,鼠标move的时候。计算频率太大，所以。做此优化
            //如果有target存在，而且当前元素正在hoverStage中，而且当前鼠标还在target内,就没必要取检测整个displayList了
            //开发派发常规mousemove事件
            e.target = e.currentTarget = oldObj;
            e.point = oldObj.globalToLocal(point);
            oldObj.dispatchEvent(e);
            return;
        }
        var obj = root.getObjectsUnderPoint(point, 1)[0];

        if (oldObj && oldObj != obj || e.type == "mouseout") {
            if (oldObj && oldObj.context) {
                me.curPointsTarget[0] = null;
                e.type = "mouseout";
                e.toTarget = obj;
                e.target = e.currentTarget = oldObj;
                e.point = oldObj.globalToLocal(point);
                oldObj.dispatchEvent(e);
            }
        }

        if (obj && oldObj != obj) {
            //&& obj._hoverable 已经 干掉了
            me.curPointsTarget[0] = obj;
            e.type = "mouseover";
            e.fromTarget = oldObj;
            e.target = e.currentTarget = obj;
            e.point = obj.globalToLocal(point);
            obj.dispatchEvent(e);
        }

        if (e.type == "mousemove" && obj) {
            e.target = e.currentTarget = oldObj;
            e.point = oldObj.globalToLocal(point);
            oldObj.dispatchEvent(e);
        }
        me._cursorHander(obj, oldObj);
    },
    _cursorHander: function _cursorHander(obj, oldObj) {
        if (!obj && !oldObj) {
            this._setCursor("default");
        }
        if (obj && oldObj != obj && obj.context) {
            this._setCursor(obj.context.cursor);
        }
    },
    _setCursor: function _setCursor(cursor) {
        if (this._cursor == cursor) {
            //如果两次要设置的鼠标状态是一样的
            return;
        }
        this.canvax.view.style.cursor = cursor;
        this._cursor = cursor;
    },
    /*
    * 原生事件系统------------------------------------------------end
    */

    /*
     *第三方库的事件系统------------------------------------------------begin
     *触屏事件处理函数
     * */
    __libHandler: function __libHandler(e) {
        var me = this;
        var root = me.canvax;
        root.updateViewOffset();
        // touch 下的 curPointsTarget 从touches中来
        //获取canvax坐标系统里面的坐标
        me.curPoints = me.__getCanvaxPointInTouchs(e);
        if (!me._draging) {
            //如果在draging的话，target已经是选中了的，可以不用 检测了
            me.curPointsTarget = me.__getChildInTouchs(me.curPoints);
        }
        if (me.curPointsTarget.length > 0) {
            //drag开始
            if (e.type == me.drag.start) {
                //dragstart的时候touch已经准备好了target， curPointsTarget 里面只要有一个是有效的
                //就认为drags开始
                _$1.each(me.curPointsTarget, function (child, i) {
                    if (child && child.dragEnabled) {
                        //只要有一个元素就认为正在准备drag了
                        me._draging = true;
                        //然后克隆一个副本到activeStage
                        me._clone2hoverStage(child, i);
                        //先把本尊给隐藏了
                        child.context.globalAlpha = 0;

                        child.fire("dragstart");

                        return false;
                    }
                });
            }

            //dragIng
            if (e.type == me.drag.move) {
                if (me._draging) {
                    _$1.each(me.curPointsTarget, function (child, i) {
                        if (child && child.dragEnabled) {
                            me._dragMoveHander(e, child, i);
                        }
                    });
                }
            }

            //drag结束
            if (e.type == me.drag.end) {
                if (me._draging) {
                    _$1.each(me.curPointsTarget, function (child, i) {
                        if (child && child.dragEnabled) {
                            me._dragEnd(e, child, 0);
                            child.fire("dragend");
                        }
                    });
                    me._draging = false;
                }
            }
            me.__dispatchEventInChilds(e, me.curPointsTarget);
        } else {
            //如果当前没有一个target，就把事件派发到canvax上面
            me.__dispatchEventInChilds(e, [root]);
        }
    },
    //从touchs中获取到对应touch , 在上面添加上canvax坐标系统的x，y
    __getCanvaxPointInTouchs: function __getCanvaxPointInTouchs(e) {
        var me = this;
        var root = me.canvax;
        var curTouchs = [];
        _$1.each(e.point, function (touch) {
            curTouchs.push({
                x: CanvaxEvent.pageX(touch) - root.viewOffset.left,
                y: CanvaxEvent.pageY(touch) - root.viewOffset.top
            });
        });
        return curTouchs;
    },
    __getChildInTouchs: function __getChildInTouchs(touchs) {
        var me = this;
        var root = me.canvax;
        var touchesTarget = [];
        _$1.each(touchs, function (touch) {
            touchesTarget.push(root.getObjectsUnderPoint(touch, 1)[0]);
        });
        return touchesTarget;
    },
    /*
    *第三方库的事件系统------------------------------------------------begin
    */

    /*
     *@param {array} childs 
     * */
    __dispatchEventInChilds: function __dispatchEventInChilds(e, childs) {
        if (!childs && !("length" in childs)) {
            return false;
        }
        var me = this;
        var hasChild = false;
        _$1.each(childs, function (child, i) {
            if (child) {
                hasChild = true;
                var ce = new CanvaxEvent(e);
                ce.target = ce.currentTarget = child || this;
                ce.stagePoint = me.curPoints[i];
                ce.point = ce.target.globalToLocal(ce.stagePoint);
                child.dispatchEvent(ce);
            }
        });
        return hasChild;
    },
    //克隆一个元素到hover stage中去
    _clone2hoverStage: function _clone2hoverStage(target, i) {
        var me = this;
        var root = me.canvax;
        var _dragDuplicate = root._bufferStage.getChildById(target.id);
        if (!_dragDuplicate) {
            _dragDuplicate = target.clone(true);
            _dragDuplicate._transform = target.getConcatenatedMatrix();

            /**
             *TODO: 因为后续可能会有手动添加的 元素到_bufferStage 里面来
             *比如tips
             *这类手动添加进来的肯定是因为需要显示在最外层的。在hover元素之上。
             *所有自动添加的hover元素都默认添加在_bufferStage的最底层
             **/
            root._bufferStage.addChildAt(_dragDuplicate, 0);
        }
        _dragDuplicate.context.globalAlpha = target._globalAlpha;
        target._dragPoint = target.globalToLocal(me.curPoints[i]);
        return _dragDuplicate;
    },
    //drag 中 的处理函数
    _dragMoveHander: function _dragMoveHander(e, target, i) {
        var me = this;
        var root = me.canvax;
        var _point = target.globalToLocal(me.curPoints[i]);

        //要对应的修改本尊的位置，但是要告诉引擎不要watch这个时候的变化
        target._notWatch = true;
        var _moveStage = target.moveing;
        target.moveing = true;
        target.context.x += _point.x - target._dragPoint.x;
        target.context.y += _point.y - target._dragPoint.y;
        target.fire("dragmove");
        target.moveing = _moveStage;
        target._notWatch = false;
        //同步完毕本尊的位置

        //这里只能直接修改_transform 。 不能用下面的修改x，y的方式。
        var _dragDuplicate = root._bufferStage.getChildById(target.id);
        _dragDuplicate._transform = target.getConcatenatedMatrix();
        //以为直接修改的_transform不会出发心跳上报， 渲染引擎不制动这个stage需要绘制。
        //所以要手动出发心跳包
        _dragDuplicate.heartBeat();
    },
    //drag结束的处理函数
    _dragEnd: function _dragEnd(e, target, i) {
        var me = this;
        var root = me.canvax;

        //_dragDuplicate 复制在_bufferStage 中的副本
        var _dragDuplicate = root._bufferStage.getChildById(target.id);
        _dragDuplicate.destroy();

        target.context.globalAlpha = target._globalAlpha;
    }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 事件管理类
 */
/**
 * 构造函数.
 * @name EventDispatcher
 * @class EventDispatcher类是可调度事件的类的基类，它允许显示列表上的任何对象都是一个事件目标。
 */
var EventManager = function EventManager() {
    //事件映射表，格式为：{type1:[listener1, listener2], type2:[listener3, listener4]}
    this._eventMap = {};
};

EventManager.prototype = {
    /*
     * 注册事件侦听器对象，以使侦听器能够接收事件通知。
     */
    _addEventListener: function _addEventListener(type, listener) {

        if (typeof listener != "function") {
            //listener必须是个function呐亲
            return false;
        }
        var addResult = true;
        var self = this;
        _$1.each(type.split(" "), function (type) {
            var map = self._eventMap[type];
            if (!map) {
                map = self._eventMap[type] = [];
                map.push(listener);
                self._eventEnabled = true;
                return true;
            }

            if (_$1.indexOf(map, listener) == -1) {
                map.push(listener);
                self._eventEnabled = true;
                return true;
            }

            addResult = false;
        });
        return addResult;
    },
    /**
     * 删除事件侦听器。
     */
    _removeEventListener: function _removeEventListener(type, listener) {
        if (arguments.length == 1) return this.removeEventListenerByType(type);

        var map = this._eventMap[type];
        if (!map) {
            return false;
        }

        for (var i = 0; i < map.length; i++) {
            var li = map[i];
            if (li === listener) {
                map.splice(i, 1);
                if (map.length == 0) {
                    delete this._eventMap[type];
                    //如果这个如果这个时候child没有任何事件侦听
                    if (_$1.isEmpty(this._eventMap)) {
                        //那么该元素不再接受事件的检测
                        this._eventEnabled = false;
                    }
                }
                return true;
            }
        }

        return false;
    },
    /**
     * 删除指定类型的所有事件侦听器。
     */
    _removeEventListenerByType: function _removeEventListenerByType(type) {
        var map = this._eventMap[type];
        if (!map) {
            delete this._eventMap[type];

            //如果这个如果这个时候child没有任何事件侦听
            if (_$1.isEmpty(this._eventMap)) {
                //那么该元素不再接受事件的检测
                this._eventEnabled = false;
            }

            return true;
        }
        return false;
    },
    /**
     * 删除所有事件侦听器。
     */
    _removeAllEventListeners: function _removeAllEventListeners() {
        this._eventMap = {};
        this._eventEnabled = false;
    },
    /**
    * 派发事件，调用事件侦听器。
    */
    _dispatchEvent: function _dispatchEvent(e) {
        var map = this._eventMap[e.type];

        if (map) {
            if (!e.target) e.target = this;
            map = map.slice();

            for (var i = 0; i < map.length; i++) {
                var listener = map[i];
                if (typeof listener == "function") {
                    listener.call(this, e);
                }
            }
        }

        if (!e._stopPropagation) {
            //向上冒泡
            if (this.parent) {
                e.currentTarget = this.parent;
                this.parent._dispatchEvent(e);
            }
        }
        return true;
    },
    /**
       * 检查是否为指定事件类型注册了任何侦听器。
       */
    _hasEventListener: function _hasEventListener(type) {
        var map = this._eventMap[type];
        return map != null && map.length > 0;
    }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 事件派发类
 */
var EventDispatcher = function EventDispatcher() {
    EventDispatcher.superclass.constructor.call(this, name);
};

Utils.creatClass(EventDispatcher, EventManager, {
    on: function on(type, listener) {
        this._addEventListener(type, listener);
        return this;
    },
    addEventListener: function addEventListener(type, listener) {
        this._addEventListener(type, listener);
        return this;
    },
    un: function un(type, listener) {
        this._removeEventListener(type, listener);
        return this;
    },
    removeEventListener: function removeEventListener(type, listener) {
        this._removeEventListener(type, listener);
        return this;
    },
    removeEventListenerByType: function removeEventListenerByType(type) {
        this._removeEventListenerByType(type);
        return this;
    },
    removeAllEventListeners: function removeAllEventListeners() {
        this._removeAllEventListeners();
        return this;
    },

    //params 要传给evt的eventhandler处理函数的参数，会被merge到Canvax event中
    fire: function fire(eventType, params) {
        var e = new CanvaxEvent(eventType);

        if (params) {
            for (var p in params) {
                if (p in e) {
                    //params中的数据不能覆盖event属性
                    console.log(p + "属性不能覆盖CanvaxEvent属性");
                } else {
                    e[p] = params[p];
                }
            }
        }

        var me = this;
        _$1.each(eventType.split(" "), function (eType) {
            e.currentTarget = me;
            me.dispatchEvent(e);
        });
        return this;
    },
    dispatchEvent: function dispatchEvent(event) {
        //this instanceof DisplayObjectContainer ==> this.children
        //TODO: 这里import DisplayObjectContainer 的话，在displayObject里面的import EventDispatcher from "../event/EventDispatcher";
        //会得到一个undefined，感觉是成了一个循环依赖的问题，所以这里换用简单的判断来判断自己是一个容易，拥有children
        if (this.children && event.point) {
            var target = this.getObjectsUnderPoint(event.point, 1)[0];
            if (target) {
                target.dispatchEvent(event);
            }
            return;
        }

        if (this.context && event.type == "mouseover") {
            //记录dispatchEvent之前的心跳
            var preHeartBeat = this._heartBeatNum;
            var pregAlpha = this.context.globalAlpha;
            this._dispatchEvent(event);
            if (preHeartBeat != this._heartBeatNum) {
                this._hoverClass = true;
                if (this.hoverClone) {
                    var canvax = this.getStage().parent;
                    //然后clone一份obj，添加到_bufferStage 中
                    var activShape = this.clone(true);
                    activShape._transform = this.getConcatenatedMatrix();
                    canvax._bufferStage.addChildAt(activShape, 0);
                    //然后把自己隐藏了
                    this._globalAlpha = pregAlpha;
                    this.context.globalAlpha = 0;
                }
            }
            return;
        }

        this._dispatchEvent(event);

        if (this.context && event.type == "mouseout") {
            if (this._hoverClass) {
                //说明刚刚over的时候有添加样式
                var canvax = this.getStage().parent;
                this._hoverClass = false;

                canvax._bufferStage.removeChildById(this.id);

                if (this._globalAlpha) {
                    this.context.globalAlpha = this._globalAlpha;
                    delete this._globalAlpha;
                }
            }
        }

        return this;
    },
    hasEvent: function hasEvent(type) {
        return this._hasEventListener(type);
    },
    hasEventListener: function hasEventListener(type) {
        return this._hasEventListener(type);
    },
    hover: function hover(overFun, outFun) {
        this.on("mouseover", overFun);
        this.on("mouseout", outFun);
        return this;
    },
    once: function once(type, listener) {
        var me = this;
        var onceHandle = function onceHandle() {
            listener.apply(me, arguments);
            this.un(type, onceHandle);
        };
        this.on(type, onceHandle);
        return this;
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * | a | c | tx|
 * | b | d | ty|
 * | 0 | 0 | 1 |
 *
 * @class
 * @memberof PIXI
 *
 *
 * Matrix 矩阵库 用于整个系统的几何变换计算
 */

var Matrix = function Matrix(a, b, c, d, tx, ty) {
    this.a = a != undefined ? a : 1;
    this.b = b != undefined ? b : 0;
    this.c = c != undefined ? c : 0;
    this.d = d != undefined ? d : 1;
    this.tx = tx != undefined ? tx : 0;
    this.ty = ty != undefined ? ty : 0;
    this.array = null;
};

Matrix.prototype = {
    concat: function concat(mtx) {
        var a = this.a;
        var c = this.c;
        var tx = this.tx;

        this.a = a * mtx.a + this.b * mtx.c;
        this.b = a * mtx.b + this.b * mtx.d;
        this.c = c * mtx.a + this.d * mtx.c;
        this.d = c * mtx.b + this.d * mtx.d;
        this.tx = tx * mtx.a + this.ty * mtx.c + mtx.tx;
        this.ty = tx * mtx.b + this.ty * mtx.d + mtx.ty;
        return this;
    },
    concatTransform: function concatTransform(x, y, scaleX, scaleY, rotation) {
        var cos = 1;
        var sin = 0;
        if (rotation % 360) {
            var r = rotation * Math.PI / 180;
            cos = Math.cos(r);
            sin = Math.sin(r);
        }

        this.concat(new Matrix(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y));
        return this;
    },
    rotate: function rotate(angle) {
        //目前已经提供对顺时针逆时针两个方向旋转的支持
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);

        var a = this.a;
        var c = this.c;
        var tx = this.tx;

        if (angle > 0) {
            this.a = a * cos - this.b * sin;
            this.b = a * sin + this.b * cos;
            this.c = c * cos - this.d * sin;
            this.d = c * sin + this.d * cos;
            this.tx = tx * cos - this.ty * sin;
            this.ty = tx * sin + this.ty * cos;
        } else {
            var st = Math.sin(Math.abs(angle));
            var ct = Math.cos(Math.abs(angle));

            this.a = a * ct + this.b * st;
            this.b = -a * st + this.b * ct;
            this.c = c * ct + this.d * st;
            this.d = -c * st + ct * this.d;
            this.tx = ct * tx + st * this.ty;
            this.ty = ct * this.ty - st * tx;
        }
        return this;
    },
    scale: function scale(sx, sy) {
        this.a *= sx;
        this.d *= sy;
        this.tx *= sx;
        this.ty *= sy;
        return this;
    },
    translate: function translate(dx, dy) {
        this.tx += dx;
        this.ty += dy;
        return this;
    },
    identity: function identity() {
        //初始化
        this.a = this.d = 1;
        this.b = this.c = this.tx = this.ty = 0;
        return this;
    },
    invert: function invert() {
        //逆向矩阵
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var tx = this.tx;
        var i = a * d - b * c;

        this.a = d / i;
        this.b = -b / i;
        this.c = -c / i;
        this.d = a / i;
        this.tx = (c * this.ty - d * tx) / i;
        this.ty = -(a * this.ty - b * tx) / i;
        return this;
    },
    clone: function clone() {
        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
    },
    toArray: function toArray(transpose, out) {
        if (arguments.length == 0) {
            //canvas2d 中不会有任何的参数传入
            return [this.a, this.b, this.c, this.d, this.tx, this.ty];
        }

        //webgl的glsl需要用的时候，需要传入transpose 来转换为一个3*3完整矩阵
        if (!this.array) {
            this.array = new Float32Array(9);
        }

        var array = out || this.array;

        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        } else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }

        return array;
    },
    /**
     * 矩阵左乘向量
     */
    mulVector: function mulVector(v) {
        var aa = this.a,
            ac = this.c,
            atx = this.tx;
        var ab = this.b,
            ad = this.d,
            aty = this.ty;

        var out = [0, 0];
        out[0] = v[0] * aa + v[1] * ac + atx;
        out[1] = v[0] * ab + v[1] * ad + aty;

        return out;
    }
};

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

var TWEEN = TWEEN || function () {

	var _tweens = [];

	return {

		getAll: function getAll() {

			return _tweens;
		},

		removeAll: function removeAll() {

			_tweens = [];
		},

		add: function add(tween) {

			_tweens.push(tween);
		},

		remove: function remove(tween) {

			var i = _$1.indexOf(_tweens, tween); //_tweens.indexOf(tween);

			if (i !== -1) {
				_tweens.splice(i, 1);
			}
		},

		update: function update(time, preserve) {

			if (_tweens.length === 0) {
				return false;
			}

			var i = 0;

			time = time !== undefined ? time : TWEEN.now();

			while (i < _tweens.length) {

				/* old 
    if (_tweens[i].update(time) || preserve) {
    i++;
    } else {
    _tweens.splice(i, 1);
    }
    */

				//new code
				//in real world, tween.update has chance to remove itself, so we have to handle this situation.
				//in certain cases, onUpdateCallback will remove instances in _tweens, which make _tweens.splice(i, 1) fail
				//@litao.lt@alibaba-inc.com
				var _t = _tweens[i];
				var _updateRes = _t.update(time);

				if (!_tweens[i]) {
					break;
				}
				if (_t === _tweens[i]) {
					if (_updateRes || preserve) {
						i++;
					} else {
						_tweens.splice(i, 1);
					}
				}
			}

			return true;
		}
	};
}();

// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof window === 'undefined' && typeof process !== 'undefined') {
	TWEEN.now = function () {
		var time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use window.performance.now if it is available.
else if (typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined) {
		// This must be bound, because directly assigning this function
		// leads to an invocation exception in Chrome.
		TWEEN.now = window.performance.now.bind(window.performance);
	}
	// Use Date.now if it is available.
	else if (Date.now !== undefined) {
			TWEEN.now = Date.now;
		}
		// Otherwise, use 'new Date().getTime()'.
		else {
				TWEEN.now = function () {
					return new Date().getTime();
				};
			}

TWEEN.Tween = function (object) {

	var _object = object;
	var _valuesStart = {};
	var _valuesEnd = {};
	var _valuesStartRepeat = {};
	var _duration = 1000;
	var _repeat = 0;
	var _repeatDelayTime;
	var _yoyo = false;
	var _isPlaying = false;
	var _reversed = false;
	var _delayTime = 0;
	var _startTime = null;
	var _easingFunction = TWEEN.Easing.Linear.None;
	var _interpolationFunction = TWEEN.Interpolation.Linear;
	var _chainedTweens = [];
	var _onStartCallback = null;
	var _onStartCallbackFired = false;
	var _onUpdateCallback = null;
	var _onCompleteCallback = null;
	var _onStopCallback = null;

	this.to = function (properties, duration) {

		_valuesEnd = properties;

		if (duration !== undefined) {
			_duration = duration;
		}

		return this;
	};

	this.start = function (time) {

		TWEEN.add(this);

		_isPlaying = true;

		_onStartCallbackFired = false;

		_startTime = time !== undefined ? time : TWEEN.now();
		_startTime += _delayTime;

		for (var property in _valuesEnd) {

			// Check if an Array was provided as property value
			if (_valuesEnd[property] instanceof Array) {

				if (_valuesEnd[property].length === 0) {
					continue;
				}

				// Create a local copy of the Array with the start value at the front
				_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
			}

			// If `to()` specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (_object[property] === undefined) {
				continue;
			}

			// Save the starting value.
			_valuesStart[property] = _object[property];

			if (_valuesStart[property] instanceof Array === false) {
				_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
			}

			_valuesStartRepeat[property] = _valuesStart[property] || 0;
		}

		return this;
	};

	this.stop = function () {

		if (!_isPlaying) {
			return this;
		}

		TWEEN.remove(this);
		_isPlaying = false;

		if (_onStopCallback !== null) {
			_onStopCallback.call(_object, _object);
		}

		this.stopChainedTweens();
		return this;
	};

	this.end = function () {

		this.update(_startTime + _duration);
		return this;
	};

	this.stopChainedTweens = function () {

		for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
			_chainedTweens[i].stop();
		}
	};

	this.delay = function (amount) {

		_delayTime = amount;
		return this;
	};

	this.repeat = function (times) {

		_repeat = times;
		return this;
	};

	this.repeatDelay = function (amount) {

		_repeatDelayTime = amount;
		return this;
	};

	this.yoyo = function (yoyo) {

		_yoyo = yoyo;
		return this;
	};

	this.easing = function (easing) {

		_easingFunction = easing;
		return this;
	};

	this.interpolation = function (interpolation) {

		_interpolationFunction = interpolation;
		return this;
	};

	this.chain = function () {

		_chainedTweens = arguments;
		return this;
	};

	this.onStart = function (callback) {

		_onStartCallback = callback;
		return this;
	};

	this.onUpdate = function (callback) {

		_onUpdateCallback = callback;
		return this;
	};

	this.onComplete = function (callback) {

		_onCompleteCallback = callback;
		return this;
	};

	this.onStop = function (callback) {

		_onStopCallback = callback;
		return this;
	};

	this.update = function (time) {

		var property;
		var elapsed;
		var value;

		if (time < _startTime) {
			return true;
		}

		if (_onStartCallbackFired === false) {

			if (_onStartCallback !== null) {
				_onStartCallback.call(_object, _object);
			}

			_onStartCallbackFired = true;
		}

		elapsed = (time - _startTime) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		value = _easingFunction(elapsed);

		for (property in _valuesEnd) {

			// Don't update properties that do not exist in the source object
			if (_valuesStart[property] === undefined) {
				continue;
			}

			var start = _valuesStart[property] || 0;
			var end = _valuesEnd[property];

			if (end instanceof Array) {

				_object[property] = _interpolationFunction(end, value);
			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if (typeof end === 'string') {

					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
						end = start + parseFloat(end);
					} else {
						end = parseFloat(end);
					}
				}

				// Protect against non numeric properties.
				if (typeof end === 'number') {
					_object[property] = start + (end - start) * value;
				}
			}
		}

		if (_onUpdateCallback !== null) {
			_onUpdateCallback.call(_object, value);
		}

		if (elapsed === 1) {

			if (_repeat > 0) {

				if (isFinite(_repeat)) {
					_repeat--;
				}

				// Reassign starting values, restart by making startTime = now
				for (property in _valuesStartRepeat) {

					if (typeof _valuesEnd[property] === 'string') {
						_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);
					}

					if (_yoyo) {
						var tmp = _valuesStartRepeat[property];

						_valuesStartRepeat[property] = _valuesEnd[property];
						_valuesEnd[property] = tmp;
					}

					_valuesStart[property] = _valuesStartRepeat[property];
				}

				if (_yoyo) {
					_reversed = !_reversed;
				}

				if (_repeatDelayTime !== undefined) {
					_startTime = time + _repeatDelayTime;
				} else {
					_startTime = time + _delayTime;
				}

				return true;
			} else {

				if (_onCompleteCallback !== null) {

					_onCompleteCallback.call(_object, _object);
				}

				for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
					// Make the chained tweens start exactly at the time they should,
					// even if the `update()` method was called way past the duration of the tween
					_chainedTweens[i].start(_startTime + _duration);
				}

				return false;
			}
		}

		return true;
	};
};

TWEEN.Easing = {

	Linear: {

		None: function None(k) {

			return k;
		}

	},

	Quadratic: {

		In: function In(k) {

			return k * k;
		},

		Out: function Out(k) {

			return k * (2 - k);
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}

			return -0.5 * (--k * (k - 2) - 1);
		}

	},

	Cubic: {

		In: function In(k) {

			return k * k * k;
		},

		Out: function Out(k) {

			return --k * k * k + 1;
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k + 2);
		}

	},

	Quartic: {

		In: function In(k) {

			return k * k * k * k;
		},

		Out: function Out(k) {

			return 1 - --k * k * k * k;
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}

			return -0.5 * ((k -= 2) * k * k * k - 2);
		}

	},

	Quintic: {

		In: function In(k) {

			return k * k * k * k * k;
		},

		Out: function Out(k) {

			return --k * k * k * k * k + 1;
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k * k * k + 2);
		}

	},

	Sinusoidal: {

		In: function In(k) {

			return 1 - Math.cos(k * Math.PI / 2);
		},

		Out: function Out(k) {

			return Math.sin(k * Math.PI / 2);
		},

		InOut: function InOut(k) {

			return 0.5 * (1 - Math.cos(Math.PI * k));
		}

	},

	Exponential: {

		In: function In(k) {

			return k === 0 ? 0 : Math.pow(1024, k - 1);
		},

		Out: function Out(k) {

			return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
		},

		InOut: function InOut(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}

			return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
		}

	},

	Circular: {

		In: function In(k) {

			return 1 - Math.sqrt(1 - k * k);
		},

		Out: function Out(k) {

			return Math.sqrt(1 - --k * k);
		},

		InOut: function InOut(k) {

			if ((k *= 2) < 1) {
				return -0.5 * (Math.sqrt(1 - k * k) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
		}

	},

	Elastic: {

		In: function In(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
		},

		Out: function Out(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
		},

		InOut: function InOut(k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			k *= 2;

			if (k < 1) {
				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
		}

	},

	Back: {

		In: function In(k) {

			var s = 1.70158;

			return k * k * ((s + 1) * k - s);
		},

		Out: function Out(k) {

			var s = 1.70158;

			return --k * k * ((s + 1) * k + s) + 1;
		},

		InOut: function InOut(k) {

			var s = 1.70158 * 1.525;

			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}

			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
		}

	},

	Bounce: {

		In: function In(k) {

			return 1 - TWEEN.Easing.Bounce.Out(1 - k);
		},

		Out: function Out(k) {

			if (k < 1 / 2.75) {
				return 7.5625 * k * k;
			} else if (k < 2 / 2.75) {
				return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
			} else if (k < 2.5 / 2.75) {
				return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
			} else {
				return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
			}
		},

		InOut: function InOut(k) {

			if (k < 0.5) {
				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
			}

			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
		}

	}

};

TWEEN.Interpolation = {

	Linear: function Linear(v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.Linear;

		if (k < 0) {
			return fn(v[0], v[1], f);
		}

		if (k > 1) {
			return fn(v[m], v[m - 1], m - f);
		}

		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
	},

	Bezier: function Bezier(v, k) {

		var b = 0;
		var n = v.length - 1;
		var pw = Math.pow;
		var bn = TWEEN.Interpolation.Utils.Bernstein;

		for (var i = 0; i <= n; i++) {
			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
		}

		return b;
	},

	CatmullRom: function CatmullRom(v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.CatmullRom;

		if (v[0] === v[m]) {

			if (k < 0) {
				i = Math.floor(f = m * (1 + k));
			}

			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
		} else {

			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
		}
	},

	Utils: {

		Linear: function Linear(p0, p1, t) {

			return (p1 - p0) * t + p0;
		},

		Bernstein: function Bernstein(n, i) {

			var fc = TWEEN.Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);
		},

		Factorial: function () {

			var a = [1];

			return function (n) {

				var s = 1;

				if (a[n]) {
					return a[n];
				}

				for (var i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;
				return s;
			};
		}(),

		CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
		}

	}

};

/**
 * 设置 AnimationFrame begin
 */
var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
}
if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}
if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
}

//管理所有图表的渲染任务
var _taskList = []; //[{ id : task: }...]
var _requestAid = null;

function enabledAnimationFrame() {
    if (!_requestAid) {
        _requestAid = requestAnimationFrame(function () {
            //console.log("frame__" + _taskList.length);
            //if ( Tween.getAll().length ) {
            TWEEN.update(); //tween自己会做length判断
            //};
            var currTaskList = _taskList;
            _taskList = [];
            _requestAid = null;
            while (currTaskList.length > 0) {
                currTaskList.shift().task();
            }
        });
    }
    return _requestAid;
}

/*
 * @param task 要加入到渲染帧队列中的任务
 * @result frameid
 */
function registFrame($frame) {
    if (!$frame) {
        return;
    }
    _taskList.push($frame);
    return enabledAnimationFrame();
}

/*
 *  @param task 要从渲染帧队列中删除的任务
 */
function destroyFrame($frame) {
    var d_result = false;
    for (var i = 0, l = _taskList.length; i < l; i++) {
        if (_taskList[i].id === $frame.id) {
            d_result = true;
            _taskList.splice(i, 1);
            i--;
            l--;
        }
    }
    if (_taskList.length == 0) {
        cancelAnimationFrame(_requestAid);
        _requestAid = null;
    }
    return d_result;
}

/* 
 * @param opt {from , to , onUpdate , onComplete , ......}
 * @result tween
 */
function registTween(options) {
    var opt = _$1.extend({
        from: null,
        to: null,
        duration: 500,
        onStart: function onStart() {},
        onUpdate: function onUpdate() {},
        onComplete: function onComplete() {},
        onStop: function onStop() {},
        repeat: 0,
        delay: 0,
        easing: 'Linear.None',
        desc: '' //动画描述，方便查找bug
    }, options);

    var tween = {};
    var tid = "tween_" + Utils.getUID();
    opt.id && (tid = tid + "_" + opt.id);

    if (opt.from && opt.to) {
        (function () {
            var animate = function animate() {

                if (tween._isCompleteed || tween._isStoped) {
                    tween = null;
                    return;
                }
                registFrame({
                    id: tid,
                    task: animate,
                    desc: opt.desc,
                    tween: tween
                });
            };

            tween = new TWEEN.Tween(opt.from).to(opt.to, opt.duration).onStart(function () {
                opt.onStart.apply(this);
            }).onUpdate(function () {
                opt.onUpdate.apply(this);
            }).onComplete(function () {
                destroyFrame({
                    id: tid
                });
                tween._isCompleteed = true;
                opt.onComplete.apply(this, [this]); //执行用户的conComplete
            }).onStop(function () {
                destroyFrame({
                    id: tid
                });
                tween._isStoped = true;
                opt.onStop.apply(this, [this]);
            }).repeat(opt.repeat).delay(opt.delay).easing(TWEEN.Easing[opt.easing.split(".")[0]][opt.easing.split(".")[1]]);

            tween.id = tid;
            tween.start();

            
            animate();
        })();
    }
    return tween;
}
/*
 * @param tween
 * @result void(0)
 */
function destroyTween(tween, msg) {
    tween.stop();
}

var AnimationFrame = {
    registFrame: registFrame,
    destroyFrame: destroyFrame,
    registTween: registTween,
    destroyTween: destroyTween
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 属性工厂，ie下面用VBS提供支持
 * 来给整个引擎提供心跳包的触发机制
 */
//定义封装好的兼容大部分浏览器的defineProperties 的 属性工厂
var unwatchOne = {
    "$skipArray": 0,
    "$watch": 1,
    "$fire": 2, //主要是get set 显性设置的 触发
    "$model": 3,
    "$accessor": 4,
    "$owner": 5,
    //"path"       : 6, //这个应该是唯一一个不用watch的不带$的成员了吧，因为地图等的path是在太大
    "$parent": 7 //用于建立数据的关系链
};

function Observe(scope, model, watchMore) {

    var stopRepeatAssign = true;

    var skipArray = scope.$skipArray,
        //要忽略监控的属性名列表
    pmodel = {},
        //要返回的对象
    accessores = {},
        //内部用于转换的对象
    VBPublics = _$1.keys(unwatchOne); //用于IE6-8

    model = model || {}; //这是pmodel上的$model属性
    watchMore = watchMore || {}; //以$开头但要强制监听的属性
    skipArray = _$1.isArray(skipArray) ? skipArray.concat(VBPublics) : VBPublics;

    function loop(name, val) {
        if (!unwatchOne[name] || unwatchOne[name] && name.charAt(0) !== "$") {
            model[name] = val;
        }
        var valueType = typeof val === "undefined" ? "undefined" : _typeof(val);
        if (valueType === "function") {
            if (!unwatchOne[name]) {
                VBPublics.push(name); //函数无需要转换
            }
        } else {
            if (_$1.indexOf(skipArray, name) !== -1 || name.charAt(0) === "$" && !watchMore[name]) {
                return VBPublics.push(name);
            }
            var accessor = function accessor(neo) {
                //创建监控属性或数组，自变量，由用户触发其改变
                var value = accessor.value,
                    preValue = value,
                    complexValue;

                if (arguments.length) {
                    //写操作
                    //set 的 值的 类型
                    var neoType = typeof neo === "undefined" ? "undefined" : _typeof(neo);

                    if (stopRepeatAssign) {
                        return; //阻止重复赋值
                    }
                    if (value !== neo) {
                        if (neo && neoType === "object" && !(neo instanceof Array) && !neo.addColorStop // neo instanceof CanvasGradient
                        ) {
                                value = neo.$model ? neo : Observe(neo, neo);
                                complexValue = value.$model;
                            } else {
                            //如果是其他数据类型
                            //if( neoType === "array" ){
                            //    value = _.clone(neo);
                            //} else {
                            value = neo;
                            //}
                        }
                        accessor.value = value;
                        model[name] = complexValue ? complexValue : value; //更新$model中的值
                        if (!complexValue) {
                            pmodel.$fire && pmodel.$fire(name, value, preValue);
                        }
                        if (valueType != neoType) {
                            //如果set的值类型已经改变，
                            //那么也要把对应的valueType修改为对应的neoType
                            valueType = neoType;
                        }
                        var hasWatchModel = pmodel;
                        //所有的赋值都要触发watch的监听事件
                        if (!pmodel.$watch) {
                            while (hasWatchModel.$parent) {
                                hasWatchModel = hasWatchModel.$parent;
                            }
                        }
                        if (hasWatchModel.$watch) {
                            hasWatchModel.$watch.call(hasWatchModel, name, value, preValue);
                        }
                    }
                } else {
                    //读操作
                    //读的时候，发现value是个obj，而且还没有defineProperty
                    //那么就临时defineProperty一次
                    if (value && valueType === "object" && !(value instanceof Array) && !value.$model && !value.addColorStop) {
                        //建立和父数据节点的关系
                        value.$parent = pmodel;
                        value = Observe(value, value);

                        //accessor.value 重新复制为defineProperty过后的对象
                        accessor.value = value;
                    }
                    return value;
                }
            };
            accessor.value = val;

            accessores[name] = {
                set: accessor,
                get: accessor,
                enumerable: true
            };
        }
    }

    for (var i in scope) {
        loop(i, scope[i]);
    }

    pmodel = defineProperties(pmodel, accessores, VBPublics); //生成一个空的ViewModel

    _$1.forEach(VBPublics, function (name) {
        if (scope[name]) {
            //先为函数等不被监控的属性赋值
            if (typeof scope[name] == "function") {
                pmodel[name] = function () {
                    scope[name].apply(this, arguments);
                };
            } else {
                pmodel[name] = scope[name];
            }
        }
    });

    pmodel.$model = model;
    pmodel.$accessor = accessores;

    pmodel.hasOwnProperty = function (name) {
        return name in pmodel.$model;
    };

    stopRepeatAssign = false;

    return pmodel;
}
var defineProperty$1 = Object.defineProperty;
//如果浏览器不支持ecma262v5的Object.defineProperties或者存在BUG，比如IE8
//标准浏览器使用__defineGetter__, __defineSetter__实现
try {
    defineProperty$1({}, "_", {
        value: "x"
    });
    var defineProperties = Object.defineProperties;
} catch (e) {
    if ("__defineGetter__" in Object) {
        defineProperty$1 = function defineProperty$$1(obj, prop, desc) {
            if ('value' in desc) {
                obj[prop] = desc.value;
            }
            if ('get' in desc) {
                obj.__defineGetter__(prop, desc.get);
            }
            if ('set' in desc) {
                obj.__defineSetter__(prop, desc.set);
            }
            return obj;
        };
        defineProperties = function defineProperties(obj, descs) {
            for (var prop in descs) {
                if (descs.hasOwnProperty(prop)) {
                    defineProperty$1(obj, prop, descs[prop]);
                }
            }
            return obj;
        };
    }
}
//IE6-8使用VBScript类的set get语句实现
if (!defineProperties && window.VBArray) {
    (function () {
        var VBMediator = function VBMediator(description, name, value) {
            var fn = description[name] && description[name].set;
            if (arguments.length === 3) {
                fn(value);
            } else {
                return fn();
            }
        };

        window.execScript(["Function parseVB(code)", "\tExecuteGlobal(code)", "End Function"].join("\n"), "VBScript");

        
        defineProperties = function defineProperties(publics, description, array) {
            publics = array.slice(0);
            publics.push("hasOwnProperty");
            var className = "VBClass" + setTimeout("1"),
                owner = {},
                buffer = [];
            buffer.push("Class " + className, "\tPrivate [__data__], [__proxy__]", "\tPublic Default Function [__const__](d, p)", "\t\tSet [__data__] = d: set [__proxy__] = p", "\t\tSet [__const__] = Me", //链式调用
            "\tEnd Function");
            _$1.forEach(publics, function (name) {
                //添加公共属性,如果此时不加以后就没机会了
                if (owner[name] !== true) {
                    owner[name] = true; //因为VBScript对象不能像JS那样随意增删属性
                    buffer.push("\tPublic [" + name + "]"); //你可以预先放到skipArray中
                }
            });
            for (var name in description) {
                owner[name] = true;
                buffer.push(
                //由于不知对方会传入什么,因此set, let都用上
                "\tPublic Property Let [" + name + "](val)", //setter
                "\t\tCall [__proxy__]([__data__], \"" + name + "\", val)", "\tEnd Property", "\tPublic Property Set [" + name + "](val)", //setter
                "\t\tCall [__proxy__]([__data__], \"" + name + "\", val)", "\tEnd Property", "\tPublic Property Get [" + name + "]", //getter
                "\tOn Error Resume Next", //必须优先使用set语句,否则它会误将数组当字符串返回
                "\t\tSet[" + name + "] = [__proxy__]([__data__],\"" + name + "\")", "\tIf Err.Number <> 0 Then", "\t\t[" + name + "] = [__proxy__]([__data__],\"" + name + "\")", "\tEnd If", "\tOn Error Goto 0", "\tEnd Property");
            }
            buffer.push("End Class"); //类定义完毕
            buffer.push("Function " + className + "Factory(a, b)", //创建实例并传入两个关键的参数
            "\tDim o", "\tSet o = (New " + className + ")(a, b)", "\tSet " + className + "Factory = o", "End Function");
            window.parseVB(buffer.join("\r\n")); //先创建一个VB类工厂
            return window[className + "Factory"](description, VBMediator); //得到其产品
        };
    })();
}

var RENDERER_TYPE = {
    UNKNOWN: 0,
    WEBGL: 1,
    CANVAS: 2
};

var DRAW_MODES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
};

var SHAPES = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3
};



var CONTEXT_DEFAULT = {
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1,
    scaleOrigin: {
        x: 0,
        y: 0
    },
    rotation: 0,
    rotateOrigin: {
        x: 0,
        y: 0
    },
    visible: true,
    globalAlpha: 1

};
var SHAPE_CONTEXT_DEFAULT = {
    cursor: "default",

    fillAlpha: 1, //context2d里没有，自定义
    fillStyle: null, //"#000000",

    lineCap: null, //默认都是直角
    lineJoin: null, //这两个目前webgl里面没实现
    miterLimit: null, //miterLimit 属性设置或返回最大斜接长度,只有当 lineJoin 属性为 "miter" 时，miterLimit 才有效。

    lineAlpha: 1, //context2d里没有，自定义
    strokeStyle: null,
    lineType: "solid", //context2d里没有，自定义线条的type，默认为实线
    lineWidth: null
};

//会影响到transform改变的context属性
var TRANSFORM_PROPS = ["x", "y", "scaleX", "scaleY", "rotation", "scaleOrigin", "rotateOrigin"];

//所有和样式相关的属性

/**
 * 线段包含判断
 * @points [0,0,0,0]
 */
var _isInsideLine = function _isInsideLine(points, x, y, lineWidth) {
    var x0 = points[0];
    var y0 = points[1];
    var x1 = points[2];
    var y1 = points[3];
    var _l = Math.max(lineWidth, 3);
    var _a = 0;
    var _b = x0;

    if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
        return false;
    }

    if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    } else {
        return Math.abs(x - x0) <= _l / 2;
    }

    var _s = (_a * x - y + _b) * (_a * x - y + _b) / (_a * _a + 1);
    return _s <= _l / 2 * _l / 2;
};

function insideLine(data, x, y, line) {
    var points = data.shape.points;
    var lineWidth = data.lineWidth;
    var insideCatch = false;
    for (var i = 0; i < points.length; ++i) {
        insideCatch = _isInsideLine(points.slice(i, i + 4), x, y, lineWidth);
        if (insideCatch) {
            break;
        }
        i += 1;
    }
    return insideCatch;
}

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3 DisplayList 的 现实对象基类
 */
var DisplayObject = function DisplayObject(opt) {
    DisplayObject.superclass.constructor.apply(this, arguments);

    //如果用户没有传入context设置，就默认为空的对象
    opt = Utils.checkOpt(opt);

    //相对父级元素的矩阵
    this._transform = null;
    this.worldTransform = null; //webgl 渲染器中专用

    //心跳次数
    this._heartBeatNum = 0;

    //元素对应的stage元素
    this.stage = null;

    //元素的父元素
    this.parent = null;

    this._eventEnabled = false; //是否响应事件交互,在添加了事件侦听后会自动设置为true

    this.dragEnabled = true; //"dragEnabled" in opt ? opt.dragEnabled : false;   //是否启用元素的拖拽

    this.xyToInt = "xyToInt" in opt ? opt.xyToInt : true; //是否对xy坐标统一int处理，默认为true，但是有的时候可以由外界用户手动指定是否需要计算为int，因为有的时候不计算比较好，比如，进度图表中，再sector的两端添加两个圆来做圆角的进度条的时候，圆circle不做int计算，才能和sector更好的衔接

    this.moveing = false; //如果元素在最轨道运动中的时候，最好把这个设置为true，这样能保证轨迹的丝搬顺滑，否则因为xyToInt的原因，会有跳跃

    //创建好context
    this._createContext(opt);

    this.id = opt.id || Utils.createId(this.type || "displayObject");

    this.init.apply(this, arguments);

    //所有属性准备好了后，先要计算一次this._updateTransform()得到_tansform
    this._updateTransform();
};

Utils.creatClass(DisplayObject, EventDispatcher, {
    init: function init() {},
    _createContext: function _createContext(opt) {
        var self = this;
        //所有显示对象，都有一个类似canvas.context类似的 context属性
        //用来存取改显示对象所有和显示有关的属性，坐标，样式等。
        //该对象为Coer.Observe()工厂函数生成
        self.context = null;

        //提供给Coer.Observe() 来 给 self.context 设置 propertys
        //这里不能用_.extend， 因为要保证_contextATTRS的纯粹，只覆盖下面已有的属性
        var _contextATTRS = _$1.extend(_$1.clone(CONTEXT_DEFAULT), opt.context, true);

        //有些引擎内部设置context属性的时候是不用上报心跳的，比如做热点检测的时候
        self._notWatch = false;

        _contextATTRS.$owner = self;
        _contextATTRS.$watch = function (name, value, preValue) {
            //下面的这些属性变化，都会需要重新组织矩阵属性 _transform 
            var obj = this.$owner;

            if (_$1.indexOf(TRANSFORM_PROPS, name) > -1) {
                obj._updateTransform();

                //stage本身就是世界坐标，所以其worldTransform不需要动态修改
                if (obj.parent && obj.type != "stage" && obj.parent.worldTransform) {
                    obj.worldTransform = null;
                    //只有parent有worldTransform，就可以算出自己对应的世界坐标
                    obj.getWorldTransform();
                    if (obj.children) {
                        //如果自己还有子元素，那么子元素的世界坐标也都要对应的调整
                        obj.updateChildWorldTransform();
                    }
                }
            }

            if (obj._notWatch) {
                return;
            }

            if (obj.$watch) {
                obj.$watch(name, value, preValue);
            }

            obj.heartBeat({
                convertType: "context",
                shape: obj,
                name: name,
                value: value,
                preValue: preValue
            });
        };

        //执行init之前，应该就根据参数，把context组织好线
        self.context = Observe(_contextATTRS);
        //self.context = _contextATTRS
    },
    /* @myself 是否生成自己的镜像 
     * 克隆又两种，一种是镜像，另外一种是绝对意义上面的新个体
     * 默认为绝对意义上面的新个体，新对象id不能相同
     * 镜像基本上是框架内部在实现  镜像的id相同 主要用来把自己画到另外的stage里面，比如
     * mouseover和mouseout的时候调用*/
    clone: function clone(myself) {
        var conf = {
            id: this.id,
            context: _$1.clone(this.context.$model)
        };

        var newObj;
        if (this.type == 'text') {
            newObj = new this.constructor(this.text, conf);
        } else {
            newObj = new this.constructor(conf);
        }

        newObj.id = conf.id;

        if (this.children) {
            newObj.children = this.children;
        }

        if (!myself) {
            newObj.id = Utils.createId(newObj.type);
        }
        return newObj;
    },
    heartBeat: function heartBeat(opt) {
        //stage存在，才说self代表的display已经被添加到了displayList中，绘图引擎需要知道其改变后
        //的属性，所以，通知到stage.displayAttrHasChange
        var stage = this.getStage();
        if (stage) {
            this._heartBeatNum++;
            stage.heartBeat && stage.heartBeat(opt);
        }
    },
    getCurrentWidth: function getCurrentWidth() {
        return Math.abs(this.context.width * this.context.scaleX);
    },
    getCurrentHeight: function getCurrentHeight() {
        return Math.abs(this.context.height * this.context.scaleY);
    },
    getStage: function getStage() {
        if (this.stage) {
            return this.stage;
        }
        var p = this;
        if (p.type != "stage") {
            while (p.parent) {
                p = p.parent;
                if (p.type == "stage") {
                    break;
                }
            }
            if (p.type !== "stage") {
                //如果得到的顶点display 的type不是Stage,也就是说不是stage元素
                //那么只能说明这个p所代表的顶端display 还没有添加到displayList中，也就是没有没添加到
                //stage舞台的childen队列中，不在引擎渲染范围内
                return false;
            }
        }
        //一直回溯到顶层object， 即是stage， stage的parent为null
        this.stage = p;
        return p;
    },
    localToGlobal: function localToGlobal(point, container) {
        !point && (point = new Point(0, 0));
        var cm = this.getConcatenatedMatrix(container);

        if (cm == null) return Point(0, 0);
        var m = new Matrix(1, 0, 0, 1, point.x, point.y);
        m.concat(cm);
        return new Point(m.tx, m.ty); //{x:m.tx, y:m.ty};
    },
    globalToLocal: function globalToLocal(point, container) {
        !point && (point = new Point(0, 0));

        if (this.type == "stage") {
            return point;
        }
        var cm = this.getConcatenatedMatrix(container);

        if (cm == null) return new Point(0, 0); //{x:0, y:0};
        cm.invert();
        var m = new Matrix(1, 0, 0, 1, point.x, point.y);
        m.concat(cm);
        return new Point(m.tx, m.ty); //{x:m.tx, y:m.ty};
    },
    localToTarget: function localToTarget(point, target) {
        var p = localToGlobal(point);
        return target.globalToLocal(p);
    },
    getConcatenatedMatrix: function getConcatenatedMatrix(container) {
        var cm = new Matrix();
        for (var o = this; o != null; o = o.parent) {
            cm.concat(o._transform);
            if (!o.parent || container && o.parent && o.parent == container || o.parent && o.parent.type == "stage") {
                //if( o.type == "stage" || (o.parent && container && o.parent.type == container.type ) ) {
                return cm; //break;
            }
        }
        return cm;
    },
    /*
     *设置元素的是否响应事件检测
     *@bool  Boolean 类型
     */
    setEventEnable: function setEventEnable(bool) {
        if (_$1.isBoolean(bool)) {
            this._eventEnabled = bool;
            return true;
        }
        return false;
    },
    /*
     *查询自己在parent的队列中的位置
     */
    getIndex: function getIndex() {
        if (!this.parent) {
            return;
        }
        return _$1.indexOf(this.parent.children, this);
    },
    /*
     *元素在z轴方向向下移动
     *@num 移动的层级
     */
    toBack: function toBack(num) {
        if (!this.parent) {
            return;
        }
        var fromIndex = this.getIndex();
        var toIndex = 0;

        if (_$1.isNumber(num)) {
            if (num == 0) {
                //原地不动
                return;
            }
            toIndex = fromIndex - num;
        }
        var me = this.parent.children.splice(fromIndex, 1)[0];
        if (toIndex < 0) {
            toIndex = 0;
        }
        this.parent.addChildAt(me, toIndex);
    },
    /*
     *元素在z轴方向向上移动
     *@num 移动的层数量 默认到顶端
     */
    toFront: function toFront(num) {
        if (!this.parent) {
            return;
        }
        var fromIndex = this.getIndex();
        var pcl = this.parent.children.length;
        var toIndex = pcl;

        if (_$1.isNumber(num)) {
            if (num == 0) {
                //原地不动
                return;
            }
            toIndex = fromIndex + num + 1;
        }
        var me = this.parent.children.splice(fromIndex, 1)[0];
        if (toIndex > pcl) {
            toIndex = pcl;
        }
        this.parent.addChildAt(me, toIndex - 1);
    },
    _updateTransform: function _updateTransform() {
        var _transform = new Matrix();
        _transform.identity();
        var context = this.context;
        //是否需要Transform
        if (context.scaleX !== 1 || context.scaleY !== 1) {
            //如果有缩放
            //缩放的原点坐标
            var origin = new Point(context.scaleOrigin);
            if (origin.x || origin.y) {
                _transform.translate(-origin.x, -origin.y);
            }
            _transform.scale(context.scaleX, context.scaleY);
            if (origin.x || origin.y) {
                _transform.translate(origin.x, origin.y);
            }
        }

        var rotation = context.rotation;
        if (rotation) {
            //如果有旋转
            //旋转的原点坐标
            var origin = new Point(context.rotateOrigin);
            if (origin.x || origin.y) {
                _transform.translate(-origin.x, -origin.y);
            }
            _transform.rotate(rotation % 360 * Math.PI / 180);
            if (origin.x || origin.y) {
                _transform.translate(origin.x, origin.y);
            }
        }

        //如果有位移
        var x, y;
        if (this.xyToInt && !this.moveing) {
            //当这个元素在做轨迹运动的时候，比如drag，animation如果实时的调整这个x ， y
            //那么该元素的轨迹会有跳跃的情况发生。所以加个条件过滤，
            var x = parseInt(context.x);
            var y = parseInt(context.y);

            if (parseInt(context.lineWidth, 10) % 2 == 1 && context.strokeStyle) {
                x += 0.5;
                y += 0.5;
            }
        } else {
            x = context.x;
            y = context.y;
        }

        if (x != 0 || y != 0) {
            _transform.translate(x, y);
        }
        this._transform = _transform;
        return _transform;
    },
    //获取全局的世界坐标系内的矩阵
    //世界坐标是从上而下的，所以只要和parent的直接坐标相乘就好了
    getWorldTransform: function getWorldTransform() {
        var cm;
        if (!this.worldTransform) {
            cm = new Matrix();
            cm.concat(this._transform);
            cm.concat(this.parent.worldTransform);
            this.worldTransform = cm;
        }
        return this.worldTransform;
    },
    //显示对象的选取检测处理函数
    getChildInPoint: function getChildInPoint(point) {

        var result = false; //检测的结果

        //第一步，吧glob的point转换到对应的obj的层级内的坐标系统
        if (this.type != "stage" && this.parent && this.parent.type != "stage") {
            point = this.parent.globalToLocal(point);
        }

        var x = point.x;
        var y = point.y;

        //对鼠标的坐标也做相同的变换
        if (this._transform) {
            var inverseMatrix = this._transform.clone().invert();
            var originPos = [x, y];
            originPos = inverseMatrix.mulVector(originPos);

            x = originPos[0];
            y = originPos[1];
        }

        if (this.graphicsData) {
            result = this.containsPoint({ x: x, y: y }, this.graphicsData);
        }

        return result;
    },
    containsPoint: function containsPoint(point, _graphicsData) {
        var graphicsData = _graphicsData || this.graphicsData;
        var inside = false;
        for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];
            if (data.shape) {
                //先检测fill， fill的检测概率大些。
                //像circle,ellipse这样的shape 就直接把lineWidth算在fill里面计算就好了，所以他们是没有insideLine的
                if (data.hasFill() && data.shape.contains(point.x, point.y)) {
                    inside = true;
                    if (inside) {
                        break;
                    }
                }

                //circle,ellipse等就没有points
                if (data.hasLine() && data.shape.points) {
                    //然后检测是否和描边碰撞
                    inside = insideLine(data, point.x, point.y);
                    if (inside) {
                        break;
                    }
                }
            }
        }
        return inside;
    },
    /*
    * animate
    * @param toContent 要动画变形到的属性集合
    * @param options tween 动画参数
    */
    animate: function animate(toContent, options) {
        var to = toContent;
        var from = {};
        for (var p in to) {
            from[p] = this.context[p];
        }
        !options && (options = {});
        options.from = from;
        options.to = to;

        var self = this;
        var upFun = function upFun() {};
        if (options.onUpdate) {
            upFun = options.onUpdate;
        }
        var tween;
        options.onUpdate = function () {
            //如果context不存在说明该obj已经被destroy了，那么要把他的tween给destroy
            if (!self.context && tween) {
                AnimationFrame.destroyTween(tween);
                tween = null;
                return;
            }
            for (var p in this) {
                self.context[p] = this[p];
            }
            upFun.apply(self, [this]);
        };
        var compFun = function compFun() {};
        if (options.onComplete) {
            compFun = options.onComplete;
        }
        options.onComplete = function (opt) {
            compFun.apply(self, arguments);
        };
        tween = AnimationFrame.registTween(options);
        return tween;
    },
    //从树中删除
    remove: function remove() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent = null;
        }
    },
    //元素的自我销毁
    destroy: function destroy() {
        this.remove();
        this.fire("destroy");
        //把自己从父节点中删除了后做自我清除，释放内存
        this.context = null;
        delete this.context;
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3的DisplayList 中的容器类
 */
var DisplayObjectContainer = function DisplayObjectContainer(opt) {
    var self = this;
    self.children = [];
    self.mouseChildren = [];
    DisplayObjectContainer.superclass.constructor.apply(this, arguments);

    //所有的容器默认支持event 检测，因为 可能有里面的shape是eventEnable是true的
    //如果用户有强制的需求让容器下的所有元素都 不可检测，可以调用
    //DisplayObjectContainer的 setEventEnable() 方法
    self._eventEnabled = true;
};

Utils.creatClass(DisplayObjectContainer, DisplayObject, {
    addChild: function addChild(child, index) {
        if (!child) {
            return;
        }
        if (this.getChildIndex(child) != -1) {
            child.parent = this;
            return child;
        }
        //如果他在别的子元素中，那么就从别人那里删除了
        if (child.parent) {
            child.parent.removeChild(child);
        }

        if (index === undefined) {
            index = this.children.length;
        }

        this.children.splice(index, 0, child);

        child.parent = this;

        if (this.heartBeat) {
            this.heartBeat({
                convertType: "children",
                target: child,
                src: this
            });
        }

        if (this._afterAddChild) {
            this._afterAddChild(child);
        }

        if (this.worldTransform) {
            //如果过自己已经有了世界坐标了，那么要把新添加进来的所有节点包括其子节点都设置好世界坐标
            this.updateChildWorldTransform();
        }

        return child;
    },
    addChildAt: function addChildAt(child, index) {
        return this.addChild(child, index);
    },
    removeChild: function removeChild(child) {
        return this.removeChildAt(_$1.indexOf(this.children, child));
    },
    removeChildAt: function removeChildAt(index) {
        if (index < 0 || index > this.children.length - 1) {
            return false;
        }
        var child = this.children[index];
        if (child != null) {
            child.parent = null;
        }
        this.children.splice(index, 1);

        if (this.heartBeat) {
            this.heartBeat({
                convertType: "children",
                target: child,
                src: this
            });
        }

        if (this._afterDelChild) {
            this._afterDelChild(child, index);
        }

        return child;
    },
    removeChildById: function removeChildById(id) {
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i].id == id) {
                return this.removeChildAt(i);
            }
        }
        return false;
    },
    removeAllChildren: function removeAllChildren() {
        while (this.children.length > 0) {
            this.removeChildAt(0);
        }
    },
    //集合类的自我销毁
    destroy: function destroy() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent = null;
        }
        this.fire("destroy");
        //依次销毁所有子元素
        for (var i = 0, l = this.children.length; i < l; i++) {
            this.getChildAt(i).destroy();
            i--;
            l--;
        }
    },
    /*
     *@id 元素的id
     *@boolen 是否深度查询，默认就在第一层子元素中查询
     **/
    getChildById: function getChildById(id, boolen) {
        if (!boolen) {
            for (var i = 0, len = this.children.length; i < len; i++) {
                if (this.children[i].id == id) {
                    return this.children[i];
                }
            }
        } else {
            //深度查询
            //TODO:暂时未实现
            return null;
        }
        return null;
    },
    getChildAt: function getChildAt(index) {
        if (index < 0 || index > this.children.length - 1) return null;
        return this.children[index];
    },
    getChildIndex: function getChildIndex(child) {
        return _$1.indexOf(this.children, child);
    },
    setChildIndex: function setChildIndex(child, index) {
        if (child.parent != this) return;
        var oldIndex = _$1.indexOf(this.children, child);
        if (index == oldIndex) return;
        this.children.splice(oldIndex, 1);
        this.children.splice(index, 0, child);
    },
    getNumChildren: function getNumChildren() {
        return this.children.length;
    },
    //获取x,y点上的所有object  num 需要返回的obj数量
    getObjectsUnderPoint: function getObjectsUnderPoint(point, num) {
        var result = [];

        for (var i = this.children.length - 1; i >= 0; i--) {
            var child = this.children[i];

            if (child == null || !child._eventEnabled && !child.dragEnabled || !child.context.visible) {
                continue;
            }
            if (child instanceof DisplayObjectContainer) {
                //是集合
                if (child.mouseChildren && child.getNumChildren() > 0) {
                    var objs = child.getObjectsUnderPoint(point);
                    if (objs.length > 0) {
                        result = result.concat(objs);
                    }
                }
            } else {
                //非集合，可以开始做getChildInPoint了
                if (child.getChildInPoint(point)) {
                    result.push(child);
                    if (num != undefined && !isNaN(num)) {
                        if (result.length == num) {
                            return result;
                        }
                    }
                }
            }
        }
        return result;
    },
    //更新所有子节点的世界坐标
    updateChildWorldTransform: function updateChildWorldTransform() {
        _$1.each(this.children, function (obj) {
            obj.getWorldTransform();
            if (obj.children) {
                obj.updateChildWorldTransform();
            }
        });
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * stage 类， 再as3中，stage则代表整个舞台。是唯一的根节点
 * 但是再canvax中，因为分层设计的需要。stage 舞台 同样代表一个canvas元素，但是不是再整个引擎设计
 * 里面， 不是唯一的根节点。而是会交由canvax类来统一管理其层级
 */
var Stage = function Stage(opt) {
    var self = this;
    self.type = "stage";
    self.canvas = null;
    self.ctx = null; //渲染的时候由renderer决定,这里不做初始值
    //stage正在渲染中
    self.stageRending = false;
    self._isReady = false;

    Stage.superclass.constructor.apply(this, arguments);
};
Utils.creatClass(Stage, DisplayObjectContainer, {
    init: function init() {},
    //由canvax的afterAddChild 回调
    initStage: function initStage(canvas, width, height) {
        var self = this;
        self.canvas = canvas;
        self.context.width = width;
        self.context.height = height;
        self.context.scaleX = Utils._devicePixelRatio;
        self.context.scaleY = Utils._devicePixelRatio;
        self._isReady = true;
    },
    heartBeat: function heartBeat(opt) {
        //shape , name , value , preValue 
        //displayList中某个属性改变了
        if (!this._isReady) {
            //在stage还没初始化完毕的情况下，无需做任何处理
            return;
        }
        opt || (opt = {}); //如果opt为空，说明就是无条件刷新
        opt.stage = this;

        //TODO临时先这么处理
        this.parent && this.parent.heartBeat(opt);
    }
});

var SystemRenderer = function () {
    function SystemRenderer() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDERER_TYPE.UNKNOWN;
        var app = arguments[1];
        var options = arguments[2];
        classCallCheck(this, SystemRenderer);

        this.type = type; //2canvas,1webgl
        this.app = app;

        //prepare options
        if (options) {
            for (var i in settings.RENDER_OPTIONS) {
                if (typeof options[i] === 'undefined') {
                    options[i] = settings.RENDER_OPTIONS[i];
                }
            }
        } else {
            options = settings.RENDER_OPTIONS;
        }

        this.options = options;

        this.requestAid = null;

        this._heartBeat = false; //心跳，默认为false，即false的时候引擎处于静默状态 true则启动渲染

        this._preRenderTime = 0;
    }

    //如果引擎处于静默状态的话，就会启动


    createClass(SystemRenderer, [{
        key: 'startEnter',
        value: function startEnter() {
            var self = this;
            if (!self.requestAid) {
                self.requestAid = AnimationFrame.registFrame({
                    id: "enterFrame", //同时肯定只有一个enterFrame的task
                    task: function task() {
                        self.enterFrame.apply(self);
                    }
                });
            }
        }
    }, {
        key: 'enterFrame',
        value: function enterFrame() {
            var self = this;
            //不管怎么样，enterFrame执行了就要把
            //requestAid null 掉
            self.requestAid = null;
            Utils.now = new Date().getTime();
            if (self._heartBeat) {

                var _begin = new Date().getTime();
                self.render(this.app);
                var _end = new Date().getTime();
                console.log(_end - _begin);

                self._heartBeat = false;
                //渲染完了，打上最新时间挫
                self._preRenderTime = new Date().getTime();
            }
        }
    }, {
        key: '_convertCanvax',
        value: function _convertCanvax(opt) {
            var me = this;
            _$1.each(me.app.children, function (stage) {
                stage.context[opt.name] = opt.value;
            });
        }
    }, {
        key: 'heartBeat',
        value: function heartBeat(opt) {
            //displayList中某个属性改变了
            var self = this;
            if (opt) {
                //心跳包有两种，一种是某元素的可视属性改变了。一种是children有变动
                //分别对应convertType  为 context  and children
                if (opt.convertType == "context") {
                    var stage = opt.stage;
                    var shape = opt.shape;
                    var name = opt.name;
                    var value = opt.value;
                    var preValue = opt.preValue;

                    if (shape.type == "canvax") {
                        self._convertCanvax(opt);
                    } else {
                        if (!self.app.convertStages[stage.id]) {
                            self.app.convertStages[stage.id] = {
                                stage: stage,
                                convertShapes: {}
                            };
                        }
                        if (shape) {
                            if (!self.app.convertStages[stage.id].convertShapes[shape.id]) {
                                self.app.convertStages[stage.id].convertShapes[shape.id] = {
                                    shape: shape,
                                    convertType: opt.convertType
                                };
                            } else {
                                //如果已经上报了该 shape 的心跳。
                                return;
                            }
                        }
                    }
                }

                if (opt.convertType == "children") {
                    //元素结构变化，比如addchild removeChild等
                    var target = opt.target;
                    var stage = opt.src.getStage();
                    if (stage || target.type == "stage") {
                        //如果操作的目标元素是Stage
                        stage = stage || target;
                        if (!self.app.convertStages[stage.id]) {
                            self.app.convertStages[stage.id] = {
                                stage: stage,
                                convertShapes: {}
                            };
                        }
                    }
                }

                if (!opt.convertType) {
                    //无条件要求刷新
                    var stage = opt.stage;
                    if (!self.app.convertStages[stage.id]) {
                        self.app.convertStages[stage.id] = {
                            stage: stage,
                            convertShapes: {}
                        };
                    }
                }
            } else {
                //无条件要求全部刷新，一般用在resize等。
                _$1.each(self.app.children, function (stage, i) {
                    self.app.convertStages[stage.id] = {
                        stage: stage,
                        convertShapes: {}
                    };
                });
            }
            if (!self._heartBeat) {
                //如果发现引擎在静默状态，那么就唤醒引擎
                self._heartBeat = true;
                self.startEnter();
            } else {
                //否则智慧继续确认心跳
                self._heartBeat = true;
            }
        }
    }]);
    return SystemRenderer;
}();

var CanvasGraphicsRenderer = function () {
    function CanvasGraphicsRenderer(renderer) {
        classCallCheck(this, CanvasGraphicsRenderer);

        this.renderer = renderer;
    }

    /**
    * @param displayObject
    * @stage 也可以displayObject.getStage()获取。
    */


    createClass(CanvasGraphicsRenderer, [{
        key: 'render',
        value: function render(displayObject, stage) {
            var renderer = this.renderer;
            var graphicsData = displayObject.graphicsData;
            var ctx = stage.ctx;
            var context = displayObject.context;

            if (displayObject.parent) {
                context.globalAlpha *= displayObject.parent.context.globalAlpha;
            }

            for (var i = 0; i < graphicsData.length; i++) {
                var data = graphicsData[i];
                var shape = data.shape;

                var fillStyle = data.fillStyle;
                var strokeStyle = data.strokeStyle;

                var fill = data.hasFill() && data.fillAlpha;
                var line = data.hasLine() && data.lineAlpha;

                ctx.lineWidth = data.lineWidth;

                if (data.type === SHAPES.POLY) {
                    ctx.beginPath();

                    this.renderPolygon(shape.points, shape.closed, ctx);

                    if (fill) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    if (line) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.stroke();
                    }
                } else if (data.type === SHAPES.RECT) {
                    if (fill) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                    }
                    if (line) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                    }
                } else if (data.type === SHAPES.CIRC) {

                    // TODO - need to be Undefined!
                    ctx.beginPath();
                    ctx.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                    ctx.closePath();

                    if (fill) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    if (line) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.stroke();
                    }
                } else if (data.type === SHAPES.ELIP) {
                    var w = shape.width * 2;
                    var h = shape.height * 2;

                    var x = shape.x - w / 2;
                    var y = shape.y - h / 2;

                    ctx.beginPath();

                    var kappa = 0.5522848;
                    var ox = w / 2 * kappa; // control point offset horizontal
                    var oy = h / 2 * kappa; // control point offset vertical
                    var xe = x + w; // x-end
                    var ye = y + h; // y-end
                    var xm = x + w / 2; // x-middle
                    var ym = y + h / 2; // y-middle

                    ctx.moveTo(x, ym);
                    ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                    ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                    ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                    ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

                    ctx.closePath();

                    if (fill) {
                        ctx.globalAlpha = data.fillAlpha;
                        ctx.fillStyle = fillStyle;
                        ctx.fill();
                    }
                    if (line) {
                        ctx.globalAlpha = data.lineAlpha;
                        ctx.strokeStyle = strokeStyle;
                        ctx.stroke();
                    }
                }
            }
        }
    }, {
        key: 'renderPolygon',
        value: function renderPolygon(points, close, ctx) {
            ctx.moveTo(points[0], points[1]);

            for (var j = 1; j < points.length / 2; ++j) {
                ctx.lineTo(points[j * 2], points[j * 2 + 1]);
            }

            if (close) {
                ctx.closePath();
            }
        }
    }]);
    return CanvasGraphicsRenderer;
}();

var GraphicsData = function () {
    function GraphicsData(lineWidth, strokeStyle, lineAlpha, fillStyle, fillAlpha, shape, displayObject) {
        classCallCheck(this, GraphicsData);

        this.lineWidth = lineWidth;
        this.strokeStyle = strokeStyle;
        this.lineAlpha = lineAlpha;

        this.fillStyle = fillStyle;
        this.fillAlpha = fillAlpha;

        this.shape = shape;
        this.type = shape.type;

        //在graphicsData中保持一份对displayObject的引用，后续可以从这里那全局矩阵等
        //其在Dispaly.Shape.addCurrentPath2GD中进行设置
        this.displayObject = displayObject;

        this.holes = [];

        //这两个可以被后续修改， 具有一票否决权
        //比如polygon的 虚线描边。必须在fill的poly上面设置line为false
        this.fill = true;
        this.line = true;
    }

    createClass(GraphicsData, [{
        key: "clone",
        value: function clone() {
            return new GraphicsData(this.lineWidth, this.strokeStyle, this.lineAlpha, this.fillStyle, this.fillAlpha, this.shape, this.displayObject);
        }
    }, {
        key: "addHole",
        value: function addHole(shape) {
            this.holes.push(shape);
        }

        //从宿主graphics中同步最新的style属性

    }, {
        key: "synsStyle",
        value: function synsStyle(graphics) {
            //从shape中把绘图需要的style属性同步过来
            this.lineWidth = graphics.lineWidth;
            this.strokeStyle = graphics.strokeStyle;
            this.lineAlpha = graphics.lineAlpha;

            this.fillStyle = graphics.fillStyle;
            this.fillAlpha = graphics.fillAlpha;
        }
    }, {
        key: "hasFill",
        value: function hasFill() {
            return this.fillStyle && this.fill && this.shape.closed !== undefined && this.shape.closed;
        }
    }, {
        key: "hasLine",
        value: function hasLine() {
            return this.strokeStyle && this.lineWidth && this.line;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.shape = null;
            this.holes = null;
            this.displayObject = null;
        }
    }]);
    return GraphicsData;
}();

/**
 * The Point object represents a location in a two-dimensional coordinate system, where x represents
 * the horizontal axis and y represents the vertical axis.
 *
 * @class
 * @memberof PIXI
 */
var Point$2 = function () {
  /**
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  function Point() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    classCallCheck(this, Point);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;
  }

  /**
   * Creates a clone of this point
   *
   * @return {PIXI.Point} a copy of the point
   */


  createClass(Point, [{
    key: "clone",
    value: function clone() {
      return new Point(this.x, this.y);
    }

    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.Point} p - The point to copy.
     */

  }, {
    key: "copy",
    value: function copy(p) {
      this.set(p.x, p.y);
    }

    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.Point} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */

  }, {
    key: "equals",
    value: function equals(p) {
      return p.x === this.x && p.y === this.y;
    }

    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */

  }, {
    key: "set",
    value: function set$$1(x, y) {
      this.x = x || 0;
      this.y = y || (y !== 0 ? this.x : 0);
    }
  }]);
  return Point;
}();

var arcToSegmentsCache = {};
var segmentToBezierCache = {};
var boundsOfCurveCache = {};
var _join = Array.prototype.join;

/* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
 * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
 * http://mozilla.org/MPL/2.0/
 */
function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
  var argsString = _join.call(arguments);
  if (arcToSegmentsCache[argsString]) {
    return arcToSegmentsCache[argsString];
  }

  var PI = Math.PI,
      th = rotateX * PI / 180,
      sinTh = Math.sin(th),
      cosTh = Math.cos(th),
      fromX = 0,
      fromY = 0;

  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
      py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
      rx2 = rx * rx,
      ry2 = ry * ry,
      py2 = py * py,
      px2 = px * px,
      pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
      root = 0;

  if (pl < 0) {
    var s = Math.sqrt(1 - pl / (rx2 * ry2));
    rx *= s;
    ry *= s;
  } else {
    root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));
  }

  var cx = root * rx * py / ry,
      cy = -root * ry * px / rx,
      cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
      cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
      mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
      dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

  if (sweep === 0 && dtheta > 0) {
    dtheta -= 2 * PI;
  } else if (sweep === 1 && dtheta < 0) {
    dtheta += 2 * PI;
  }

  // Convert into cubic bezier segments <= 90deg
  var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
      result = [],
      mDelta = dtheta / segments,
      mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
      th3 = mTheta + mDelta;

  for (var i = 0; i < segments; i++) {
    result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
    fromX = result[i][4];
    fromY = result[i][5];
    mTheta = th3;
    th3 += mDelta;
  }
  arcToSegmentsCache[argsString] = result;
  return result;
}

function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
  var argsString2 = _join.call(arguments);
  if (segmentToBezierCache[argsString2]) {
    return segmentToBezierCache[argsString2];
  }

  var costh2 = Math.cos(th2),
      sinth2 = Math.sin(th2),
      costh3 = Math.cos(th3),
      sinth3 = Math.sin(th3),
      toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
      toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
      cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2),
      cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2),
      cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3),
      cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);

  segmentToBezierCache[argsString2] = [cp1X, cp1Y, cp2X, cp2Y, toX, toY];
  return segmentToBezierCache[argsString2];
}

/*
 * Private
 */
function calcVectorAngle(ux, uy, vx, vy) {
  var ta = Math.atan2(uy, ux),
      tb = Math.atan2(vy, vx);
  if (tb >= ta) {
    return tb - ta;
  } else {
    return 2 * Math.PI - (ta - tb);
  }
}

/**
 * Draws arc
 * @param {graphics} graphics
 * @param {Number} fx
 * @param {Number} fy
 * @param {Array} coords
 */
var drawArc = function drawArc(graphics, fx, fy, coords) {
  var rx = coords[0],
      ry = coords[1],
      rot = coords[2],
      large = coords[3],
      sweep = coords[4],
      tx = coords[5],
      ty = coords[6],
      segs = [[], [], [], []],
      segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

  for (var i = 0, len = segsNorm.length; i < len; i++) {
    segs[i][0] = segsNorm[i][0] + fx;
    segs[i][1] = segsNorm[i][1] + fy;
    segs[i][2] = segsNorm[i][2] + fx;
    segs[i][3] = segsNorm[i][3] + fy;
    segs[i][4] = segsNorm[i][4] + fx;
    segs[i][5] = segsNorm[i][5] + fy;
    graphics.bezierCurveTo.apply(graphics, segs[i]);
  }
};

/**
 * Calculate bounding box of a elliptic-arc
 * @param {Number} fx start point of arc
 * @param {Number} fy
 * @param {Number} rx horizontal radius
 * @param {Number} ry vertical radius
 * @param {Number} rot angle of horizontal axe
 * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
 * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
 * @param {Number} tx end point of arc
 * @param {Number} ty
 */
var getBoundsOfArc = function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

  var fromX = 0,
      fromY = 0,
      bound,
      bounds = [],
      segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

  for (var i = 0, len = segs.length; i < len; i++) {
    bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
    bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
    bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
    fromX = segs[i][4];
    fromY = segs[i][5];
  }
  return bounds;
};

/**
 * Calculate bounding box of a beziercurve
 * @param {Number} x0 starting point
 * @param {Number} y0
 * @param {Number} x1 first control point
 * @param {Number} y1
 * @param {Number} x2 secondo control point
 * @param {Number} y2
 * @param {Number} x3 end of beizer
 * @param {Number} y3
 */
// taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
  var argsString = _join.call(arguments);
  if (boundsOfCurveCache[argsString]) {
    return boundsOfCurveCache[argsString];
  }

  var sqrt = Math.sqrt,
      min = Math.min,
      max = Math.max,
      abs = Math.abs,
      tvalues = [],
      bounds = [[], []],
      a,
      b,
      c,
      t,
      t1,
      t2,
      b2ac,
      sqrtb2ac;

  b = 6 * x0 - 12 * x1 + 6 * x2;
  a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
  c = 3 * x1 - 3 * x0;

  for (var i = 0; i < 2; ++i) {
    if (i > 0) {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (abs(a) < 1e-12) {
      if (abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (0 < t && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    b2ac = b * b - 4 * c * a;
    if (b2ac < 0) {
      continue;
    }
    sqrtb2ac = sqrt(b2ac);
    t1 = (-b + sqrtb2ac) / (2 * a);
    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }
    t2 = (-b - sqrtb2ac) / (2 * a);
    if (0 < t2 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var x,
      y,
      j = tvalues.length,
      jlen = j,
      mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[0][j] = x;

    y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    bounds[1][j] = y;
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  var result = [{
    x: min.apply(null, bounds[0]),
    y: min.apply(null, bounds[1])
  }, {
    x: max.apply(null, bounds[0]),
    y: max.apply(null, bounds[1])
  }];
  boundsOfCurveCache[argsString] = result;
  return result;
}

var Arc = {
  drawArc: drawArc,
  getBoundsOfCurve: getBoundsOfCurve,
  getBoundsOfArc: getBoundsOfArc
};

/**
 * Rectangle object is an area defined by its position, as indicated by its top-left corner
 * point (x, y) and by its width and its height.
 *
 * @class
 * @memberof PIXI
 */

var Rectangle = function () {
    /**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
     * @param {number} [width=0] - The overall width of this rectangle
     * @param {number} [height=0] - The overall height of this rectangle
     */
    function Rectangle() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        classCallCheck(this, Rectangle);

        /**
         * @member {number}
         * @default 0
         */
        this.x = x;

        /**
         * @member {number}
         * @default 0
         */
        this.y = y;

        /**
         * @member {number}
         * @default 0
         */
        this.width = width;

        /**
         * @member {number}
         * @default 0
         */
        this.height = height;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */
        this.type = SHAPES.RECT;
    }

    /**
     * returns the left edge of the rectangle
     *
     * @member {number}
     */


    createClass(Rectangle, [{
        key: 'clone',


        /**
         * Creates a clone of this Rectangle
         *
         * @return {PIXI.Rectangle} a copy of the rectangle
         */
        value: function clone() {
            return new Rectangle(this.x, this.y, this.width, this.height);
        }

        /**
         * Copies another rectangle to this one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to copy.
         * @return {PIXI.Rectangle} Returns itself.
         */

    }, {
        key: 'copy',
        value: function copy(rectangle) {
            this.x = rectangle.x;
            this.y = rectangle.y;
            this.width = rectangle.width;
            this.height = rectangle.height;

            return this;
        }

        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this Rectangle
         */

    }, {
        key: 'contains',
        value: function contains(x, y) {
            if (this.width <= 0 || this.height <= 0) {
                return false;
            }

            if (x >= this.x && x < this.x + this.width) {
                if (y >= this.y && y < this.y + this.height) {
                    return true;
                }
            }

            return false;
        }

        /**
         * Pads the rectangle making it grow in all directions.
         *
         * @param {number} paddingX - The horizontal padding amount.
         * @param {number} paddingY - The vertical padding amount.
         */

    }, {
        key: 'pad',
        value: function pad(paddingX, paddingY) {
            paddingX = paddingX || 0;
            paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);

            this.x -= paddingX;
            this.y -= paddingY;

            this.width += paddingX * 2;
            this.height += paddingY * 2;
        }

        /**
         * Fits this rectangle around the passed one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
         */

    }, {
        key: 'fit',
        value: function fit(rectangle) {
            if (this.x < rectangle.x) {
                this.width += this.x;
                if (this.width < 0) {
                    this.width = 0;
                }

                this.x = rectangle.x;
            }

            if (this.y < rectangle.y) {
                this.height += this.y;
                if (this.height < 0) {
                    this.height = 0;
                }
                this.y = rectangle.y;
            }

            if (this.x + this.width > rectangle.x + rectangle.width) {
                this.width = rectangle.width - this.x;
                if (this.width < 0) {
                    this.width = 0;
                }
            }

            if (this.y + this.height > rectangle.y + rectangle.height) {
                this.height = rectangle.height - this.y;
                if (this.height < 0) {
                    this.height = 0;
                }
            }
        }

        /**
         * Enlarges this rectangle to include the passed rectangle.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to include.
         */

    }, {
        key: 'enlarge',
        value: function enlarge(rectangle) {
            var x1 = Math.min(this.x, rectangle.x);
            var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
            var y1 = Math.min(this.y, rectangle.y);
            var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);

            this.x = x1;
            this.width = x2 - x1;
            this.y = y1;
            this.height = y2 - y1;
        }
    }, {
        key: 'left',
        get: function get$$1() {
            return this.x;
        }

        /**
         * returns the right edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'right',
        get: function get$$1() {
            return this.x + this.width;
        }

        /**
         * returns the top edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'top',
        get: function get$$1() {
            return this.y;
        }

        /**
         * returns the bottom edge of the rectangle
         *
         * @member {number}
         */

    }, {
        key: 'bottom',
        get: function get$$1() {
            return this.y + this.height;
        }

        /**
         * A constant empty rectangle.
         *
         * @static
         * @constant
         */

    }], [{
        key: 'EMPTY',
        get: function get$$1() {
            return new Rectangle(0, 0, 0, 0);
        }
    }]);
    return Rectangle;
}();

/**
 * The Circle object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */

var Circle = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this circle
   * @param {number} [y=0] - The Y coordinate of the center of this circle
   * @param {number} [radius=0] - The radius of the circle
   */
  function Circle() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    classCallCheck(this, Circle);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.radius = radius;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.CIRC
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.CIRC;

    this.closed = true;
  }

  /**
   * Creates a clone of this Circle instance
   *
   * @return {PIXI.Circle} a copy of the Circle
   */


  createClass(Circle, [{
    key: 'clone',
    value: function clone() {
      return new Circle(this.x, this.y, this.radius);
    }

    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */

  }, {
    key: 'contains',
    value: function contains(x, y) {
      if (this.radius <= 0) {
        return false;
      }

      var r2 = this.radius * this.radius;
      var dx = this.x - x;
      var dy = this.y - y;

      dx *= dx;
      dy *= dy;

      return dx + dy <= r2;
    }

    /**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */

  }, {
    key: 'getBounds',
    value: function getBounds() {
      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
  }]);
  return Circle;
}();

/**
 * The Ellipse object can be used to specify a hit area for displayObjects
 *
 * @class
 * @memberof PIXI
 */

var Ellipse = function () {
  /**
   * @param {number} [x=0] - The X coordinate of the center of this circle
   * @param {number} [y=0] - The Y coordinate of the center of this circle
   * @param {number} [width=0] - The half width of this ellipse
   * @param {number} [height=0] - The half height of this ellipse
   */
  function Ellipse() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    classCallCheck(this, Ellipse);

    /**
     * @member {number}
     * @default 0
     */
    this.x = x;

    /**
     * @member {number}
     * @default 0
     */
    this.y = y;

    /**
     * @member {number}
     * @default 0
     */
    this.width = width;

    /**
     * @member {number}
     * @default 0
     */
    this.height = height;

    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     *
     * @member {number}
     * @readOnly
     * @default PIXI.SHAPES.ELIP
     * @see PIXI.SHAPES
     */
    this.type = SHAPES.ELIP;

    this.closed = true;
  }

  /**
   * Creates a clone of this Ellipse instance
   *
   * @return {PIXI.Ellipse} a copy of the ellipse
   */


  createClass(Ellipse, [{
    key: 'clone',
    value: function clone() {
      return new Ellipse(this.x, this.y, this.width, this.height);
    }

    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */

  }, {
    key: 'contains',
    value: function contains(x, y) {
      if (this.width <= 0 || this.height <= 0) {
        return false;
      }

      // normalize the coords to an ellipse with center 0,0
      var normx = (x - this.x) / this.width;
      var normy = (y - this.y) / this.height;

      normx *= normx;
      normy *= normy;

      return normx + normy <= 1;
    }

    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */

  }, {
    key: 'getBounds',
    value: function getBounds() {
      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
  }]);
  return Ellipse;
}();

/**
 * @class
 * @memberof PIXI
 */

var Polygon = function () {
    /**
     * @param {PIXI.Point[]|number[]} points - This can be an array of Points
     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
     *  the arguments passed can be all the points of the polygon e.g.
     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
     */
    function Polygon() {
        for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
            points[_key] = arguments[_key];
        }

        classCallCheck(this, Polygon);

        if (Array.isArray(points[0])) {
            points = points[0];
        }

        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof Point$2) {
            var p = [];

            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }

            points = p;
        }

        this.closed = true;

        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;

        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = SHAPES.POLY;
    }

    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */


    createClass(Polygon, [{
        key: 'clone',
        value: function clone() {
            return new Polygon(this.points.slice());
        }

        /**
         * Closes the polygon, adding points if necessary.
         *
         */

    }, {
        key: 'close',
        value: function close() {
            var points = this.points;
            if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
                points.push(points[0], points[1]);
            }
            this.closed = true;
        }
    }, {
        key: 'contains',
        value: function contains(x, y) {
            return this._isInsidePolygon_WindingNumber(x, y);
        }

        /**
         * 多边形包含判断 Nonzero Winding Number Rule
         */

    }, {
        key: '_isInsidePolygon_WindingNumber',
        value: function _isInsidePolygon_WindingNumber(x, y) {
            var points = this.points;
            var wn = 0;
            for (var shiftP, shift = points[1] > y, i = 3; i < points.length; i += 2) {
                shiftP = shift;
                shift = points[i] > y;
                if (shiftP != shift) {
                    var n = (shiftP ? 1 : 0) - (shift ? 1 : 0);
                    if (n * ((points[i - 3] - x) * (points[i - 0] - y) - (points[i - 2] - y) * (points[i - 1] - x)) > 0) {
                        wn += n;
                    }
                }
            }
            return wn;
        }
    }]);
    return Polygon;
}();

/**
 * Math classes and utilities mixed into PIXI namespace.
 *
 * @lends PIXI
 */

function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    var path = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];

    var n = 20;
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;

    path.push(fromX, fromY);

    for (var i = 1, j = 0; i <= n; ++i) {
        j = i / n;

        dt = 1 - j;
        dt2 = dt * dt;
        dt3 = dt2 * dt;

        t2 = j * j;
        t3 = t2 * j;

        path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }

    return path;
}

/*
* Graphics绘图法则
* 单个grahics实例里的fill line 样式属性，都从对应shape.context中获取
* 
*/

var Graphics = function () {
    function Graphics(shape) {
        classCallCheck(this, Graphics);

        this.lineWidth = 1;
        this.strokeStyle = null;
        this.lineAlpha = 1;
        this.fillStyle = null;
        this.fillAlpha = 1;

        this.graphicsData = [];
        this.currentPath = null;

        this.dirty = 0; //用于检测图形对象是否已更改。 如果这是设置为true，那么图形对象将被重新计算。
        this.clearDirty = 0; //用于检测我们是否清除了图形webGL数据

        this._webGL = {};
        this.worldAlpha = 1;
        this.tint = 0xFFFFFF; //目标对象附加颜色
    }

    createClass(Graphics, [{
        key: 'setStyle',
        value: function setStyle(context) {
            //从 shape 中把绘图需要的style属性同步过来
            this.lineWidth = context.lineWidth;
            this.strokeStyle = context.strokeStyle;
            this.lineAlpha = context.lineAlpha * context.globalAlpha;

            this.fillStyle = context.fillStyle;
            this.fillAlpha = context.fillAlpha * context.globalAlpha;
        }
    }, {
        key: 'clone',
        value: function clone() {
            var clone = new Graphics();

            clone.dirty = 0;

            // copy graphics data
            for (var i = 0; i < this.graphicsData.length; ++i) {
                clone.graphicsData.push(this.graphicsData[i].clone());
            }

            clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];
            return clone;
        }
    }, {
        key: 'moveTo',
        value: function moveTo(x, y) {
            var shape = new Polygon([x, y]);

            shape.closed = false;
            this.drawShape(shape);

            return this;
        }
    }, {
        key: 'lineTo',
        value: function lineTo(x, y) {
            if (this.currentPath) {
                this.currentPath.shape.points.push(x, y);
                this.dirty++;
            } else {
                this.moveTo(0, 0);
            }
            return this;
        }
    }, {
        key: 'quadraticCurveTo',
        value: function quadraticCurveTo(cpX, cpY, toX, toY) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points = [0, 0];
                }
            } else {
                this.moveTo(0, 0);
            }

            var n = 20;
            var points = this.currentPath.shape.points;
            var xa = 0;
            var ya = 0;

            if (points.length === 0) {
                this.moveTo(0, 0);
            }

            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];

            for (var i = 1; i <= n; ++i) {
                var j = i / n;

                xa = fromX + (cpX - fromX) * j;
                ya = fromY + (cpY - fromY) * j;

                points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
            }

            this.dirty++;

            return this;
        }
    }, {
        key: 'bezierCurveTo',
        value: function bezierCurveTo$$1(cpX, cpY, cpX2, cpY2, toX, toY) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points = [0, 0];
                }
            } else {
                this.moveTo(0, 0);
            }

            var points = this.currentPath.shape.points;

            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];

            points.length -= 2;

            bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);

            this.dirty++;

            return this;
        }
    }, {
        key: 'arcTo',
        value: function arcTo(x1, y1, x2, y2, radius) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points.push(x1, y1);
                }
            } else {
                this.moveTo(x1, y1);
            }

            var points = this.currentPath.shape.points;
            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];
            var a1 = fromY - y1;
            var b1 = fromX - x1;
            var a2 = y2 - y1;
            var b2 = x2 - x1;
            var mm = Math.abs(a1 * b2 - b1 * a2);

            if (mm < 1.0e-8 || radius === 0) {
                if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                    points.push(x1, y1);
                }
            } else {
                var dd = a1 * a1 + b1 * b1;
                var cc = a2 * a2 + b2 * b2;
                var tt = a1 * a2 + b1 * b2;
                var k1 = radius * Math.sqrt(dd) / mm;
                var k2 = radius * Math.sqrt(cc) / mm;
                var j1 = k1 * tt / dd;
                var j2 = k2 * tt / cc;
                var cx = k1 * b2 + k2 * b1;
                var cy = k1 * a2 + k2 * a1;
                var px = b1 * (k2 + j1);
                var py = a1 * (k2 + j1);
                var qx = b2 * (k1 + j2);
                var qy = a2 * (k1 + j2);
                var startAngle = Math.atan2(py - cy, px - cx);
                var endAngle = Math.atan2(qy - cy, qx - cx);

                this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
            }

            this.dirty++;

            return this;
        }
    }, {
        key: 'arc',
        value: function arc(cx, cy, radius, startAngle, endAngle) {
            var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

            if (startAngle === endAngle) {
                return this;
            }

            if (!anticlockwise && endAngle <= startAngle) {
                endAngle += Math.PI * 2;
            } else if (anticlockwise && startAngle <= endAngle) {
                startAngle += Math.PI * 2;
            }

            var sweep = endAngle - startAngle;
            var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;

            if (sweep === 0) {
                return this;
            }

            var startX = cx + Math.cos(startAngle) * radius;
            var startY = cy + Math.sin(startAngle) * radius;

            // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
            var points = this.currentPath ? this.currentPath.shape.points : null;

            if (points) {
                if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
                    points.push(startX, startY);
                }
            } else {
                this.moveTo(startX, startY);
                points = this.currentPath.shape.points;
            }

            var theta = sweep / (segs * 2);
            var theta2 = theta * 2;

            var cTheta = Math.cos(theta);
            var sTheta = Math.sin(theta);

            var segMinus = segs - 1;

            var remainder = segMinus % 1 / segMinus;

            for (var i = 0; i <= segMinus; ++i) {
                var real = i + remainder * i;

                var angle = theta + startAngle + theta2 * real;

                var c = Math.cos(angle);
                var s = -Math.sin(angle);

                points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
            }

            this.dirty++;

            return this;
        }
    }, {
        key: 'drawRect',
        value: function drawRect(x, y, width, height) {
            this.drawShape(new Rectangle(x, y, width, height));
            return this;
        }
    }, {
        key: 'drawCircle',
        value: function drawCircle(x, y, radius) {
            this.drawShape(new Circle(x, y, radius));

            return this;
        }
    }, {
        key: 'drawEllipse',
        value: function drawEllipse(x, y, width, height) {
            this.drawShape(new Ellipse(x, y, width, height));

            return this;
        }
    }, {
        key: 'drawPolygon',
        value: function drawPolygon(path) {
            // prevents an argument assignment deopt
            // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            var points = path;

            var closed = true;

            if (points instanceof Polygon) {
                closed = points.closed;
                points = points.points;
            }

            if (!Array.isArray(points)) {
                // prevents an argument leak deopt
                // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
                points = new Array(arguments.length);

                for (var i = 0; i < points.length; ++i) {
                    points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
                }
            }

            var shape = new Polygon(points);

            shape.closed = closed;

            this.drawShape(shape);

            return this;
        }
    }, {
        key: 'clear',
        value: function clear() {
            if (this.graphicsData.length > 0) {
                this.dirty++;
                this.clearDirty++;
                this.graphicsData.length = 0;
            }

            this.currentPath = null;

            return this;
        }
    }, {
        key: 'drawShape',
        value: function drawShape(shape) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length <= 2) {
                    this.graphicsData.pop();
                }
            }

            this.currentPath = null;

            var data = new GraphicsData(this.lineWidth, this.strokeStyle, this.lineAlpha, this.fillStyle, this.fillAlpha, shape);

            this.graphicsData.push(data);

            if (data.type === SHAPES.POLY) {
                data.shape.closed = data.shape.closed;
                this.currentPath = data;
            }

            this.dirty++;

            return data;
        }
    }, {
        key: 'beginPath',
        value: function beginPath() {
            this.currentPath = null;
        }
    }, {
        key: 'closePath',
        value: function closePath() {
            var currentPath = this.currentPath;

            if (currentPath && currentPath.shape) {
                currentPath.shape.close();
            }

            return this;
        }

        /**
        * Update the bounds of the object
        *
        */

    }, {
        key: 'updateLocalBounds',
        value: function updateLocalBounds() {
            var minX = Infinity;
            var maxX = -Infinity;

            var minY = Infinity;
            var maxY = -Infinity;

            if (this.graphicsData.length) {
                var shape = 0;
                var x = 0;
                var y = 0;
                var w = 0;
                var h = 0;

                for (var i = 0; i < this.graphicsData.length; i++) {
                    var data = this.graphicsData[i];
                    var type = data.type;
                    var lineWidth = data.lineWidth;

                    shape = data.shape;

                    if (type === SHAPES.RECT || type === SHAPES.RREC) {
                        x = shape.x - lineWidth / 2;
                        y = shape.y - lineWidth / 2;
                        w = shape.width + lineWidth;
                        h = shape.height + lineWidth;

                        minX = x < minX ? x : minX;
                        maxX = x + w > maxX ? x + w : maxX;

                        minY = y < minY ? y : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else if (type === SHAPES.CIRC) {
                        x = shape.x;
                        y = shape.y;
                        w = shape.radius + lineWidth / 2;
                        h = shape.radius + lineWidth / 2;

                        minX = x - w < minX ? x - w : minX;
                        maxX = x + w > maxX ? x + w : maxX;

                        minY = y - h < minY ? y - h : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else if (type === SHAPES.ELIP) {
                        x = shape.x;
                        y = shape.y;
                        w = shape.width + lineWidth / 2;
                        h = shape.height + lineWidth / 2;

                        minX = x - w < minX ? x - w : minX;
                        maxX = x + w > maxX ? x + w : maxX;

                        minY = y - h < minY ? y - h : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else {
                        // POLY
                        var points = shape.points;
                        var x2 = 0;
                        var y2 = 0;
                        var dx = 0;
                        var dy = 0;
                        var rw = 0;
                        var rh = 0;
                        var cx = 0;
                        var cy = 0;

                        for (var j = 0; j + 2 < points.length; j += 2) {
                            x = points[j];
                            y = points[j + 1];
                            x2 = points[j + 2];
                            y2 = points[j + 3];
                            dx = Math.abs(x2 - x);
                            dy = Math.abs(y2 - y);
                            h = lineWidth;
                            w = Math.sqrt(dx * dx + dy * dy);

                            if (w < 1e-9) {
                                continue;
                            }

                            rw = (h / w * dy + dx) / 2;
                            rh = (h / w * dx + dy) / 2;
                            cx = (x2 + x) / 2;
                            cy = (y2 + y) / 2;

                            minX = cx - rw < minX ? cx - rw : minX;
                            maxX = cx + rw > maxX ? cx + rw : maxX;

                            minY = cy - rh < minY ? cy - rh : minY;
                            maxY = cy + rh > maxY ? cy + rh : maxY;
                        }
                    }
                }
            } else {
                minX = 0;
                maxX = 0;
                minY = 0;
                maxY = 0;
            }

            this.Bound.minX = minX;
            this.Bound.maxX = maxX;

            this.Bound.minY = minY;
            this.Bound.maxY = maxY;
        }
    }, {
        key: 'destroy',
        value: function destroy(options) {
            get(Graphics.prototype.__proto__ || Object.getPrototypeOf(Graphics.prototype), 'destroy', this).call(this, options);

            for (var i = 0; i < this.graphicsData.length; ++i) {
                this.graphicsData[i].destroy();
            }
            for (var id in this._webGL) {
                for (var j = 0; j < this._webGL[id].data.length; ++j) {
                    this._webGL[id].data[j].destroy();
                }
            }

            this.graphicsData = null;
            this.currentPath = null;
            this._webGL = null;
        }
    }]);
    return Graphics;
}();

var CanvasRenderer = function (_SystemRenderer) {
    inherits(CanvasRenderer, _SystemRenderer);

    function CanvasRenderer(app) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        classCallCheck(this, CanvasRenderer);

        var _this = possibleConstructorReturn(this, (CanvasRenderer.__proto__ || Object.getPrototypeOf(CanvasRenderer)).call(this, RENDERER_TYPE.CANVAS, app, options));

        _this.CGR = new CanvasGraphicsRenderer(_this);
        //一个stage用一个graphics来绘制所有的shape
        _this.graphics = new Graphics();
        return _this;
    }

    createClass(CanvasRenderer, [{
        key: 'render',
        value: function render(app) {
            var me = this;
            me.app = app;
            _$1.each(_$1.values(app.convertStages), function (convertStage) {
                me.renderStage(convertStage.stage);
            });
            app.convertStages = {};
        }
    }, {
        key: 'renderStage',
        value: function renderStage(stage) {
            if (!stage.ctx) {
                stage.ctx = stage.canvas.getContext("2d");
            }
            stage.stageRending = true;
            this._clear(stage);
            this._render(stage);
            stage.stageRending = false;
        }
    }, {
        key: '_render',
        value: function _render(stage, displayObject) {
            if (!displayObject) {
                displayObject = stage;
            }

            if (!displayObject.context.visible || displayObject.context.globalAlpha <= 0) {
                return;
            }

            var ctx = stage.ctx;

            if (displayObject.graphicsData) {
                //当渲染器开始渲染app的时候，app下面的所有displayObject都已经准备好了对应的世界矩阵
                ctx.setTransform.apply(ctx, displayObject.worldTransform.toArray());
                displayObject._draw(stage, this); //_draw会完成绘制准备好 graphicsData
                this.CGR.render(displayObject, stage, this);
            }

            if (displayObject.children) {
                for (var i = 0, len = displayObject.children.length; i < len; i++) {
                    this._render(stage, displayObject.children[i]);
                }
            }
        }
    }, {
        key: '_clear',
        value: function _clear(stage) {
            var ctx = stage.ctx;
            ctx.setTransform.apply(ctx, stage.worldTransform.toArray());
            ctx.clearRect(0, 0, this.app.width, this.app.height);
        }
    }]);
    return CanvasRenderer;
}(SystemRenderer);

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/**
 * Helper class to create a webGL Context
 *
 * @class
 * @memberof PIXI.glCore
 * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
 * @param options {Object} An options object that gets passed in to the canvas element containing the context attributes,
 *                         see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext for the options available
 * @return {WebGLRenderingContext} the WebGL context
 */
var createContext = function(canvas, options)
{
    var gl = canvas.getContext('webgl', options) || 
         canvas.getContext('experimental-webgl', options);

    if (!gl)
    {
        // fail, not able to get a context
        throw new Error('This browser does not support webGL. Try using the canvas renderer');
    }

    return gl;
};

var createContext_1 = createContext;

// var GL_MAP = {};

/**
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param attribs {*}
 * @param state {*}
 */
var setVertexAttribArrays = function (gl, attribs, state)
{
    var i;
    if(state)
    {
        var tempAttribState = state.tempAttribState,
            attribState = state.attribState;

        for (i = 0; i < tempAttribState.length; i++)
        {
            tempAttribState[i] = false;
        }

        // set the new attribs
        for (i = 0; i < attribs.length; i++)
        {
            tempAttribState[attribs[i].attribute.location] = true;
        }

        for (i = 0; i < attribState.length; i++)
        {
            if (attribState[i] !== tempAttribState[i])
            {
                attribState[i] = tempAttribState[i];

                if (state.attribState[i])
                {
                    gl.enableVertexAttribArray(i);
                }
                else
                {
                    gl.disableVertexAttribArray(i);
                }
            }
        }

    }
    else
    {
        for (i = 0; i < attribs.length; i++)
        {
            var attrib = attribs[i];
            gl.enableVertexAttribArray(attrib.attribute.location);
        }
    }
};

var setVertexAttribArrays_1 = setVertexAttribArrays;

var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);

/**
 * Helper class to create a webGL buffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param type {gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER} @mat
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 * @param drawType {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
 */
var Buffer = function(gl, type, data, drawType)
{

	/**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
	this.gl = gl;

	/**
     * The WebGL buffer, created upon instantiation
     *
     * @member {WebGLBuffer}
     */
	this.buffer = gl.createBuffer();

	/**
     * The type of the buffer
     *
     * @member {gl.ARRAY_BUFFER|gl.ELEMENT_ARRAY_BUFFER}
     */
	this.type = type || gl.ARRAY_BUFFER;

	/**
     * The draw type of the buffer
     *
     * @member {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
     */
	this.drawType = drawType || gl.STATIC_DRAW;

	/**
     * The data in the buffer, as a typed array
     *
     * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
     */
	this.data = EMPTY_ARRAY_BUFFER;

	if(data)
	{
		this.upload(data);
	}

	this._updateID = 0;
};

/**
 * Uploads the buffer to the GPU
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data to upload
 * @param offset {Number} if only a subset of the data should be uploaded, this is the amount of data to subtract
 * @param dontBind {Boolean} whether to bind the buffer before uploading it
 */
Buffer.prototype.upload = function(data, offset, dontBind)
{
	// todo - needed?
	if(!dontBind) this.bind();

	var gl = this.gl;

	data = data || this.data;
	offset = offset || 0;

	if(this.data.byteLength >= data.byteLength)
	{
		gl.bufferSubData(this.type, offset, data);
	}
	else
	{
		gl.bufferData(this.type, data, this.drawType);
	}

	this.data = data;
};
/**
 * Binds the buffer
 *
 */
Buffer.prototype.bind = function()
{
	var gl = this.gl;
	gl.bindBuffer(this.type, this.buffer);
};

Buffer.createVertexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType);
};

Buffer.createIndexBuffer = function(gl, data, drawType)
{
	return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType);
};

Buffer.create = function(gl, type, data, drawType)
{
	return new Buffer(gl, type, data, drawType);
};

/**
 * Destroys the buffer
 *
 */
Buffer.prototype.destroy = function(){
	this.gl.deleteBuffer(this.buffer);
};

var GLBuffer = Buffer;

/**
 * Helper class to create a WebGL Texture
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param width {number} the width of the texture
 * @param height {number} the height of the texture
 * @param format {number} the pixel format of the texture. defaults to gl.RGBA
 * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE
 */
var Texture = function(gl, width, height, format, type)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;


	/**
	 * The WebGL texture
	 *
	 * @member {WebGLTexture}
	 */
	this.texture = gl.createTexture();

	/**
	 * If mipmapping was used for this texture, enable and disable with enableMipmap()
	 *
	 * @member {Boolean}
	 */
	// some settings..
	this.mipmap = false;


	/**
	 * Set to true to enable pre-multiplied alpha
	 *
	 * @member {Boolean}
	 */
	this.premultiplyAlpha = false;

	/**
	 * The width of texture
	 *
	 * @member {Number}
	 */
	this.width = width || -1;
	/**
	 * The height of texture
	 *
	 * @member {Number}
	 */
	this.height = height || -1;

	/**
	 * The pixel format of the texture. defaults to gl.RGBA
	 *
	 * @member {Number}
	 */
	this.format = format || gl.RGBA;

	/**
	 * The gl type of the texture. defaults to gl.UNSIGNED_BYTE
	 *
	 * @member {Number}
	 */
	this.type = type || gl.UNSIGNED_BYTE;


};

/**
 * Uploads this texture to the GPU
 * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture
 */
Texture.prototype.upload = function(source)
{
	this.bind();

	var gl = this.gl;


	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

	var newWidth = source.videoWidth || source.width;
	var newHeight = source.videoHeight || source.height;

	if(newHeight !== this.height || newWidth !== this.width)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);
	}
	else
	{
    	gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);
	}

	// if the source is a video, we need to use the videoWidth / videoHeight properties as width / height will be incorrect.
	this.width = newWidth;
	this.height = newHeight;

};

var FLOATING_POINT_AVAILABLE = false;

/**
 * Use a data source and uploads this texture to the GPU
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.prototype.uploadData = function(data, width, height)
{
	this.bind();

	var gl = this.gl;


	if(data instanceof Float32Array)
	{
		if(!FLOATING_POINT_AVAILABLE)
		{
			var ext = gl.getExtension("OES_texture_float");

			if(ext)
			{
				FLOATING_POINT_AVAILABLE = true;
			}
			else
			{
				throw new Error('floating point textures not available');
			}
		}

		this.type = gl.FLOAT;
	}
	else
	{
		// TODO support for other types
		this.type = this.type || gl.UNSIGNED_BYTE;
	}

	// what type of data?
	gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);


	if(width !== this.width || height !== this.height)
	{
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format,  width, height, 0, this.format, this.type, data || null);
	}
	else
	{
		gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);
	}

	this.width = width;
	this.height = height;


//	texSubImage2D
};

/**
 * Binds the texture
 * @param  location
 */
Texture.prototype.bind = function(location)
{
	var gl = this.gl;

	if(location !== undefined)
	{
		gl.activeTexture(gl.TEXTURE0 + location);
	}

	gl.bindTexture(gl.TEXTURE_2D, this.texture);
};

/**
 * Unbinds the texture
 */
Texture.prototype.unbind = function()
{
	var gl = this.gl;
	gl.bindTexture(gl.TEXTURE_2D, null);
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.minFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	if(this.mipmap)
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
	}
	else
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);
	}
};

/**
 * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
 */
Texture.prototype.magFilter = function( linear )
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);
};

/**
 * Enables mipmapping
 */
Texture.prototype.enableMipmap = function()
{
	var gl = this.gl;

	this.bind();

	this.mipmap = true;

	gl.generateMipmap(gl.TEXTURE_2D);
};

/**
 * Enables linear filtering
 */
Texture.prototype.enableLinearScaling = function()
{
	this.minFilter(true);
	this.magFilter(true);
};

/**
 * Enables nearest neighbour interpolation
 */
Texture.prototype.enableNearestScaling = function()
{
	this.minFilter(false);
	this.magFilter(false);
};

/**
 * Enables clamping on the texture so WebGL will not repeat it
 */
Texture.prototype.enableWrapClamp = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
};

/**
 * Enable tiling on the texture
 */
Texture.prototype.enableWrapRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
};

Texture.prototype.enableWrapMirrorRepeat = function()
{
	var gl = this.gl;

	this.bind();

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
};


/**
 * Destroys this texture
 */
Texture.prototype.destroy = function()
{
	var gl = this.gl;
	//TODO
	gl.deleteTexture(this.texture);
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param source {HTMLImageElement|ImageData} the source image of the texture
 * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha
 */
Texture.fromSource = function(gl, source, premultiplyAlpha)
{
	var texture = new Texture(gl);
	texture.premultiplyAlpha = premultiplyAlpha || false;
	texture.upload(source);

	return texture;
};

/**
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL context
 * @param data {TypedArray} the data to upload to the texture
 * @param width {number} the new width of the texture
 * @param height {number} the new height of the texture
 */
Texture.fromData = function(gl, data, width, height)
{
	//console.log(data, width, height);
	var texture = new Texture(gl);
	texture.uploadData(data, width, height);

	return texture;
};


var GLTexture = Texture;

/**
 * Helper class to create a webGL Framebuffer
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 */
var Framebuffer = function(gl, width, height)
{
    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * The frame buffer
     *
     * @member {WebGLFramebuffer}
     */
    this.framebuffer = gl.createFramebuffer();

    /**
     * The stencil buffer
     *
     * @member {WebGLRenderbuffer}
     */
    this.stencil = null;

    /**
     * The stencil buffer
     *
     * @member {PIXI.glCore.GLTexture}
     */
    this.texture = null;

    /**
     * The width of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.width = width || 100;
    /**
     * The height of the drawing area of the buffer
     *
     * @member {Number}
     */
    this.height = height || 100;
};

/**
 * Adds a texture to the frame buffer
 * @param texture {PIXI.glCore.GLTexture}
 */
Framebuffer.prototype.enableTexture = function(texture)
{
    var gl = this.gl;

    this.texture = texture || new GLTexture(gl);

    this.texture.bind();

    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    this.bind();

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
};

/**
 * Initialises the stencil buffer
 */
Framebuffer.prototype.enableStencil = function()
{
    if(this.stencil)return;

    var gl = this.gl;

    this.stencil = gl.createRenderbuffer();

    gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);

    // TODO.. this is depth AND stencil?
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.width  , this.height );


};

/**
 * Erases the drawing area and fills it with a colour
 * @param  r {Number} the red value of the clearing colour
 * @param  g {Number} the green value of the clearing colour
 * @param  b {Number} the blue value of the clearing colour
 * @param  a {Number} the alpha value of the clearing colour
 */
Framebuffer.prototype.clear = function( r, g, b, a )
{
    this.bind();

    var gl = this.gl;

    gl.clearColor(r, g, b, a);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};

/**
 * Binds the frame buffer to the WebGL context
 */
Framebuffer.prototype.bind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );
};

/**
 * Unbinds the frame buffer to the WebGL context
 */
Framebuffer.prototype.unbind = function()
{
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null );
};
/**
 * Resizes the drawing area of the buffer to the given width and height
 * @param  width  {Number} the new width
 * @param  height {Number} the new height
 */
Framebuffer.prototype.resize = function(width, height)
{
    var gl = this.gl;

    this.width = width;
    this.height = height;

    if ( this.texture )
    {
        this.texture.uploadData(null, width, height);
    }

    if ( this.stencil )
    {
        // update the stencil buffer width and height
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    }
};

/**
 * Destroys this buffer
 */
Framebuffer.prototype.destroy = function()
{
    var gl = this.gl;

    //TODO
    if(this.texture)
    {
        this.texture.destroy();
    }

    gl.deleteFramebuffer(this.framebuffer);

    this.gl = null;

    this.stencil = null;
    this.texture = null;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createRGBA = function(gl, width, height, data)
{
    var texture = GLTexture.fromData(gl, null, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);

    //fbo.enableStencil(); // get this back on soon!

    fbo.unbind();

    return fbo;
};

/**
 * Creates a frame buffer with a texture containing the given data
 * @static
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param width {Number} the width of the drawing area of the frame buffer
 * @param height {Number} the height of the drawing area of the frame buffer
 * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
 */
Framebuffer.createFloat32 = function(gl, width, height, data)
{
    // create a new texture..
    var texture = new GLTexture.fromData(gl, data, width, height);
    texture.enableNearestScaling();
    texture.enableWrapClamp();

    //now create the framebuffer object and attach the texture to it.
    var fbo = new Framebuffer(gl, width, height);
    fbo.enableTexture(texture);

    fbo.unbind();

    return fbo;
};

var GLFramebuffer$1 = Framebuffer;

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
var compileProgram = function(gl, vertexSrc, fragmentSrc, attributeLocations)
{
    var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
    var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);

    var program = gl.createProgram();

    gl.attachShader(program, glVertShader);
    gl.attachShader(program, glFragShader);

    // optionally, set the attributes manually for the program rather than letting WebGL decide..
    if(attributeLocations)
    {
        for(var i in attributeLocations)
        {
            gl.bindAttribLocation(program, attributeLocations[i], i);
        }
    }


    gl.linkProgram(program);

    // if linking fails, then log and cleanup
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        console.error('Pixi.js Error: Could not initialize shader.');
        console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error('gl.getError()', gl.getError());

        // if there is a program info log, log it
        if (gl.getProgramInfoLog(program) !== '')
        {
            console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
        }

        gl.deleteProgram(program);
        program = null;
    }

    // clean up some shaders
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);

    return program;
};

/**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
var compileShader = function (gl, type, src)
{
    var shader = gl.createShader(type);

    gl.shaderSource(shader, src);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        console.log(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
};

var compileProgram_1 = compileProgram;

var mapSize = function(gl, type) 
{
    if(!GL_TABLE) 
    {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);

        GL_TABLE = {};

        for(var i = 0; i < typeNames.length; ++i) 
        {
            var tn = typeNames[i];
            GL_TABLE[ gl[tn] ] = GL_TO_GLSL_TYPES[tn];
        }
    }

  return GL_TABLE[type];
};

var GL_TABLE = null;

var GL_TO_GLSL_TYPES = {
  'FLOAT':       'float',
  'FLOAT_VEC2':  'vec2',
  'FLOAT_VEC3':  'vec3',
  'FLOAT_VEC4':  'vec4',

  'INT':         'int',
  'INT_VEC2':    'ivec2',
  'INT_VEC3':    'ivec3',
  'INT_VEC4':    'ivec4',
  
  'BOOL':        'bool',
  'BOOL_VEC2':   'bvec2',
  'BOOL_VEC3':   'bvec3',
  'BOOL_VEC4':   'bvec4',
  
  'FLOAT_MAT2':  'mat2',
  'FLOAT_MAT3':  'mat3',
  'FLOAT_MAT4':  'mat4',
  
  'SAMPLER_2D':  'sampler2D'  
};

var mapType = mapSize;

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String}
 * @return {Number}
 */
var mapSize$1 = function(type) 
{ 
    return GLSL_TO_SIZE[type];
};


var GLSL_TO_SIZE = {
    'float':    1,
    'vec2':     2,
    'vec3':     3,
    'vec4':     4,

    'int':      1,
    'ivec2':    2,
    'ivec3':    3,
    'ivec4':    4,

    'bool':     1,
    'bvec2':    2,
    'bvec3':    3,
    'bvec4':    4,

    'mat2':     4,
    'mat3':     9,
    'mat4':     16,

    'sampler2D':  1
};

var mapSize_1 = mapSize$1;

/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the attributes from
 * @return attributes {Object}
 */
var extractAttributes = function(gl, program)
{
    var attributes = {};

    var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

    for (var i = 0; i < totalAttributes; i++)
    {
        var attribData = gl.getActiveAttrib(program, i);
        var type = mapType(gl, attribData.type);

        attributes[attribData.name] = {
            type:type,
            size:mapSize_1(type),
            location:gl.getAttribLocation(program, attribData.name),
            //TODO - make an attribute object
            pointer: pointer
        };
    }

    return attributes;
};

var pointer = function(type, normalized, stride, start){
    // console.log(this.location)
    gl.vertexAttribPointer(this.location,this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0);
};

var extractAttributes_1 = extractAttributes;

/**
 * @class
 * @memberof PIXI.glCore.shader
 * @param type {String} Type of value
 * @param size {Number}
 */
var defaultValue = function(type, size) 
{
    switch (type)
    {
        case 'float':
            return 0;

        case 'vec2': 
            return new Float32Array(2 * size);

        case 'vec3':
            return new Float32Array(3 * size);

        case 'vec4':     
            return new Float32Array(4 * size);
            
        case 'int':
        case 'sampler2D':
            return 0;

        case 'ivec2':   
            return new Int32Array(2 * size);

        case 'ivec3':
            return new Int32Array(3 * size);

        case 'ivec4': 
            return new Int32Array(4 * size);

        case 'bool':     
            return false;

        case 'bvec2':

            return booleanArray( 2 * size);

        case 'bvec3':
            return booleanArray(3 * size);

        case 'bvec4':
            return booleanArray(4 * size);

        case 'mat2':
            return new Float32Array([1, 0,
                                     0, 1]);

        case 'mat3': 
            return new Float32Array([1, 0, 0,
                                     0, 1, 0,
                                     0, 0, 1]);

        case 'mat4':
            return new Float32Array([1, 0, 0, 0,
                                     0, 1, 0, 0,
                                     0, 0, 1, 0,
                                     0, 0, 0, 1]);
    }
};

var booleanArray = function(size)
{
    var array = new Array(size);

    for (var i = 0; i < array.length; i++) 
    {
        array[i] = false;
    }

    return array;
};

var defaultValue_1 = defaultValue;

/**
 * Extracts the uniforms
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param program {WebGLProgram} The shader program to get the uniforms from
 * @return uniforms {Object}
 */
var extractUniforms = function(gl, program)
{
	var uniforms = {};

    var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    for (var i = 0; i < totalUniforms; i++)
    {
    	var uniformData = gl.getActiveUniform(program, i);
    	var name = uniformData.name.replace(/\[.*?\]/, "");
        var type = mapType(gl, uniformData.type );

    	uniforms[name] = {
    		type:type,
    		size:uniformData.size,
    		location:gl.getUniformLocation(program, name),
    		value:defaultValue_1(type, uniformData.size)
    	};
    }

	return uniforms;
};

var extractUniforms_1 = extractUniforms;

/**
 * Sets the float precision on the shader. If the precision is already present this function will do nothing
 * @param {string} src       the shader source
 * @param {string} precision The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 *
 * @return {string} modified shader source
 */
var setPrecision = function(src, precision)
{
    if(src.substring(0, 9) !== 'precision')
    {
        return 'precision ' + precision + ' float;\n' + src;
    }

    return src;
};

var setPrecision_1 = setPrecision;

/**
 * Extracts the attributes
 * @class
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 * @param uniforms {Array} @mat ?
 * @return attributes {Object}
 */
var generateUniformAccessObject = function(gl, uniformData)
{
    // this is the object we will be sending back.
    // an object hierachy will be created for structs
    var uniforms = {data:{}};

    uniforms.gl = gl;

    var uniformKeys= Object.keys(uniformData);

    for (var i = 0; i < uniformKeys.length; i++)
    {
        var fullName = uniformKeys[i];

        var nameTokens = fullName.split('.');
        var name = nameTokens[nameTokens.length - 1];


        var uniformGroup = getUniformGroup(nameTokens, uniforms);

        var uniform =  uniformData[fullName];
        uniformGroup.data[name] = uniform;

        uniformGroup.gl = gl;

        Object.defineProperty(uniformGroup, name, {
            get: generateGetter(name),
            set: generateSetter(name, uniform)
        });
    }

    return uniforms;
};

var generateGetter = function(name)
{
	var template = getterTemplate.replace('%%', name);
	return new Function(template); // jshint ignore:line
};

var generateSetter = function(name, uniform)
{
    var template = setterTemplate.replace(/%%/g, name);
    var setTemplate;

    if(uniform.size === 1)
    {
        setTemplate = GLSL_TO_SINGLE_SETTERS[uniform.type];
    }
    else
    {
        setTemplate = GLSL_TO_ARRAY_SETTERS[uniform.type];
    }

    if(setTemplate)
    {
        template += "\nthis.gl." + setTemplate + ";";
    }

  	return new Function('value', template); // jshint ignore:line
};

var getUniformGroup = function(nameTokens, uniform)
{
    var cur = uniform;

    for (var i = 0; i < nameTokens.length - 1; i++)
    {
        var o = cur[nameTokens[i]] || {data:{}};
        cur[nameTokens[i]] = o;
        cur = o;
    }

    return cur;
};

var getterTemplate = [
    'return this.data.%%.value;',
].join('\n');

var setterTemplate = [
    'this.data.%%.value = value;',
    'var location = this.data.%%.location;'
].join('\n');


var GLSL_TO_SINGLE_SETTERS = {

    'float':    'uniform1f(location, value)',

    'vec2':     'uniform2f(location, value[0], value[1])',
    'vec3':     'uniform3f(location, value[0], value[1], value[2])',
    'vec4':     'uniform4f(location, value[0], value[1], value[2], value[3])',

    'int':      'uniform1i(location, value)',
    'ivec2':    'uniform2i(location, value[0], value[1])',
    'ivec3':    'uniform3i(location, value[0], value[1], value[2])',
    'ivec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',

    'bool':     'uniform1i(location, value)',
    'bvec2':    'uniform2i(location, value[0], value[1])',
    'bvec3':    'uniform3i(location, value[0], value[1], value[2])',
    'bvec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',

    'mat2':     'uniformMatrix2fv(location, false, value)',
    'mat3':     'uniformMatrix3fv(location, false, value)',
    'mat4':     'uniformMatrix4fv(location, false, value)',

    'sampler2D':'uniform1i(location, value)'
};

var GLSL_TO_ARRAY_SETTERS = {

    'float':    'uniform1fv(location, value)',

    'vec2':     'uniform2fv(location, value)',
    'vec3':     'uniform3fv(location, value)',
    'vec4':     'uniform4fv(location, value)',

    'int':      'uniform1iv(location, value)',
    'ivec2':    'uniform2iv(location, value)',
    'ivec3':    'uniform3iv(location, value)',
    'ivec4':    'uniform4iv(location, value)',

    'bool':     'uniform1iv(location, value)',
    'bvec2':    'uniform2iv(location, value)',
    'bvec3':    'uniform3iv(location, value)',
    'bvec4':    'uniform4iv(location, value)',

    'sampler2D':'uniform1iv(location, value)'
};

var generateUniformAccessObject_1 = generateUniformAccessObject;

/**
 * Helper class to create a webGL Shader
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param precision {precision]} The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
 * @param attributeLocations {object} A key value pair showing which location eact attribute should sit eg {position:0, uvs:1}
 */
var Shader = function(gl, vertexSrc, fragmentSrc, precision, attributeLocations)
{
	/**
	 * The current WebGL rendering context
	 *
	 * @member {WebGLRenderingContext}
	 */
	this.gl = gl;

	if(precision)
	{
		vertexSrc = setPrecision_1(vertexSrc, precision);
		fragmentSrc = setPrecision_1(fragmentSrc, precision);
	}

	/**
	 * The shader program
	 *
	 * @member {WebGLProgram}
	 */
	// First compile the program..
	this.program = compileProgram_1(gl, vertexSrc, fragmentSrc, attributeLocations);

	/**
	 * The attributes of the shader as an object containing the following properties
	 * {
	 * 	type,
	 * 	size,
	 * 	location,
	 * 	pointer
	 * }
	 * @member {Object}
	 */
	// next extract the attributes
	this.attributes = extractAttributes_1(gl, this.program);

    this.uniformData = extractUniforms_1(gl, this.program);

	/**
	 * The uniforms of the shader as an object containing the following properties
	 * {
	 * 	gl,
	 * 	data
	 * }
	 * @member {Object}
	 */
	this.uniforms = generateUniformAccessObject_1( gl, this.uniformData );

};
/**
 * Uses this shader
 */
Shader.prototype.bind = function()
{
	this.gl.useProgram(this.program);
};

/**
 * Destroys this shader
 * TODO
 */
Shader.prototype.destroy = function()
{
	this.attributes = null;
	this.uniformData = null;
	this.uniforms = null;

	var gl = this.gl;
	gl.deleteProgram(this.program);
};


var GLShader = Shader;

// state object//


/**
 * Helper class to work with WebGL VertexArrayObjects (vaos)
 * Only works if WebGL extensions are enabled (they usually are)
 *
 * @class
 * @memberof PIXI.glCore
 * @param gl {WebGLRenderingContext} The current WebGL rendering context
 */
function VertexArrayObject(gl, state)
{
    this.nativeVaoExtension = null;

    if(!VertexArrayObject.FORCE_NATIVE)
    {
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') ||
                                  gl.getExtension('MOZ_OES_vertex_array_object') ||
                                  gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    this.nativeState = state;

    if(this.nativeVaoExtension)
    {
        this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();

        var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        // VAO - overwrite the state..
        this.nativeState = {
            tempAttribState: new Array(maxAttribs),
            attribState: new Array(maxAttribs)
        };
    }

    /**
     * The current WebGL rendering context
     *
     * @member {WebGLRenderingContext}
     */
    this.gl = gl;

    /**
     * An array of attributes
     *
     * @member {Array}
     */
    this.attributes = [];

    /**
     * @member {PIXI.glCore.GLBuffer}
     */
    this.indexBuffer = null;

    /**
     * A boolean flag
     *
     * @member {Boolean}
     */
    this.dirty = false;
}

VertexArrayObject.prototype.constructor = VertexArrayObject;
var VertexArrayObject_1 = VertexArrayObject;

/**
* Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
* If you find on older devices that things have gone a bit weird then set this to true.
*/
/**
 * Lets the VAO know if you should use the WebGL extension or the native methods.
 * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
 * If you find on older devices that things have gone a bit weird then set this to true.
 * @static
 * @property {Boolean} FORCE_NATIVE
 */
VertexArrayObject.FORCE_NATIVE = false;

/**
 * Binds the buffer
 */
VertexArrayObject.prototype.bind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);

        if(this.dirty)
        {
            this.dirty = false;
            this.activate();
        }
    }
    else
    {

        this.activate();
    }

    return this;
};

/**
 * Unbinds the buffer
 */
VertexArrayObject.prototype.unbind = function()
{
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(null);
    }

    return this;
};

/**
 * Uses this vao
 */
VertexArrayObject.prototype.activate = function()
{

    var gl = this.gl;
    var lastBuffer = null;

    for (var i = 0; i < this.attributes.length; i++)
    {
        var attrib = this.attributes[i];

        if(lastBuffer !== attrib.buffer)
        {
            attrib.buffer.bind();
            lastBuffer = attrib.buffer;
        }

        gl.vertexAttribPointer(attrib.attribute.location,
                               attrib.attribute.size,
                               attrib.type || gl.FLOAT,
                               attrib.normalized || false,
                               attrib.stride || 0,
                               attrib.start || 0);
    }

    setVertexAttribArrays_1(gl, this.attributes, this.nativeState);

    if(this.indexBuffer)
    {
        this.indexBuffer.bind();
    }

    return this;
};

/**
 *
 * @param buffer     {PIXI.gl.GLBuffer}
 * @param attribute  {*}
 * @param type       {String}
 * @param normalized {Boolean}
 * @param stride     {Number}
 * @param start      {Number}
 */
VertexArrayObject.prototype.addAttribute = function(buffer, attribute, type, normalized, stride, start)
{
    this.attributes.push({
        buffer:     buffer,
        attribute:  attribute,

        location:   attribute.location,
        type:       type || this.gl.FLOAT,
        normalized: normalized || false,
        stride:     stride || 0,
        start:      start || 0
    });

    this.dirty = true;

    return this;
};

/**
 *
 * @param buffer   {PIXI.gl.GLBuffer}
 */
VertexArrayObject.prototype.addIndex = function(buffer/*, options*/)
{
    this.indexBuffer = buffer;

    this.dirty = true;

    return this;
};

/**
 * Unbinds this vao and disables it
 */
VertexArrayObject.prototype.clear = function()
{
    // var gl = this.gl;

    // TODO - should this function unbind after clear?
    // for now, no but lets see what happens in the real world!
    if(this.nativeVao)
    {
        this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
    }

    this.attributes.length = 0;
    this.indexBuffer = null;

    return this;
};

/**
 * @param type  {Number}
 * @param size  {Number}
 * @param start {Number}
 */
VertexArrayObject.prototype.draw = function(type, size, start)
{
    var gl = this.gl;

    if(this.indexBuffer)
    {
        gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2 );
    }
    else
    {
        // TODO need a better way to calculate size..
        gl.drawArrays(type, start, size || this.getSize());
    }

    return this;
};

/**
 * Destroy this vao
 */
VertexArrayObject.prototype.destroy = function()
{
    // lose references
    this.gl = null;
    this.indexBuffer = null;
    this.attributes = null;
    this.nativeState = null;

    if(this.nativeVao)
    {
        this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);
    }

    this.nativeVaoExtension = null;
    this.nativeVao = null;
};

VertexArrayObject.prototype.getSize = function()
{
    var attrib = this.attributes[0];
    return attrib.buffer.data.length / (( attrib.stride/4 ) || attrib.attribute.size);
};

var index$1 = {
    compileProgram: compileProgram_1,
    defaultValue: defaultValue_1,
    extractAttributes: extractAttributes_1,
    extractUniforms: extractUniforms_1,
    generateUniformAccessObject: generateUniformAccessObject_1,
    setPrecision: setPrecision_1,
    mapSize: mapSize_1,
    mapType: mapType
};

var index = createCommonjsModule(function (module) {
var gl = {
    createContext:          createContext_1,
    setVertexAttribArrays:  setVertexAttribArrays_1,
    GLBuffer:               GLBuffer,
    GLFramebuffer:          GLFramebuffer$1,
    GLShader:               GLShader,
    GLTexture:              GLTexture,
    VertexArrayObject:      VertexArrayObject_1,
    shader:                 index$1
};

// Export for Node-compatible environments
if ('object' !== 'undefined' && module.exports)
{
    // Export the module
    module.exports = gl;
}

// Add to the browser window pixi.gl
if (typeof window !== 'undefined')
{
    // add the window object
    window.PIXI = window.PIXI || {};
    window.PIXI.glCore = gl;
}
});

var GLFramebuffer = index.GLFramebuffer;

var RenderTarget = function () {
    function RenderTarget(gl, width, height, resolution, root) {
        classCallCheck(this, RenderTarget);

        this.gl = gl;

        // framebuffer 是WebGL渲染的终点。当你看屏幕时，其他就是在看 framebuffer 中的内容。
        this.frameBuffer = null;

        this.clearColor = [0, 0, 0, 0];

        this.size = new Rectangle(0, 0, 1, 1);

        /**
         * 设备分辨率
         */
        this.resolution = resolution || settings.RESOLUTION;

        //投影矩阵，把所有的顶点投射到webgl的[-1,1]的坐标系内
        this.projectionMatrix = new Matrix();

        this.frame = null;

        this.defaultFrame = new Rectangle();
        this.destinationFrame = null;
        this.sourceFrame = null;

        this.root = root;

        this.frameBuffer = new GLFramebuffer(gl, 100, 100);
        this.frameBuffer.framebuffer = null;

        this.setFrame();

        this.resize(width, height);
    }

    createClass(RenderTarget, [{
        key: 'clear',
        value: function clear(clearColor) {
            var cc = clearColor || this.clearColor;

            this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);
        }
    }, {
        key: 'setFrame',
        value: function setFrame(destinationFrame, sourceFrame) {
            this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
            this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        }

        //在WebGLRenderer中被调用

    }, {
        key: 'activate',
        value: function activate() {
            var gl = this.gl;

            this.frameBuffer.bind();

            this.calculateProjection(this.destinationFrame, this.sourceFrame);

            if (this.destinationFrame !== this.sourceFrame) {
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
            } else {
                gl.disable(gl.SCISSOR_TEST);
            }

            gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
        }

        //计算投影矩阵，把所有的顶点数据投射到 webgl 的 [-1,1] 坐标系内来

    }, {
        key: 'calculateProjection',
        value: function calculateProjection(destinationFrame, sourceFrame) {
            var pm = this.projectionMatrix;

            sourceFrame = sourceFrame || destinationFrame;

            pm.identity();

            pm.a = 1 / destinationFrame.width * 2;
            pm.d = -1 / destinationFrame.height * 2;

            pm.tx = -1 - sourceFrame.x * pm.a;
            pm.ty = 1 - sourceFrame.y * pm.d;
        }

        //stage 的 size发生变化，需要重新初始化这些对象的size，尤其是 projectionMatrix 投影举证

    }, {
        key: 'resize',
        value: function resize(width, height) {
            width = width | 0;
            height = height | 0;

            if (this.size.width === width && this.size.height === height) {
                return;
            }

            this.size.width = width;
            this.size.height = height;

            this.defaultFrame.width = width;
            this.defaultFrame.height = height;

            this.frameBuffer.resize(width * this.resolution, height * this.resolution);

            var projectionFrame = this.frame || this.size;

            this.calculateProjection(projectionFrame);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.frameBuffer.destroy();
            this.frameBuffer = null;
        }
    }]);
    return RenderTarget;
}();

var DEPTH_TEST = 1;
var FRONT_FACE = 2;
var CULL_FACE = 3;

var WebGLState = function () {
    function WebGLState(gl) {
        classCallCheck(this, WebGLState);


        this.activeState = new Uint8Array(16);

        this.defaultState = new Uint8Array(16);

        this.defaultState[0] = 1;

        this.stackIndex = 0;

        this.stack = [];

        this.gl = gl;

        this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

        this.attribState = {
            tempAttribState: new Array(this.maxAttribs),
            attribState: new Array(this.maxAttribs)
        };

        // check we have vao..
        this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');
    }

    createClass(WebGLState, [{
        key: 'push',
        value: function push() {
            var state = this.stack[++this.stackIndex];

            if (!state) {
                state = this.stack[this.stackIndex] = new Uint8Array(16);
            }

            for (var i = 0; i < this.activeState.length; i++) {
                this.activeState[i] = state[i];
            }
        }
    }, {
        key: 'pop',
        value: function pop() {
            var state = this.stack[--this.stackIndex];

            this.setState(state);
        }
    }, {
        key: 'setState',
        value: function setState(state) {
            this.setDepthTest(state[DEPTH_TEST]);
            this.setFrontFace(state[FRONT_FACE]);
            this.setCullFace(state[CULL_FACE]);
        }
    }, {
        key: 'setDepthTest',
        value: function setDepthTest(value) {
            value = value ? 1 : 0;

            if (this.activeState[DEPTH_TEST] === value) {
                return;
            }

            this.activeState[DEPTH_TEST] = value;
            this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
        }
    }, {
        key: 'setCullFace',
        value: function setCullFace(value) {
            value = value ? 1 : 0;

            if (this.activeState[CULL_FACE] === value) {
                return;
            }

            this.activeState[CULL_FACE] = value;
            this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
        }
    }, {
        key: 'setFrontFace',
        value: function setFrontFace(value) {
            value = value ? 1 : 0;

            if (this.activeState[FRONT_FACE] === value) {
                return;
            }

            this.activeState[FRONT_FACE] = value;
            this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
        }
    }, {
        key: 'resetAttributes',
        value: function resetAttributes() {
            for (var i = 0; i < this.attribState.tempAttribState.length; i++) {
                this.attribState.tempAttribState[i] = 0;
            }

            for (var _i = 0; _i < this.attribState.attribState.length; _i++) {
                this.attribState.attribState[_i] = 0;
            }

            for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) {
                this.gl.disableVertexAttribArray(_i2);
            }
        }
    }, {
        key: 'resetToDefault',
        value: function resetToDefault() {
            if (this.nativeVaoExtension) {
                this.nativeVaoExtension.bindVertexArrayOES(null);
            }

            this.resetAttributes();

            for (var i = 0; i < this.activeState.length; ++i) {
                this.activeState[i] = 32;
            }

            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);

            this.setState(this.defaultState);
        }
    }]);
    return WebGLState;
}();

function hex2rgb(hex, out) {
  //hex可能是“#ff0000” 也可能是 0xff0000
  if (hex.replace) {
    hex = parseInt(hex.replace("#", "0X"), 16);
  }

  out = out || [];

  out[0] = (hex >> 16 & 0xFF) / 255;
  out[1] = (hex >> 8 & 0xFF) / 255;
  out[2] = (hex & 0xFF) / 255;

  return out;
}

var WebGLGraphicsData = function () {
  function WebGLGraphicsData(gl, shader, attribsState) {
    classCallCheck(this, WebGLGraphicsData);

    this.gl = gl;

    this.color = [0, 0, 0]; // color split!


    this.points = [];

    /**
     * The indices of the vertices
     * @member {number[]}
     */
    this.indices = [];
    /**
     * The main buffer
     * @member {WebGLBuffer}
     */
    this.buffer = index.GLBuffer.createVertexBuffer(gl);

    /**
     * The index buffer
     * @member {WebGLBuffer}
     */
    this.indexBuffer = index.GLBuffer.createIndexBuffer(gl);

    /**
     * Whether this graphics is dirty or not
     * @member {boolean}
     */
    this.dirty = true;

    this.glPoints = null;
    this.glIndices = null;

    /**
     *
     * @member {PIXI.Shader}
     */
    this.shader = shader;

    this.vao = new index.VertexArrayObject(gl, attribsState).addIndex(this.indexBuffer).addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4);
  }

  /**
   * Resets the vertices and the indices
   */


  createClass(WebGLGraphicsData, [{
    key: 'reset',
    value: function reset() {
      this.points.length = 0;
      this.indices.length = 0;
    }

    /**
     * Binds the buffers and uploads the data
     */

  }, {
    key: 'upload',
    value: function upload() {
      this.glPoints = new Float32Array(this.points);
      this.buffer.upload(this.glPoints);

      this.glIndices = new Uint16Array(this.indices);
      this.indexBuffer.upload(this.glIndices);

      this.dirty = false;
    }

    /**
     * Empties all the data
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.color = null;
      this.points = null;
      this.indices = null;

      this.vao.destroy();
      this.buffer.destroy();
      this.indexBuffer.destroy();

      this.gl = null;

      this.buffer = null;
      this.indexBuffer = null;

      this.glPoints = null;
      this.glIndices = null;
    }
  }]);
  return WebGLGraphicsData;
}();

var PRECISION = settings.PRECISION;

var GLShader$2 = index.GLShader;

function checkPrecision(src) {
    if (src instanceof Array) {
        if (src[0].substring(0, 9) !== 'precision') {
            var copy = src.slice(0);

            copy.unshift('precision ' + PRECISION + ' float;');

            return copy;
        }
    } else if (src.substring(0, 9) !== 'precision') {
        return 'precision ' + PRECISION + ' float;\n' + src;
    }

    return src;
}

/**
 * Wrapper class, webGL Shader for Pixi.
 * Adds precision string if vertexSrc or fragmentSrc have no mention of it.
 *
 * @class
 * @extends GLShader
 * @memberof PIXI
 */

var Shader$1 = function (_GLShader) {
    inherits(Shader, _GLShader);

    /**
     *
     * @param {WebGLRenderingContext} gl - The current WebGL rendering context
     * @param {string|string[]} vertexSrc - The vertex shader source as an array of strings.
     * @param {string|string[]} fragmentSrc - The fragment shader source as an array of strings.
     */
    function Shader(gl, vertexSrc, fragmentSrc) {
        classCallCheck(this, Shader);
        return possibleConstructorReturn(this, (Shader.__proto__ || Object.getPrototypeOf(Shader)).call(this, gl, checkPrecision(vertexSrc), checkPrecision(fragmentSrc)));
    }

    return Shader;
}(GLShader$2);

var PrimitiveShader = function (_Shader) {
    inherits(PrimitiveShader, _Shader);

    function PrimitiveShader(gl) {
        classCallCheck(this, PrimitiveShader);
        return possibleConstructorReturn(this, (PrimitiveShader.__proto__ || Object.getPrototypeOf(PrimitiveShader)).call(this, gl,
        //vertex shader
        ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'),
        // fragment shader
        ['varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n')));
    }

    return PrimitiveShader;
}(Shader$1);

function buildLine(graphicsData, webGLData) {
    var points = graphicsData.points;

    if (points.length === 0) {
        return;
    }

    var firstPoint = new Point$2(points[0], points[1]);
    var lastPoint = new Point$2(points[points.length - 2], points[points.length - 1]);

    if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
        points = points.slice();

        points.pop();
        points.pop();

        lastPoint = new Point$2(points[points.length - 2], points[points.length - 1]);

        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;

        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
    }

    var verts = webGLData.points;
    var indices = webGLData.indices;
    var length = points.length / 2;
    var indexCount = points.length;
    var indexStart = verts.length / 6;

    var width = graphicsData.lineWidth / 2;

    var color = hex2rgb(graphicsData.strokeStyle);
    var alpha = graphicsData.lineAlpha;
    var r = color[0] * alpha;
    var g = color[1] * alpha;
    var b = color[2] * alpha;

    var p1x = points[0];
    var p1y = points[1];
    var p2x = points[2];
    var p2y = points[3];
    var p3x = 0;
    var p3y = 0;

    var perpx = -(p1y - p2y);
    var perpy = p1x - p2x;
    var perp2x = 0;
    var perp2y = 0;
    var perp3x = 0;
    var perp3y = 0;

    var dist = Math.sqrt(perpx * perpx + perpy * perpy);

    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    // start
    verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);

    verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);

    for (var i = 1; i < length - 1; ++i) {
        p1x = points[(i - 1) * 2];
        p1y = points[(i - 1) * 2 + 1];

        p2x = points[i * 2];
        p2y = points[i * 2 + 1];

        p3x = points[(i + 1) * 2];
        p3y = points[(i + 1) * 2 + 1];

        perpx = -(p1y - p2y);
        perpy = p1x - p2x;

        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;

        perp2x = -(p2y - p3y);
        perp2y = p2x - p3x;

        dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
        perp2x /= dist;
        perp2y /= dist;
        perp2x *= width;
        perp2y *= width;

        var a1 = -perpy + p1y - (-perpy + p2y);
        var b1 = -perpx + p2x - (-perpx + p1x);
        var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
        var a2 = -perp2y + p3y - (-perp2y + p2y);
        var b2 = -perp2x + p2x - (-perp2x + p3x);
        var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);

        var denom = a1 * b2 - a2 * b1;

        if (Math.abs(denom) < 0.1) {
            denom += 10.1;
            verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);

            verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);

            continue;
        }

        var px = (b1 * c2 - b2 * c1) / denom;
        var py = (a2 * c1 - a1 * c2) / denom;
        var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);

        if (pdist > 196 * width * width) {
            perp3x = perpx - perp2x;
            perp3y = perpy - perp2y;

            dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
            perp3x /= dist;
            perp3y /= dist;
            perp3x *= width;
            perp3y *= width;

            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x + perp3x, p2y + perp3y);
            verts.push(r, g, b, alpha);

            verts.push(p2x - perp3x, p2y - perp3y);
            verts.push(r, g, b, alpha);

            indexCount++;
        } else {
            verts.push(px, py);
            verts.push(r, g, b, alpha);

            verts.push(p2x - (px - p2x), p2y - (py - p2y));
            verts.push(r, g, b, alpha);
        }
    }

    p1x = points[(length - 2) * 2];
    p1y = points[(length - 2) * 2 + 1];

    p2x = points[(length - 1) * 2];
    p2y = points[(length - 1) * 2 + 1];

    perpx = -(p1y - p2y);
    perpy = p1x - p2x;

    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;

    verts.push(p2x - perpx, p2y - perpy);
    verts.push(r, g, b, alpha);

    verts.push(p2x + perpx, p2y + perpy);
    verts.push(r, g, b, alpha);

    indices.push(indexStart);

    for (var _i = 0; _i < indexCount; ++_i) {
        indices.push(indexStart++);
    }

    indices.push(indexStart - 1);
}

var earcut_1 = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

function buildPoly(graphicsData, webGLData) {
    graphicsData.points = graphicsData.shape.points.slice();

    var points = graphicsData.points;

    if (graphicsData.hasFill() && graphicsData.fillAlpha && points.length >= 6) {
        var holeArray = [];
        var holes = graphicsData.holes;

        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];

            holeArray.push(points.length / 2);

            points = points.concat(hole.points);
        }

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var length = points.length / 2;

        var color = hex2rgb(graphicsData.fillStyle);
        var alpha = graphicsData.fillAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var triangles = earcut_1(points, holeArray, 2);

        if (!triangles) {
            return;
        }

        var vertPos = verts.length / 6;

        for (var _i = 0; _i < triangles.length; _i += 3) {
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i] + vertPos);
            indices.push(triangles[_i + 1] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
            indices.push(triangles[_i + 2] + vertPos);
        }

        for (var _i2 = 0; _i2 < length; _i2++) {
            verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);
        }
    }

    if (graphicsData.hasLine() && graphicsData.lineAlpha) {
        buildLine(graphicsData, webGLData);
    }
}

function buildRectangle(graphicsData, webGLData) {

    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;

    if (graphicsData.hasFill() && graphicsData.fillAlpha) {
        var color = hex2rgb(graphicsData.fillStyle);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vertPos = verts.length / 6;

        // start
        verts.push(x, y);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y);
        verts.push(r, g, b, alpha);

        verts.push(x, y + height);
        verts.push(r, g, b, alpha);

        verts.push(x + width, y + height);
        verts.push(r, g, b, alpha);

        // insert 2 dead triangles..
        indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
    }

    if (graphicsData.hasLine() && graphicsData.lineAlpha) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];

        buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}

function buildCircle(graphicsData, webGLData) {

    var circleData = graphicsData.shape;
    var x = circleData.x;
    var y = circleData.y;
    var width = void 0;
    var height = void 0;

    if (graphicsData.type === SHAPES.CIRC) {
        width = circleData.radius;
        height = circleData.radius;
    } else {
        width = circleData.width;
        height = circleData.height;
    }

    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));

    var seg = Math.PI * 2 / totalSegs;

    if (graphicsData.hasFill() && graphicsData.fillAlpha) {
        var color = hex2rgb(graphicsData.fillStyle);
        var alpha = graphicsData.fillAlpha;

        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;

        var verts = webGLData.points;
        var indices = webGLData.indices;

        var vecPos = verts.length / 6;

        indices.push(vecPos);

        for (var i = 0; i < totalSegs + 1; i++) {
            verts.push(x, y, r, g, b, alpha);

            verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);

            indices.push(vecPos++, vecPos++);
        }

        indices.push(vecPos - 1);
    }

    if (graphicsData.hasLine() && graphicsData.lineAlpha) {
        var tempPoints = graphicsData.points;

        graphicsData.points = [];

        for (var _i = 0; _i < totalSegs + 1; _i++) {
            graphicsData.points.push(x + Math.sin(seg * _i) * width, y + Math.cos(seg * _i) * height);
        }

        buildLine(graphicsData, webGLData);

        graphicsData.points = tempPoints;
    }
}

var GraphicsRenderer = function () {
    function GraphicsRenderer(renderer) {
        classCallCheck(this, GraphicsRenderer);

        this.renderer = renderer;
        this.graphicsDataPool = [];
        this.primitiveShader = null;
        this.gl = renderer.gl;
        this.CONTEXT_UID = 0;
    }

    createClass(GraphicsRenderer, [{
        key: 'onContextChange',
        value: function onContextChange() {
            this.gl = this.renderer.gl;
            this.CONTEXT_UID = this.renderer.CONTEXT_UID;
            this.primitiveShader = new PrimitiveShader(this.gl);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.renderer = null;

            for (var i = 0; i < this.graphicsDataPool.length; ++i) {
                this.graphicsDataPool[i].destroy();
            }

            this.graphicsDataPool = null;
        }
    }, {
        key: 'render',
        value: function render(displayObject, stage, graphics) {
            //const graphics = displayObject.graphics;
            var renderer = this.renderer;
            var gl = renderer.gl;

            var webGLData = void 0;
            var webGL = graphics._webGL[this.CONTEXT_UID];

            if (!webGL || graphics.dirty !== webGL.dirty) {
                this.updateGraphics(graphics, displayObject);

                webGL = graphics._webGL[this.CONTEXT_UID];
            }

            var shader = this.primitiveShader;

            renderer.bindShader(shader);

            for (var i = 0, n = webGL.data.length; i < n; i++) {
                webGLData = webGL.data[i];
                var shaderTemp = webGLData.shader;

                renderer.bindShader(shaderTemp);
                shaderTemp.uniforms.translationMatrix = displayObject.worldTransform;
                shaderTemp.uniforms.tint = hex2rgb(graphics.tint);
                shaderTemp.uniforms.alpha = graphics.worldAlpha;

                renderer.bindVao(webGLData.vao);
                webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);
            }
        }
    }, {
        key: 'updateGraphics',
        value: function updateGraphics(graphics, displayObject) {
            var gl = this.renderer.gl;

            var webGL = graphics._webGL[this.CONTEXT_UID];

            if (!webGL) {
                webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 };
            }

            webGL.dirty = graphics.dirty;

            if (graphics.clearDirty !== webGL.clearDirty) {
                webGL.clearDirty = graphics.clearDirty;

                for (var i = 0; i < webGL.data.length; i++) {
                    this.graphicsDataPool.push(webGL.data[i]);
                }

                webGL.data.length = 0;
                webGL.lastIndex = 0;
            }

            var webGLData = void 0;

            for (var _i = webGL.lastIndex; _i < displayObject.graphicsData.length; _i++) {
                var data = displayObject.graphicsData[_i];

                webGLData = this.getWebGLData(webGL, 0);

                if (data.type === SHAPES.POLY) {
                    buildPoly(data, webGLData);
                }
                if (data.type === SHAPES.RECT) {
                    buildRectangle(data, webGLData);
                } else if (data.type === SHAPES.CIRC || data.type === SHAPES.ELIP) {
                    buildCircle(data, webGLData);
                }

                webGL.lastIndex++;
            }

            this.renderer.bindVao(null);

            for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {
                webGLData = webGL.data[_i2];

                if (webGLData.dirty) {
                    webGLData.upload();
                }
            }
        }
    }, {
        key: 'getWebGLData',
        value: function getWebGLData(gl, type) {
            var webGLData = gl.data[gl.data.length - 1];

            if (!webGLData || webGLData.points.length > 320000) {
                webGLData = this.graphicsDataPool.pop() || new WebGLGraphicsData(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);

                webGLData.reset(type);
                gl.data.push(webGLData);
            }

            webGLData.dirty = true;

            return webGLData;
        }
    }]);
    return GraphicsRenderer;
}();

var CONTEXT_UID = 0;

var WebGLStageRenderer = function () {
    function WebGLStageRenderer(stage, app) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        classCallCheck(this, WebGLStageRenderer);

        this.type = RENDERER_TYPE.WEBGL;
        this.width = app.width;
        this.height = app.height;
        this.canvas = stage.canvas;

        /*
        * WebGL程序必须有一个用于处理上下文丢失（Lost Context）的机制
        * 导致上下文丢失的原因：
        * 移动设备电力不足
        * 其他外因导致GPU重置
        * 当浏览器标签页处于后台时，浏览器抛弃了上下文
        * 耗费资源过多，浏览器抛弃了上下文
        */
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        this.canvas.addEventListener('webglcontextlost', this.handleContextLost, false);
        this.canvas.addEventListener('webglcontextrestored', this.handleContextRestored, false);

        this._backgroundColorRgba = [0, 0, 0, 0];

        this._contextOptions = {
            alpha: options.transparent,
            antialias: options.antialias,
            premultipliedAlpha: options.transparent && options.transparent !== 'notMultiplied',
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer
        };

        this.gl = options.context || index.createContext(this.canvas, this._contextOptions);

        this.CONTEXT_UID = CONTEXT_UID++;

        this.state = new WebGLState(this.gl);

        this._activeShader = null;

        this._activeVao = null;

        this._activeRenderTarget = null;

        this.drawModes = this.mapWebGLDrawModes();

        this.webglGR = new GraphicsRenderer(this);

        this._initContext();
    }

    createClass(WebGLStageRenderer, [{
        key: '_initContext',
        value: function _initContext() {
            var gl = this.gl;

            // restore a context if it was previously lost
            if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
                gl.getExtension('WEBGL_lose_context').restoreContext();
            }

            this.state.resetToDefault();

            this.rootRenderTarget = new RenderTarget(gl, this.width, this.height, settings.RESOLUTION, true);
            this.rootRenderTarget.clearColor = this._backgroundColorRgba;

            this.bindRenderTarget(this.rootRenderTarget);

            this.webglGR.onContextChange();
        }
    }, {
        key: 'render',
        value: function render(displayObject, stage, graphics) {
            if (!this.gl || this.gl.isContextLost()) {
                return;
            }
            this.webglGR.render(displayObject, stage, graphics);
        }
    }, {
        key: 'resize',
        value: function resize(width, height) {
            this.rootRenderTarget.resize(width, height);
            if (this._activeRenderTarget === this.rootRenderTarget) {
                this.rootRenderTarget.activate();

                if (this._activeShader) {
                    this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);
                }
            }
        }
    }, {
        key: 'clear',
        value: function clear(clearColor) {
            this._activeRenderTarget.clear(clearColor);
        }
    }, {
        key: 'bindRenderTarget',
        value: function bindRenderTarget(renderTarget) {
            if (renderTarget !== this._activeRenderTarget) {
                this._activeRenderTarget = renderTarget;
                renderTarget.activate();

                if (this._activeShader) {
                    this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);
                }
            }
            return this;
        }
    }, {
        key: 'bindShader',
        value: function bindShader(shader) {
            if (this._activeShader !== shader) {
                this._activeShader = shader;
                shader.bind();
                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);
            }

            return this;
        }
    }, {
        key: 'createVao',
        value: function createVao() {
            return new index.VertexArrayObject(this.gl, this.state.attribState);
        }
    }, {
        key: 'bindVao',
        value: function bindVao(vao) {
            if (this._activeVao === vao) {
                return this;
            }

            if (vao) {
                vao.bind();
            } else if (this._activeVao) {
                this._activeVao.unbind();
            }

            this._activeVao = vao;

            return this;
        }
    }, {
        key: 'reset',
        value: function reset() {
            this._activeShader = null;
            this._activeRenderTarget = this.rootRenderTarget;

            this.rootRenderTarget.activate();

            this.state.resetToDefault();

            return this;
        }
    }, {
        key: 'handleContextLost',
        value: function handleContextLost(event) {
            event.preventDefault();
        }
    }, {
        key: 'handleContextRestored',
        value: function handleContextRestored() {
            this._initContext();
            this.textureManager.removeAll();
        }
    }, {
        key: 'mapWebGLDrawModes',
        value: function mapWebGLDrawModes() {
            var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            object[DRAW_MODES.POINTS] = this.gl.POINTS;
            object[DRAW_MODES.LINES] = this.gl.LINES;
            object[DRAW_MODES.LINE_LOOP] = this.gl.LINE_LOOP;
            object[DRAW_MODES.LINE_STRIP] = this.gl.LINE_STRIP;
            object[DRAW_MODES.TRIANGLES] = this.gl.TRIANGLES;
            object[DRAW_MODES.TRIANGLE_STRIP] = this.gl.TRIANGLE_STRIP;
            object[DRAW_MODES.TRIANGLE_FAN] = this.gl.TRIANGLE_FAN;

            return object;
        }
    }, {
        key: 'destroy',
        value: function destroy(removeView) {
            this.destroyPlugins();

            this.canvas.removeEventListener('webglcontextlost', this.handleContextLost);
            this.canvas.removeEventListener('webglcontextrestored', this.handleContextRestored);

            get(WebGLStageRenderer.prototype.__proto__ || Object.getPrototypeOf(WebGLStageRenderer.prototype), 'destroy', this).call(this, removeView);

            this.uid = 0;

            this.handleContextLost = null;
            this.handleContextRestored = null;

            this._contextOptions = null;
            this.gl.useProgram(null);

            if (this.gl.getExtension('WEBGL_lose_context')) {
                this.gl.getExtension('WEBGL_lose_context').loseContext();
            }

            this.gl = null;
        }
    }]);
    return WebGLStageRenderer;
}();

var WebGLRenderer = function (_SystemRenderer) {
    inherits(WebGLRenderer, _SystemRenderer);

    function WebGLRenderer(app) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        classCallCheck(this, WebGLRenderer);

        var _this = possibleConstructorReturn(this, (WebGLRenderer.__proto__ || Object.getPrototypeOf(WebGLRenderer)).call(this, RENDERER_TYPE.CANVAS, app, options));

        _this.graphics = new Graphics();
        return _this;
    }

    createClass(WebGLRenderer, [{
        key: 'render',
        value: function render(app) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var me = this;

            me.app = app;
            _$1.extend(this.options, options);

            _$1.each(_$1.values(app.convertStages), function (convertStage) {
                me.renderStage(convertStage.stage);
            });

            app.convertStages = {};
        }
    }, {
        key: 'renderStage',
        value: function renderStage(stage) {
            if (!stage.webGLStageRenderer) {
                stage.webGLStageRenderer = new WebGLStageRenderer(stage, app, this.options);
            }
            stage.stageRending = true;
            this._clear(stage);
            this._render(stage);
            stage.stageRending = false;
        }
    }, {
        key: '_render',
        value: function _render(stage, displayObject) {
            if (!displayObject) {
                displayObject = stage;
            }

            if (!displayObject.context.visible || displayObject.context.globalAlpha <= 0) {
                return;
            }

            if (displayObject.graphicsData) {
                displayObject.draw(stage, this);
                stage.webGLStageRenderer.render(displayObject, stage, this.graphics);
            }

            if (displayObject.children) {
                for (var i = 0, len = displayObject.children.length; i < len; i++) {
                    this._render(stage, displayObject.children[i]);
                }
            }
        }
    }, {
        key: '_clear',
        value: function _clear(stage) {
            stage.webGLStageRenderer.clear();
        }
    }]);
    return WebGLRenderer;
}(SystemRenderer);

function autoRenderer(app, options) {
    if (app.webGL && Utils.isWebGLSupported()) {
        return new WebGLRenderer(app, options);
    }
    return new CanvasRenderer(app, options);
}

/**
 * Application {{PKG_VERSION}}
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 主引擎 类
 *
 * 负责所有canvas的层级管理，和心跳机制的实现,捕获到心跳包后 
 * 分发到对应的stage(canvas)来绘制对应的改动
 * 然后 默认有实现了shape的 mouseover  mouseout  drag 事件
 *
 **/

//utils
var Application = function Application(opt) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this.type = "canvax";
    this._cid = new Date().getTime() + "_" + Math.floor(Math.random() * 100);

    this.el = $.query(opt.el);

    this.width = parseInt("width" in opt || this.el.offsetWidth, 10);
    this.height = parseInt("height" in opt || this.el.offsetHeight, 10);

    var viewObj = $.createView(this.width, this.height, this._cid);
    this.view = viewObj.view;
    this.stage_c = viewObj.stage_c;
    this.dom_c = viewObj.dom_c;

    this.el.innerHTML = "";
    this.el.appendChild(this.view);

    this.viewOffset = $.offset(this.view);
    this.lastGetRO = 0; //最后一次获取 viewOffset 的时间

    this.webGL = opt.webGL;
    this.renderer = autoRenderer(this, options);

    this.event = null;

    this._bufferStage = null;

    //是否阻止浏览器默认事件的执行
    this.preventDefault = true;
    if (opt.preventDefault === false) {
        this.preventDefault = false;
    }

    //该属性在systenRender里面操作，每帧由心跳上报的 需要重绘的stages 列表
    this.convertStages = {};

    Application.superclass.constructor.apply(this, arguments);
};

Utils.creatClass(Application, DisplayObjectContainer, {
    init: function init() {
        this.context.width = this.width;
        this.context.height = this.height;

        //然后创建一个用于绘制激活 shape 的 stage 到activation
        this._creatHoverStage();

        //创建一个如果要用像素检测的时候的容器
        this._createPixelContext();

        //设置一个默认的matrix做为app的世界根节点坐标
        this.worldTransform = new Matrix().identity();
    },
    registEvent: function registEvent(opt) {
        //初始化事件委托到root元素上面
        this.event = new EventHandler(this, opt);
        this.event.init();
        return this.event;
    },
    resize: function resize(opt) {
        //重新设置坐标系统 高宽 等。
        this.width = parseInt(opt && "width" in opt || this.el.offsetWidth, 10);
        this.height = parseInt(opt && "height" in opt || this.el.offsetHeight, 10);

        this.view.style.width = this.width + "px";
        this.view.style.height = this.height + "px";

        this.viewOffset = $.offset(this.view);
        this._notWatch = true;
        this.context.width = this.width;
        this.context.height = this.height;
        this._notWatch = false;

        var me = this;
        var reSizeCanvas = function reSizeCanvas(ctx) {
            var canvas = ctx.canvas;
            canvas.style.width = me.width + "px";
            canvas.style.height = me.height + "px";
            canvas.setAttribute("width", me.width * Utils._devicePixelRatio);
            canvas.setAttribute("height", me.height * Utils._devicePixelRatio);

            //如果是swf的话就还要调用这个方法。
            if (ctx.resize) {
                ctx.resize(me.width, me.height);
            }
        };
        _$1.each(this.children, function (s, i) {
            s._notWatch = true;
            s.context.width = me.width;
            s.context.height = me.height;
            reSizeCanvas(s.canvas);
            s._notWatch = false;
        });

        this.dom_c.style.width = this.width + "px";
        this.dom_c.style.height = this.height + "px";

        this.heartBeat();
    },
    getHoverStage: function getHoverStage() {
        return this._bufferStage;
    },
    _creatHoverStage: function _creatHoverStage() {
        //TODO:创建stage的时候一定要传入width height  两个参数
        this._bufferStage = new Stage({
            id: "activCanvas" + new Date().getTime(),
            context: {
                width: this.context.width,
                height: this.context.height
            }
        });
        //该stage不参与事件检测
        this._bufferStage._eventEnabled = false;
        this.addChild(this._bufferStage);
    },
    /**
     * 用来检测文本width height 
     * @return {Object} 上下文
    */
    _createPixelContext: function _createPixelContext() {
        var _pixelCanvas = $.query("_pixelCanvas");
        if (!_pixelCanvas) {
            _pixelCanvas = $.createCanvas(0, 0, "_pixelCanvas");
        } else {
            //如果又的话 就不需要在创建了
            return;
        }
        document.body.appendChild(_pixelCanvas);
        Utils.initElement(_pixelCanvas);
        if (Utils.canvasSupport()) {
            //canvas的话，哪怕是display:none的页可以用来左像素检测和measureText文本width检测
            _pixelCanvas.style.display = "none";
        } else {
            //flashCanvas 的话，swf如果display:none了。就做不了measureText 文本宽度 检测了
            _pixelCanvas.style.zIndex = -1;
            _pixelCanvas.style.position = "absolute";
            _pixelCanvas.style.left = -this.context.width + "px";
            _pixelCanvas.style.top = -this.context.height + "px";
            _pixelCanvas.style.visibility = "hidden";
        }
        Utils._pixelCtx = _pixelCanvas.getContext('2d');
    },

    updateViewOffset: function updateViewOffset() {
        var now = new Date().getTime();
        if (now - this.lastGetRO > 1000) {
            this.viewOffset = $.offset(this.view);
            this.lastGetRO = now;
        }
    },

    _afterAddChild: function _afterAddChild(stage, index) {
        var canvas;

        if (!stage.canvas) {
            canvas = $.createCanvas(this.context.width, this.context.height, stage.id);
        } else {
            canvas = stage.canvas;
        }

        if (this.children.length == 1) {
            this.stage_c.appendChild(canvas);
        } else if (this.children.length > 1) {
            if (index == undefined) {
                //如果没有指定位置，那么就放到_bufferStage的下面。
                this.stage_c.insertBefore(canvas, this._bufferStage.canvas);
            } else {
                //如果有指定的位置，那么就指定的位置来
                if (index >= this.children.length - 1) {
                    this.stage_c.appendChild(canvas);
                } else {
                    this.stage_c.insertBefore(canvas, this.children[index].canvas);
                }
            }
        }

        Utils.initElement(canvas);
        stage.initStage(canvas, this.context.width, this.context.height);
    },
    _afterDelChild: function _afterDelChild(stage) {
        this.stage_c.removeChild(stage.canvas);
    },

    heartBeat: function heartBeat(opt) {
        if (this.children.length > 0) {
            this.renderer.heartBeat(opt);
        }
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3 中 的sprite类，目前还只是个简单的容易。
 */
var Sprite = function Sprite() {
    this.type = "sprite";
    Sprite.superclass.constructor.apply(this, arguments);
};

Utils.creatClass(Sprite, DisplayObjectContainer, {
    init: function init() {}
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 模拟as3 DisplayList 中的shape 类
 */
var Shape = function (_DisplayObject) {
    inherits(Shape, _DisplayObject);

    function Shape(opt) {
        classCallCheck(this, Shape);


        opt = Utils.checkOpt(opt);
        var _context = _$1.extend(_$1.clone(SHAPE_CONTEXT_DEFAULT), opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this, opt));

        _this.graphicsData = [];

        //元素是否有hover事件 和 chick事件，由addEvenetLister和remiveEventLister来触发修改
        _this._hoverable = false;
        _this._clickable = false;

        //over的时候如果有修改样式，就为true
        _this._hoverClass = false;
        _this.hoverClone = true; //是否开启在hover的时候clone一份到active stage 中 
        _this.pointChkPriority = true; //在鼠标mouseover到该节点，然后mousemove的时候，是否优先检测该节点

        //拖拽drag的时候显示在activShape的副本
        _this._dragDuplicate = null;

        //元素是否 开启 drag 拖动，这个有用户设置传入
        //self.draggable = opt.draggable || false;

        _this.type = _this.type || "shape";
        opt.draw && (_this.draw = opt.draw);

        //处理所有的图形一些共有的属性配置,把除开id,context之外的所有属性，全部挂载到this上面
        _this.initCompProperty(opt);

        _this._rect = null;
        return _this;
    }

    createClass(Shape, [{
        key: "_draw",
        value: function _draw(stage, renderer) {
            if (this.graphicsData.length == 0) {
                //先设置好当前graphics的style
                renderer.graphics.setStyle(this.context);

                var lastGDind = renderer.graphics.graphicsData.length;
                this.draw(renderer.graphics);
                this.graphicsData = renderer.graphics.graphicsData.slice(lastGDind);
                var me = this;
                _$1.each(this.graphicsData, function (gd) {
                    gd.displayObject = me;
                });
            }
        }
    }, {
        key: "clearGraphicsData",
        value: function clearGraphicsData() {
            _$1.each(this.graphicsData, function (d) {
                d.destroy();
            });
            this.graphicsData.length = 0;
        }
    }, {
        key: "$watch",
        value: function $watch(name, value, preValue) {
            this.watch(name, value, preValue);
        }
    }, {
        key: "initCompProperty",
        value: function initCompProperty(opt) {
            for (var i in opt) {
                if (i != "id" && i != "context") {
                    this[i] = opt[i];
                }
            }
        }

        /*
         * 画虚线
         */

    }, {
        key: "dashedLineTo",
        value: function dashedLineTo(graphics, x1, y1, x2, y2, dashLength) {
            dashLength = typeof dashLength == 'undefined' ? 3 : dashLength;
            dashLength = Math.max(dashLength, this.context.lineWidth);
            var deltaX = x2 - x1;
            var deltaY = y2 - y1;
            var numDashes = Math.floor(Math.sqrt(deltaX * deltaX + deltaY * deltaY) / dashLength);
            for (var i = 0; i < numDashes; ++i) {
                var x = parseInt(x1 + deltaX / numDashes * i);
                var y = parseInt(y1 + deltaY / numDashes * i);
                graphics[i % 2 === 0 ? 'moveTo' : 'lineTo'](x, y);
                if (i == numDashes - 1 && i % 2 === 0) {
                    graphics.lineTo(x2, y2);
                }
            }
        }

        /*
         *从cpl节点中获取到4个方向的边界节点
         *@param  context 
         *
         **/

    }, {
        key: "getRectFormPointList",
        value: function getRectFormPointList(context) {
            var minX = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var minY = Number.MAX_VALUE;
            var maxY = Number.MIN_VALUE;

            var cpl = context.pointList; //this.getcpl();
            for (var i = 0, l = cpl.length; i < l; i++) {
                if (cpl[i][0] < minX) {
                    minX = cpl[i][0];
                }
                if (cpl[i][0] > maxX) {
                    maxX = cpl[i][0];
                }
                if (cpl[i][1] < minY) {
                    minY = cpl[i][1];
                }
                if (cpl[i][1] > maxY) {
                    maxY = cpl[i][1];
                }
            }

            var lineWidth;
            if (context.strokeStyle || context.fillStyle) {
                lineWidth = context.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            return {
                x: Math.round(minX - lineWidth / 2),
                y: Math.round(minY - lineWidth / 2),
                width: maxX - minX + lineWidth,
                height: maxY - minY + lineWidth
            };
        }
    }]);
    return Shape;
}(DisplayObject);

/**
 * Canvax--Text
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 文本 类
 **/
var Text = function Text(text, opt) {
    var self = this;
    self.type = "text";
    self._reNewline = /\r?\n/;
    self.fontProperts = ["fontStyle", "fontVariant", "fontWeight", "fontSize", "fontFamily"];

    //做一次简单的opt参数校验，保证在用户不传opt的时候 或者传了opt但是里面没有context的时候报错
    opt = Utils.checkOpt(opt);

    self._context = _$1.extend({
        fontSize: 13, //字体大小默认13
        fontWeight: "normal",
        fontFamily: "微软雅黑,sans-serif",
        textDecoration: null,
        fillStyle: 'blank',
        strokeStyle: null,
        lineWidth: 0,
        lineHeight: 1.2,
        backgroundColor: null,
        textBackgroundColor: null
    }, opt.context);

    self._context.font = self._getFontDeclaration();

    self.text = text.toString();

    Text.superclass.constructor.apply(this, [opt]);
};

Utils.creatClass(Text, DisplayObject, {
    $watch: function $watch(name, value, preValue) {
        //context属性有变化的监听函数
        if (_$1.indexOf(this.fontProperts, name) >= 0) {
            this._context[name] = value;
            //如果修改的是font的某个内容，就重新组装一遍font的值，
            //然后通知引擎这次对context的修改不需要上报心跳
            this._notWatch = false;
            this.context.font = this._getFontDeclaration();
            this.context.width = this.getTextWidth();
            this.context.height = this.getTextHeight();
        }
    },
    init: function init(text, opt) {
        var self = this;
        var c = this.context;
        c.width = this.getTextWidth();
        c.height = this.getTextHeight();
    },
    render: function render(ctx) {
        for (var p in this.context.$model) {
            if (p in ctx) {
                if (p != "textBaseline" && this.context.$model[p]) {
                    ctx[p] = this.context.$model[p];
                }
            }
        }
        this._renderText(ctx, this._getTextLines());
    },
    resetText: function resetText(text) {
        this.text = text.toString();
        this.heartBeat();
    },
    getTextWidth: function getTextWidth() {
        var width = 0;
        Utils._pixelCtx.save();
        Utils._pixelCtx.font = this.context.font;
        width = this._getTextWidth(Utils._pixelCtx, this._getTextLines());
        Utils._pixelCtx.restore();
        return width;
    },
    getTextHeight: function getTextHeight() {
        return this._getTextHeight(Utils._pixelCtx, this._getTextLines());
    },
    _getTextLines: function _getTextLines() {
        return this.text.split(this._reNewline);
    },
    _renderText: function _renderText(ctx, textLines) {
        ctx.save();
        this._renderTextStroke(ctx, textLines);
        this._renderTextFill(ctx, textLines);
        ctx.restore();
    },
    _getFontDeclaration: function _getFontDeclaration() {
        var self = this;
        var fontArr = [];

        _$1.each(this.fontProperts, function (p) {
            var fontP = self._context[p];
            if (p == "fontSize") {
                fontP = parseFloat(fontP) + "px";
            }
            fontP && fontArr.push(fontP);
        });

        return fontArr.join(' ');
    },
    _renderTextFill: function _renderTextFill(ctx, textLines) {
        if (!this.context.fillStyle) return;

        this._boundaries = [];
        var lineHeights = 0;

        for (var i = 0, len = textLines.length; i < len; i++) {
            var heightOfLine = this._getHeightOfLine(ctx, i, textLines);
            lineHeights += heightOfLine;

            this._renderTextLine('fillText', ctx, textLines[i], 0, //this._getLeftOffset(),
            this._getTopOffset() + lineHeights, i);
        }
    },
    _renderTextStroke: function _renderTextStroke(ctx, textLines) {
        if (!this.context.strokeStyle || !this.context.lineWidth) return;

        var lineHeights = 0;

        ctx.save();
        if (this.strokeDashArray) {
            if (1 & this.strokeDashArray.length) {
                this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);
            }
            supportsLineDash && ctx.setLineDash(this.strokeDashArray);
        }

        ctx.beginPath();
        for (var i = 0, len = textLines.length; i < len; i++) {
            var heightOfLine = this._getHeightOfLine(ctx, i, textLines);
            lineHeights += heightOfLine;

            this._renderTextLine('strokeText', ctx, textLines[i], 0, //this._getLeftOffset(),
            this._getTopOffset() + lineHeights, i);
        }
        ctx.closePath();
        ctx.restore();
    },
    _renderTextLine: function _renderTextLine(method, ctx, line, left, top, lineIndex) {
        top -= this._getHeightOfLine() / 4;
        if (this.context.textAlign !== 'justify') {
            this._renderChars(method, ctx, line, left, top, lineIndex);
            return;
        }
        var lineWidth = ctx.measureText(line).width;
        var totalWidth = this.context.width;

        if (totalWidth > lineWidth) {
            var words = line.split(/\s+/);
            var wordsWidth = ctx.measureText(line.replace(/\s+/g, '')).width;
            var widthDiff = totalWidth - wordsWidth;
            var numSpaces = words.length - 1;
            var spaceWidth = widthDiff / numSpaces;

            var leftOffset = 0;
            for (var i = 0, len = words.length; i < len; i++) {
                this._renderChars(method, ctx, words[i], left + leftOffset, top, lineIndex);
                leftOffset += ctx.measureText(words[i]).width + spaceWidth;
            }
        } else {
            this._renderChars(method, ctx, line, left, top, lineIndex);
        }
    },
    _renderChars: function _renderChars(method, ctx, chars, left, top) {
        ctx[method](chars, 0, top);
    },
    _getHeightOfLine: function _getHeightOfLine() {
        return this.context.fontSize * this.context.lineHeight;
    },
    _getTextWidth: function _getTextWidth(ctx, textLines) {
        var maxWidth = ctx.measureText(textLines[0] || '|').width;
        for (var i = 1, len = textLines.length; i < len; i++) {
            var currentLineWidth = ctx.measureText(textLines[i]).width;
            if (currentLineWidth > maxWidth) {
                maxWidth = currentLineWidth;
            }
        }
        return maxWidth;
    },
    _getTextHeight: function _getTextHeight(ctx, textLines) {
        return this.context.fontSize * textLines.length * this.context.lineHeight;
    },

    /**
     * @private
     * @return {Number} Top offset
     */
    _getTopOffset: function _getTopOffset() {
        var t = 0;
        switch (this.context.textBaseline) {
            case "top":
                t = 0;
                break;
            case "middle":
                t = -this.context.height / 2;
                break;
            case "bottom":
                t = -this.context.height;
                break;
        }
        return t;
    },
    getRect: function getRect() {
        var c = this.context;
        var x = 0;
        var y = 0;
        //更具textAlign 和 textBaseline 重新矫正 xy
        if (c.textAlign == "center") {
            x = -c.width / 2;
        }
        if (c.textAlign == "right") {
            x = -c.width;
        }
        if (c.textBaseline == "middle") {
            y = -c.height / 2;
        }
        if (c.textBaseline == "bottom") {
            y = -c.height;
        }

        return {
            x: x,
            y: y,
            width: c.width,
            height: c.height
        };
    }
});

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 向量操作类
 * */
function Vector(x, y) {
    var vx = 0,
        vy = 0;
    if (arguments.length == 1 && _$1.isObject(x)) {
        var arg = arguments[0];
        if (_$1.isArray(arg)) {
            vx = arg[0];
            vy = arg[1];
        } else if (arg.hasOwnProperty("x") && arg.hasOwnProperty("y")) {
            vx = arg.x;
            vy = arg.y;
        }
    }
    this._axes = [vx, vy];
}
Vector.prototype = {
    distance: function distance(v) {
        var x = this._axes[0] - v._axes[0];
        var y = this._axes[1] - v._axes[1];

        return Math.sqrt(x * x + y * y);
    }
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 处理为平滑线条
 */
/**
 * @inner
 */
function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.25;
    var v1 = (p3 - p1) * 0.25;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}
/**
 * 多线段平滑曲线 
 * opt ==> points , isLoop
 */
var SmoothSpline = function (opt) {
    var points = opt.points;
    var isLoop = opt.isLoop;
    var smoothFilter = opt.smoothFilter;

    var len = points.length;
    if (len == 1) {
        return points;
    }
    var ret = [];
    var distance = 0;
    var preVertor = new Vector(points[0]);
    var iVtor = null;
    for (var i = 1; i < len; i++) {
        iVtor = new Vector(points[i]);
        distance += preVertor.distance(iVtor);
        preVertor = iVtor;
    }

    preVertor = null;
    iVtor = null;

    //基本上等于曲率
    var segs = distance / 6;

    segs = segs < len ? len : segs;
    for (var i = 0; i < segs; i++) {
        var pos = i / (segs - 1) * (isLoop ? len : len - 1);
        var idx = Math.floor(pos);

        var w = pos - idx;

        var p0;
        var p1 = points[idx % len];
        var p2;
        var p3;
        if (!isLoop) {
            p0 = points[idx === 0 ? idx : idx - 1];
            p2 = points[idx > len - 2 ? len - 1 : idx + 1];
            p3 = points[idx > len - 3 ? len - 1 : idx + 2];
        } else {
            p0 = points[(idx - 1 + len) % len];
            p2 = points[(idx + 1) % len];
            p3 = points[(idx + 2) % len];
        }

        var w2 = w * w;
        var w3 = w * w2;

        var rp = [interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)];

        _$1.isFunction(smoothFilter) && smoothFilter(rp);

        ret.push(rp);
    }
    return ret;
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 数学 类
 *
 **/

var _cache = {
    sin: {}, //sin缓存
    cos: {} //cos缓存
};
var _radians = Math.PI / 180;

/**
 * @param angle 弧度（角度）参数
 * @param isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
 */
function sin(angle, isDegrees) {
    angle = (isDegrees ? angle * _radians : angle).toFixed(4);
    if (typeof _cache.sin[angle] == 'undefined') {
        _cache.sin[angle] = Math.sin(angle);
    }
    return _cache.sin[angle];
}

/**
 * @param radians 弧度参数
 */
function cos(angle, isDegrees) {
    angle = (isDegrees ? angle * _radians : angle).toFixed(4);
    if (typeof _cache.cos[angle] == 'undefined') {
        _cache.cos[angle] = Math.cos(angle);
    }
    return _cache.cos[angle];
}

/**
 * 角度转弧度
 * @param {Object} angle
 */
function degreeToRadian(angle) {
    return angle * _radians;
}

/**
 * 弧度转角度
 * @param {Object} angle
 */
function radianToDegree(angle) {
    return angle / _radians;
}

/*
 * 校验角度到360度内
 * @param {angle} number
 */
function degreeTo360(angle) {
    var reAng = (360 + angle % 360) % 360; //Math.abs(360 + Math.ceil( angle ) % 360) % 360;
    if (reAng == 0 && angle !== 0) {
        reAng = 360;
    }
    return reAng;
}

function getIsgonPointList(n, r) {
    var pointList = [];
    var dStep = 2 * Math.PI / n;
    var beginDeg = -Math.PI / 2;
    var deg = beginDeg;
    for (var i = 0, end = n; i < end; i++) {
        pointList.push([r * Math.cos(deg), r * Math.sin(deg)]);
        deg += dStep;
    }
    return pointList;
}

function getSmoothPointList(pList, smoothFilter) {
    //smoothFilter -- 比如在折线图中。会传一个smoothFilter过来做point的纠正。
    //让y不能超过底部的原点
    var obj = {
        points: pList
    };
    if (_.isFunction(smoothFilter)) {
        obj.smoothFilter = smoothFilter;
    }

    var currL = SmoothSpline(obj);
    if (pList && pList.length > 0) {
        currL.push(pList[pList.length - 1]);
    }

    return currL;
}

var myMath = {
    PI: Math.PI,
    sin: sin,
    cos: cos,
    degreeToRadian: degreeToRadian,
    radianToDegree: radianToDegree,
    degreeTo360: degreeTo360,
    getIsgonPointList: getIsgonPointList,
    getSmoothPointList: getSmoothPointList
};

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 折线 类
 *
 * 对应context的属性有
 * @pointList 各个顶角坐标
 **/
var BrokenLine = function (_Shape) {
    inherits(BrokenLine, _Shape);

    function BrokenLine(opt, atype) {
        classCallCheck(this, BrokenLine);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            lineType: null,
            smooth: false,
            pointList: [], //{Array}  // 必须，各个顶角坐标
            smoothFilter: Utils.__emptyFunc
        }, opt.context);

        if (atype !== "clone" && _context.smooth) {
            _context.pointList = myMath.getSmoothPointList(_context.pointList);
        }

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (BrokenLine.__proto__ || Object.getPrototypeOf(BrokenLine)).call(this, opt));

        _this.type = "brokenline";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(BrokenLine, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "pointList" || name == "smooth" || name == "lineType") {
                this.clearGraphicsData();
            }
        }
    }, {
        key: "draw",
        value: function draw(graphics) {
            var context = this.context;
            var pointList = context.pointList;
            if (pointList.length < 2) {
                //少于2个点就不画了~
                return this;
            }
            if (!context.lineType || context.lineType == 'solid') {
                //默认为实线
                //TODO:目前如果 有设置smooth 的情况下是不支持虚线的
                graphics.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 1, l = pointList.length; i < l; i++) {
                    graphics.lineTo(pointList[i][0], pointList[i][1]);
                }
            } else if (context.lineType == 'dashed' || context.lineType == 'dotted') {
                if (context.smooth) {
                    for (var si = 0, sl = pointList.length; si < sl; si++) {
                        if (si == sl - 1) {
                            break;
                        }
                        graphics.moveTo(pointList[si][0], pointList[si][1]);
                        graphics.lineTo(pointList[si + 1][0], pointList[si + 1][1]);
                        si += 1;
                    }
                } else {
                    //画虚线的方法  
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        var fromX = pointList[i - 1][0];
                        var toX = pointList[i][0];
                        var fromY = pointList[i - 1][1];
                        var toY = pointList[i][1];
                        this.dashedLineTo(graphics, fromX, fromY, toX, toY, 5);
                    }
                }
            }
            return this;
        }
    }]);
    return BrokenLine;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 圆形 类
 *
 * 坐标原点再圆心
 *
 * 对应context的属性有
 * @r 圆半径
 **/
var Circle$2 = function (_Shape) {
    inherits(Circle, _Shape);

    function Circle(opt) {
        classCallCheck(this, Circle);

        opt = Utils.checkOpt(opt);
        //默认情况下面，circle不需要把xy进行parentInt转换
        "xyToInt" in opt || (opt.xyToInt = false);
        var _context = _$1.extend({
            r: 0 //{number},  // 必须，圆半径
        }, opt.context);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, opt));

        _this.type = "circle";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Circle, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "r") {
                this.clearGraphicsData();
            }
        }
    }, {
        key: "draw",
        value: function draw(graphics) {
            graphics.beginPath();
            graphics.drawCircle(0, 0, this.context.r);
        }
    }]);
    return Circle;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * Path 类，Path主要用于把svgpath 字符串转换为pointList，然后构建graphicsData
 *
 * 对应context的属性有
 * @path path串
 **/
var Path = function (_Shape) {
    inherits(Path, _Shape);

    function Path(opt) {
        classCallCheck(this, Path);


        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            pointList: [], //从下面的path中计算得到的边界点的集合
            path: "" //字符串 必须，路径。例如:M 0 0 L 0 10 L 10 10 Z (一个三角形)
            //M = moveto
            //L = lineto
            //H = horizontal lineto
            //V = vertical lineto
            //C = curveto
            //S = smooth curveto
            //Q = quadratic Belzier curve
            //T = smooth quadratic Belzier curveto
            //Z = closepath
        }, opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Path.__proto__ || Object.getPrototypeOf(Path)).call(this, opt));

        if ("drawTypeOnly" in opt) {
            _this.drawTypeOnly = opt.drawTypeOnly;
        }

        _this.__parsePathData = null;

        _this.type = "path";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Path, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "path") {
                //如果path有变动，需要自动计算新的pointList
                this.clearGraphicsData();
            }
        }
    }, {
        key: "_parsePathData",
        value: function _parsePathData(data) {
            if (this.__parsePathData) {
                return this.__parsePathData;
            }
            if (!data) {
                return [];
            }
            //分拆子分组
            this.__parsePathData = [];
            var paths = _$1.compact(data.replace(/[Mm]/g, "\\r$&").split('\\r'));
            var me = this;
            _$1.each(paths, function (pathStr) {
                me.__parsePathData.push(me._parseChildPathData(pathStr));
            });
            return this.__parsePathData;
        }
    }, {
        key: "_parseChildPathData",
        value: function _parseChildPathData(data) {
            // command string
            var cs = data;
            // command chars
            var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
            cs = cs.replace(/  /g, ' ');
            cs = cs.replace(/ /g, ',');
            //cs = cs.replace(/(.)-/g, "$1,-");
            cs = cs.replace(/(\d)-/g, '$1,-');
            cs = cs.replace(/,,/g, ',');
            var n;
            // create pipes so that we can split the data
            for (n = 0; n < cc.length; n++) {
                cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
            }
            // create array
            var arr = cs.split('|');
            var ca = [];
            // init context point
            var cpx = 0;
            var cpy = 0;
            for (n = 1; n < arr.length; n++) {
                var str = arr[n];
                var c = str.charAt(0);
                str = str.slice(1);
                str = str.replace(new RegExp('e,-', 'g'), 'e-');

                //有的时候，比如“22，-22” 数据可能会经常的被写成22-22，那么需要手动修改
                //str = str.replace(new RegExp('-', 'g'), ',-');
                //str = str.replace(/(.)-/g, "$1,-")
                var p = str.split(',');

                if (p.length > 0 && p[0] === '') {
                    p.shift();
                }

                for (var i = 0; i < p.length; i++) {
                    p[i] = parseFloat(p[i]);
                }
                while (p.length > 0) {
                    if (isNaN(p[0])) {
                        break;
                    }
                    var cmd = null;
                    var points = [];

                    var ctlPtx;
                    var ctlPty;
                    var prevCmd;

                    var rx;
                    var ry;
                    var psi;
                    var fa;
                    var fs;

                    var x1 = cpx;
                    var y1 = cpy;

                    // convert l, H, h, V, and v to L
                    switch (c) {
                        case 'l':
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'L':
                            cpx = p.shift();
                            cpy = p.shift();
                            points.push(cpx, cpy);
                            break;
                        case 'm':
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'M';
                            points.push(cpx, cpy);
                            c = 'l';
                            break;
                        case 'M':
                            cpx = p.shift();
                            cpy = p.shift();
                            cmd = 'M';
                            points.push(cpx, cpy);
                            c = 'L';
                            break;

                        case 'h':
                            cpx += p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'H':
                            cpx = p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'v':
                            cpy += p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'V':
                            cpy = p.shift();
                            cmd = 'L';
                            points.push(cpx, cpy);
                            break;
                        case 'C':
                            points.push(p.shift(), p.shift(), p.shift(), p.shift());
                            cpx = p.shift();
                            cpy = p.shift();
                            points.push(cpx, cpy);
                            break;
                        case 'c':
                            points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'C';
                            points.push(cpx, cpy);
                            break;
                        case 'S':
                            ctlPtx = cpx;
                            ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'C') {
                                ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                ctlPty = cpy + (cpy - prevCmd.points[3]);
                            }
                            points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                            cpx = p.shift();
                            cpy = p.shift();
                            cmd = 'C';
                            points.push(cpx, cpy);
                            break;
                        case 's':
                            ctlPtx = cpx, ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'C') {
                                ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                ctlPty = cpy + (cpy - prevCmd.points[3]);
                            }
                            points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'C';
                            points.push(cpx, cpy);
                            break;
                        case 'Q':
                            points.push(p.shift(), p.shift());
                            cpx = p.shift();
                            cpy = p.shift();
                            points.push(cpx, cpy);
                            break;
                        case 'q':
                            points.push(cpx + p.shift(), cpy + p.shift());
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'Q';
                            points.push(cpx, cpy);
                            break;
                        case 'T':
                            ctlPtx = cpx, ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'Q') {
                                ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                ctlPty = cpy + (cpy - prevCmd.points[1]);
                            }
                            cpx = p.shift();
                            cpy = p.shift();
                            cmd = 'Q';
                            points.push(ctlPtx, ctlPty, cpx, cpy);
                            break;
                        case 't':
                            ctlPtx = cpx, ctlPty = cpy;
                            prevCmd = ca[ca.length - 1];
                            if (prevCmd.command === 'Q') {
                                ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                ctlPty = cpy + (cpy - prevCmd.points[1]);
                            }
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'Q';
                            points.push(ctlPtx, ctlPty, cpx, cpy);
                            break;
                        case 'A':
                            rx = p.shift(); //x半径
                            ry = p.shift(); //y半径
                            psi = p.shift(); //旋转角度
                            fa = p.shift(); //角度大小 
                            fs = p.shift(); //时针方向

                            x1 = cpx, y1 = cpy;
                            cpx = p.shift(), cpy = p.shift();
                            cmd = 'A';
                            points = [rx, ry, psi, fa, fs, cpx, cpy, x1, y1];
                            break;
                        case 'a':
                            rx = p.shift();
                            ry = p.shift();
                            psi = p.shift();
                            fa = p.shift();
                            fs = p.shift();

                            x1 = cpx, y1 = cpy;
                            cpx += p.shift();
                            cpy += p.shift();
                            cmd = 'A';
                            points = [rx, ry, psi, fa, fs, cpx, cpy, x1, y1];
                            break;

                    }

                    ca.push({
                        command: cmd || c,
                        points: points
                    });
                }

                if (c === 'z' || c === 'Z') {
                    ca.push({
                        command: 'z',
                        points: []
                    });
                }
            }
            return ca;
        }

        //重新根的path绘制 graphics

    }, {
        key: "draw",
        value: function draw(graphics) {
            graphics.beginPath();
            this.__parsePathData = null;
            this.context.pointList = [];

            var pathArray = this._parsePathData(this.context.path);

            for (var g = 0, gl = pathArray.length; g < gl; g++) {
                for (var i = 0, l = pathArray[g].length; i < l; i++) {
                    var c = pathArray[g][i].command,
                        p = pathArray[g][i].points;
                    switch (c) {
                        case 'L':
                            graphics.lineTo(p[0], p[1]);
                            break;
                        case 'M':
                            graphics.moveTo(p[0], p[1]);
                            break;
                        case 'C':
                            graphics.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                            break;
                        case 'Q':
                            graphics.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                            break;
                        case 'A':
                            //前面6个元素用来放path的A 6个参数，path A命令详见
                            Arc.drawArc(graphics, p[7], p[8], p);
                            break;
                        case 'z':
                            graphics.closePath();
                            break;
                    }
                }
            }
            return this;
        }
    }]);
    return Path;
}(Shape);

/**
 * Canvax
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 水滴形 类
 * 派生自Path类
 *
 * 对应context的属性有
 * @hr 水滴横宽（中心到水平边缘最宽处距离）
 * @vr 水滴纵高（中心到尖端距离）
 **/
var Droplet = function (_Path) {
    inherits(Droplet, _Path);

    function Droplet(opt) {
        var _this;

        classCallCheck(this, Droplet);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            hr: 0, //{number},  // 必须，水滴横宽（中心到水平边缘最宽处距离）
            vr: 0 //{number},  // 必须，水滴纵高（中心到尖端距离）
        }, opt.context);

        opt.context = _context;

        var my = (_this = possibleConstructorReturn(this, (Droplet.__proto__ || Object.getPrototypeOf(Droplet)).call(this, opt)), _this);

        _this.type = "droplet";
        _this.id = Utils.createId(_this.type);

        _this.context.path = _this.createPath();
        return _this;
    }

    createClass(Droplet, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "hr" || name == "vr") {
                this.context.path = this.createPath();
            }
        }
    }, {
        key: "createPath",
        value: function createPath() {
            var context = this.context;
            var ps = "M 0 " + context.hr + " C " + context.hr + " " + context.hr + " " + context.hr * 3 / 2 + " " + -context.hr / 3 + " 0 " + -context.vr;
            ps += " C " + -context.hr * 3 / 2 + " " + -context.hr / 3 + " " + -context.hr + " " + context.hr + " 0 " + context.hr + "z";
            return ps;
        }
    }]);
    return Droplet;
}(Path);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 椭圆形 类
 *
 * 对应context的属性有 
 *
 * @hr 椭圆横轴半径
 * @vr 椭圆纵轴半径
 */
var Ellipse$2 = function (_Shape) {
    inherits(Ellipse, _Shape);

    function Ellipse(opt) {
        classCallCheck(this, Ellipse);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            //x             : 0 , //{number},  // 丢弃
            //y             : 0 , //{number},  // 丢弃，原因同circle
            hr: 0, //{number},  // 必须，椭圆横轴半径
            vr: 0 //{number},  // 必须，椭圆纵轴半径
        }, opt.context);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Ellipse.__proto__ || Object.getPrototypeOf(Ellipse)).call(this, opt));

        _this.type = "ellipse";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Ellipse, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "hr" || name == "vr") {
                this.clearGraphicsData();
            }
        }
    }, {
        key: "draw",
        value: function draw(graphics) {
            graphics.beginPath();
            graphics.drawEllipse(0, 0, this.context.hr * 2, this.context.vr * 2);
        }
    }]);
    return Ellipse;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 多边形 类  （不规则）
 *
 * 对应context的属性有
 * @pointList 多边形各个顶角坐标
 **/
var Polygon$2 = function (_Shape) {
    inherits(Polygon, _Shape);

    function Polygon(opt, atype) {
        classCallCheck(this, Polygon);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            lineType: null,
            smooth: false,
            pointList: [], //{Array}  // 必须，各个顶角坐标
            smoothFilter: Utils.__emptyFunc
        }, opt.context);

        if (atype !== "clone") {
            var start = _context.pointList[0];
            var end = _context.pointList.slice(-1)[0];
            if (_context.smooth) {
                _context.pointList.unshift(end);
                _context.pointList = myMath.getSmoothPointList(_context.pointList);
            }
            //else {
            //    _context.pointList.push( start );
            //}
        }

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, opt, atype));

        _this._drawTypeOnly = null;
        _this.type = "polygon";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Polygon, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            //调用parent的setGraphics
            if (name == "pointList" || name == "smooth" || name == "lineType") {
                this.clearGraphicsData();
            }
        }
    }, {
        key: "draw",
        value: function draw(graphics) {
            graphics.beginPath();
            var context = this.context;
            var pointList = context.pointList;
            if (pointList.length < 2) {
                //少于2个点就不画了~
                return;
            }

            graphics.moveTo(pointList[0][0], pointList[0][1]);
            for (var i = 1, l = pointList.length; i < l; i++) {
                graphics.lineTo(pointList[i][0], pointList[i][1]);
            }
            graphics.closePath();

            //如果为虚线
            if (context.lineType == 'dashed' || context.lineType == 'dotted') {
                //首先把前面的draphicsData设置为fill only
                //也就是把line强制设置为false，这点很重要，否则你虚线画不出来，会和这个实现重叠了
                graphics.currentPath.line = false;

                if (context.smooth) {
                    //如果是smooth，本身已经被用曲率打散过了，不需要采用间隔法
                    for (var si = 0, sl = pointList.length; si < sl; si++) {
                        if (si == sl - 1) {
                            break;
                        }
                        graphics.moveTo(pointList[si][0], pointList[si][1]);
                        graphics.lineTo(pointList[si + 1][0], pointList[si + 1][1]);
                        si += 1;
                    }
                } else {
                    //画虚线的方法  
                    graphics.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        var fromX = pointList[i - 1][0];
                        var toX = pointList[i][0];
                        var fromY = pointList[i - 1][1];
                        var toY = pointList[i][1];
                        this.dashedLineTo(graphics, fromX, fromY, toX, toY, 5);
                    }
                }
            }

            graphics.closePath();
            return;
        }
    }]);
    return Polygon;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 正n边形（n>=3）
 *
 * 对应context的属性有 
 *
 * @r 正n边形外接圆半径
 * @r 指明正几边形
 *
 * @pointList 私有，从上面的r和n计算得到的边界值的集合
 */
var Isogon = function (_Polygon) {
    inherits(Isogon, _Polygon);

    function Isogon(opt) {
        classCallCheck(this, Isogon);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            pointList: [], //从下面的r和n计算得到的边界值的集合
            r: 0, //{number},  // 必须，正n边形外接圆半径
            n: 0 //{number},  // 必须，指明正几边形
        }, opt.context);
        _context.pointList = myMath.getIsgonPointList(_context.n, _context.r);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Isogon.__proto__ || Object.getPrototypeOf(Isogon)).call(this, opt));

        _this.type = "isogon";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Isogon, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "r" || name == "n") {
                //如果path有变动，需要自动计算新的pointList
                this.context.pointList = myMath.getIsgonPointList(style.n, style.r);
            }

            if (name == "pointList" || name == "smooth" || name == "lineType") {
                this.clearGraphicsData();
            }
        }
    }]);
    return Isogon;
}(Polygon$2);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 线条 类
 *
 *
 * 对应context的属性有
 * @lineType  可选 虚线 实现 的 类型
 * @xStart    必须，起点横坐标
 * @yStart    必须，起点纵坐标
 * @xEnd      必须，终点横坐标
 * @yEnd      必须，终点纵坐标
 **/
var Line = function (_Shape) {
    inherits(Line, _Shape);

    function Line(opt) {
        classCallCheck(this, Line);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            lineType: null, //可选 虚线 实现 的 类型
            start: {
                x: 0, // 必须，起点横坐标
                y: 0 // 必须，起点纵坐标
            },
            end: {
                x: 0, // 必须，终点横坐标
                y: 0 // 必须，终点纵坐标
            },
            dashLength: 3 // 虚线间隔
        }, opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this, opt));

        _this.type = "line";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Line, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            //并不清楚是start.x 还是end.x， 当然，这并不重要
            if (name == "x" || name == "y") {
                this.clearGraphicsData();
            }
        }
    }, {
        key: "draw",
        value: function draw(graphics) {
            graphics.beginPath();
            var context = this.context;
            if (!context.lineType || context.lineType == 'solid') {
                graphics.moveTo(context.start.x, context.start.y);
                graphics.lineTo(context.end.x, context.end.y);
            } else if (context.lineType == 'dashed' || context.lineType == 'dotted') {
                this.dashedLineTo(graphics, context.start.x, context.start.y, context.end.x, context.end.y, this.context.dashLength);
            }
            return this;
        }
    }]);
    return Line;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 矩现 类  （不规则）
 *
 *
 * 对应context的属性有
 * @width 宽度
 * @height 高度
 * @radius 如果是圆角的，则为【上右下左】顺序的圆角半径数组
 **/
var Rect = function (_Shape) {
    inherits(Rect, _Shape);

    function Rect(opt) {
        classCallCheck(this, Rect);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            width: 0,
            height: 0,
            radius: []
        }, opt.context);
        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this, opt));

        _this.type = "rect";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Rect, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "width" || name == "height" || name == "radius") {
                this.clearGraphicsData();
            }
        }

        /**
         * 绘制圆角矩形
         */

    }, {
        key: "_buildRadiusPath",
        value: function _buildRadiusPath(graphics) {
            var context = this.context;
            //左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
            //r缩写为1         相当于 [1, 1, 1, 1]
            //r缩写为[1]       相当于 [1, 1, 1, 1]
            //r缩写为[1, 2]    相当于 [1, 2, 1, 2]
            //r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
            var x = 0;
            var y = 0;
            var width = this.context.width;
            var height = this.context.height;

            var r = Utils.getCssOrderArr(context.radius);
            var G = graphics;

            G.moveTo(parseInt(x + r[0]), parseInt(y));
            G.lineTo(parseInt(x + width - r[1]), parseInt(y));
            r[1] !== 0 && G.quadraticCurveTo(x + width, y, x + width, y + r[1]);
            G.lineTo(parseInt(x + width), parseInt(y + height - r[2]));
            r[2] !== 0 && G.quadraticCurveTo(x + width, y + height, x + width - r[2], y + height);
            G.lineTo(parseInt(x + r[3]), parseInt(y + height));
            r[3] !== 0 && G.quadraticCurveTo(x, y + height, x, y + height - r[3]);
            G.lineTo(parseInt(x), parseInt(y + r[0]));
            r[0] !== 0 && G.quadraticCurveTo(x, y, x + r[0], y);
        }
        /**
         * 创建矩形路径
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} context 样式
         */

    }, {
        key: "draw",
        value: function draw(graphics) {
            graphics.beginPath();
            if (!this.context.radius.length) {
                graphics.drawRect(0, 0, this.context.width, this.context.height);
            } else {
                this._buildRadiusPath(graphics);
            }
            graphics.closePath();
            return;
        }
    }]);
    return Rect;
}(Shape);

/**
 * Canvax
 *
 * @author 释剑 (李涛, litao.lt@alibaba-inc.com)
 *
 * 扇形 类
 *
 * 坐标原点再圆心
 *
 * 对应context的属性有
 * @r0 默认为0，内圆半径指定后将出现内弧，同时扇边长度 = r - r0
 * @r  必须，外圆半径
 * @startAngle 起始角度(0, 360)
 * @endAngle   结束角度(0, 360)
 **/
var Sector = function (_Shape) {
    inherits(Sector, _Shape);

    function Sector(opt) {
        classCallCheck(this, Sector);

        opt = Utils.checkOpt(opt);
        var _context = _$1.extend({
            pointList: [], //边界点的集合,私有，从下面的属性计算的来
            r0: 0, // 默认为0，内圆半径指定后将出现内弧，同时扇边长度 = r - r0
            r: 0, //{number},  // 必须，外圆半径
            startAngle: 0, //{number},  // 必须，起始角度[0, 360)
            endAngle: 0, //{number},  // 必须，结束角度(0, 360]
            clockwise: false //是否顺时针，默认为false(顺时针)
        }, opt.context);

        opt.context = _context;

        var _this = possibleConstructorReturn(this, (Sector.__proto__ || Object.getPrototypeOf(Sector)).call(this, opt));

        _this.regAngle = [];
        _this.isRing = false; //是否为一个圆环
        _this.type = "sector";
        _this.id = Utils.createId(_this.type);
        return _this;
    }

    createClass(Sector, [{
        key: "watch",
        value: function watch(name, value, preValue) {
            if (name == "r0" || name == "r" || name == "startAngle" || name == "endAngle" || name == "clockwise") {
                this.clearGraphicsData();
            }
        }
    }, {
        key: "draw",
        value: function draw(graphics) {
            graphics.beginPath();
            var context = this.context;
            // 形内半径[0,r)
            var r0 = typeof context.r0 == 'undefined' ? 0 : context.r0;
            var r = context.r; // 扇形外半径(0,r]
            var startAngle = myMath.degreeTo360(context.startAngle); // 起始角度[0,360)
            var endAngle = myMath.degreeTo360(context.endAngle); // 结束角度(0,360]

            //var isRing     = false;                       //是否为圆环

            //if( startAngle != endAngle && Math.abs(startAngle - endAngle) % 360 == 0 ) {
            if (startAngle == endAngle && context.startAngle != context.endAngle) {
                //如果两个角度相等，那么就认为是个圆环了
                this.isRing = true;
                startAngle = 0;
                endAngle = 360;
            }

            startAngle = myMath.degreeToRadian(startAngle);
            endAngle = myMath.degreeToRadian(endAngle);

            //处理下极小夹角的情况
            if (endAngle - startAngle < 0.025) {
                startAngle -= 0.003;
            }

            var G = graphics;

            G.arc(0, 0, r, startAngle, endAngle, this.context.clockwise);
            if (r0 !== 0) {
                if (this.isRing) {
                    //加上这个isRing的逻辑是为了兼容flashcanvas下绘制圆环的的问题
                    //不加这个逻辑flashcanvas会绘制一个大圆 ， 而不是圆环
                    G.moveTo(r0, 0);
                    G.arc(0, 0, r0, startAngle, endAngle, !this.context.clockwise);
                } else {
                    G.arc(0, 0, r0, endAngle, startAngle, !this.context.clockwise);
                }
            } else {
                //TODO:在r0为0的时候，如果不加lineTo(0,0)来把路径闭合，会出现有搞笑的一个bug
                //整个圆会出现一个以每个扇形两端为节点的镂空，我可能描述不清楚，反正这个加上就好了
                G.lineTo(0, 0);
            }

            G.closePath();
        }
    }, {
        key: "getRect",
        value: function getRect(context) {
            var context = context ? context : this.context;
            var r0 = typeof context.r0 == 'undefined' // 形内半径[0,r)
            ? 0 : context.r0;
            var r = context.r; // 扇形外半径(0,r]

            this.getRegAngle();

            var startAngle = myMath.degreeTo360(context.startAngle); // 起始角度[0,360)
            var endAngle = myMath.degreeTo360(context.endAngle); // 结束角度(0,360]

            var pointList = [];

            var p4Direction = {
                "90": [0, r],
                "180": [-r, 0],
                "270": [0, -r],
                "360": [r, 0]
            };

            for (var d in p4Direction) {
                var inAngleReg = parseInt(d) > this.regAngle[0] && parseInt(d) < this.regAngle[1];
                if (this.isRing || inAngleReg && this.regIn || !inAngleReg && !this.regIn) {
                    pointList.push(p4Direction[d]);
                }
            }

            if (!this.isRing) {
                startAngle = myMath.degreeToRadian(startAngle);
                endAngle = myMath.degreeToRadian(endAngle);

                pointList.push([myMath.cos(startAngle) * r0, myMath.sin(startAngle) * r0]);

                pointList.push([myMath.cos(startAngle) * r, myMath.sin(startAngle) * r]);

                pointList.push([myMath.cos(endAngle) * r, myMath.sin(endAngle) * r]);

                pointList.push([myMath.cos(endAngle) * r0, myMath.sin(endAngle) * r0]);
            }

            context.pointList = pointList;
            return this.getRectFormPointList(context);
        }
    }, {
        key: "getRegAngle",
        value: function getRegAngle() {
            this.regIn = true; //如果在start和end的数值中，end大于start而且是顺时针则regIn为true
            var c = this.context;
            var startAngle = myMath.degreeTo360(c.startAngle); // 起始角度[0,360)
            var endAngle = myMath.degreeTo360(c.endAngle); // 结束角度(0,360]

            if (startAngle > endAngle && !c.clockwise || startAngle < endAngle && c.clockwise) {
                this.regIn = false; //out
            }
            //度的范围，从小到大
            this.regAngle = [Math.min(startAngle, endAngle), Math.max(startAngle, endAngle)];
        }
    }]);
    return Sector;
}(Shape);

//shapes
var Canvax = {
    App: Application
};

Canvax.Display = {
    DisplayObject: DisplayObject,
    DisplayObjectContainer: DisplayObjectContainer,
    Stage: Stage,
    Sprite: Sprite,
    Shape: Shape,
    Point: Point,
    Text: Text
};

Canvax.Shapes = {
    BrokenLine: BrokenLine,
    Circle: Circle$2,
    Droplet: Droplet,
    Ellipse: Ellipse$2,
    Isogon: Isogon,
    Line: Line,
    Path: Path,
    Polygon: Polygon$2,
    Rect: Rect,
    Sector: Sector
};

Canvax.Event = {
    EventDispatcher: EventDispatcher,
    EventManager: EventManager
};

module.exports = Canvax;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmF4LmpzIiwic291cmNlcyI6WyIuLi8uLi9jYW52YXgvdXRpbHMvdW5kZXJzY29yZS5qcyIsIi4uLy4uL2NhbnZheC91dGlscy9pbmRleC5qcyIsIi4uLy4uL2NhbnZheC9kaXNwbGF5L1BvaW50LmpzIiwiLi4vLi4vY2FudmF4L2V2ZW50L0NhbnZheEV2ZW50LmpzIiwiLi4vLi4vY2FudmF4L3NldHRpbmdzLmpzIiwiLi4vLi4vY2FudmF4L3V0aWxzL2RvbS5qcyIsIi4uLy4uL2NhbnZheC9ldmVudC9FdmVudEhhbmRsZXIuanMiLCIuLi8uLi9jYW52YXgvZXZlbnQvRXZlbnRNYW5hZ2VyLmpzIiwiLi4vLi4vY2FudmF4L2V2ZW50L0V2ZW50RGlzcGF0Y2hlci5qcyIsIi4uLy4uL2NhbnZheC9nZW9tL01hdHJpeC5qcyIsIi4uLy4uL2NhbnZheC9hbmltYXRpb24vVHdlZW4uanMiLCIuLi8uLi9jYW52YXgvYW5pbWF0aW9uL0FuaW1hdGlvbkZyYW1lLmpzIiwiLi4vLi4vY2FudmF4L3V0aWxzL29ic2VydmUuanMiLCIuLi8uLi9jYW52YXgvY29uc3QuanMiLCIuLi8uLi9jYW52YXgvZ2VvbS9JbnNpZGVMaW5lLmpzIiwiLi4vLi4vY2FudmF4L2Rpc3BsYXkvRGlzcGxheU9iamVjdC5qcyIsIi4uLy4uL2NhbnZheC9kaXNwbGF5L0Rpc3BsYXlPYmplY3RDb250YWluZXIuanMiLCIuLi8uLi9jYW52YXgvZGlzcGxheS9TdGFnZS5qcyIsIi4uLy4uL2NhbnZheC9yZW5kZXJlcnMvU3lzdGVtUmVuZGVyZXIuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3MvY2FudmFzL0dyYXBoaWNzUmVuZGVyZXIuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3MvR3JhcGhpY3NEYXRhLmpzIiwiLi4vLi4vY2FudmF4L21hdGgvUG9pbnQuanMiLCIuLi8uLi9jYW52YXgvbWF0aC9BcmMuanMiLCIuLi8uLi9jYW52YXgvbWF0aC9zaGFwZXMvUmVjdGFuZ2xlLmpzIiwiLi4vLi4vY2FudmF4L21hdGgvc2hhcGVzL0NpcmNsZS5qcyIsIi4uLy4uL2NhbnZheC9tYXRoL3NoYXBlcy9FbGxpcHNlLmpzIiwiLi4vLi4vY2FudmF4L21hdGgvc2hhcGVzL1BvbHlnb24uanMiLCIuLi8uLi9jYW52YXgvbWF0aC9pbmRleC5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy91dGlscy9iZXppZXJDdXJ2ZVRvLmpzIiwiLi4vLi4vY2FudmF4L2dyYXBoaWNzL0dyYXBoaWNzLmpzIiwiLi4vLi4vY2FudmF4L3JlbmRlcmVycy9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9jcmVhdGVDb250ZXh0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2V0VmVydGV4QXR0cmliQXJyYXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvR0xCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9HTFRleHR1cmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9HTEZyYW1lYnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2NvbXBpbGVQcm9ncmFtLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL21hcFR5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvbWFwU2l6ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9leHRyYWN0QXR0cmlidXRlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9kZWZhdWx0VmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9zaGFkZXIvZXh0cmFjdFVuaWZvcm1zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL3NldFByZWNpc2lvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL3NoYWRlci9nZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcGl4aS1nbC1jb3JlL3NyYy9HTFNoYWRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9waXhpLWdsLWNvcmUvc3JjL1ZlcnRleEFycmF5T2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvc2hhZGVyL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BpeGktZ2wtY29yZS9zcmMvaW5kZXguanMiLCIuLi8uLi9jYW52YXgvcmVuZGVyZXJzL3dlYmdsL3V0aWxzL1JlbmRlclRhcmdldC5qcyIsIi4uLy4uL2NhbnZheC9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qcyIsIi4uLy4uL2NhbnZheC91dGlscy9jb2xvci5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy93ZWJnbC9XZWJHTEdyYXBoaWNzRGF0YS5qcyIsIi4uLy4uL2NhbnZheC9TaGFkZXIuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3Mvd2ViZ2wvc2hhZGVycy9QcmltaXRpdmVTaGFkZXIuanMiLCIuLi8uLi9jYW52YXgvZ3JhcGhpY3Mvd2ViZ2wvdXRpbHMvYnVpbGRMaW5lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzIiwiLi4vLi4vY2FudmF4L2dyYXBoaWNzL3dlYmdsL3V0aWxzL2J1aWxkUG9seS5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZFJlY3RhbmdsZS5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy93ZWJnbC91dGlscy9idWlsZENpcmNsZS5qcyIsIi4uLy4uL2NhbnZheC9ncmFwaGljcy93ZWJnbC9HcmFwaGljc1JlbmRlcmVyLmpzIiwiLi4vLi4vY2FudmF4L3JlbmRlcmVycy93ZWJnbC9XZWJHTFN0YWdlUmVuZGVyZXIuanMiLCIuLi8uLi9jYW52YXgvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXIuanMiLCIuLi8uLi9jYW52YXgvcmVuZGVyZXJzL2F1dG9SZW5kZXJlci5qcyIsIi4uLy4uL2NhbnZheC9BcHBsaWNhdGlvbi5qcyIsIi4uLy4uL2NhbnZheC9kaXNwbGF5L1Nwcml0ZS5qcyIsIi4uLy4uL2NhbnZheC9kaXNwbGF5L1NoYXBlLmpzIiwiLi4vLi4vY2FudmF4L2Rpc3BsYXkvVGV4dC5qcyIsIi4uLy4uL2NhbnZheC9nZW9tL1ZlY3Rvci5qcyIsIi4uLy4uL2NhbnZheC9nZW9tL1Ntb290aFNwbGluZS5qcyIsIi4uLy4uL2NhbnZheC9nZW9tL01hdGguanMiLCIuLi8uLi9jYW52YXgvc2hhcGUvQnJva2VuTGluZS5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9DaXJjbGUuanMiLCIuLi8uLi9jYW52YXgvc2hhcGUvUGF0aC5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9Ecm9wbGV0LmpzIiwiLi4vLi4vY2FudmF4L3NoYXBlL0VsbGlwc2UuanMiLCIuLi8uLi9jYW52YXgvc2hhcGUvUG9seWdvbi5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9Jc29nb24uanMiLCIuLi8uLi9jYW52YXgvc2hhcGUvTGluZS5qcyIsIi4uLy4uL2NhbnZheC9zaGFwZS9SZWN0LmpzIiwiLi4vLi4vY2FudmF4L3NoYXBlL1NlY3Rvci5qcyIsIi4uLy4uL2NhbnZheC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgXyA9IHt9XG52YXIgYnJlYWtlciA9IHt9O1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyXG50b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG5oYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbnZhclxubmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLFxubmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXG5uYXRpdmVJbmRleE9mICAgICAgPSBBcnJheVByb3RvLmluZGV4T2YsXG5uYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxubmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXM7XG5cbl8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG5fLmtleXMgPSBuYXRpdmVLZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICBpZiAob2JqICE9PSBPYmplY3Qob2JqKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG5fLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5cbnZhciBlYWNoID0gXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG5fLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xufTtcblxuXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgaWYgKG5hdGl2ZUZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHJldHVybiBvYmouZmlsdGVyKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbihuYW1lKSB7XG4gIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgfTtcbn0pO1xuXG5pZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICB9O1xufTtcblxuXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbn07XG5cbl8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbn07XG5cbl8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufTtcblxuXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbn07XG5cbl8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xufTtcblxuXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbl8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5fLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGlmIChpc1NvcnRlZCkge1xuICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgfVxuICB9XG4gIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0sIGlzU29ydGVkKTtcbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG59O1xuXG5fLmlzV2luZG93ID0gZnVuY3Rpb24oIG9iaiApIHsgXG4gICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3c7XG59O1xuXy5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICAvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbFxuICAgIGlmICggIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBfLmlzV2luZG93KCBvYmogKSApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG4gICAgICAgIGlmICggb2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAhaGFzT3duLmNhbGwob2JqLCBcImNvbnN0cnVjdG9yXCIpICYmXG4gICAgICAgICAgICAhaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgIC8vIElFOCw5IFdpbGwgdGhyb3cgZXhjZXB0aW9ucyBvbiBjZXJ0YWluIGhvc3Qgb2JqZWN0cyAjOTg5N1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuICAgIC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuICAgIHZhciBrZXk7XG4gICAgZm9yICgga2V5IGluIG9iaiApIHt9XG5cbiAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG59O1xuXG4vKipcbipcbirlpoLmnpzmmK/mt7HluqZleHRlbmTvvIznrKzkuIDkuKrlj4LmlbDlsLHorr7nva7kuLp0cnVlXG4qL1xuXy5leHRlbmQgPSBmdW5jdGlvbigpIHsgIFxuICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsICBcbiAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSwgIFxuICAgICAgaSA9IDEsICBcbiAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsICBcbiAgICAgIGRlZXAgPSBmYWxzZTsgIFxuICBpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkgeyAgXG4gICAgICBkZWVwID0gdGFyZ2V0OyAgXG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307ICBcbiAgICAgIGkgPSAyOyAgXG4gIH07ICBcbiAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFfLmlzRnVuY3Rpb24odGFyZ2V0KSApIHsgIFxuICAgICAgdGFyZ2V0ID0ge307ICBcbiAgfTsgIFxuICBpZiAoIGxlbmd0aCA9PT0gaSApIHsgIFxuICAgICAgdGFyZ2V0ID0gdGhpczsgIFxuICAgICAgLS1pOyAgXG4gIH07ICBcbiAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7ICBcbiAgICAgIGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHsgIFxuICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHsgIFxuICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTsgIFxuICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1sgbmFtZSBdOyAgXG4gICAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkgeyAgXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTsgIFxuICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICAgICAgaWYgKCBkZWVwICYmIGNvcHkgJiYgKCBfLmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gXy5pc0FycmF5KGNvcHkpKSApICkgeyAgXG4gICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkgeyAgXG4gICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTsgIFxuICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIF8uaXNBcnJheShzcmMpID8gc3JjIDogW107ICBcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICBcbiAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBfLmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9OyAgXG4gICAgICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gXy5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7ICBcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkgeyAgXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7ICBcbiAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgfSAgXG4gICAgICB9ICBcbiAgfSAgXG4gIHJldHVybiB0YXJnZXQ7ICBcbn07IFxuXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh0cnVlLCB7fSwgb2JqKTtcbn07XG5leHBvcnQgZGVmYXVsdCBfOyIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tIFxuKi9cbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbnZhciBVdGlscyA9IHtcbiAgICBtYWluRnJhbWVSYXRlICAgOiA2MCwvL+m7mOiupOS4u+W4p+eOh1xuICAgIG5vdyA6IDAsXG4gICAgLyrlg4/ntKDmo4DmtYvkuJPnlKgqL1xuICAgIF9waXhlbEN0eCAgIDogbnVsbCxcbiAgICBfX2VtcHR5RnVuYyA6IGZ1bmN0aW9uKCl7fSxcbiAgICAvL3JldGluYSDlsY/luZXkvJjljJZcbiAgICBfZGV2aWNlUGl4ZWxSYXRpbyA6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgX1VJRCAgOiAwLCAvL+ivpeWAvOS4uuWQkeS4iueahOiHquWinumVv+aVtOaVsOWAvFxuICAgIGdldFVJRDpmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fVUlEKys7XG4gICAgfSxcbiAgICBjcmVhdGVJZCA6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYoIW5hbWUpe1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgLy9pZiBlbmQgd2l0aCBhIGRpZ2l0LCB0aGVuIGFwcGVuZCBhbiB1bmRlcnNCYXNlIGJlZm9yZSBhcHBlbmRpbmdcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gbmFtZS5jaGFyQ29kZUF0KG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykgbmFtZSArPSBcIl9cIjtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBVdGlscy5nZXRVSUQoKTtcbiAgICB9LFxuICAgIGNhbnZhc1N1cHBvcnQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dDtcbiAgICB9LFxuICAgIGNyZWF0ZU9iamVjdCA6IGZ1bmN0aW9uKCBwcm90byAsIGNvbnN0cnVjdG9yICkge1xuICAgICAgICB2YXIgbmV3UHJvdG87XG4gICAgICAgIHZhciBPYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuICAgICAgICBpZiAoT2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgICBuZXdQcm90byA9IE9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBVdGlscy5fX2VtcHR5RnVuYy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgICAgIG5ld1Byb3RvID0gbmV3IFV0aWxzLl9fZW1wdHlGdW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UHJvdG8uY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ld1Byb3RvO1xuICAgIH0sXG4gICAgY3JlYXRDbGFzcyA6IGZ1bmN0aW9uKHIsIHMsIHB4KXtcbiAgICAgICAgaWYgKCFzIHx8ICFyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3AgPSBzLnByb3RvdHlwZSwgcnA7XG4gICAgICAgIC8vIGFkZCBwcm90b3R5cGUgY2hhaW5cbiAgICAgICAgcnAgPSBVdGlscy5jcmVhdGVPYmplY3Qoc3AsIHIpO1xuICAgICAgICByLnByb3RvdHlwZSA9IF8uZXh0ZW5kKHJwLCByLnByb3RvdHlwZSk7XG4gICAgICAgIHIuc3VwZXJjbGFzcyA9IFV0aWxzLmNyZWF0ZU9iamVjdChzcCwgcyk7XG4gICAgICAgIC8vIGFkZCBwcm90b3R5cGUgb3ZlcnJpZGVzXG4gICAgICAgIGlmIChweCkge1xuICAgICAgICAgICAgXy5leHRlbmQocnAsIHB4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIGluaXRFbGVtZW50IDogZnVuY3Rpb24oIGNhbnZhcyApe1xuICAgICAgICBpZiggd2luZG93LkZsYXNoQ2FudmFzICYmIEZsYXNoQ2FudmFzLmluaXRFbGVtZW50KXtcbiAgICAgICAgICAgIEZsYXNoQ2FudmFzLmluaXRFbGVtZW50KCBjYW52YXMgKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy/lgZrkuIDmrKHnroDljZXnmoRvcHTlj4LmlbDmoKHpqozvvIzkv53or4HlnKjnlKjmiLfkuI3kvKBvcHTnmoTml7blgJkg5oiW6ICF5Lyg5LqGb3B05L2G5piv6YeM6Z2i5rKh5pyJY29udGV4dOeahOaXtuWAmeaKpemUmVxuICAgIGNoZWNrT3B0ICAgIDogZnVuY3Rpb24ob3B0KXtcbiAgICAgICAgaWYoICFvcHQgKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGV4dCA6IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gICBcbiAgICAgICAgfSBlbHNlIGlmKCBvcHQgJiYgIW9wdC5jb250ZXh0ICkge1xuICAgICAgICAgIG9wdC5jb250ZXh0ID0ge31cbiAgICAgICAgICByZXR1cm4gb3B0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvcHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIOaMieeFp2Nzc+eahOmhuuW6j++8jOi/lOWbnuS4gOS4qlvkuIos5Y+zLOS4iyzlt6ZdXG4gICAgICovXG4gICAgZ2V0Q3NzT3JkZXJBcnIgOiBmdW5jdGlvbiggciApe1xuICAgICAgICB2YXIgcjE7IFxuICAgICAgICB2YXIgcjI7IFxuICAgICAgICB2YXIgcjM7IFxuICAgICAgICB2YXIgcjQ7XG5cbiAgICAgICAgaWYodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICByMSA9IHIzID0gclswXTtcbiAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByMSA9IHJbMF07XG4gICAgICAgICAgICAgICAgcjIgPSByWzFdO1xuICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICByNCA9IHJbM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyMSxyMixyMyxyNF07XG4gICAgfSxcblxuICAgIGlzV2ViR0xTdXBwb3J0ZWQgOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0geyBzdGVuY2lsOiB0cnVlIH07XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQpIC8v5LiN5a2Y5Zyo55u05o6lcmV0dXJuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLCBcbiAgICAgICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGNvbnRleHRPcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgY29udGV4dE9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuICEhKGdsICYmIGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuc3RlbmNpbCk7IC8v6L+Y6KaB56Gu5a6e5qOA5rWL5piv5ZCm5pSv5oyBd2ViR0zmqKHlvI9cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVXRpbHM7IiwiLyoqXG4gKiBQb2ludFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRcbntcbiAgICBjb25zdHJ1Y3RvciggeD0wICwgeT0wIClcbiAgICB7XG4gICAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoPT0xICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT0gJ29iamVjdCcgKXtcbiAgICAgICAgICAgIHZhciBhcmc9YXJndW1lbnRzWzBdXG4gICAgICAgICAgICBpZiggXCJ4XCIgaW4gYXJnICYmIFwieVwiIGluIGFyZyApe1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IGFyZy54KjE7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gYXJnLnkqMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGk9MDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIGFyZyl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGk9PTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYXJnW3BdKjE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBhcmdbcF0qMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4KjE7XG4gICAgICAgICAgICB0aGlzLnkgPSB5KjE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0FycmF5KClcbiAgICB7XG4gICAgICAgIHJldHVybiBbdGhpcy54ICwgdGhpcy55XSAgXG4gICAgfVxufTtcblxuIiwiLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICogY2FudmFzIOS4iuWnlOaJmOeahOS6i+S7tueuoeeQhlxuICovXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xuXG52YXIgQ2FudmF4RXZlbnQgPSBmdW5jdGlvbiggZXZ0ICwgcGFyYW1zICkge1xuXHRcblx0dmFyIGV2ZW50VHlwZSA9IFwiQ2FudmF4RXZlbnRcIjsgXG4gICAgaWYoIF8uaXNTdHJpbmcoIGV2dCApICl7XG4gICAgXHRldmVudFR5cGUgPSBldnQ7XG4gICAgfTtcbiAgICBpZiggXy5pc09iamVjdCggZXZ0ICkgJiYgZXZ0LnR5cGUgKXtcbiAgICBcdGV2ZW50VHlwZSA9IGV2dC50eXBlO1xuICAgIH07XG5cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcdFxuICAgIHRoaXMudHlwZSAgID0gZXZlbnRUeXBlO1xuICAgIHRoaXMucG9pbnQgID0gbnVsbDtcblxuICAgIHRoaXMuX3N0b3BQcm9wYWdhdGlvbiA9IGZhbHNlIDsgLy/pu5jorqTkuI3pmLvmraLkuovku7blhpLms6Fcbn1cbkNhbnZheEV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICBzdG9wUHJvcGFnYXRpb24gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBDYW52YXhFdmVudDsiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgLy/orr7lpIfliIbovqjnjodcbiAgICBSRVNPTFVUSU9OOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuXG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgZnJhbWVzIHBlciBtaWxsaXNlY29uZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wNlxuICAgICAqL1xuICAgIFRBUkdFVF9GUE1TOiAwLjA2LFxuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUgV2ViR0wgd2lsbCBhdHRlbXB0IG1ha2UgdGV4dHVyZXMgbWltcGFwZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBNaXBtYXBwaW5nIHdpbGwgb25seSBzdWNjZWVkIGlmIHRoZSBiYXNlIHRleHR1cmUgdXBsb2FkZWQgaGFzIHBvd2VyIG9mIHR3byBkaW1lbnNpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIE1JUE1BUF9URVhUVVJFUzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZmlsdGVyIHJlc29sdXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICBGSUxURVJfUkVTT0xVVElPTjogMSxcblxuXG4gICAgLy8gVE9ETzogbWF5YmUgY2hhbmdlIHRvIFNQUklURS5CQVRDSF9TSVpFOiAyMDAwXG4gICAgLy8gVE9ETzogbWF5YmUgYWRkIFBBUlRJQ0xFLkJBVENIX1NJWkU6IDE1MDAwXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBzcHJpdGUgYmF0Y2ggc2l6ZS5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGFpbXMgdG8gYmFsYW5jZSBkZXNrdG9wIGFuZCBtb2JpbGUgZGV2aWNlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNDA5NlxuICAgICAqL1xuICAgIFNQUklURV9CQVRDSF9TSVpFOiA0MDk2LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByZWZpeCB0aGF0IGRlbm90ZXMgYSBVUkwgaXMgZm9yIGEgcmV0aW5hIGFzc2V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge1JlZ0V4cHxzdHJpbmd9XG4gICAgICogQGV4YW1wbGUgYEAyeGBcbiAgICAgKiBAZGVmYXVsdCAvQCguKyl4L1xuICAgICAqL1xuICAgIFJFVElOQV9QUkVGSVg6IC9AKC4rKXgvLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyIG9wdGlvbnMgaWYgbm9uZSBhcmUgc3VwcGxpZWQgdG8ge0BsaW5rIFBJWEkuV2ViR0xSZW5kZXJlcn1cbiAgICAgKiBvciB7QGxpbmsgUElYSS5DYW52YXNSZW5kZXJlcn0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR9IHZpZXc9bnVsbFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNvbHV0aW9uPTFcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFudGlhbGlhcz1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZm9yY2VGWEFBPWZhbHNlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdXRvUmVzaXplPWZhbHNlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSB0cmFuc3BhcmVudD1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiYWNrZ3JvdW5kQ29sb3I9MHgwMDAwMDBcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNsZWFyQmVmb3JlUmVuZGVyPXRydWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm91bmRQaXhlbHM9ZmFsc2VcbiAgICAgKi9cbiAgICBSRU5ERVJfT1BUSU9OUzoge1xuICAgICAgICB2aWV3OiBudWxsLFxuICAgICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAgIGZvcmNlRlhBQTogZmFsc2UsXG4gICAgICAgIGF1dG9SZXNpemU6IGZhbHNlLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAweDAwMDAwMCxcbiAgICAgICAgY2xlYXJCZWZvcmVSZW5kZXI6IHRydWUsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgIHJvdW5kUGl4ZWxzOiBmYWxzZSxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB0cmFuc2Zvcm0gdHlwZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtQSVhJLlRSQU5TRk9STV9NT0RFfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuVFJBTlNGT1JNX01PREUuU1RBVElDXG4gICAgICovXG4gICAgVFJBTlNGT1JNX01PREU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge1BJWEkuR0NfTU9ERVN9XG4gICAgICogQGRlZmF1bHQgUElYSS5HQ19NT0RFUy5BVVRPXG4gICAgICovXG4gICAgR0NfTU9ERTogMCxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1heCBpZGxlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAzNjAwXG4gICAgICovXG4gICAgR0NfTUFYX0lETEU6IDYwICogNjAsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtYXhpbXVtIGNoZWNrIGNvdW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cbiAgICBHQ19NQVhfQ0hFQ0tfQ09VTlQ6IDYwICogMTAsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHdyYXAgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAgICAgKiBAdHlwZSB7UElYSS5XUkFQX01PREVTfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuV1JBUF9NT0RFUy5DTEFNUFxuICAgICAqL1xuICAgIFdSQVBfTU9ERTogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBtb2RlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgcGl4aS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtQSVhJLlNDQUxFX01PREVTfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuU0NBTEVfTU9ERVMuTElORUFSXG4gICAgICovXG4gICAgU0NBTEVfTU9ERTogMCxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3BlY2lmeSBmbG9hdCBwcmVjaXNpb24gaW4gc2hhZGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICAgICAqIEB0eXBlIHtQSVhJLlBSRUNJU0lPTn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLlBSRUNJU0lPTi5NRURJVU1cbiAgICAgKi9cbiAgICBQUkVDSVNJT046ICdtZWRpdW1wJyxcblxufTtcbiIsImltcG9ydCBfIGZyb20gXCIuL3VuZGVyc2NvcmVcIjtcbmltcG9ydCBzZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3NcIlxuXG52YXIgYWRkT3JSbW92ZUV2ZW50SGFuZCA9IGZ1bmN0aW9uKCBkb21IYW5kICwgaWVIYW5kICl7XG4gICAgaWYoIGRvY3VtZW50WyBkb21IYW5kIF0gKXtcbiAgICAgICAgZnVuY3Rpb24gZXZlbnREb21GbiggZWwgLCB0eXBlICwgZm4gKXtcbiAgICAgICAgICAgIGlmKCBlbC5sZW5ndGggKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MCA7IGkgPCBlbC5sZW5ndGggOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBldmVudERvbUZuKCBlbFtpXSAsIHR5cGUgLCBmbiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxbIGRvbUhhbmQgXSggdHlwZSAsIGZuICwgZmFsc2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV2ZW50RG9tRm5cbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBldmVudEZuKCBlbCAsIHR5cGUgLCBmbiApe1xuICAgICAgICAgICAgaWYoIGVsLmxlbmd0aCApe1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wIDsgaSA8IGVsLmxlbmd0aCA7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Rm4oIGVsW2ldLHR5cGUsZm4gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsWyBpZUhhbmQgXSggXCJvblwiK3R5cGUgLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbCggZWwgLCB3aW5kb3cuZXZlbnQgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV2ZW50Rm5cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgLy8gZG9t5pON5L2c55u45YWz5Luj56CBXG4gICAgcXVlcnkgOiBmdW5jdGlvbihlbCl7XG4gICAgICAgIGlmKF8uaXNTdHJpbmcoZWwpKXtcbiAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKVxuICAgICAgICB9XG4gICAgICAgIGlmKGVsLm5vZGVUeXBlID09IDEpe1xuICAgICAgICAgICAvL+WImeS4uuS4gOS4qmVsZW1lbnTmnKzouqtcbiAgICAgICAgICAgcmV0dXJuIGVsXG4gICAgICAgIH1cbiAgICAgICAgaWYoZWwubGVuZ3RoKXtcbiAgICAgICAgICAgcmV0dXJuIGVsWzBdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBvZmZzZXQgOiBmdW5jdGlvbihlbCl7XG4gICAgICAgIHZhciBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgXG4gICAgICAgIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsIFxuICAgICAgICBib2R5ID0gZG9jLmJvZHksIFxuICAgICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCwgXG5cbiAgICAgICAgLy8gZm9yIGllICBcbiAgICAgICAgY2xpZW50VG9wID0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCwgXG4gICAgICAgIGNsaWVudExlZnQgPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDAsIFxuXG4gICAgICAgIC8vIEluIEludGVybmV0IEV4cGxvcmVyIDcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHByb3BlcnR5IGlzIHRyZWF0ZWQgYXMgcGh5c2ljYWwsIFxuICAgICAgICAvLyB3aGlsZSBvdGhlcnMgYXJlIGxvZ2ljYWwuIE1ha2UgYWxsIGxvZ2ljYWwsIGxpa2UgaW4gSUU4LiBcbiAgICAgICAgem9vbSA9IDE7IFxuICAgICAgICBpZiAoYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHsgXG4gICAgICAgICAgICB2YXIgYm91bmQgPSBib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyBcbiAgICAgICAgICAgIHpvb20gPSAoYm91bmQucmlnaHQgLSBib3VuZC5sZWZ0KS9ib2R5LmNsaWVudFdpZHRoOyBcbiAgICAgICAgfSBcbiAgICAgICAgaWYgKHpvb20gPiAxKXsgXG4gICAgICAgICAgICBjbGllbnRUb3AgPSAwOyBcbiAgICAgICAgICAgIGNsaWVudExlZnQgPSAwOyBcbiAgICAgICAgfSBcbiAgICAgICAgdmFyIHRvcCA9IGJveC50b3Avem9vbSArICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLnNjcm9sbFRvcC96b29tIHx8IGJvZHkuc2Nyb2xsVG9wL3pvb20pIC0gY2xpZW50VG9wLCBcbiAgICAgICAgICAgIGxlZnQgPSBib3gubGVmdC96b29tICsgKHdpbmRvdy5wYWdlWE9mZnNldHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5zY3JvbGxMZWZ0L3pvb20gfHwgYm9keS5zY3JvbGxMZWZ0L3pvb20pIC0gY2xpZW50TGVmdDsgXG5cbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICB0b3A6IHRvcCwgXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0IFxuICAgICAgICB9OyBcbiAgICB9LFxuICAgIGFkZEV2ZW50IDogYWRkT3JSbW92ZUV2ZW50SGFuZCggXCJhZGRFdmVudExpc3RlbmVyXCIgLCBcImF0dGFjaEV2ZW50XCIgKSxcbiAgICByZW1vdmVFdmVudCA6IGFkZE9yUm1vdmVFdmVudEhhbmQoIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiICwgXCJkZXRhY2hFdmVudFwiICksXG4gICAgcGFnZVg6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUucGFnZVgpIHJldHVybiBlLnBhZ2VYO1xuICAgICAgICBlbHNlIGlmIChlLmNsaWVudFgpXG4gICAgICAgICAgICByZXR1cm4gZS5jbGllbnRYICsgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ID9cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpO1xuICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcGFnZVk6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUucGFnZVkpIHJldHVybiBlLnBhZ2VZO1xuICAgICAgICBlbHNlIGlmIChlLmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gZS5jbGllbnRZICsgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgP1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApO1xuICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yib5bu6ZG9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGRvbSBpZCDlvoXnlKhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSA6IGRvbSB0eXBl77yMIHN1Y2ggYXMgY2FudmFzLCBkaXYgZXRjLlxuICAgICAqL1xuICAgIGNyZWF0ZUNhbnZhcyA6IGZ1bmN0aW9uKCBfd2lkdGggLCBfaGVpZ2h0ICwgaWQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCAgPSBfd2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gX2hlaWdodCArICdweCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ICAgPSAwO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wICAgID0gMDtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBfd2lkdGggKiBzZXR0aW5ncy5SRVNPTFVUSU9OKTtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgX2hlaWdodCAqIHNldHRpbmdzLlJFU09MVVRJT04pO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9LFxuICAgIGNyZWF0ZVZpZXc6IGZ1bmN0aW9uKF93aWR0aCAsIF9oZWlnaHQsIGlkKXtcbiAgICAgICAgdmFyIHZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2aWV3LmNsYXNzTmFtZSA9IFwiY2FudmF4LXZpZXdcIjtcbiAgICAgICAgdmlldy5zdHlsZS5jc3NUZXh0ICs9IFwicG9zaXRpb246cmVsYXRpdmU7d2lkdGg6XCIgKyBfd2lkdGggKyBcInB4O2hlaWdodDpcIiArIF9oZWlnaHQgK1wicHg7XCJcblxuICAgICAgICB2YXIgc3RhZ2VfYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZpZXcuc3R5bGUuY3NzVGV4dCArPSBcInBvc2l0aW9uOmFic29sdXRlO3dpZHRoOlwiICsgX3dpZHRoICsgXCJweDtoZWlnaHQ6XCIgKyBfaGVpZ2h0ICtcInB4O1wiXG5cbiAgICAgICAgLy/nlKjmnaXlrZjmlL7kuIDkuptkb23lhYPntKBcbiAgICAgICAgdmFyIGRvbV9jID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmlldy5zdHlsZS5jc3NUZXh0ICs9IFwicG9zaXRpb246YWJzb2x1dGU7d2lkdGg6XCIgKyBfd2lkdGggKyBcInB4O2hlaWdodDpcIiArIF9oZWlnaHQgK1wicHg7XCJcblxuICAgICAgICB2aWV3LmFwcGVuZENoaWxkKHN0YWdlX2MpO1xuICAgICAgICB2aWV3LmFwcGVuZENoaWxkKGRvbV9jKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aWV3IDogdmlldyxcbiAgICAgICAgICAgIHN0YWdlX2M6IHN0YWdlX2MsXG4gICAgICAgICAgICBkb21fYzogZG9tX2NcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2RvbeebuOWFs+S7o+eggee7k+adn1xufTsiLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKi9cbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vZGlzcGxheS9Qb2ludFwiO1xuaW1wb3J0IENhbnZheEV2ZW50IGZyb20gXCIuL0NhbnZheEV2ZW50XCI7XG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuaW1wb3J0ICQgZnJvbSBcIi4uL3V0aWxzL2RvbVwiO1xuXG52YXIgX21vdXNlRXZlbnRUeXBlcyA9IFtcImNsaWNrXCIsXCJkYmxjbGlja1wiLFwibW91c2Vkb3duXCIsXCJtb3VzZW1vdmVcIixcIm1vdXNldXBcIixcIm1vdXNlb3V0XCJdO1xudmFyIF9oYW1tZXJFdmVudFR5cGVzID0gWyBcbiAgICBcInBhblwiLFwicGFuc3RhcnRcIixcInBhbm1vdmVcIixcInBhbmVuZFwiLFwicGFuY2FuY2VsXCIsXCJwYW5sZWZ0XCIsXCJwYW5yaWdodFwiLFwicGFudXBcIixcInBhbmRvd25cIixcbiAgICBcInByZXNzXCIgLCBcInByZXNzdXBcIixcbiAgICBcInN3aXBlXCIgLCBcInN3aXBlbGVmdFwiICwgXCJzd2lwZXJpZ2h0XCIgLCBcInN3aXBldXBcIiAsIFwic3dpcGVkb3duXCIsXG4gICAgXCJ0YXBcIlxuXTtcblxudmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKGNhbnZheCAsIG9wdCkge1xuICAgIHRoaXMuY2FudmF4ID0gY2FudmF4O1xuXG4gICAgdGhpcy5jdXJQb2ludHMgPSBbbmV3IFBvaW50KDAsIDApXSAvL1gsWSDnmoQgcG9pbnQg6ZuG5ZCILCDlnKh0b3VjaOS4i+mdouWImeS4uiB0b3VjaOeahOmbhuWQiO+8jOWPquaYr+i/meS4qnRvdWNo6KKr5re75Yqg5LqG5a+55bqU55qEeO+8jHlcbiAgICAvL+W9k+WJjea/gOa0u+eahOeCueWvueW6lOeahG9iau+8jOWcqHRvdWNo5LiL5Y+v5Lul5piv5Liq5pWw57uELOWSjOS4iumdoueahCBjdXJQb2ludHMg5a+55bqUXG4gICAgdGhpcy5jdXJQb2ludHNUYXJnZXQgPSBbXTtcblxuICAgIHRoaXMuX3RvdWNoaW5nID0gZmFsc2U7XG4gICAgLy/mraPlnKjmi5bliqjvvIzliY3mj5DmmK9fdG91Y2hpbmc9dHJ1ZVxuICAgIHRoaXMuX2RyYWdpbmcgPSBmYWxzZTtcblxuICAgIC8v5b2T5YmN55qE6byg5qCH54q25oCBXG4gICAgdGhpcy5fY3Vyc29yID0gXCJkZWZhdWx0XCI7XG5cbiAgICB0aGlzLnRhcmdldCA9IHRoaXMuY2FudmF4LnZpZXc7XG4gICAgdGhpcy50eXBlcyA9IFtdO1xuXG4gICAgLy9tb3VzZeS9k+e7n+S4reS4jemcgOimgemFjee9rmRyYWcsdG91Y2jkuK3kvJrnlKjliLDnrKzkuInmlrnnmoR0b3VjaOW6k++8jOavj+S4quW6k+eahOS6i+S7tuWQjeensOWPr+iDveS4jeS4gOagt++8jFxuICAgIC8v5bCx6KaB6L+Z6YeM6YWN572u77yM6buY6K6k5a6e546w55qE5pivaGFtbWVyanPnmoQs5omA5Lul6buY6K6k5Y+v5Lul5Zyo6aG555uu6YeM5byV5YWlaGFtbWVyanMgaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAgICB0aGlzLmRyYWcgPSB7XG4gICAgICAgIHN0YXJ0IDogXCJwYW5zdGFydFwiLFxuICAgICAgICBtb3ZlIDogXCJwYW5tb3ZlXCIsXG4gICAgICAgIGVuZCA6IFwicGFuZW5kXCJcbiAgICB9O1xuXG4gICAgXy5leHRlbmQoIHRydWUgLCB0aGlzICwgb3B0ICk7XG5cbn07XG5cbi8v6L+Z5qC355qE5aW95aSE5pivZG9jdW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb27lj6rkvJrlnKjlrprkuYnnmoTml7blgJnmiafooYzkuIDmrKHjgIJcbnZhciBjb250YWlucyA9IGRvY3VtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiggIWNoaWxkICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHBhcmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihjaGlsZCkgJiAxNik7XG59IDogZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiggIWNoaWxkICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkICE9PSBjaGlsZCAmJiAocGFyZW50LmNvbnRhaW5zID8gcGFyZW50LmNvbnRhaW5zKGNoaWxkKSA6IHRydWUpO1xufTtcblxuRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgICBpbml0IDogZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgIC8v5L6d5qyh5re75Yqg5LiK5rWP6KeI5Zmo55qE6Ieq5bim5LqL5Lu25L6m5ZCsXG4gICAgICAgIHZhciBtZSAgID0gdGhpcztcbiAgICAgICAgaWYoIG1lLnRhcmdldC5ub2RlVHlwZSA9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIC8v5aaC5p6cdGFyZ2V0Lm5vZGVUeXBl5rKh5pyJ55qE6K+d77yMIOivtOaYjuivpXRhcmdldOS4uuS4gOS4qmpRdWVyeeWvueixoSBvciBraXNzeSDlr7nosaFvciBoYW1tZXLlr7nosaFcbiAgICAgICAgICAgIC8v5Y2z5Li656ys5LiJ5pa55bqT77yM6YKj5LmI5bCx6KaB5a+55o6l56ys5LiJ5pa55bqT55qE5LqL5Lu257O757uf44CC6buY6K6k5a6e546waGFtbWVy55qE5aSn6YOo5YiG5LqL5Lu257O757ufXG4gICAgICAgICAgICBpZiggIW1lLnR5cGVzIHx8IG1lLnR5cGVzLmxlbmd0aCA9PSAwICApe1xuICAgICAgICAgICAgICAgIG1lLnR5cGVzID0gX2hhbW1lckV2ZW50VHlwZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYoIG1lLnRhcmdldC5ub2RlVHlwZSA9PSAxICl7XG4gICAgICAgICAgICBtZS50eXBlcyA9IF9tb3VzZUV2ZW50VHlwZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgXy5lYWNoKCBtZS50eXBlcyAsIGZ1bmN0aW9uKCB0eXBlICl7XG4gICAgICAgICAgICAvL+S4jeWGjeWFs+W/g+a1j+iniOWZqOeOr+Wig+aYr+WQpiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgXG4gICAgICAgICAgICAvL+iAjOaYr+ebtOaOpeWPqueuoeS8oOe7meS6i+S7tuaooeWdl+eahOaYr+S4gOS4quWOn+eUn2Rvbei/mOaYryBqceWvueixoSBvciBoYW1tZXLlr7nosaHnrYlcbiAgICAgICAgICAgIGlmKCBtZS50YXJnZXQubm9kZVR5cGUgPT0gMSApe1xuICAgICAgICAgICAgICAgICQuYWRkRXZlbnQoIG1lLnRhcmdldCAsIHR5cGUgLCBmdW5jdGlvbiggZSApe1xuICAgICAgICAgICAgICAgICAgICBtZS5fX21vdXNlSGFuZGxlciggZSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWUudGFyZ2V0Lm9uKCB0eXBlICwgZnVuY3Rpb24oIGUgKXtcbiAgICAgICAgICAgICAgICAgICAgbWUuX19saWJIYW5kbGVyKCBlICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG4gICAgfSxcbiAgICAvKlxuICAgICog5Y6f55Sf5LqL5Lu257O757ufLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tYmVnaW5cbiAgICAqIOm8oOagh+S6i+S7tuWkhOeQhuWHveaVsFxuICAgICoqL1xuICAgIF9fbW91c2VIYW5kbGVyIDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdCA9IG1lLmNhbnZheDtcblxuICAgICAgICByb290LnVwZGF0ZVZpZXdPZmZzZXQoKTtcbiAgICBcbiAgICAgICAgbWUuY3VyUG9pbnRzID0gWyBuZXcgUG9pbnQoIFxuICAgICAgICAgICAgJC5wYWdlWCggZSApIC0gcm9vdC52aWV3T2Zmc2V0LmxlZnQgLCBcbiAgICAgICAgICAgICQucGFnZVkoIGUgKSAtIHJvb3Qudmlld09mZnNldC50b3BcbiAgICAgICAgKV07XG5cbiAgICAgICAgLy/nkIborrrkuIrmnaXor7TvvIzov5nph4zmi7/liLBwb2ludOS6huWQju+8jOWwseimgeiuoeeul+i/meS4qnBvaW505a+55bqU55qEdGFyZ2V05p2lcHVzaOWIsGN1clBvaW50c1RhcmdldOmHjO+8jFxuICAgICAgICAvL+S9huaYr+WboOS4uuWcqGRyYWfnmoTml7blgJnlhbblrp7mmK/lj6/ku6XkuI3nlKjorqHnrpflr7nlupR0YXJnZXTnmoTjgIJcbiAgICAgICAgLy/miYDku6XmlL7lnKjkuobkuIvpnaLnmoRtZS5fX2dldGN1clBvaW50c1RhcmdldCggZSAsIGN1ck1vdXNlUG9pbnQgKTvluLjop4Rtb3VzZW1vdmXkuK3miafooYxcblxuICAgICAgICB2YXIgY3VyTW91c2VQb2ludCAgPSBtZS5jdXJQb2ludHNbMF07IFxuICAgICAgICB2YXIgY3VyTW91c2VUYXJnZXQgPSBtZS5jdXJQb2ludHNUYXJnZXRbMF07XG5cbiAgICAgICAgLy/mqKHmi59kcmFnLG1vdXNlb3Zlcixtb3VzZW91dCDpg6jliIbku6PnoIEgYmVnaW4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgLy9tb3VzZWRvd27nmoTml7blgJkg5aaC5p6cIGN1ck1vdXNlVGFyZ2V0LmRyYWdFbmFibGVkIOS4unRydWXjgILlsLHopoHlvIDlp4vlh4blpIdkcmFn5LqGXG4gICAgICAgIGlmKCBlLnR5cGUgPT0gXCJtb3VzZWRvd25cIiApe1xuICAgICAgICAgICAvL+WmguaenGN1clRhcmdldCDnmoTmlbDnu4TkuLrnqbrmiJbogIXnrKzkuIDkuKrkuLpmYWxzZSDvvIzvvIzvvIxcbiAgICAgICAgICAgaWYoICFjdXJNb3VzZVRhcmdldCApe1xuICAgICAgICAgICAgIHZhciBvYmogPSByb290LmdldE9iamVjdHNVbmRlclBvaW50KCBjdXJNb3VzZVBvaW50ICwgMSlbMF07XG4gICAgICAgICAgICAgaWYob2JqKXtcbiAgICAgICAgICAgICAgIG1lLmN1clBvaW50c1RhcmdldCA9IFsgb2JqIF07XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9O1xuICAgICAgICAgICBjdXJNb3VzZVRhcmdldCA9IG1lLmN1clBvaW50c1RhcmdldFswXTtcbiAgICAgICAgICAgaWYgKCBjdXJNb3VzZVRhcmdldCAmJiBjdXJNb3VzZVRhcmdldC5kcmFnRW5hYmxlZCApe1xuICAgICAgICAgICAgICAgLy/pvKDmoIfkuovku7blt7Lnu4/mkbjliLDkuobkuIDkuKpcbiAgICAgICAgICAgICAgIG1lLl90b3VjaGluZyA9IHRydWU7XG4gICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGUudHlwZSA9PSBcIm1vdXNldXBcIiB8fCAoZS50eXBlID09IFwibW91c2VvdXRcIiAmJiAhY29udGFpbnMocm9vdC52aWV3ICwgKGUudG9FbGVtZW50IHx8IGUucmVsYXRlZFRhcmdldCkgKSkgKXtcbiAgICAgICAgICAgIGlmKG1lLl9kcmFnaW5nID09IHRydWUpe1xuICAgICAgICAgICAgICAgIC8v6K+05piO5Yia5Yia5Zyo5ouW5YqoXG4gICAgICAgICAgICAgICAgbWUuX2RyYWdFbmQoIGUgLCBjdXJNb3VzZVRhcmdldCAsIDAgKTtcbiAgICAgICAgICAgICAgICBjdXJNb3VzZVRhcmdldC5maXJlKFwiZHJhZ2VuZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZS5fZHJhZ2luZyAgPSBmYWxzZTtcbiAgICAgICAgICAgIG1lLl90b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBlLnR5cGUgPT0gXCJtb3VzZW91dFwiICl7XG4gICAgICAgICAgICBpZiggIWNvbnRhaW5zKHJvb3QudmlldyAsIChlLnRvRWxlbWVudCB8fCBlLnJlbGF0ZWRUYXJnZXQpICkgKXtcbiAgICAgICAgICAgICAgICBtZS5fX2dldGN1clBvaW50c1RhcmdldChlICwgY3VyTW91c2VQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggZS50eXBlID09IFwibW91c2Vtb3ZlXCIgKXsgIC8vfHwgZS50eXBlID09IFwibW91c2Vkb3duXCIgKXtcbiAgICAgICAgICAgIC8v5ouW5Yqo6L+H56iL5Lit5bCx5LiN5Zyo5YGa5YW25LuW55qEbW91c2VvdmVy5qOA5rWL77yMZHJhZ+S8mOWFiFxuICAgICAgICAgICAgaWYobWUuX3RvdWNoaW5nICYmIGUudHlwZSA9PSBcIm1vdXNlbW92ZVwiICYmIGN1ck1vdXNlVGFyZ2V0KXtcbiAgICAgICAgICAgICAgICAvL+ivtOaYjuato+WcqOaLluWKqOWVilxuICAgICAgICAgICAgICAgIGlmKCFtZS5fZHJhZ2luZyl7XG4gICAgICAgICAgICAgICAgICAgIC8vYmVnaW4gZHJhZ1xuICAgICAgICAgICAgICAgICAgICBjdXJNb3VzZVRhcmdldC5maXJlKFwiZHJhZ3N0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAvL+WFiOaKiuacrOWwiue7memakOiXj+S6hlxuICAgICAgICAgICAgICAgICAgICBjdXJNb3VzZVRhcmdldC5jb250ZXh0Lmdsb2JhbEFscGhhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy/nhLblkI7lhYvpmobkuIDkuKrlia/mnKzliLBhY3RpdmVTdGFnZVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lT2JqZWN0ID0gbWUuX2Nsb25lMmhvdmVyU3RhZ2UoIGN1ck1vdXNlVGFyZ2V0ICwgMCApO1xuICAgICAgICAgICAgICAgICAgICBjbG9uZU9iamVjdC5jb250ZXh0Lmdsb2JhbEFscGhhID0gY3VyTW91c2VUYXJnZXQuX2dsb2JhbEFscGhhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZHJhZyBtb3ZlIGluZ1xuICAgICAgICAgICAgICAgICAgICBtZS5fZHJhZ01vdmVIYW5kZXIoIGUgLCBjdXJNb3VzZVRhcmdldCAsIDAgKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lLl9kcmFnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy/luLjop4Rtb3VzZW1vdmXmo4DmtYtcbiAgICAgICAgICAgICAgICAvL21vdmXkuovku7bkuK3vvIzpnIDopoHkuI3lgZznmoTmkJzntKJ0YXJnZXTvvIzov5nkuKrlvIDplIDmjLrlpKfvvIxcbiAgICAgICAgICAgICAgICAvL+WQjue7reWPr+S7peS8mOWMlu+8jOWKoOS4iuWSjOW4p+eOh+ebuOW9k+eahOW7tui/n+WkhOeQhlxuICAgICAgICAgICAgICAgIG1lLl9fZ2V0Y3VyUG9pbnRzVGFyZ2V0KCBlICwgY3VyTW91c2VQb2ludCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL+WFtuS7lueahOS6i+S7tuWwseebtOaOpeWcqHRhcmdldOS4iumdoua0vuWPkeS6i+S7tlxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY3VyTW91c2VUYXJnZXQ7XG4gICAgICAgICAgICBpZiggIWNoaWxkICl7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSByb290O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lLl9fZGlzcGF0Y2hFdmVudEluQ2hpbGRzKCBlICwgWyBjaGlsZCBdICk7XG4gICAgICAgICAgICBtZS5fY3Vyc29ySGFuZGVyKCBjaGlsZCApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCByb290LnByZXZlbnREZWZhdWx0ICkge1xuICAgICAgICAgICAgLy/pmLvmraLpu5jorqTmtY/op4jlmajliqjkvZwoVzNDKSBcbiAgICAgICAgICAgIGlmICggZSAmJiBlLnByZXZlbnREZWZhdWx0ICkge1xuICAgICAgICAgICAgICAgwqBlLnByZXZlbnREZWZhdWx0KCk7IFxuICAgICAgICAgICAgfcKgZWxzZSB7XG4gICAgICAgICAgICDCoMKgwqDCoHdpbmRvdy5ldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9OyBcbiAgICB9LFxuICAgIF9fZ2V0Y3VyUG9pbnRzVGFyZ2V0IDogZnVuY3Rpb24oZSAsIHBvaW50ICkge1xuICAgICAgICB2YXIgbWUgICAgID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgICA9IG1lLmNhbnZheDtcbiAgICAgICAgdmFyIG9sZE9iaiA9IG1lLmN1clBvaW50c1RhcmdldFswXTtcblxuICAgICAgICBpZiggb2xkT2JqICYmICFvbGRPYmouY29udGV4dCApe1xuICAgICAgICAgICAgb2xkT2JqID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZSA9IG5ldyBDYW52YXhFdmVudCggZSApO1xuXG4gICAgICAgIGlmKCBlLnR5cGU9PVwibW91c2Vtb3ZlXCJcbiAgICAgICAgICAgICYmIG9sZE9iaiAmJiBvbGRPYmouX2hvdmVyQ2xhc3MgJiYgb2xkT2JqLnBvaW50Q2hrUHJpb3JpdHlcbiAgICAgICAgICAgICYmIG9sZE9iai5nZXRDaGlsZEluUG9pbnQoIHBvaW50ICkgKXtcbiAgICAgICAgICAgIC8v5bCP5LyY5YyWLOm8oOagh21vdmXnmoTml7blgJnjgILorqHnrpfpopHnjoflpKrlpKfvvIzmiYDku6XjgILlgZrmraTkvJjljJZcbiAgICAgICAgICAgIC8v5aaC5p6c5pyJdGFyZ2V05a2Y5Zyo77yM6ICM5LiU5b2T5YmN5YWD57Sg5q2j5ZyoaG92ZXJTdGFnZeS4re+8jOiAjOS4lOW9k+WJjem8oOagh+i/mOWcqHRhcmdldOWGhSzlsLHmsqHlv4XopoHlj5bmo4DmtYvmlbTkuKpkaXNwbGF5TGlzdOS6hlxuICAgICAgICAgICAgLy/lvIDlj5HmtL7lj5HluLjop4Rtb3VzZW1vdmXkuovku7ZcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0ID0gb2xkT2JqO1xuICAgICAgICAgICAgZS5wb2ludCAgPSBvbGRPYmouZ2xvYmFsVG9Mb2NhbCggcG9pbnQgKTtcbiAgICAgICAgICAgIG9sZE9iai5kaXNwYXRjaEV2ZW50KCBlICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvYmogPSByb290LmdldE9iamVjdHNVbmRlclBvaW50KCBwb2ludCAsIDEpWzBdO1xuXG4gICAgICAgIGlmKG9sZE9iaiAmJiBvbGRPYmogIT0gb2JqIHx8IGUudHlwZT09XCJtb3VzZW91dFwiKSB7XG4gICAgICAgICAgICBpZiggb2xkT2JqICYmIG9sZE9iai5jb250ZXh0ICl7XG4gICAgICAgICAgICAgICAgbWUuY3VyUG9pbnRzVGFyZ2V0WzBdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlLnR5cGUgICAgID0gXCJtb3VzZW91dFwiO1xuICAgICAgICAgICAgICAgIGUudG9UYXJnZXQgPSBvYmo7IFxuICAgICAgICAgICAgICAgIGUudGFyZ2V0ICAgPSBlLmN1cnJlbnRUYXJnZXQgPSBvbGRPYmo7XG4gICAgICAgICAgICAgICAgZS5wb2ludCAgICA9IG9sZE9iai5nbG9iYWxUb0xvY2FsKCBwb2ludCApO1xuICAgICAgICAgICAgICAgIG9sZE9iai5kaXNwYXRjaEV2ZW50KCBlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIG9iaiAmJiBvbGRPYmogIT0gb2JqICl7IC8vJiYgb2JqLl9ob3ZlcmFibGUg5bey57uPIOW5suaOieS6hlxuICAgICAgICAgICAgbWUuY3VyUG9pbnRzVGFyZ2V0WzBdID0gb2JqO1xuICAgICAgICAgICAgZS50eXBlICAgICAgID0gXCJtb3VzZW92ZXJcIjtcbiAgICAgICAgICAgIGUuZnJvbVRhcmdldCA9IG9sZE9iajtcbiAgICAgICAgICAgIGUudGFyZ2V0ICAgICA9IGUuY3VycmVudFRhcmdldCA9IG9iajtcbiAgICAgICAgICAgIGUucG9pbnQgICAgICA9IG9iai5nbG9iYWxUb0xvY2FsKCBwb2ludCApO1xuICAgICAgICAgICAgb2JqLmRpc3BhdGNoRXZlbnQoIGUgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggZS50eXBlID09IFwibW91c2Vtb3ZlXCIgJiYgb2JqICl7XG4gICAgICAgICAgICBlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldCA9IG9sZE9iajtcbiAgICAgICAgICAgIGUucG9pbnQgID0gb2xkT2JqLmdsb2JhbFRvTG9jYWwoIHBvaW50ICk7XG4gICAgICAgICAgICBvbGRPYmouZGlzcGF0Y2hFdmVudCggZSApO1xuICAgICAgICB9O1xuICAgICAgICBtZS5fY3Vyc29ySGFuZGVyKCBvYmogLCBvbGRPYmogKTtcbiAgICB9LFxuICAgIF9jdXJzb3JIYW5kZXIgICAgOiBmdW5jdGlvbiggb2JqICwgb2xkT2JqICl7XG4gICAgICAgIGlmKCFvYmogJiYgIW9sZE9iaiApe1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKFwiZGVmYXVsdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmogJiYgb2xkT2JqICE9IG9iaiAmJiBvYmouY29udGV4dCl7XG4gICAgICAgICAgICB0aGlzLl9zZXRDdXJzb3Iob2JqLmNvbnRleHQuY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3NldEN1cnNvciA6IGZ1bmN0aW9uKGN1cnNvcikge1xuICAgICAgICBpZih0aGlzLl9jdXJzb3IgPT0gY3Vyc29yKXtcbiAgICAgICAgICAvL+WmguaenOS4pOasoeimgeiuvue9rueahOm8oOagh+eKtuaAgeaYr+S4gOagt+eahFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW52YXgudmlldy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIHRoaXMuX2N1cnNvciA9IGN1cnNvcjtcbiAgICB9LFxuICAgIC8qXG4gICAgKiDljp/nlJ/kuovku7bns7vnu58tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1lbmRcbiAgICAqL1xuXG4gICAgLypcbiAgICAgKuesrOS4ieaWueW6k+eahOS6i+S7tuezu+e7ny0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLWJlZ2luXG4gICAgICrop6blsY/kuovku7blpITnkIblh73mlbBcbiAgICAgKiAqL1xuICAgIF9fbGliSGFuZGxlciA6IGZ1bmN0aW9uKCBlICkge1xuICAgICAgICB2YXIgbWUgICA9IHRoaXM7XG4gICAgICAgIHZhciByb290ID0gbWUuY2FudmF4O1xuICAgICAgICByb290LnVwZGF0ZVZpZXdPZmZzZXQoKTtcbiAgICAgICAgLy8gdG91Y2gg5LiL55qEIGN1clBvaW50c1RhcmdldCDku450b3VjaGVz5Lit5p2lXG4gICAgICAgIC8v6I635Y+WY2FudmF45Z2Q5qCH57O757uf6YeM6Z2i55qE5Z2Q5qCHXG4gICAgICAgIG1lLmN1clBvaW50cyA9IG1lLl9fZ2V0Q2FudmF4UG9pbnRJblRvdWNocyggZSApO1xuICAgICAgICBpZiggIW1lLl9kcmFnaW5nICl7XG4gICAgICAgICAgICAvL+WmguaenOWcqGRyYWdpbmfnmoTor53vvIx0YXJnZXTlt7Lnu4/mmK/pgInkuK3kuobnmoTvvIzlj6/ku6XkuI3nlKgg5qOA5rWL5LqGXG4gICAgICAgICAgICBtZS5jdXJQb2ludHNUYXJnZXQgPSBtZS5fX2dldENoaWxkSW5Ub3VjaHMoIG1lLmN1clBvaW50cyApO1xuICAgICAgICB9O1xuICAgICAgICBpZiggbWUuY3VyUG9pbnRzVGFyZ2V0Lmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIC8vZHJhZ+W8gOWni1xuICAgICAgICAgICAgaWYoIGUudHlwZSA9PSBtZS5kcmFnLnN0YXJ0KXtcbiAgICAgICAgICAgICAgICAvL2RyYWdzdGFydOeahOaXtuWAmXRvdWNo5bey57uP5YeG5aSH5aW95LqGdGFyZ2V077yMIGN1clBvaW50c1RhcmdldCDph4zpnaLlj6ropoHmnInkuIDkuKrmmK/mnInmlYjnmoRcbiAgICAgICAgICAgICAgICAvL+WwseiupOS4umRyYWdz5byA5aeLXG4gICAgICAgICAgICAgICAgXy5lYWNoKCBtZS5jdXJQb2ludHNUYXJnZXQgLCBmdW5jdGlvbiggY2hpbGQgLCBpICl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBjaGlsZCAmJiBjaGlsZC5kcmFnRW5hYmxlZCApe1xuICAgICAgICAgICAgICAgICAgICAgICAvL+WPquimgeacieS4gOS4quWFg+e0oOWwseiupOS4uuato+WcqOWHhuWkh2RyYWfkuoZcbiAgICAgICAgICAgICAgICAgICAgICAgbWUuX2RyYWdpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAvL+eEtuWQjuWFi+mahuS4gOS4quWJr+acrOWIsGFjdGl2ZVN0YWdlXG4gICAgICAgICAgICAgICAgICAgICAgIG1lLl9jbG9uZTJob3ZlclN0YWdlKCBjaGlsZCAsIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgLy/lhYjmiormnKzlsIrnu5npmpDol4/kuoZcbiAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGV4dC5nbG9iYWxBbHBoYSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZmlyZShcImRyYWdzdGFydFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICkgXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL2RyYWdJbmdcbiAgICAgICAgICAgIGlmKCBlLnR5cGUgPT0gbWUuZHJhZy5tb3ZlKXtcbiAgICAgICAgICAgICAgICBpZiggbWUuX2RyYWdpbmcgKXtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKCBtZS5jdXJQb2ludHNUYXJnZXQgLCBmdW5jdGlvbiggY2hpbGQgLCBpICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggY2hpbGQgJiYgY2hpbGQuZHJhZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLl9kcmFnTW92ZUhhbmRlciggZSAsIGNoaWxkICwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vZHJhZ+e7k+adn1xuICAgICAgICAgICAgaWYoIGUudHlwZSA9PSBtZS5kcmFnLmVuZCl7XG4gICAgICAgICAgICAgICAgaWYoIG1lLl9kcmFnaW5nICl7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaCggbWUuY3VyUG9pbnRzVGFyZ2V0ICwgZnVuY3Rpb24oIGNoaWxkICwgaSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGNoaWxkICYmIGNoaWxkLmRyYWdFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuX2RyYWdFbmQoIGUgLCBjaGlsZCAsIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5maXJlKFwiZHJhZ2VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICBtZS5fZHJhZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZS5fX2Rpc3BhdGNoRXZlbnRJbkNoaWxkcyggZSAsIG1lLmN1clBvaW50c1RhcmdldCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy/lpoLmnpzlvZPliY3msqHmnInkuIDkuKp0YXJnZXTvvIzlsLHmiorkuovku7bmtL7lj5HliLBjYW52YXjkuIrpnaJcbiAgICAgICAgICAgIG1lLl9fZGlzcGF0Y2hFdmVudEluQ2hpbGRzKCBlICwgWyByb290IF0gKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8v5LuOdG91Y2hz5Lit6I635Y+W5Yiw5a+55bqUdG91Y2ggLCDlnKjkuIrpnaLmt7vliqDkuIpjYW52YXjlnZDmoIfns7vnu5/nmoR477yMeVxuICAgIF9fZ2V0Q2FudmF4UG9pbnRJblRvdWNocyA6IGZ1bmN0aW9uKCBlICl7XG4gICAgICAgIHZhciBtZSAgICAgICAgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdCAgICAgID0gbWUuY2FudmF4O1xuICAgICAgICB2YXIgY3VyVG91Y2hzID0gW107XG4gICAgICAgIF8uZWFjaCggZS5wb2ludCAsIGZ1bmN0aW9uKCB0b3VjaCApe1xuICAgICAgICAgICBjdXJUb3VjaHMucHVzaCgge1xuICAgICAgICAgICAgICAgeCA6IENhbnZheEV2ZW50LnBhZ2VYKCB0b3VjaCApIC0gcm9vdC52aWV3T2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICB5IDogQ2FudmF4RXZlbnQucGFnZVkoIHRvdWNoICkgLSByb290LnZpZXdPZmZzZXQudG9wXG4gICAgICAgICAgIH0gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXJUb3VjaHM7XG4gICAgfSxcbiAgICBfX2dldENoaWxkSW5Ub3VjaHMgOiBmdW5jdGlvbiggdG91Y2hzICl7XG4gICAgICAgIHZhciBtZSAgID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgPSBtZS5jYW52YXg7XG4gICAgICAgIHZhciB0b3VjaGVzVGFyZ2V0ID0gW107XG4gICAgICAgIF8uZWFjaCggdG91Y2hzICwgZnVuY3Rpb24odG91Y2gpe1xuICAgICAgICAgICAgdG91Y2hlc1RhcmdldC5wdXNoKCByb290LmdldE9iamVjdHNVbmRlclBvaW50KCB0b3VjaCAsIDEpWzBdICk7XG4gICAgICAgIH0gKTtcbiAgICAgICAgcmV0dXJuIHRvdWNoZXNUYXJnZXQ7XG4gICAgfSxcbiAgICAvKlxuICAgICrnrKzkuInmlrnlupPnmoTkuovku7bns7vnu58tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1iZWdpblxuICAgICovXG5cblxuICAgIC8qXG4gICAgICpAcGFyYW0ge2FycmF5fSBjaGlsZHMgXG4gICAgICogKi9cbiAgICBfX2Rpc3BhdGNoRXZlbnRJbkNoaWxkczogZnVuY3Rpb24oZSwgY2hpbGRzKSB7XG4gICAgICAgIGlmICghY2hpbGRzICYmICEoXCJsZW5ndGhcIiBpbiBjaGlsZHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGhhc0NoaWxkID0gZmFsc2U7XG4gICAgICAgIF8uZWFjaChjaGlsZHMsIGZ1bmN0aW9uKGNoaWxkLCBpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBoYXNDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGNlID0gbmV3IENhbnZheEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgIGNlLnRhcmdldCA9IGNlLmN1cnJlbnRUYXJnZXQgPSBjaGlsZCB8fCB0aGlzO1xuICAgICAgICAgICAgICAgIGNlLnN0YWdlUG9pbnQgPSBtZS5jdXJQb2ludHNbaV07XG4gICAgICAgICAgICAgICAgY2UucG9pbnQgPSBjZS50YXJnZXQuZ2xvYmFsVG9Mb2NhbChjZS5zdGFnZVBvaW50KTtcbiAgICAgICAgICAgICAgICBjaGlsZC5kaXNwYXRjaEV2ZW50KGNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoYXNDaGlsZDtcbiAgICB9LFxuICAgIC8v5YWL6ZqG5LiA5Liq5YWD57Sg5YiwaG92ZXIgc3RhZ2XkuK3ljrtcbiAgICBfY2xvbmUyaG92ZXJTdGFnZTogZnVuY3Rpb24odGFyZ2V0LCBpKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciByb290ID0gbWUuY2FudmF4O1xuICAgICAgICB2YXIgX2RyYWdEdXBsaWNhdGUgPSByb290Ll9idWZmZXJTdGFnZS5nZXRDaGlsZEJ5SWQodGFyZ2V0LmlkKTtcbiAgICAgICAgaWYgKCFfZHJhZ0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgX2RyYWdEdXBsaWNhdGUgPSB0YXJnZXQuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICBfZHJhZ0R1cGxpY2F0ZS5fdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbmNhdGVuYXRlZE1hdHJpeCgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqVE9ETzog5Zug5Li65ZCO57ut5Y+v6IO95Lya5pyJ5omL5Yqo5re75Yqg55qEIOWFg+e0oOWIsF9idWZmZXJTdGFnZSDph4zpnaLmnaVcbiAgICAgICAgICAgICAq5q+U5aaCdGlwc1xuICAgICAgICAgICAgICrov5nnsbvmiYvliqjmt7vliqDov5vmnaXnmoTogq/lrprmmK/lm6DkuLrpnIDopoHmmL7npLrlnKjmnIDlpJblsYLnmoTjgILlnKhob3ZlcuWFg+e0oOS5i+S4iuOAglxuICAgICAgICAgICAgICrmiYDmnInoh6rliqjmt7vliqDnmoRob3ZlcuWFg+e0oOmDvem7mOiupOa3u+WKoOWcqF9idWZmZXJTdGFnZeeahOacgOW6leWxglxuICAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgcm9vdC5fYnVmZmVyU3RhZ2UuYWRkQ2hpbGRBdChfZHJhZ0R1cGxpY2F0ZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgX2RyYWdEdXBsaWNhdGUuY29udGV4dC5nbG9iYWxBbHBoYSA9IHRhcmdldC5fZ2xvYmFsQWxwaGE7XG4gICAgICAgIHRhcmdldC5fZHJhZ1BvaW50ID0gdGFyZ2V0Lmdsb2JhbFRvTG9jYWwobWUuY3VyUG9pbnRzW2ldKTtcbiAgICAgICAgcmV0dXJuIF9kcmFnRHVwbGljYXRlO1xuICAgIH0sXG4gICAgLy9kcmFnIOS4rSDnmoTlpITnkIblh73mlbBcbiAgICBfZHJhZ01vdmVIYW5kZXI6IGZ1bmN0aW9uKGUsIHRhcmdldCwgaSkge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgcm9vdCA9IG1lLmNhbnZheDtcbiAgICAgICAgdmFyIF9wb2ludCA9IHRhcmdldC5nbG9iYWxUb0xvY2FsKCBtZS5jdXJQb2ludHNbaV0gKTtcblxuICAgICAgICAvL+imgeWvueW6lOeahOS/ruaUueacrOWwiueahOS9jee9ru+8jOS9huaYr+imgeWRiuivieW8leaTjuS4jeimgXdhdGNo6L+Z5Liq5pe25YCZ55qE5Y+Y5YyWXG4gICAgICAgIHRhcmdldC5fbm90V2F0Y2ggPSB0cnVlO1xuICAgICAgICB2YXIgX21vdmVTdGFnZSA9IHRhcmdldC5tb3ZlaW5nO1xuICAgICAgICB0YXJnZXQubW92ZWluZyA9IHRydWU7XG4gICAgICAgIHRhcmdldC5jb250ZXh0LnggKz0gKF9wb2ludC54IC0gdGFyZ2V0Ll9kcmFnUG9pbnQueCk7XG4gICAgICAgIHRhcmdldC5jb250ZXh0LnkgKz0gKF9wb2ludC55IC0gdGFyZ2V0Ll9kcmFnUG9pbnQueSk7XG4gICAgICAgIHRhcmdldC5maXJlKFwiZHJhZ21vdmVcIik7XG4gICAgICAgIHRhcmdldC5tb3ZlaW5nID0gX21vdmVTdGFnZTtcbiAgICAgICAgdGFyZ2V0Ll9ub3RXYXRjaCA9IGZhbHNlO1xuICAgICAgICAvL+WQjOatpeWujOavleacrOWwiueahOS9jee9rlxuXG4gICAgICAgIC8v6L+Z6YeM5Y+q6IO955u05o6l5L+u5pS5X3RyYW5zZm9ybSDjgIIg5LiN6IO955So5LiL6Z2i55qE5L+u5pS5eO+8jHnnmoTmlrnlvI/jgIJcbiAgICAgICAgdmFyIF9kcmFnRHVwbGljYXRlID0gcm9vdC5fYnVmZmVyU3RhZ2UuZ2V0Q2hpbGRCeUlkKHRhcmdldC5pZCk7XG4gICAgICAgIF9kcmFnRHVwbGljYXRlLl90cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KCk7XG4gICAgICAgIC8v5Lul5Li655u05o6l5L+u5pS555qEX3RyYW5zZm9ybeS4jeS8muWHuuWPkeW/g+i3s+S4iuaKpe+8jCDmuLLmn5PlvJXmk47kuI3liLbliqjov5nkuKpzdGFnZemcgOimgee7mOWItuOAglxuICAgICAgICAvL+aJgOS7peimgeaJi+WKqOWHuuWPkeW/g+i3s+WMhVxuICAgICAgICBfZHJhZ0R1cGxpY2F0ZS5oZWFydEJlYXQoKTtcbiAgICB9LFxuICAgIC8vZHJhZ+e7k+adn+eahOWkhOeQhuWHveaVsFxuICAgIF9kcmFnRW5kOiBmdW5jdGlvbihlLCB0YXJnZXQsIGkpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgPSBtZS5jYW52YXg7XG5cbiAgICAgICAgLy9fZHJhZ0R1cGxpY2F0ZSDlpI3liLblnKhfYnVmZmVyU3RhZ2Ug5Lit55qE5Ymv5pysXG4gICAgICAgIHZhciBfZHJhZ0R1cGxpY2F0ZSA9IHJvb3QuX2J1ZmZlclN0YWdlLmdldENoaWxkQnlJZCh0YXJnZXQuaWQpO1xuICAgICAgICBfZHJhZ0R1cGxpY2F0ZS5kZXN0cm95KCk7XG5cbiAgICAgICAgdGFyZ2V0LmNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0YXJnZXQuX2dsb2JhbEFscGhhO1xuICAgIH1cbn07XG5leHBvcnQgZGVmYXVsdCBFdmVudEhhbmRsZXI7IiwiLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICog5LqL5Lu2566h55CG57G7XG4gKi9cbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbi8qKlxuICog5p6E6YCg5Ye95pWwLlxuICogQG5hbWUgRXZlbnREaXNwYXRjaGVyXG4gKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVy57G75piv5Y+v6LCD5bqm5LqL5Lu255qE57G755qE5Z+657G777yM5a6D5YWB6K645pi+56S65YiX6KGo5LiK55qE5Lu75L2V5a+56LGh6YO95piv5LiA5Liq5LqL5Lu255uu5qCH44CCXG4gKi9cbnZhciBFdmVudE1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvL+S6i+S7tuaYoOWwhOihqO+8jOagvOW8j+S4uu+8mnt0eXBlMTpbbGlzdGVuZXIxLCBsaXN0ZW5lcjJdLCB0eXBlMjpbbGlzdGVuZXIzLCBsaXN0ZW5lcjRdfVxuICAgIHRoaXMuX2V2ZW50TWFwID0ge307XG59O1xuXG5FdmVudE1hbmFnZXIucHJvdG90eXBlID0geyBcbiAgICAvKlxuICAgICAqIOazqOWGjOS6i+S7tuS+puWQrOWZqOWvueixoe+8jOS7peS9v+S+puWQrOWZqOiDveWkn+aOpeaUtuS6i+S7tumAmuefpeOAglxuICAgICAqL1xuICAgIF9hZGRFdmVudExpc3RlbmVyIDogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcblxuICAgICAgICBpZiggdHlwZW9mIGxpc3RlbmVyICE9IFwiZnVuY3Rpb25cIiApe1xuICAgICAgICAgIC8vbGlzdGVuZXLlv4XpobvmmK/kuKpmdW5jdGlvbuWRkOS6slxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRkUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNlbGYgICAgICA9IHRoaXM7XG4gICAgICAgIF8uZWFjaCggdHlwZS5zcGxpdChcIiBcIikgLCBmdW5jdGlvbih0eXBlKXtcbiAgICAgICAgICAgIHZhciBtYXAgPSBzZWxmLl9ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgICAgIGlmKCFtYXApe1xuICAgICAgICAgICAgICAgIG1hcCA9IHNlbGYuX2V2ZW50TWFwW3R5cGVdID0gW107XG4gICAgICAgICAgICAgICAgbWFwLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2V2ZW50RW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKF8uaW5kZXhPZihtYXAgLGxpc3RlbmVyKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1hcC5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9ldmVudEVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhZGRSZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDliKDpmaTkuovku7bkvqblkKzlmajjgIJcbiAgICAgKi9cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lciA6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgcmV0dXJuIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lckJ5VHlwZSh0eXBlKTtcblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fZXZlbnRNYXBbdHlwZV07XG4gICAgICAgIGlmKCFtYXApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpID0gbWFwW2ldO1xuICAgICAgICAgICAgaWYobGkgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpZihtYXAubGVuZ3RoICAgID09IDApIHsgXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzov5nkuKrlpoLmnpzov5nkuKrml7blgJljaGlsZOayoeacieS7u+S9leS6i+S7tuS+puWQrFxuICAgICAgICAgICAgICAgICAgICBpZihfLmlzRW1wdHkodGhpcy5fZXZlbnRNYXApKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v6YKj5LmI6K+l5YWD57Sg5LiN5YaN5o6l5Y+X5LqL5Lu255qE5qOA5rWLXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICog5Yig6Zmk5oyH5a6a57G75Z6L55qE5omA5pyJ5LqL5Lu25L6m5ZCs5Zmo44CCXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJCeVR5cGUgOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgaWYoIW1hcCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwW3R5cGVdO1xuXG4gICAgICAgICAgICAvL+WmguaenOi/meS4quWmguaenOi/meS4quaXtuWAmWNoaWxk5rKh5pyJ5Lu75L2V5LqL5Lu25L6m5ZCsXG4gICAgICAgICAgICBpZihfLmlzRW1wdHkodGhpcy5fZXZlbnRNYXApKXtcbiAgICAgICAgICAgICAgICAvL+mCo+S5iOivpeWFg+e0oOS4jeWGjeaOpeWPl+S6i+S7tueahOajgOa1i1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDliKDpmaTmiYDmnInkuovku7bkvqblkKzlmajjgIJcbiAgICAgKi9cbiAgICBfcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgOiBmdW5jdGlvbigpIHtcdFxuICAgICAgICB0aGlzLl9ldmVudE1hcCA9IHt9O1xuICAgICAgICB0aGlzLl9ldmVudEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICog5rS+5Y+R5LqL5Lu277yM6LCD55So5LqL5Lu25L6m5ZCs5Zmo44CCXG4gICAgKi9cbiAgICBfZGlzcGF0Y2hFdmVudCA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX2V2ZW50TWFwW2UudHlwZV07XG4gICAgICAgIFxuICAgICAgICBpZiggbWFwICl7XG4gICAgICAgICAgICBpZighZS50YXJnZXQpIGUudGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIG1hcCA9IG1hcC5zbGljZSgpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbWFwW2ldO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihsaXN0ZW5lcikgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFlLl9zdG9wUHJvcGFnYXRpb24gKSB7XG4gICAgICAgICAgICAvL+WQkeS4iuWGkuazoVxuICAgICAgICAgICAgaWYoIHRoaXMucGFyZW50ICl7XG4gICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX2Rpc3BhdGNoRXZlbnQoIGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAqIOajgOafpeaYr+WQpuS4uuaMh+WumuS6i+S7tuexu+Wei+azqOWGjOS6huS7u+S9leS+puWQrOWZqOOAglxuICAgICAgICovXG4gICAgX2hhc0V2ZW50TGlzdGVuZXIgOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgcmV0dXJuIG1hcCAhPSBudWxsICYmIG1hcC5sZW5ndGggPiAwO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRNYW5hZ2VyO1xuIiwiLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICog5LqL5Lu25rS+5Y+R57G7XG4gKi9cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcbmltcG9ydCBFdmVudE1hbmFnZXIgZnJvbSBcIi4vRXZlbnRNYW5hZ2VyXCI7XG5pbXBvcnQgQ2FudmF4RXZlbnQgZnJvbSBcIi4vQ2FudmF4RXZlbnRcIjtcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCl7XG4gICAgRXZlbnREaXNwYXRjaGVyLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBuYW1lKTtcbn07XG5cblV0aWxzLmNyZWF0Q2xhc3MoRXZlbnREaXNwYXRjaGVyICwgRXZlbnRNYW5hZ2VyICwge1xuICAgIG9uIDogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcil7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB1biA6IGZ1bmN0aW9uKHR5cGUsbGlzdGVuZXIpe1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbih0eXBlLGxpc3RlbmVyKXtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJCeVR5cGU6ZnVuY3Rpb24odHlwZSl7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJCeVR5cGUoIHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvL3BhcmFtcyDopoHkvKDnu5lldnTnmoRldmVudGhhbmRsZXLlpITnkIblh73mlbDnmoTlj4LmlbDvvIzkvJrooqttZXJnZeWIsENhbnZheCBldmVudOS4rVxuICAgIGZpcmUgOiBmdW5jdGlvbihldmVudFR5cGUgLCBwYXJhbXMpe1xuICAgICAgICB2YXIgZSA9IG5ldyBDYW52YXhFdmVudCggZXZlbnRUeXBlICk7XG5cbiAgICAgICAgaWYoIHBhcmFtcyApe1xuICAgICAgICAgICAgZm9yKCB2YXIgcCBpbiBwYXJhbXMgKXtcbiAgICAgICAgICAgICAgICBpZiggcCBpbiBlICl7XG4gICAgICAgICAgICAgICAgICAgIC8vcGFyYW1z5Lit55qE5pWw5o2u5LiN6IO96KaG55uWZXZlbnTlsZ7mgKdcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIHAgKyBcIuWxnuaAp+S4jeiDveimhueblkNhbnZheEV2ZW505bGe5oCnXCIgKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVbcF0gPSBwYXJhbXNbcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIF8uZWFjaCggZXZlbnRUeXBlLnNwbGl0KFwiIFwiKSAsIGZ1bmN0aW9uKGVUeXBlKXtcbiAgICAgICAgICAgIGUuY3VycmVudFRhcmdldCA9IG1lO1xuICAgICAgICAgICAgbWUuZGlzcGF0Y2hFdmVudCggZSApO1xuICAgICAgICB9ICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFdmVudDpmdW5jdGlvbihldmVudCl7XG4gICAgICAgIC8vdGhpcyBpbnN0YW5jZW9mIERpc3BsYXlPYmplY3RDb250YWluZXIgPT0+IHRoaXMuY2hpbGRyZW5cbiAgICAgICAgLy9UT0RPOiDov5nph4xpbXBvcnQgRGlzcGxheU9iamVjdENvbnRhaW5lciDnmoTor53vvIzlnKhkaXNwbGF5T2JqZWN06YeM6Z2i55qEaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tIFwiLi4vZXZlbnQvRXZlbnREaXNwYXRjaGVyXCI7XG4gICAgICAgIC8v5Lya5b6X5Yiw5LiA5LiqdW5kZWZpbmVk77yM5oSf6KeJ5piv5oiQ5LqG5LiA5Liq5b6q546v5L6d6LWW55qE6Zeu6aKY77yM5omA5Lul6L+Z6YeM5o2i55So566A5Y2V55qE5Yik5pat5p2l5Yik5pat6Ieq5bex5piv5LiA5Liq5a655piT77yM5oul5pyJY2hpbGRyZW5cbiAgICAgICAgaWYoIHRoaXMuY2hpbGRyZW4gICYmIGV2ZW50LnBvaW50ICl7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRPYmplY3RzVW5kZXJQb2ludCggZXZlbnQucG9pbnQgLCAxKVswXTtcbiAgICAgICAgICAgIGlmKCB0YXJnZXQgKXtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuY29udGV4dCAmJiBldmVudC50eXBlID09IFwibW91c2VvdmVyXCIpe1xuICAgICAgICAgICAgLy/orrDlvZVkaXNwYXRjaEV2ZW505LmL5YmN55qE5b+D6LezXG4gICAgICAgICAgICB2YXIgcHJlSGVhcnRCZWF0ID0gdGhpcy5faGVhcnRCZWF0TnVtO1xuICAgICAgICAgICAgdmFyIHByZWdBbHBoYSAgICA9IHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XG4gICAgICAgICAgICBpZiggcHJlSGVhcnRCZWF0ICE9IHRoaXMuX2hlYXJ0QmVhdE51bSApe1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyQ2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmKCB0aGlzLmhvdmVyQ2xvbmUgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZheCA9IHRoaXMuZ2V0U3RhZ2UoKS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8v54S25ZCOY2xvbmXkuIDku71vYmrvvIzmt7vliqDliLBfYnVmZmVyU3RhZ2Ug5LitXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdlNoYXBlID0gdGhpcy5jbG9uZSh0cnVlKTsgIFxuICAgICAgICAgICAgICAgICAgICBhY3RpdlNoYXBlLl90cmFuc2Zvcm0gPSB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXguX2J1ZmZlclN0YWdlLmFkZENoaWxkQXQoIGFjdGl2U2hhcGUgLCAwICk7IFxuICAgICAgICAgICAgICAgICAgICAvL+eEtuWQjuaKiuiHquW3semakOiXj+S6hlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxBbHBoYSA9IHByZWdBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcblxuICAgICAgICBpZiggdGhpcy5jb250ZXh0ICYmIGV2ZW50LnR5cGUgPT0gXCJtb3VzZW91dFwiKXtcbiAgICAgICAgICAgIGlmKHRoaXMuX2hvdmVyQ2xhc3Mpe1xuICAgICAgICAgICAgICAgIC8v6K+05piO5Yia5Yiab3ZlcueahOaXtuWAmeaciea3u+WKoOagt+W8j1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXggPSB0aGlzLmdldFN0YWdlKCkucGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyQ2xhc3MgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNhbnZheC5fYnVmZmVyU3RhZ2UucmVtb3ZlQ2hpbGRCeUlkKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCB0aGlzLl9nbG9iYWxBbHBoYSApe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLl9nbG9iYWxBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dsb2JhbEFscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaGFzRXZlbnQ6ZnVuY3Rpb24odHlwZSl7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNFdmVudExpc3RlbmVyKHR5cGUpO1xuICAgIH0sXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbih0eXBlKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0V2ZW50TGlzdGVuZXIodHlwZSk7XG4gICAgfSxcbiAgICBob3ZlciA6IGZ1bmN0aW9uKCBvdmVyRnVuICwgb3V0RnVuICl7XG4gICAgICAgIHRoaXMub24oXCJtb3VzZW92ZXJcIiAsIG92ZXJGdW4pO1xuICAgICAgICB0aGlzLm9uKFwibW91c2VvdXRcIiAgLCBvdXRGdW4gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmNlIDogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpe1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICB2YXIgb25jZUhhbmRsZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsaXN0ZW5lci5hcHBseShtZSAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnVuKHR5cGUgLCBvbmNlSGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbih0eXBlICwgb25jZUhhbmRsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudERpc3BhdGNoZXI7XG4iLCJcbi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIHwgYSB8IGMgfCB0eHxcbiAqIHwgYiB8IGQgfCB0eXxcbiAqIHwgMCB8IDAgfCAxIHxcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKlxuICpcbiAqIE1hdHJpeCDnn6npmLXlupMg55So5LqO5pW05Liq57O757uf55qE5Yeg5L2V5Y+Y5o2i6K6h566XXG4gKi9cblxudmFyIE1hdHJpeCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSl7XG4gICAgdGhpcy5hID0gYSAhPSB1bmRlZmluZWQgPyBhIDogMTtcbiAgICB0aGlzLmIgPSBiICE9IHVuZGVmaW5lZCA/IGIgOiAwO1xuICAgIHRoaXMuYyA9IGMgIT0gdW5kZWZpbmVkID8gYyA6IDA7XG4gICAgdGhpcy5kID0gZCAhPSB1bmRlZmluZWQgPyBkIDogMTtcbiAgICB0aGlzLnR4ID0gdHggIT0gdW5kZWZpbmVkID8gdHggOiAwO1xuICAgIHRoaXMudHkgPSB0eSAhPSB1bmRlZmluZWQgPyB0eSA6IDA7XG4gICAgdGhpcy5hcnJheSA9IG51bGw7XG59O1xuXG5NYXRyaXgucHJvdG90eXBlID0ge1xuICAgIGNvbmNhdCA6IGZ1bmN0aW9uKG10eCl7XG4gICAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgICB2YXIgYyA9IHRoaXMuYztcbiAgICAgICAgdmFyIHR4ID0gdGhpcy50eDtcblxuICAgICAgICB0aGlzLmEgPSBhICogbXR4LmEgKyB0aGlzLmIgKiBtdHguYztcbiAgICAgICAgdGhpcy5iID0gYSAqIG10eC5iICsgdGhpcy5iICogbXR4LmQ7XG4gICAgICAgIHRoaXMuYyA9IGMgKiBtdHguYSArIHRoaXMuZCAqIG10eC5jO1xuICAgICAgICB0aGlzLmQgPSBjICogbXR4LmIgKyB0aGlzLmQgKiBtdHguZDtcbiAgICAgICAgdGhpcy50eCA9IHR4ICogbXR4LmEgKyB0aGlzLnR5ICogbXR4LmMgKyBtdHgudHg7XG4gICAgICAgIHRoaXMudHkgPSB0eCAqIG10eC5iICsgdGhpcy50eSAqIG10eC5kICsgbXR4LnR5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNvbmNhdFRyYW5zZm9ybSA6IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbil7XG4gICAgICAgIHZhciBjb3MgPSAxO1xuICAgICAgICB2YXIgc2luID0gMDtcbiAgICAgICAgaWYocm90YXRpb24lMzYwKXtcbiAgICAgICAgICAgIHZhciByID0gcm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgY29zID0gTWF0aC5jb3Mocik7XG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uY2F0KG5ldyBNYXRyaXgoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIHgsIHkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByb3RhdGUgOiBmdW5jdGlvbihhbmdsZSl7XG4gICAgICAgIC8v55uu5YmN5bey57uP5o+Q5L6b5a+56aG65pe26ZKI6YCG5pe26ZKI5Lik5Liq5pa55ZCR5peL6L2s55qE5pSv5oyBXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBjID0gdGhpcy5jO1xuICAgICAgICB2YXIgdHggPSB0aGlzLnR4O1xuXG4gICAgICAgIGlmIChhbmdsZT4wKXtcbiAgICAgICAgICAgIHRoaXMuYSA9IGEgKiBjb3MgLSB0aGlzLmIgKiBzaW47XG4gICAgICAgICAgICB0aGlzLmIgPSBhICogc2luICsgdGhpcy5iICogY29zO1xuICAgICAgICAgICAgdGhpcy5jID0gYyAqIGNvcyAtIHRoaXMuZCAqIHNpbjtcbiAgICAgICAgICAgIHRoaXMuZCA9IGMgKiBzaW4gKyB0aGlzLmQgKiBjb3M7XG4gICAgICAgICAgICB0aGlzLnR4ID0gdHggKiBjb3MgLSB0aGlzLnR5ICogc2luO1xuICAgICAgICAgICAgdGhpcy50eSA9IHR4ICogc2luICsgdGhpcy50eSAqIGNvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdCA9IE1hdGguc2luKE1hdGguYWJzKGFuZ2xlKSk7XG4gICAgICAgICAgICB2YXIgY3QgPSBNYXRoLmNvcyhNYXRoLmFicyhhbmdsZSkpO1xuXG4gICAgICAgICAgICB0aGlzLmEgPSBhKmN0ICsgdGhpcy5iKnN0O1xuICAgICAgICAgICAgdGhpcy5iID0gLWEqc3QgKyB0aGlzLmIqY3Q7XG4gICAgICAgICAgICB0aGlzLmMgPSBjKmN0ICsgdGhpcy5kKnN0O1xuICAgICAgICAgICAgdGhpcy5kID0gLWMqc3QgKyBjdCp0aGlzLmQ7XG4gICAgICAgICAgICB0aGlzLnR4ID0gY3QqdHggKyBzdCp0aGlzLnR5O1xuICAgICAgICAgICAgdGhpcy50eSA9IGN0KnRoaXMudHkgLSBzdCp0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNjYWxlIDogZnVuY3Rpb24oc3gsIHN5KXtcbiAgICAgICAgdGhpcy5hICo9IHN4O1xuICAgICAgICB0aGlzLmQgKj0gc3k7XG4gICAgICAgIHRoaXMudHggKj0gc3g7XG4gICAgICAgIHRoaXMudHkgKj0gc3k7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdHJhbnNsYXRlIDogZnVuY3Rpb24oZHgsIGR5KXtcbiAgICAgICAgdGhpcy50eCArPSBkeDtcbiAgICAgICAgdGhpcy50eSArPSBkeTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpZGVudGl0eSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8v5Yid5aeL5YyWXG4gICAgICAgIHRoaXMuYSA9IHRoaXMuZCA9IDE7XG4gICAgICAgIHRoaXMuYiA9IHRoaXMuYyA9IHRoaXMudHggPSB0aGlzLnR5ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpbnZlcnQgOiBmdW5jdGlvbigpe1xuICAgICAgICAvL+mAhuWQkeefqemYtVxuICAgICAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmI7XG4gICAgICAgIHZhciBjID0gdGhpcy5jO1xuICAgICAgICB2YXIgZCA9IHRoaXMuZDtcbiAgICAgICAgdmFyIHR4ID0gdGhpcy50eDtcbiAgICAgICAgdmFyIGkgPSBhICogZCAtIGIgKiBjO1xuXG4gICAgICAgIHRoaXMuYSA9IGQgLyBpO1xuICAgICAgICB0aGlzLmIgPSAtYiAvIGk7XG4gICAgICAgIHRoaXMuYyA9IC1jIC8gaTtcbiAgICAgICAgdGhpcy5kID0gYSAvIGk7XG4gICAgICAgIHRoaXMudHggPSAoYyAqIHRoaXMudHkgLSBkICogdHgpIC8gaTtcbiAgICAgICAgdGhpcy50eSA9IC0oYSAqIHRoaXMudHkgLSBiICogdHgpIC8gaTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjbG9uZSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy50eCwgdGhpcy50eSk7XG4gICAgfSxcbiAgICB0b0FycmF5IDogZnVuY3Rpb24odHJhbnNwb3NlLCBvdXQpe1xuICAgICAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSAwIClcbiAgICAgICAge1xuICAgICAgICAgICAgLy9jYW52YXMyZCDkuK3kuI3kvJrmnInku7vkvZXnmoTlj4LmlbDkvKDlhaVcbiAgICAgICAgICAgIHJldHVybiBbIHRoaXMuYSAsIHRoaXMuYiAsIHRoaXMuYyAsIHRoaXMuZCAsIHRoaXMudHggLCB0aGlzLnR5IF07XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlYmds55qEZ2xzbOmcgOimgeeUqOeahOaXtuWAme+8jOmcgOimgeS8oOWFpXRyYW5zcG9zZSDmnaXovazmjaLkuLrkuIDkuKozKjPlrozmlbTnn6npmLVcbiAgICAgICAgaWYgKCF0aGlzLmFycmF5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnJheSA9IG91dCB8fCB0aGlzLmFycmF5O1xuXG4gICAgICAgIGlmICh0cmFuc3Bvc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFycmF5WzBdID0gdGhpcy5hO1xuICAgICAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmI7XG4gICAgICAgICAgICBhcnJheVsyXSA9IDA7XG4gICAgICAgICAgICBhcnJheVszXSA9IHRoaXMuYztcbiAgICAgICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xuICAgICAgICAgICAgYXJyYXlbNV0gPSAwO1xuICAgICAgICAgICAgYXJyYXlbNl0gPSB0aGlzLnR4O1xuICAgICAgICAgICAgYXJyYXlbN10gPSB0aGlzLnR5O1xuICAgICAgICAgICAgYXJyYXlbOF0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgICAgICBhcnJheVsxXSA9IHRoaXMuYztcbiAgICAgICAgICAgIGFycmF5WzJdID0gdGhpcy50eDtcbiAgICAgICAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xuICAgICAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgICAgICBhcnJheVs1XSA9IHRoaXMudHk7XG4gICAgICAgICAgICBhcnJheVs2XSA9IDA7XG4gICAgICAgICAgICBhcnJheVs3XSA9IDA7XG4gICAgICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiDnn6npmLXlt6bkuZjlkJHph49cbiAgICAgKi9cbiAgICBtdWxWZWN0b3IgOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBhYSA9IHRoaXMuYSwgYWMgPSB0aGlzLmMsIGF0eCA9IHRoaXMudHg7XG4gICAgICAgIHZhciBhYiA9IHRoaXMuYiwgYWQgPSB0aGlzLmQsIGF0eSA9IHRoaXMudHk7XG5cbiAgICAgICAgdmFyIG91dCA9IFswLDBdO1xuICAgICAgICBvdXRbMF0gPSB2WzBdICogYWEgKyB2WzFdICogYWMgKyBhdHg7XG4gICAgICAgIG91dFsxXSA9IHZbMF0gKiBhYiArIHZbMV0gKiBhZCArIGF0eTtcblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0gICAgXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hdHJpeDtcbiIsImltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbi8qKlxuICogVHdlZW4uanMgLSBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2VlbmpzL3R3ZWVuLmpzL2dyYXBocy9jb250cmlidXRvcnMgZm9yIHRoZSBmdWxsIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXG4gKi9cblxuIHZhciBUV0VFTiA9IFRXRUVOIHx8IChmdW5jdGlvbiAoKSB7XG5cbiBcdHZhciBfdHdlZW5zID0gW107XG5cbiBcdHJldHVybiB7XG5cbiBcdFx0Z2V0QWxsOiBmdW5jdGlvbiAoKSB7XG5cbiBcdFx0XHRyZXR1cm4gX3R3ZWVucztcblxuIFx0XHR9LFxuXG4gXHRcdHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuXG4gXHRcdFx0X3R3ZWVucyA9IFtdO1xuXG4gXHRcdH0sXG5cbiBcdFx0YWRkOiBmdW5jdGlvbiAodHdlZW4pIHtcblxuIFx0XHRcdF90d2VlbnMucHVzaCh0d2Vlbik7XG5cbiBcdFx0fSxcblxuIFx0XHRyZW1vdmU6IGZ1bmN0aW9uICh0d2Vlbikge1xuXG5cdFx0XHR2YXIgaSA9IF8uaW5kZXhPZiggX3R3ZWVucyAsIHR3ZWVuICk7Ly9fdHdlZW5zLmluZGV4T2YodHdlZW4pO1xuXG5cdFx0XHRpZiAoaSAhPT0gLTEpIHtcblx0XHRcdFx0X3R3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAodGltZSwgcHJlc2VydmUpIHtcblxuXHRcdFx0aWYgKF90d2VlbnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHR0aW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gdGltZSA6IFRXRUVOLm5vdygpO1xuXG5cdFx0XHR3aGlsZSAoaSA8IF90d2VlbnMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAvKiBvbGQgXG5cdFx0XHRcdGlmIChfdHdlZW5zW2ldLnVwZGF0ZSh0aW1lKSB8fCBwcmVzZXJ2ZSkge1xuXHRcdFx0XHRcdGkrKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfdHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQqL1xuXG4gICAgICAgICAgICAgICAgLy9uZXcgY29kZVxuICAgICAgICAgICAgICAgIC8vaW4gcmVhbCB3b3JsZCwgdHdlZW4udXBkYXRlIGhhcyBjaGFuY2UgdG8gcmVtb3ZlIGl0c2VsZiwgc28gd2UgaGF2ZSB0byBoYW5kbGUgdGhpcyBzaXR1YXRpb24uXG4gICAgICAgICAgICAgICAgLy9pbiBjZXJ0YWluIGNhc2VzLCBvblVwZGF0ZUNhbGxiYWNrIHdpbGwgcmVtb3ZlIGluc3RhbmNlcyBpbiBfdHdlZW5zLCB3aGljaCBtYWtlIF90d2VlbnMuc3BsaWNlKGksIDEpIGZhaWxcbiAgICAgICAgICAgICAgICAvL0BsaXRhby5sdEBhbGliYWJhLWluYy5jb21cbiAgICAgICAgICAgICAgICB2YXIgX3QgPSBfdHdlZW5zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBfdXBkYXRlUmVzID0gX3QudXBkYXRlKHRpbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYoICFfdHdlZW5zW2ldICl7XG4gICAgICAgICAgICAgICAgXHRicmVhaztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICggX3QgPT09IF90d2VlbnNbaV0gKSB7XG4gICAgICAgICAgICAgICAgXHRpZiAoIF91cGRhdGVSZXMgfHwgcHJlc2VydmUgKSB7XG4gICAgICAgICAgICAgICAgXHRcdGkrKztcbiAgICAgICAgICAgICAgICBcdH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXHRcdF90d2VlbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIFx0fVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG4vLyBJbmNsdWRlIGEgcGVyZm9ybWFuY2Uubm93IHBvbHlmaWxsLlxuLy8gSW4gbm9kZS5qcywgdXNlIHByb2Nlc3MuaHJ0aW1lLlxuaWYgKHR5cGVvZiAod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIChwcm9jZXNzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0VFdFRU4ubm93ID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aW1lID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuXHRcdC8vIENvbnZlcnQgW3NlY29uZHMsIG5hbm9zZWNvbmRzXSB0byBtaWxsaXNlY29uZHMuXG5cdFx0cmV0dXJuIHRpbWVbMF0gKiAxMDAwICsgdGltZVsxXSAvIDEwMDAwMDA7XG5cdH07XG59XG4vLyBJbiBhIGJyb3dzZXIsIHVzZSB3aW5kb3cucGVyZm9ybWFuY2Uubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKHR5cGVvZiAod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0d2luZG93LnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiZcblx0d2luZG93LnBlcmZvcm1hbmNlLm5vdyAhPT0gdW5kZWZpbmVkKSB7XG5cdC8vIFRoaXMgbXVzdCBiZSBib3VuZCwgYmVjYXVzZSBkaXJlY3RseSBhc3NpZ25pbmcgdGhpcyBmdW5jdGlvblxuXHQvLyBsZWFkcyB0byBhbiBpbnZvY2F0aW9uIGV4Y2VwdGlvbiBpbiBDaHJvbWUuXG5cdFRXRUVOLm5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpO1xufVxuLy8gVXNlIERhdGUubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKERhdGUubm93ICE9PSB1bmRlZmluZWQpIHtcblx0VFdFRU4ubm93ID0gRGF0ZS5ub3c7XG59XG4vLyBPdGhlcndpc2UsIHVzZSAnbmV3IERhdGUoKS5nZXRUaW1lKCknLlxuZWxzZSB7XG5cdFRXRUVOLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH07XG59XG5cblxuVFdFRU4uVHdlZW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cblx0dmFyIF9vYmplY3QgPSBvYmplY3Q7XG5cdHZhciBfdmFsdWVzU3RhcnQgPSB7fTtcblx0dmFyIF92YWx1ZXNFbmQgPSB7fTtcblx0dmFyIF92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xuXHR2YXIgX2R1cmF0aW9uID0gMTAwMDtcblx0dmFyIF9yZXBlYXQgPSAwO1xuXHR2YXIgX3JlcGVhdERlbGF5VGltZTtcblx0dmFyIF95b3lvID0gZmFsc2U7XG5cdHZhciBfaXNQbGF5aW5nID0gZmFsc2U7XG5cdHZhciBfcmV2ZXJzZWQgPSBmYWxzZTtcblx0dmFyIF9kZWxheVRpbWUgPSAwO1xuXHR2YXIgX3N0YXJ0VGltZSA9IG51bGw7XG5cdHZhciBfZWFzaW5nRnVuY3Rpb24gPSBUV0VFTi5FYXNpbmcuTGluZWFyLk5vbmU7XG5cdHZhciBfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5MaW5lYXI7XG5cdHZhciBfY2hhaW5lZFR3ZWVucyA9IFtdO1xuXHR2YXIgX29uU3RhcnRDYWxsYmFjayA9IG51bGw7XG5cdHZhciBfb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblx0dmFyIF9vblVwZGF0ZUNhbGxiYWNrID0gbnVsbDtcblx0dmFyIF9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBudWxsO1xuXHR2YXIgX29uU3RvcENhbGxiYWNrID0gbnVsbDtcblxuXHR0aGlzLnRvID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGR1cmF0aW9uKSB7XG5cblx0XHRfdmFsdWVzRW5kID0gcHJvcGVydGllcztcblxuXHRcdGlmIChkdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRfZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXG5cdFx0VFdFRU4uYWRkKHRoaXMpO1xuXG5cdFx0X2lzUGxheWluZyA9IHRydWU7XG5cblx0XHRfb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblxuXHRcdF9zdGFydFRpbWUgPSB0aW1lICE9PSB1bmRlZmluZWQgPyB0aW1lIDogVFdFRU4ubm93KCk7XG5cdFx0X3N0YXJ0VGltZSArPSBfZGVsYXlUaW1lO1xuXG5cdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCkge1xuXG5cdFx0XHQvLyBDaGVjayBpZiBhbiBBcnJheSB3YXMgcHJvdmlkZWQgYXMgcHJvcGVydHkgdmFsdWVcblx0XHRcdGlmIChfdmFsdWVzRW5kW3Byb3BlcnR5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cblx0XHRcdFx0aWYgKF92YWx1ZXNFbmRbcHJvcGVydHldLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIGEgbG9jYWwgY29weSBvZiB0aGUgQXJyYXkgd2l0aCB0aGUgc3RhcnQgdmFsdWUgYXQgdGhlIGZyb250XG5cdFx0XHRcdF92YWx1ZXNFbmRbcHJvcGVydHldID0gW19vYmplY3RbcHJvcGVydHldXS5jb25jYXQoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGB0bygpYCBzcGVjaWZpZXMgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3QsXG5cdFx0XHQvLyB3ZSBzaG91bGQgbm90IHNldCB0aGF0IHByb3BlcnR5IGluIHRoZSBvYmplY3Rcblx0XHRcdGlmIChfb2JqZWN0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIHRoZSBzdGFydGluZyB2YWx1ZS5cblx0XHRcdF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSBfb2JqZWN0W3Byb3BlcnR5XTtcblxuXHRcdFx0aWYgKChfdmFsdWVzU3RhcnRbcHJvcGVydHldIGluc3RhbmNlb2YgQXJyYXkpID09PSBmYWxzZSkge1xuXHRcdFx0XHRfdmFsdWVzU3RhcnRbcHJvcGVydHldICo9IDEuMDsgLy8gRW5zdXJlcyB3ZSdyZSB1c2luZyBudW1iZXJzLCBub3Qgc3RyaW5nc1xuXHRcdFx0fVxuXG5cdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIV9pc1BsYXlpbmcpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdFRXRUVOLnJlbW92ZSh0aGlzKTtcblx0XHRfaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHRpZiAoX29uU3RvcENhbGxiYWNrICE9PSBudWxsKSB7XG5cdFx0XHRfb25TdG9wQ2FsbGJhY2suY2FsbChfb2JqZWN0LCBfb2JqZWN0KTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BDaGFpbmVkVHdlZW5zKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLmVuZCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMudXBkYXRlKF9zdGFydFRpbWUgKyBfZHVyYXRpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5zdG9wQ2hhaW5lZFR3ZWVucyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XG5cdFx0XHRfY2hhaW5lZFR3ZWVuc1tpXS5zdG9wKCk7XG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5kZWxheSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcblxuXHRcdF9kZWxheVRpbWUgPSBhbW91bnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuXG5cdFx0X3JlcGVhdCA9IHRpbWVzO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcblxuXHRcdF9yZXBlYXREZWxheVRpbWUgPSBhbW91bnQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLnlveW8gPSBmdW5jdGlvbiAoeW95bykge1xuXG5cdFx0X3lveW8gPSB5b3lvO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblxuXHR0aGlzLmVhc2luZyA9IGZ1bmN0aW9uIChlYXNpbmcpIHtcblxuXHRcdF9lYXNpbmdGdW5jdGlvbiA9IGVhc2luZztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuaW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uKSB7XG5cblx0XHRfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gaW50ZXJwb2xhdGlvbjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfY2hhaW5lZFR3ZWVucyA9IGFyZ3VtZW50cztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25TdGFydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG5cdFx0X29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vblVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG5cdFx0X29uVXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG5cdFx0X29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vblN0b3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuXHRcdF9vblN0b3BDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAodGltZSkge1xuXG5cdFx0dmFyIHByb3BlcnR5O1xuXHRcdHZhciBlbGFwc2VkO1xuXHRcdHZhciB2YWx1ZTtcblxuXHRcdGlmICh0aW1lIDwgX3N0YXJ0VGltZSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9PT0gZmFsc2UpIHtcblxuXHRcdFx0aWYgKF9vblN0YXJ0Q2FsbGJhY2sgIT09IG51bGwpIHtcblx0XHRcdFx0X29uU3RhcnRDYWxsYmFjay5jYWxsKF9vYmplY3QsIF9vYmplY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRfb25TdGFydENhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGVsYXBzZWQgPSAodGltZSAtIF9zdGFydFRpbWUpIC8gX2R1cmF0aW9uO1xuXHRcdGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG5cdFx0dmFsdWUgPSBfZWFzaW5nRnVuY3Rpb24oZWxhcHNlZCk7XG5cblx0XHRmb3IgKHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIHByb3BlcnRpZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHNvdXJjZSBvYmplY3Rcblx0XHRcdGlmIChfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdGFydCA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcblx0XHRcdHZhciBlbmQgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcblxuXHRcdFx0aWYgKGVuZCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cblx0XHRcdFx0X29iamVjdFtwcm9wZXJ0eV0gPSBfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGVuZCwgdmFsdWUpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnNlcyByZWxhdGl2ZSBlbmQgdmFsdWVzIHdpdGggc3RhcnQgYXMgYmFzZSAoZS5nLjogKzEwLCAtMylcblx0XHRcdFx0aWYgKHR5cGVvZiAoZW5kKSA9PT0gJ3N0cmluZycpIHtcblxuXHRcdFx0XHRcdGlmIChlbmQuY2hhckF0KDApID09PSAnKycgfHwgZW5kLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBzdGFydCArIHBhcnNlRmxvYXQoZW5kKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZW5kID0gcGFyc2VGbG9hdChlbmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3RlY3QgYWdhaW5zdCBub24gbnVtZXJpYyBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRpZiAodHlwZW9mIChlbmQpID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdF9vYmplY3RbcHJvcGVydHldID0gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKF9vblVwZGF0ZUNhbGxiYWNrICE9PSBudWxsKSB7XG5cdFx0XHRfb25VcGRhdGVDYWxsYmFjay5jYWxsKF9vYmplY3QsIHZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAoZWxhcHNlZCA9PT0gMSkge1xuXG5cdFx0XHRpZiAoX3JlcGVhdCA+IDApIHtcblxuXHRcdFx0XHRpZiAoaXNGaW5pdGUoX3JlcGVhdCkpIHtcblx0XHRcdFx0XHRfcmVwZWF0LS07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWFzc2lnbiBzdGFydGluZyB2YWx1ZXMsIHJlc3RhcnQgYnkgbWFraW5nIHN0YXJ0VGltZSA9IG5vd1xuXHRcdFx0XHRmb3IgKHByb3BlcnR5IGluIF92YWx1ZXNTdGFydFJlcGVhdCkge1xuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiAoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IF92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gKyBwYXJzZUZsb2F0KF92YWx1ZXNFbmRbcHJvcGVydHldKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoX3lveW8pIHtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0XHRfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRfdmFsdWVzRW5kW3Byb3BlcnR5XSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF95b3lvKSB7XG5cdFx0XHRcdFx0X3JldmVyc2VkID0gIV9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChfcmVwZWF0RGVsYXlUaW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRfc3RhcnRUaW1lID0gdGltZSArIF9yZXBlYXREZWxheVRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3N0YXJ0VGltZSA9IHRpbWUgKyBfZGVsYXlUaW1lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKF9vbkNvbXBsZXRlQ2FsbGJhY2sgIT09IG51bGwpIHtcblxuXHRcdFx0XHRcdF9vbkNvbXBsZXRlQ2FsbGJhY2suY2FsbChfb2JqZWN0LCBfb2JqZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XG5cdFx0XHRcdFx0Ly8gTWFrZSB0aGUgY2hhaW5lZCB0d2VlbnMgc3RhcnQgZXhhY3RseSBhdCB0aGUgdGltZSB0aGV5IHNob3VsZCxcblx0XHRcdFx0XHQvLyBldmVuIGlmIHRoZSBgdXBkYXRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIHdheSBwYXN0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cblx0XHRcdFx0XHRfY2hhaW5lZFR3ZWVuc1tpXS5zdGFydChfc3RhcnRUaW1lICsgX2R1cmF0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxufTtcblxuXG5UV0VFTi5FYXNpbmcgPSB7XG5cblx0TGluZWFyOiB7XG5cblx0XHROb25lOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gaztcblxuXHRcdH1cblxuXHR9LFxuXG5cdFF1YWRyYXRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrICogKDIgLSBrKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAtIDAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRDdWJpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVhcnRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIC0gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWludGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFNpbnVzb2lkYWw6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEV4cG9uZW50aWFsOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0gMTAgKiBrKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwLjUgKiAoLSBNYXRoLnBvdygyLCAtIDEwICogKGsgLSAxKSkgKyAyKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdENpcmN1bGFyOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIC0gMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRFbGFzdGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gLU1hdGgucG93KDIsIDEwICogKGsgLSAxKSkgKiBNYXRoLnNpbigoayAtIDEuMSkgKiA1ICogTWF0aC5QSSk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gMC4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0ayAqPSAyO1xuXG5cdFx0XHRpZiAoayA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIC0wLjUgKiBNYXRoLnBvdygyLCAxMCAqIChrIC0gMSkpICogTWF0aC5zaW4oKGsgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKiBNYXRoLnNpbigoayAtIDEuMSkgKiA1ICogTWF0aC5QSSkgKyAxO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0QmFjazoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHZhciBzID0gMS43MDE1ODtcblxuXHRcdFx0cmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cblx0XHRcdHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG5cblx0XHR9XG5cblx0fSxcblxuXHRCb3VuY2U6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gMSAtIFRXRUVOLkVhc2luZy5Cb3VuY2UuT3V0KDEgLSBrKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmIChrIDwgKDEgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogayAqIGs7XG5cdFx0XHR9IGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMS41IC8gMi43NSkpICogayArIDAuNzU7XG5cdFx0XHR9IGVsc2UgaWYgKGsgPCAoMi41IC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjI1IC8gMi43NSkpICogayArIDAuOTM3NTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi42MjUgLyAyLjc1KSkgKiBrICsgMC45ODQzNzU7XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmIChrIDwgMC41KSB7XG5cdFx0XHRcdHJldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLkluKGsgKiAyKSAqIDAuNTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFRXRUVOLkVhc2luZy5Cb3VuY2UuT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5UV0VFTi5JbnRlcnBvbGF0aW9uID0ge1xuXG5cdExpbmVhcjogZnVuY3Rpb24gKHYsIGspIHtcblxuXHRcdHZhciBtID0gdi5sZW5ndGggLSAxO1xuXHRcdHZhciBmID0gbSAqIGs7XG5cdFx0dmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuXHRcdHZhciBmbiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuTGluZWFyO1xuXG5cdFx0aWYgKGsgPCAwKSB7XG5cdFx0XHRyZXR1cm4gZm4odlswXSwgdlsxXSwgZik7XG5cdFx0fVxuXG5cdFx0aWYgKGsgPiAxKSB7XG5cdFx0XHRyZXR1cm4gZm4odlttXSwgdlttIC0gMV0sIG0gLSBmKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm4odltpXSwgdltpICsgMSA+IG0gPyBtIDogaSArIDFdLCBmIC0gaSk7XG5cblx0fSxcblxuXHRCZXppZXI6IGZ1bmN0aW9uICh2LCBrKSB7XG5cblx0XHR2YXIgYiA9IDA7XG5cdFx0dmFyIG4gPSB2Lmxlbmd0aCAtIDE7XG5cdFx0dmFyIHB3ID0gTWF0aC5wb3c7XG5cdFx0dmFyIGJuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5CZXJuc3RlaW47XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpKyspIHtcblx0XHRcdGIgKz0gcHcoMSAtIGssIG4gLSBpKSAqIHB3KGssIGkpICogdltpXSAqIGJuKG4sIGkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBiO1xuXG5cdH0sXG5cblx0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKHYsIGspIHtcblxuXHRcdHZhciBtID0gdi5sZW5ndGggLSAxO1xuXHRcdHZhciBmID0gbSAqIGs7XG5cdFx0dmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuXHRcdHZhciBmbiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQ2F0bXVsbFJvbTtcblxuXHRcdGlmICh2WzBdID09PSB2W21dKSB7XG5cblx0XHRcdGlmIChrIDwgMCkge1xuXHRcdFx0XHRpID0gTWF0aC5mbG9vcihmID0gbSAqICgxICsgaykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm4odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmIChrIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4gdlswXSAtIChmbih2WzBdLCB2WzBdLCB2WzFdLCB2WzFdLCAtZikgLSB2WzBdKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGsgPiAxKSB7XG5cdFx0XHRcdHJldHVybiB2W21dIC0gKGZuKHZbbV0sIHZbbV0sIHZbbSAtIDFdLCB2W20gLSAxXSwgZiAtIG0pIC0gdlttXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbih2W2kgPyBpIC0gMSA6IDBdLCB2W2ldLCB2W20gPCBpICsgMSA/IG0gOiBpICsgMV0sIHZbbSA8IGkgKyAyID8gbSA6IGkgKyAyXSwgZiAtIGkpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0VXRpbHM6IHtcblxuXHRcdExpbmVhcjogZnVuY3Rpb24gKHAwLCBwMSwgdCkge1xuXG5cdFx0XHRyZXR1cm4gKHAxIC0gcDApICogdCArIHAwO1xuXG5cdFx0fSxcblxuXHRcdEJlcm5zdGVpbjogZnVuY3Rpb24gKG4sIGkpIHtcblxuXHRcdFx0dmFyIGZjID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5GYWN0b3JpYWw7XG5cblx0XHRcdHJldHVybiBmYyhuKSAvIGZjKGkpIC8gZmMobiAtIGkpO1xuXG5cdFx0fSxcblxuXHRcdEZhY3RvcmlhbDogKGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGEgPSBbMV07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAobikge1xuXG5cdFx0XHRcdHZhciBzID0gMTtcblxuXHRcdFx0XHRpZiAoYVtuXSkge1xuXHRcdFx0XHRcdHJldHVybiBhW25dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IG47IGkgPiAxOyBpLS0pIHtcblx0XHRcdFx0XHRzICo9IGk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhW25dID0gcztcblx0XHRcdFx0cmV0dXJuIHM7XG5cblx0XHRcdH07XG5cblx0XHR9KSgpLFxuXG5cdFx0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG5cblx0XHRcdHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcblx0XHRcdHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcblx0XHRcdHZhciB0MiA9IHQgKiB0O1xuXHRcdFx0dmFyIHQzID0gdCAqIHQyO1xuXG5cdFx0XHRyZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLSAzICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgVFdFRU47XG4iLCJpbXBvcnQgVHdlZW4gZnJvbSBcIi4vVHdlZW5cIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbi8qKlxuICog6K6+572uIEFuaW1hdGlvbkZyYW1lIGJlZ2luXG4gKi9cbnZhciBsYXN0VGltZSA9IDA7XG52YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5mb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbn07XG5pZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVUb0NhbGwpO1xuICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG59O1xuaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG59O1xuXG4vL+euoeeQhuaJgOacieWbvuihqOeahOa4suafk+S7u+WKoVxudmFyIF90YXNrTGlzdCA9IFtdOyAvL1t7IGlkIDogdGFzazogfS4uLl1cbnZhciBfcmVxdWVzdEFpZCA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuYWJsZWRBbmltYXRpb25GcmFtZSgpe1xuICAgIGlmICghX3JlcXVlc3RBaWQpIHtcbiAgICAgICAgX3JlcXVlc3RBaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZnJhbWVfX1wiICsgX3Rhc2tMaXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICAvL2lmICggVHdlZW4uZ2V0QWxsKCkubGVuZ3RoICkge1xuICAgICAgICAgICAgVHdlZW4udXBkYXRlKCk7IC8vdHdlZW7oh6rlt7HkvJrlgZpsZW5ndGjliKTmlq1cbiAgICAgICAgICAgIC8vfTtcbiAgICAgICAgICAgIHZhciBjdXJyVGFza0xpc3QgPSBfdGFza0xpc3Q7XG4gICAgICAgICAgICBfdGFza0xpc3QgPSBbXTtcbiAgICAgICAgICAgIF9yZXF1ZXN0QWlkID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyVGFza0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJUYXNrTGlzdC5zaGlmdCgpLnRhc2soKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIF9yZXF1ZXN0QWlkO1xufTsgXG5cbi8qXG4gKiBAcGFyYW0gdGFzayDopoHliqDlhaXliLDmuLLmn5PluKfpmJ/liJfkuK3nmoTku7vliqFcbiAqIEByZXN1bHQgZnJhbWVpZFxuICovXG5mdW5jdGlvbiByZWdpc3RGcmFtZSggJGZyYW1lICkge1xuICAgIGlmICghJGZyYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIF90YXNrTGlzdC5wdXNoKCRmcmFtZSk7XG4gICAgcmV0dXJuIGVuYWJsZWRBbmltYXRpb25GcmFtZSgpO1xufTtcblxuLypcbiAqICBAcGFyYW0gdGFzayDopoHku47muLLmn5PluKfpmJ/liJfkuK3liKDpmaTnmoTku7vliqFcbiAqL1xuZnVuY3Rpb24gZGVzdHJveUZyYW1lKCAkZnJhbWUgKSB7XG4gICAgdmFyIGRfcmVzdWx0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfdGFza0xpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChfdGFza0xpc3RbaV0uaWQgPT09ICRmcmFtZS5pZCkge1xuICAgICAgICAgICAgZF9yZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgX3Rhc2tMaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGwtLTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGlmIChfdGFza0xpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3JlcXVlc3RBaWQpO1xuICAgICAgICBfcmVxdWVzdEFpZCA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZF9yZXN1bHQ7XG59O1xuXG5cbi8qIFxuICogQHBhcmFtIG9wdCB7ZnJvbSAsIHRvICwgb25VcGRhdGUgLCBvbkNvbXBsZXRlICwgLi4uLi4ufVxuICogQHJlc3VsdCB0d2VlblxuICovXG5mdW5jdGlvbiByZWdpc3RUd2VlbihvcHRpb25zKSB7XG4gICAgdmFyIG9wdCA9IF8uZXh0ZW5kKHtcbiAgICAgICAgZnJvbTogbnVsbCxcbiAgICAgICAgdG86IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uKCl7fSxcbiAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIG9uU3RvcDogZnVuY3Rpb24oKXt9LFxuICAgICAgICByZXBlYXQ6IDAsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBlYXNpbmc6ICdMaW5lYXIuTm9uZScsXG4gICAgICAgIGRlc2M6ICcnIC8v5Yqo55S75o+P6L+w77yM5pa55L6/5p+l5om+YnVnXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgdHdlZW4gPSB7fTtcbiAgICB2YXIgdGlkID0gXCJ0d2Vlbl9cIiArIFV0aWxzLmdldFVJRCgpO1xuICAgIG9wdC5pZCAmJiAoIHRpZCA9IHRpZCtcIl9cIitvcHQuaWQgKTtcblxuICAgIGlmIChvcHQuZnJvbSAmJiBvcHQudG8pIHtcbiAgICAgICAgdHdlZW4gPSBuZXcgVHdlZW4uVHdlZW4oIG9wdC5mcm9tIClcbiAgICAgICAgLnRvKCBvcHQudG8sIG9wdC5kdXJhdGlvbiApXG4gICAgICAgIC5vblN0YXJ0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvcHQub25TdGFydC5hcHBseSggdGhpcyApXG4gICAgICAgIH0pXG4gICAgICAgIC5vblVwZGF0ZSggZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9wdC5vblVwZGF0ZS5hcHBseSggdGhpcyApO1xuICAgICAgICB9IClcbiAgICAgICAgLm9uQ29tcGxldGUoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVzdHJveUZyYW1lKHtcbiAgICAgICAgICAgICAgICBpZDogdGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHR3ZWVuLl9pc0NvbXBsZXRlZWQgPSB0cnVlO1xuICAgICAgICAgICAgb3B0Lm9uQ29tcGxldGUuYXBwbHkoIHRoaXMgLCBbdGhpc10gKTsgLy/miafooYznlKjmiLfnmoRjb25Db21wbGV0ZVxuICAgICAgICB9IClcbiAgICAgICAgLm9uU3RvcCggZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGRlc3Ryb3lGcmFtZSh7XG4gICAgICAgICAgICAgICAgaWQ6IHRpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0d2Vlbi5faXNTdG9wZWQgPSB0cnVlO1xuICAgICAgICAgICAgb3B0Lm9uU3RvcC5hcHBseSggdGhpcyAsIFt0aGlzXSApO1xuICAgICAgICB9IClcbiAgICAgICAgLnJlcGVhdCggb3B0LnJlcGVhdCApXG4gICAgICAgIC5kZWxheSggb3B0LmRlbGF5IClcbiAgICAgICAgLmVhc2luZyggVHdlZW4uRWFzaW5nW29wdC5lYXNpbmcuc3BsaXQoXCIuXCIpWzBdXVtvcHQuZWFzaW5nLnNwbGl0KFwiLlwiKVsxXV0gKVxuICAgICAgICBcbiAgICAgICAgdHdlZW4uaWQgPSB0aWQ7XG4gICAgICAgIHR3ZWVuLnN0YXJ0KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcblxuICAgICAgICAgICAgaWYgKCB0d2Vlbi5faXNDb21wbGV0ZWVkIHx8IHR3ZWVuLl9pc1N0b3BlZCApIHtcbiAgICAgICAgICAgICAgICB0d2VlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlZ2lzdEZyYW1lKHtcbiAgICAgICAgICAgICAgICBpZDogdGlkLFxuICAgICAgICAgICAgICAgIHRhc2s6IGFuaW1hdGUsXG4gICAgICAgICAgICAgICAgZGVzYzogb3B0LmRlc2MsXG4gICAgICAgICAgICAgICAgdHdlZW46IHR3ZWVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgYW5pbWF0ZSgpO1xuXG4gICAgfTtcbiAgICByZXR1cm4gdHdlZW47XG59O1xuLypcbiAqIEBwYXJhbSB0d2VlblxuICogQHJlc3VsdCB2b2lkKDApXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3lUd2Vlbih0d2VlbiAsIG1zZykge1xuICAgIHR3ZWVuLnN0b3AoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICByZWdpc3RGcmFtZTogcmVnaXN0RnJhbWUsXG4gICAgZGVzdHJveUZyYW1lOiBkZXN0cm95RnJhbWUsXG4gICAgcmVnaXN0VHdlZW46IHJlZ2lzdFR3ZWVuLFxuICAgIGRlc3Ryb3lUd2VlbjogZGVzdHJveVR3ZWVuXG59OyIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOWxnuaAp+W3peWOgu+8jGll5LiL6Z2i55SoVkJT5o+Q5L6b5pSv5oyBXG4gKiDmnaXnu5nmlbTkuKrlvJXmk47mj5Dkvpvlv4Pot7PljIXnmoTop6blj5HmnLrliLZcbiAqL1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxuLy/lrprkuYnlsIHoo4Xlpb3nmoTlhbzlrrnlpKfpg6jliIbmtY/op4jlmajnmoRkZWZpbmVQcm9wZXJ0aWVzIOeahCDlsZ7mgKflt6XljoJcbnZhciB1bndhdGNoT25lID0ge1xuICAgIFwiJHNraXBBcnJheVwiIDogMCxcbiAgICBcIiR3YXRjaFwiICAgICA6IDEsXG4gICAgXCIkZmlyZVwiICAgICAgOiAyLC8v5Li76KaB5pivZ2V0IHNldCDmmL7mgKforr7nva7nmoQg6Kem5Y+RXG4gICAgXCIkbW9kZWxcIiAgICAgOiAzLFxuICAgIFwiJGFjY2Vzc29yXCIgIDogNCxcbiAgICBcIiRvd25lclwiICAgICA6IDUsXG4gICAgLy9cInBhdGhcIiAgICAgICA6IDYsIC8v6L+Z5Liq5bqU6K+l5piv5ZSv5LiA5LiA5Liq5LiN55Sod2F0Y2jnmoTkuI3luKYk55qE5oiQ5ZGY5LqG5ZCn77yM5Zug5Li65Zyw5Zu+562J55qEcGF0aOaYr+WcqOWkquWkp1xuICAgIFwiJHBhcmVudFwiICAgIDogNyAgLy/nlKjkuo7lu7rnq4vmlbDmja7nmoTlhbPns7vpk75cbn1cblxuZnVuY3Rpb24gT2JzZXJ2ZShzY29wZSwgbW9kZWwsIHdhdGNoTW9yZSkge1xuXG4gICAgdmFyIHN0b3BSZXBlYXRBc3NpZ249dHJ1ZTtcblxuICAgIHZhciBza2lwQXJyYXkgPSBzY29wZS4kc2tpcEFycmF5LCAvL+imgeW/veeVpeebkeaOp+eahOWxnuaAp+WQjeWIl+ihqFxuICAgICAgICBwbW9kZWwgPSB7fSwgLy/opoHov5Tlm57nmoTlr7nosaFcbiAgICAgICAgYWNjZXNzb3JlcyA9IHt9LCAvL+WGhemDqOeUqOS6jui9rOaNoueahOWvueixoVxuICAgICAgICBWQlB1YmxpY3MgPSBfLmtleXMoIHVud2F0Y2hPbmUgKTsgLy/nlKjkuo5JRTYtOFxuXG4gICAgICAgIG1vZGVsID0gbW9kZWwgfHwge307Ly/ov5nmmK9wbW9kZWzkuIrnmoQkbW9kZWzlsZ7mgKdcbiAgICAgICAgd2F0Y2hNb3JlID0gd2F0Y2hNb3JlIHx8IHt9Oy8v5LulJOW8gOWktOS9huimgeW8uuWItuebkeWQrOeahOWxnuaAp1xuICAgICAgICBza2lwQXJyYXkgPSBfLmlzQXJyYXkoc2tpcEFycmF5KSA/IHNraXBBcnJheS5jb25jYXQoVkJQdWJsaWNzKSA6IFZCUHVibGljcztcblxuICAgIGZ1bmN0aW9uIGxvb3AobmFtZSwgdmFsKSB7XG4gICAgICAgIGlmICggIXVud2F0Y2hPbmVbbmFtZV0gfHwgKHVud2F0Y2hPbmVbbmFtZV0gJiYgbmFtZS5jaGFyQXQoMCkgIT09IFwiJFwiKSApIHtcbiAgICAgICAgICAgIG1vZGVsW25hbWVdID0gdmFsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAodmFsdWVUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmKCF1bndhdGNoT25lW25hbWVdKXtcbiAgICAgICAgICAgICAgVkJQdWJsaWNzLnB1c2gobmFtZSkgLy/lh73mlbDml6DpnIDopoHovazmjaJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfLmluZGV4T2Yoc2tpcEFycmF5LG5hbWUpICE9PSAtMSB8fCAobmFtZS5jaGFyQXQoMCkgPT09IFwiJFwiICYmICF3YXRjaE1vcmVbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZCUHVibGljcy5wdXNoKG5hbWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWNjZXNzb3IgPSBmdW5jdGlvbihuZW8pIHsgLy/liJvlu7rnm5HmjqflsZ7mgKfmiJbmlbDnu4TvvIzoh6rlj5jph4/vvIznlLHnlKjmiLfop6blj5HlhbbmlLnlj5hcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhY2Nlc3Nvci52YWx1ZSwgcHJlVmFsdWUgPSB2YWx1ZSwgY29tcGxleFZhbHVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v5YaZ5pON5L2cXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IOeahCDlgLznmoQg57G75Z6LXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZW9UeXBlID0gdHlwZW9mIG5lbztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcFJlcGVhdEFzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8v6Zi75q2i6YeN5aSN6LWL5YC8XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBuZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBuZW8gJiYgbmVvVHlwZSA9PT0gXCJvYmplY3RcIiAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKG5lbyBpbnN0YW5jZW9mIEFycmF5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFuZW8uYWRkQ29sb3JTdG9wIC8vIG5lbyBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lby4kbW9kZWwgPyBuZW8gOiBPYnNlcnZlKG5lbyAsIG5lbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxleFZhbHVlID0gdmFsdWUuJG1vZGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsvL+WmguaenOaYr+WFtuS7luaVsOaNruexu+Wei1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYoIG5lb1R5cGUgPT09IFwiYXJyYXlcIiApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHZhbHVlID0gXy5jbG9uZShuZW8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc29yLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFtuYW1lXSA9IGNvbXBsZXhWYWx1ZSA/IGNvbXBsZXhWYWx1ZSA6IHZhbHVlOy8v5pu05pawJG1vZGVs5Lit55qE5YC8XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsZXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBtb2RlbC4kZmlyZSAmJiBwbW9kZWwuJGZpcmUobmFtZSwgdmFsdWUsIHByZVZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsdWVUeXBlICE9IG5lb1R5cGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6cc2V055qE5YC857G75Z6L5bey57uP5pS55Y+Y77yMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/pgqPkuYjkuZ/opoHmiorlr7nlupTnmoR2YWx1ZVR5cGXkv67mlLnkuLrlr7nlupTnmoRuZW9UeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gbmVvVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNXYXRjaE1vZGVsID0gcG1vZGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy/miYDmnInnmoTotYvlgLzpg73opoHop6blj5F3YXRjaOeahOebkeWQrOS6i+S7tlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcG1vZGVsLiR3YXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoIGhhc1dhdGNoTW9kZWwuJHBhcmVudCApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXRjaE1vZGVsID0gaGFzV2F0Y2hNb2RlbC4kcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhc1dhdGNoTW9kZWwuJHdhdGNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXRjaE1vZGVsLiR3YXRjaC5jYWxsKGhhc1dhdGNoTW9kZWwgLCBuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy/or7vmk43kvZxcbiAgICAgICAgICAgICAgICAgICAgLy/or7vnmoTml7blgJnvvIzlj5HnjrB2YWx1ZeaYr+S4qm9iau+8jOiAjOS4lOi/mOayoeaciWRlZmluZVByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIC8v6YKj5LmI5bCx5Li05pe2ZGVmaW5lUHJvcGVydHnkuIDmrKFcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAmJiAodmFsdWVUeXBlID09PSBcIm9iamVjdFwiKSBcbiAgICAgICAgICAgICAgICAgICAgICAgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSBcbiAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZhbHVlLiRtb2RlbFxuICAgICAgICAgICAgICAgICAgICAgICAmJiAhdmFsdWUuYWRkQ29sb3JTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL+W7uueri+WSjOeItuaVsOaNruiKgueCueeahOWFs+ezu1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJHBhcmVudCA9IHBtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gT2JzZXJ2ZSh2YWx1ZSAsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hY2Nlc3Nvci52YWx1ZSDph43mlrDlpI3liLbkuLpkZWZpbmVQcm9wZXJ0eei/h+WQjueahOWvueixoVxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY2Vzc29yLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhY2Nlc3NvcmVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHNldDogYWNjZXNzb3IsXG4gICAgICAgICAgICAgICAgZ2V0OiBhY2Nlc3NvcixcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZvciAodmFyIGkgaW4gc2NvcGUpIHtcbiAgICAgICAgbG9vcChpLCBzY29wZVtpXSlcbiAgICB9O1xuXG4gICAgcG1vZGVsID0gZGVmaW5lUHJvcGVydGllcyhwbW9kZWwsIGFjY2Vzc29yZXMsIFZCUHVibGljcyk7Ly/nlJ/miJDkuIDkuKrnqbrnmoRWaWV3TW9kZWxcblxuICAgIF8uZm9yRWFjaChWQlB1YmxpY3MsZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoc2NvcGVbbmFtZV0pIHsvL+WFiOS4uuWHveaVsOetieS4jeiiq+ebkeaOp+eahOWxnuaAp+i1i+WAvFxuICAgICAgICAgICAgaWYodHlwZW9mIHNjb3BlW25hbWVdID09IFwiZnVuY3Rpb25cIiApe1xuICAgICAgICAgICAgICAgcG1vZGVsW25hbWVdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgIHNjb3BlW25hbWVdLmFwcGx5KHRoaXMgLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHBtb2RlbFtuYW1lXSA9IHNjb3BlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwbW9kZWwuJG1vZGVsID0gbW9kZWw7XG4gICAgcG1vZGVsLiRhY2Nlc3NvciA9IGFjY2Vzc29yZXM7XG5cbiAgICBwbW9kZWwuaGFzT3duUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lIGluIHBtb2RlbC4kbW9kZWxcbiAgICB9O1xuXG4gICAgc3RvcFJlcGVhdEFzc2lnbiA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHBtb2RlbFxufVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgLy/lpoLmnpzmtY/op4jlmajkuI3mlK/mjIFlY21hMjYydjXnmoRPYmplY3QuZGVmaW5lUHJvcGVydGllc+aIluiAheWtmOWcqEJVR++8jOavlOWmgklFOFxuICAgIC8v5qCH5YeG5rWP6KeI5Zmo5L2/55SoX19kZWZpbmVHZXR0ZXJfXywgX19kZWZpbmVTZXR0ZXJfX+WunueOsFxuICAgIHRyeSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHt9LCBcIl9cIiwge1xuICAgICAgICAgICAgdmFsdWU6IFwieFwiXG4gICAgICAgIH0pXG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChcIl9fZGVmaW5lR2V0dGVyX19cIiBpbiBPYmplY3QpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wLCBkZXNjKSB7XG4gICAgICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBkZXNjLnZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnZ2V0JyBpbiBkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5fX2RlZmluZUdldHRlcl9fKHByb3AsIGRlc2MuZ2V0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3NldCcgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgICAgICBvYmouX19kZWZpbmVTZXR0ZXJfXyhwcm9wLCBkZXNjLnNldClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbihvYmosIGRlc2NzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBkZXNjcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzY3MuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZGVzY3NbcHJvcF0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbi8vSUU2LTjkvb/nlKhWQlNjcmlwdOexu+eahHNldCBnZXTor63lj6Xlrp7njrBcbmlmICghZGVmaW5lUHJvcGVydGllcyAmJiB3aW5kb3cuVkJBcnJheSkge1xuICAgIHdpbmRvdy5leGVjU2NyaXB0KFtcbiAgICAgICAgICAgIFwiRnVuY3Rpb24gcGFyc2VWQihjb2RlKVwiLFxuICAgICAgICAgICAgXCJcXHRFeGVjdXRlR2xvYmFsKGNvZGUpXCIsXG4gICAgICAgICAgICBcIkVuZCBGdW5jdGlvblwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIiksIFwiVkJTY3JpcHRcIik7XG5cbiAgICBmdW5jdGlvbiBWQk1lZGlhdG9yKGRlc2NyaXB0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZm4gPSBkZXNjcmlwdGlvbltuYW1lXSAmJiBkZXNjcmlwdGlvbltuYW1lXS5zZXQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBmbih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKHB1YmxpY3MsIGRlc2NyaXB0aW9uLCBhcnJheSkge1xuICAgICAgICBwdWJsaWNzID0gYXJyYXkuc2xpY2UoMCk7XG4gICAgICAgIHB1YmxpY3MucHVzaChcImhhc093blByb3BlcnR5XCIpO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJWQkNsYXNzXCIgKyBzZXRUaW1lb3V0KFwiMVwiKSwgb3duZXIgPSB7fSwgYnVmZmVyID0gW107XG4gICAgICAgIGJ1ZmZlci5wdXNoKFxuICAgICAgICAgICAgICAgIFwiQ2xhc3MgXCIgKyBjbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgXCJcXHRQcml2YXRlIFtfX2RhdGFfX10sIFtfX3Byb3h5X19dXCIsXG4gICAgICAgICAgICAgICAgXCJcXHRQdWJsaWMgRGVmYXVsdCBGdW5jdGlvbiBbX19jb25zdF9fXShkLCBwKVwiLFxuICAgICAgICAgICAgICAgIFwiXFx0XFx0U2V0IFtfX2RhdGFfX10gPSBkOiBzZXQgW19fcHJveHlfX10gPSBwXCIsXG4gICAgICAgICAgICAgICAgXCJcXHRcXHRTZXQgW19fY29uc3RfX10gPSBNZVwiLCAvL+mTvuW8j+iwg+eUqFxuICAgICAgICAgICAgICAgIFwiXFx0RW5kIEZ1bmN0aW9uXCIpO1xuICAgICAgICBfLmZvckVhY2gocHVibGljcyxmdW5jdGlvbihuYW1lKSB7IC8v5re75Yqg5YWs5YWx5bGe5oCnLOWmguaenOatpOaXtuS4jeWKoOS7peWQjuWwseayoeacuuS8muS6hlxuICAgICAgICAgICAgaWYgKG93bmVyW25hbWVdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgb3duZXJbbmFtZV0gPSB0cnVlIC8v5Zug5Li6VkJTY3JpcHTlr7nosaHkuI3og73lg49KU+mCo+agt+maj+aEj+WinuWIoOWxnuaAp1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goXCJcXHRQdWJsaWMgW1wiICsgbmFtZSArIFwiXVwiKSAvL+S9oOWPr+S7pemihOWFiOaUvuWIsHNraXBBcnJheeS4rVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgb3duZXJbbmFtZV0gPSB0cnVlXG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+eUseS6juS4jeefpeWvueaWueS8muS8oOWFpeS7gOS5iCzlm6DmraRzZXQsIGxldOmDveeUqOS4ilxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRQdWJsaWMgUHJvcGVydHkgTGV0IFtcIiArIG5hbWUgKyBcIl0odmFsKVwiLCAvL3NldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRcXHRDYWxsIFtfX3Byb3h5X19dKFtfX2RhdGFfX10sIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHZhbClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0RW5kIFByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFB1YmxpYyBQcm9wZXJ0eSBTZXQgW1wiICsgbmFtZSArIFwiXSh2YWwpXCIsIC8vc2V0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFxcdENhbGwgW19fcHJveHlfX10oW19fZGF0YV9fXSwgXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgdmFsKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRFbmQgUHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0UHVibGljIFByb3BlcnR5IEdldCBbXCIgKyBuYW1lICsgXCJdXCIsIC8vZ2V0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdE9uIEVycm9yIFJlc3VtZSBOZXh0XCIsIC8v5b+F6aG75LyY5YWI5L2/55Soc2V06K+t5Y+lLOWQpuWImeWug+S8muivr+WwhuaVsOe7hOW9k+Wtl+espuS4sui/lOWbnlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRcXHRTZXRbXCIgKyBuYW1lICsgXCJdID0gW19fcHJveHlfX10oW19fZGF0YV9fXSxcXFwiXCIgKyBuYW1lICsgXCJcXFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRJZiBFcnIuTnVtYmVyIDw+IDAgVGhlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRcXHRbXCIgKyBuYW1lICsgXCJdID0gW19fcHJveHlfX10oW19fZGF0YV9fXSxcXFwiXCIgKyBuYW1lICsgXCJcXFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRFbmQgSWZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0T24gRXJyb3IgR290byAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEVuZCBQcm9wZXJ0eVwiKVxuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKFwiRW5kIENsYXNzXCIpOyAvL+exu+WumuS5ieWujOavlVxuICAgICAgICBidWZmZXIucHVzaChcbiAgICAgICAgICAgICAgICBcIkZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJGYWN0b3J5KGEsIGIpXCIsIC8v5Yib5bu65a6e5L6L5bm25Lyg5YWl5Lik5Liq5YWz6ZSu55qE5Y+C5pWwXG4gICAgICAgICAgICAgICAgXCJcXHREaW0gb1wiLFxuICAgICAgICAgICAgICAgIFwiXFx0U2V0IG8gPSAoTmV3IFwiICsgY2xhc3NOYW1lICsgXCIpKGEsIGIpXCIsXG4gICAgICAgICAgICAgICAgXCJcXHRTZXQgXCIgKyBjbGFzc05hbWUgKyBcIkZhY3RvcnkgPSBvXCIsXG4gICAgICAgICAgICAgICAgXCJFbmQgRnVuY3Rpb25cIik7XG4gICAgICAgIHdpbmRvdy5wYXJzZVZCKGJ1ZmZlci5qb2luKFwiXFxyXFxuXCIpKTsvL+WFiOWIm+W7uuS4gOS4qlZC57G75bel5Y6CXG4gICAgICAgIHJldHVybiAgd2luZG93W2NsYXNzTmFtZSArIFwiRmFjdG9yeVwiXShkZXNjcmlwdGlvbiwgVkJNZWRpYXRvcik7Ly/lvpfliLDlhbbkuqflk4FcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBPYnNlcnZlO1xuXG4iLCJcbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gX19WRVJTSU9OX187XG5cbmV4cG9ydCBjb25zdCBQSV8yID0gTWF0aC5QSSAqIDI7XG5cbmV4cG9ydCBjb25zdCBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IGNvbnN0IERFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG5leHBvcnQgY29uc3QgUkVOREVSRVJfVFlQRSA9IHtcbiAgICBVTktOT1dOOiAgICAwLFxuICAgIFdFQkdMOiAgICAgIDEsXG4gICAgQ0FOVkFTOiAgICAgMixcbn07XG5cbmV4cG9ydCBjb25zdCBEUkFXX01PREVTID0ge1xuICAgIFBPSU5UUzogICAgICAgICAwLFxuICAgIExJTkVTOiAgICAgICAgICAxLFxuICAgIExJTkVfTE9PUDogICAgICAyLFxuICAgIExJTkVfU1RSSVA6ICAgICAzLFxuICAgIFRSSUFOR0xFUzogICAgICA0LFxuICAgIFRSSUFOR0xFX1NUUklQOiA1LFxuICAgIFRSSUFOR0xFX0ZBTjogICA2LFxufTtcblxuZXhwb3J0IGNvbnN0IFNIQVBFUyA9IHtcbiAgICBQT0xZOiAwLFxuICAgIFJFQ1Q6IDEsXG4gICAgQ0lSQzogMixcbiAgICBFTElQOiAzLFxufTtcblxuZXhwb3J0IGNvbnN0IFNDQUxFX01PREVTID0ge1xuICAgIExJTkVBUjogICAgIDAsXG4gICAgTkVBUkVTVDogICAgMSxcbn07XG5cbmV4cG9ydCBjb25zdCBDT05URVhUX0RFRkFVTFQgPSB7XG4gICAgd2lkdGggICAgICAgICA6IDAsXG4gICAgaGVpZ2h0ICAgICAgICA6IDAsXG4gICAgeCAgICAgICAgICAgICA6IDAsXG4gICAgeSAgICAgICAgICAgICA6IDAsXG4gICAgc2NhbGVYICAgICAgICA6IDEsXG4gICAgc2NhbGVZICAgICAgICA6IDEsXG4gICAgc2NhbGVPcmlnaW4gICA6IHtcbiAgICAgICAgeCA6IDAsXG4gICAgICAgIHkgOiAwXG4gICAgfSxcbiAgICByb3RhdGlvbiAgICAgIDogMCxcbiAgICByb3RhdGVPcmlnaW4gIDogIHtcbiAgICAgICAgeCA6IDAsXG4gICAgICAgIHkgOiAwXG4gICAgfSxcbiAgICB2aXNpYmxlICAgICAgIDogdHJ1ZSxcbiAgICBnbG9iYWxBbHBoYSAgIDogMSxcblxuICAgIC8vc2hhcGUg5omN6ZyA6KaB55So5Yiw77yMIOW3sue7j+i/geenu+WIsHNoYXBl5Lit5Y675LqG77yM6L+Z6YeM5YWI5rOo6YeK5o6JXG4gICAgLypcbiAgICBjdXJzb3IgICAgICAgIDogXCJkZWZhdWx0XCIsXG5cbiAgICBmaWxsQWxwaGEgICAgIDogMSwvL2NvbnRleHQyZOmHjOayoeacie+8jOiHquWumuS5iVxuICAgIGZpbGxTdHlsZSAgICAgOiBudWxsLC8vXCIjMDAwMDAwXCIsXG5cbiAgICBsaW5lQ2FwICAgICAgIDogbnVsbCwvL+m7mOiupOmDveaYr+ebtOinklxuICAgIGxpbmVKb2luICAgICAgOiBudWxsLC8v6L+Z5Lik5Liq55uu5YmNd2ViZ2zph4zpnaLmsqHlrp7njrBcbiAgICBtaXRlckxpbWl0ICAgIDogbnVsbCwvL21pdGVyTGltaXQg5bGe5oCn6K6+572u5oiW6L+U5Zue5pyA5aSn5pac5o6l6ZW/5bqmLOWPquacieW9kyBsaW5lSm9pbiDlsZ7mgKfkuLogXCJtaXRlclwiIOaXtu+8jG1pdGVyTGltaXQg5omN5pyJ5pWI44CCXG5cbiAgICBsaW5lQWxwaGEgICAgIDogMSwvL2NvbnRleHQyZOmHjOayoeacie+8jOiHquWumuS5iVxuICAgIHN0cm9rZVN0eWxlICAgOiBudWxsLFxuICAgIGxpbmVUeXBlICAgICAgOiBcInNvbGlkXCIsIC8vY29udGV4dDJk6YeM5rKh5pyJ77yM6Ieq5a6a5LmJ57q/5p2h55qEdHlwZe+8jOm7mOiupOS4uuWunue6v1xuICAgIGxpbmVXaWR0aCAgICAgOiBudWxsLFxuICAgICovXG4gICAgXG4gICAgXG4gICAgLy/msqHnlKjliLDnmoTmmoLml7bkuI3nlKhcbiAgICAvL3NoYWRvd0JsdXIgICAgOiBudWxsLFxuICAgIC8vc2hhZG93Q29sb3IgICA6IG51bGwsXG4gICAgLy9zaGFkb3dPZmZzZXRYIDogbnVsbCxcbiAgICAvL3NoYWRvd09mZnNldFkgOiBudWxsLFxuICAgIFxuICAgIC8vZm9udCAgICAgICAgICA6IG51bGwsXG4gICAgLy90ZXh0QWxpZ24gICAgIDogXCJsZWZ0XCIsXG4gICAgLy90ZXh0QmFzZWxpbmUgIDogXCJ0b3BcIiwgXG4gICAgLy9hcmNTY2FsZVhfICAgIDogbnVsbCxcbiAgICAvL2FyY1NjYWxlWV8gICAgOiBudWxsLFxuICAgIC8vbGluZVNjYWxlXyAgICA6IG51bGwsXG4gICAgXG4gICAgLy9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gOiBudWxsXG5cbn07XG5leHBvcnQgY29uc3QgU0hBUEVfQ09OVEVYVF9ERUZBVUxUID0ge1xuICAgIGN1cnNvciAgICAgICAgOiBcImRlZmF1bHRcIixcblxuICAgIGZpbGxBbHBoYSAgICAgOiAxLC8vY29udGV4dDJk6YeM5rKh5pyJ77yM6Ieq5a6a5LmJXG4gICAgZmlsbFN0eWxlICAgICA6IG51bGwsLy9cIiMwMDAwMDBcIixcblxuICAgIGxpbmVDYXAgICAgICAgOiBudWxsLC8v6buY6K6k6YO95piv55u06KeSXG4gICAgbGluZUpvaW4gICAgICA6IG51bGwsLy/ov5nkuKTkuKrnm67liY13ZWJnbOmHjOmdouayoeWunueOsFxuICAgIG1pdGVyTGltaXQgICAgOiBudWxsLC8vbWl0ZXJMaW1pdCDlsZ7mgKforr7nva7miJbov5Tlm57mnIDlpKfmlpzmjqXplb/luqYs5Y+q5pyJ5b2TIGxpbmVKb2luIOWxnuaAp+S4uiBcIm1pdGVyXCIg5pe277yMbWl0ZXJMaW1pdCDmiY3mnInmlYjjgIJcblxuICAgIGxpbmVBbHBoYSAgICAgOiAxLC8vY29udGV4dDJk6YeM5rKh5pyJ77yM6Ieq5a6a5LmJXG4gICAgc3Ryb2tlU3R5bGUgICA6IG51bGwsXG4gICAgbGluZVR5cGUgICAgICA6IFwic29saWRcIiwgLy9jb250ZXh0MmTph4zmsqHmnInvvIzoh6rlrprkuYnnur/mnaHnmoR0eXBl77yM6buY6K6k5Li65a6e57q/XG4gICAgbGluZVdpZHRoICAgICA6IG51bGxcbn1cblxuLy/kvJrlvbHlk43liLB0cmFuc2Zvcm3mlLnlj5jnmoRjb250ZXh05bGe5oCnXG5leHBvcnQgY29uc3QgVFJBTlNGT1JNX1BST1BTID0gWyBcbiAgICBcInhcIiAsIFxuICAgIFwieVwiICwgXG4gICAgXCJzY2FsZVhcIiAsIFxuICAgIFwic2NhbGVZXCIgLCBcbiAgICBcInJvdGF0aW9uXCIgLCBcbiAgICBcInNjYWxlT3JpZ2luXCIgLCBcbiAgICBcInJvdGF0ZU9yaWdpblwiIFxuXVxuXG4vL+aJgOacieWSjOagt+W8j+ebuOWFs+eahOWxnuaAp1xuZXhwb3J0IGNvbnN0IFNUWUxFX1BST1BTID0gW1xuICAgIFwibGluZVdpZHRoXCIgLFxuICAgIFwibGluZUFscGhhXCIsXG4gICAgXCJzdHJva2VTdHlsZVwiLFxuICAgIFwiZmlsbFN0eWxlXCIsXG4gICAgXCJmaWxsQWxwaGFcIixcbiAgICBcImdsb2JhbEFscGhhXCJcbl1cblxuXG5cblxuIiwiXG5cbi8qKlxuICog57q/5q615YyF5ZCr5Yik5patXG4gKiBAcG9pbnRzIFswLDAsMCwwXVxuICovXG52YXIgX2lzSW5zaWRlTGluZSA9IGZ1bmN0aW9uKCBwb2ludHMsIHgsIHksIGxpbmVXaWR0aCApIFxue1xuICAgIHZhciB4MCA9IHBvaW50c1swXTtcbiAgICB2YXIgeTAgPSBwb2ludHNbMV07XG4gICAgdmFyIHgxID0gcG9pbnRzWzJdO1xuICAgIHZhciB5MSA9IHBvaW50c1szXTtcbiAgICB2YXIgX2wgPSBNYXRoLm1heChsaW5lV2lkdGggLCAzKTtcbiAgICB2YXIgX2EgPSAwO1xuICAgIHZhciBfYiA9IHgwO1xuXG4gICAgaWYoXG4gICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCkgXG4gICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCkgXG4gICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCkgXG4gICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCkgXG4gICAgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh4MCAhPT0geDEpIHtcbiAgICAgICAgX2EgPSAoeTAgLSB5MSkgLyAoeDAgLSB4MSk7XG4gICAgICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gICAgfVxuXG4gICAgdmFyIF9zID0gKF9hICogeCAtIHkgKyBfYikgKiAoX2EgKiB4IC0geSArIF9iKSAvIChfYSAqIF9hICsgMSk7XG4gICAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbn0gXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc2lkZUxpbmUoZGF0YSwgeCwgeSwgbGluZSkgXG57ICAgXG4gICAgdmFyIHBvaW50cyA9IGRhdGEuc2hhcGUucG9pbnRzO1xuICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcbiAgICB2YXIgaW5zaWRlQ2F0Y2ggPSBmYWxzZTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaW5zaWRlQ2F0Y2ggPSBfaXNJbnNpZGVMaW5lKCBwb2ludHMuc2xpY2UoaSAsIGkrNCkgLCB4ICwgeSAsIGxpbmVXaWR0aCApO1xuICAgICAgICBpZiggaW5zaWRlQ2F0Y2ggKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9O1xuICAgICAgICBpICs9IDFcbiAgICB9O1xuICAgIHJldHVybiBpbnNpZGVDYXRjaDtcbn0iLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiDmqKHmi59hczMgRGlzcGxheUxpc3Qg55qEIOeOsOWunuWvueixoeWfuuexu1xuICovXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tIFwiLi4vZXZlbnQvRXZlbnREaXNwYXRjaGVyXCI7XG5pbXBvcnQgTWF0cml4IGZyb20gXCIuLi9nZW9tL01hdHJpeFwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuL1BvaW50XCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XG5pbXBvcnQgQW5pbWF0aW9uRnJhbWUgZnJvbSBcIi4uL2FuaW1hdGlvbi9BbmltYXRpb25GcmFtZVwiO1xuaW1wb3J0IE9ic2VydmUgZnJvbSBcIi4uL3V0aWxzL29ic2VydmVcIjtcbmltcG9ydCB7Q09OVEVYVF9ERUZBVUxULCBUUkFOU0ZPUk1fUFJPUFN9IGZyb20gXCIuLi9jb25zdFwiO1xuaW1wb3J0IEluc2lkZUxpbmUgZnJvbSAnLi4vZ2VvbS9JbnNpZGVMaW5lJztcblxudmFyIERpc3BsYXlPYmplY3QgPSBmdW5jdGlvbihvcHQpe1xuICAgIERpc3BsYXlPYmplY3Quc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy/lpoLmnpznlKjmiLfmsqHmnInkvKDlhaVjb250ZXh06K6+572u77yM5bCx6buY6K6k5Li656m655qE5a+56LGhXG4gICAgb3B0ICAgICAgPSBVdGlscy5jaGVja09wdCggb3B0ICk7XG5cbiAgICAvL+ebuOWvueeItue6p+WFg+e0oOeahOefqemYtVxuICAgIHRoaXMuX3RyYW5zZm9ybSAgICAgID0gbnVsbDtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtICA9IG51bGw7IC8vd2ViZ2wg5riy5p+T5Zmo5Lit5LiT55SoXG5cbiAgICAvL+W/g+i3s+asoeaVsFxuICAgIHRoaXMuX2hlYXJ0QmVhdE51bSAgID0gMDtcblxuICAgIC8v5YWD57Sg5a+55bqU55qEc3RhZ2XlhYPntKBcbiAgICB0aGlzLnN0YWdlICAgICAgICAgICA9IG51bGw7XG5cbiAgICAvL+WFg+e0oOeahOeItuWFg+e0oFxuICAgIHRoaXMucGFyZW50ICAgICAgICAgID0gbnVsbDtcblxuICAgIHRoaXMuX2V2ZW50RW5hYmxlZCAgID0gZmFsc2U7ICAgLy/mmK/lkKblk43lupTkuovku7bkuqTkupIs5Zyo5re75Yqg5LqG5LqL5Lu25L6m5ZCs5ZCO5Lya6Ieq5Yqo6K6+572u5Li6dHJ1ZVxuXG4gICAgdGhpcy5kcmFnRW5hYmxlZCAgICAgPSB0cnVlIDsvL1wiZHJhZ0VuYWJsZWRcIiBpbiBvcHQgPyBvcHQuZHJhZ0VuYWJsZWQgOiBmYWxzZTsgICAvL+aYr+WQpuWQr+eUqOWFg+e0oOeahOaLluaLvVxuXG4gICAgdGhpcy54eVRvSW50ICAgICAgICAgPSBcInh5VG9JbnRcIiBpbiBvcHQgPyBvcHQueHlUb0ludCA6IHRydWU7ICAgIC8v5piv5ZCm5a+5eHnlnZDmoIfnu5/kuIBpbnTlpITnkIbvvIzpu5jorqTkuLp0cnVl77yM5L2G5piv5pyJ55qE5pe25YCZ5Y+v5Lul55Sx5aSW55WM55So5oi35omL5Yqo5oyH5a6a5piv5ZCm6ZyA6KaB6K6h566X5Li6aW5077yM5Zug5Li65pyJ55qE5pe25YCZ5LiN6K6h566X5q+U6L6D5aW977yM5q+U5aaC77yM6L+b5bqm5Zu+6KGo5Lit77yM5YaNc2VjdG9y55qE5Lik56uv5re75Yqg5Lik5Liq5ZyG5p2l5YGa5ZyG6KeS55qE6L+b5bqm5p2h55qE5pe25YCZ77yM5ZyGY2lyY2xl5LiN5YGaaW506K6h566X77yM5omN6IO95ZKMc2VjdG9y5pu05aW955qE6KGU5o6lXG5cbiAgICB0aGlzLm1vdmVpbmcgICAgICAgICA9IGZhbHNlOyAvL+WmguaenOWFg+e0oOWcqOacgOi9qOmBk+i/kOWKqOS4reeahOaXtuWAme+8jOacgOWlveaKiui/meS4quiuvue9ruS4unRydWXvvIzov5nmoLfog73kv53or4Hovajov7nnmoTkuJ3mkKzpobrmu5HvvIzlkKbliJnlm6DkuLp4eVRvSW5055qE5Y6f5Zug77yM5Lya5pyJ6Lez6LeDXG5cbiAgICAvL+WIm+W7uuWlvWNvbnRleHRcbiAgICB0aGlzLl9jcmVhdGVDb250ZXh0KCBvcHQgKTtcblxuICAgIHRoaXMuaWQgPSBvcHQuaWQgfHwgVXRpbHMuY3JlYXRlSWQodGhpcy50eXBlIHx8IFwiZGlzcGxheU9iamVjdFwiKTtcblxuICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzICwgYXJndW1lbnRzKTtcblxuICAgIC8v5omA5pyJ5bGe5oCn5YeG5aSH5aW95LqG5ZCO77yM5YWI6KaB6K6h566X5LiA5qyhdGhpcy5fdXBkYXRlVHJhbnNmb3JtKCnlvpfliLBfdGFuc2Zvcm1cbiAgICB0aGlzLl91cGRhdGVUcmFuc2Zvcm0oKTtcbn07XG5cblV0aWxzLmNyZWF0Q2xhc3MoIERpc3BsYXlPYmplY3QgLCBFdmVudERpc3BhdGNoZXIgLCB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uKCl7fSxcbiAgICBfY3JlYXRlQ29udGV4dCA6IGZ1bmN0aW9uKCBvcHQgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvL+aJgOacieaYvuekuuWvueixoe+8jOmDveacieS4gOS4quexu+S8vGNhbnZhcy5jb250ZXh057G75Ly855qEIGNvbnRleHTlsZ7mgKdcbiAgICAgICAgLy/nlKjmnaXlrZjlj5bmlLnmmL7npLrlr7nosaHmiYDmnInlkozmmL7npLrmnInlhbPnmoTlsZ7mgKfvvIzlnZDmoIfvvIzmoLflvI/nrYnjgIJcbiAgICAgICAgLy/or6Xlr7nosaHkuLpDb2VyLk9ic2VydmUoKeW3peWOguWHveaVsOeUn+aIkFxuICAgICAgICBzZWxmLmNvbnRleHQgPSBudWxsO1xuXG4gICAgICAgIC8v5o+Q5L6b57uZQ29lci5PYnNlcnZlKCkg5p2lIOe7mSBzZWxmLmNvbnRleHQg6K6+572uIHByb3BlcnR5c1xuICAgICAgICAvL+i/memHjOS4jeiDveeUqF8uZXh0ZW5k77yMIOWboOS4uuimgeS/neivgV9jb250ZXh0QVRUUlPnmoTnuq/nsrnvvIzlj6ropobnm5bkuIvpnaLlt7LmnInnmoTlsZ7mgKdcbiAgICAgICAgdmFyIF9jb250ZXh0QVRUUlMgPSBfLmV4dGVuZCggXy5jbG9uZShDT05URVhUX0RFRkFVTFQpLCBvcHQuY29udGV4dCAsIHRydWUpO1xuXG4gICAgICAgIC8v5pyJ5Lqb5byV5pOO5YaF6YOo6K6+572uY29udGV4dOWxnuaAp+eahOaXtuWAmeaYr+S4jeeUqOS4iuaKpeW/g+i3s+eahO+8jOavlOWmguWBmueDreeCueajgOa1i+eahOaXtuWAmVxuICAgICAgICBzZWxmLl9ub3RXYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgIF9jb250ZXh0QVRUUlMuJG93bmVyID0gc2VsZjtcbiAgICAgICAgX2NvbnRleHRBVFRSUy4kd2F0Y2ggPSBmdW5jdGlvbihuYW1lICwgdmFsdWUgLCBwcmVWYWx1ZSl7XG4gICAgICAgICAgICAvL+S4i+mdoueahOi/meS6m+WxnuaAp+WPmOWMlu+8jOmDveS8mumcgOimgemHjeaWsOe7hOe7h+efqemYteWxnuaApyBfdHJhbnNmb3JtIFxuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuJG93bmVyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggXy5pbmRleE9mKCBUUkFOU0ZPUk1fUFJPUFMgLCBuYW1lICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICBvYmouX3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vc3RhZ2XmnKzouqvlsLHmmK/kuJbnlYzlnZDmoIfvvIzmiYDku6XlhbZ3b3JsZFRyYW5zZm9ybeS4jemcgOimgeWKqOaAgeS/ruaUuVxuICAgICAgICAgICAgICAgIGlmKCBvYmoucGFyZW50ICYmIG9iai50eXBlICE9IFwic3RhZ2VcIiAmJiBvYmoucGFyZW50LndvcmxkVHJhbnNmb3JtICl7XG4gICAgICAgICAgICAgICAgICAgIG9iai53b3JsZFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8v5Y+q5pyJcGFyZW505pyJd29ybGRUcmFuc2Zvcm3vvIzlsLHlj6/ku6Xnrpflh7roh6rlt7Hlr7nlupTnmoTkuJbnlYzlnZDmoIdcbiAgICAgICAgICAgICAgICAgICAgb2JqLmdldFdvcmxkVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBvYmouY2hpbGRyZW4gKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c6Ieq5bex6L+Y5pyJ5a2Q5YWD57Sg77yM6YKj5LmI5a2Q5YWD57Sg55qE5LiW55WM5Z2Q5qCH5Lmf6YO96KaB5a+55bqU55qE6LCD5pW0XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoudXBkYXRlQ2hpbGRXb3JsZFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYoIG9iai5fbm90V2F0Y2ggKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiggb2JqLiR3YXRjaCApe1xuICAgICAgICAgICAgICAgIG9iai4kd2F0Y2goIG5hbWUgLCB2YWx1ZSAsIHByZVZhbHVlICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvYmouaGVhcnRCZWF0KCB7XG4gICAgICAgICAgICAgICAgY29udmVydFR5cGU6XCJjb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgc2hhcGUgICAgICA6IG9iaixcbiAgICAgICAgICAgICAgICBuYW1lICAgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICAgIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcHJlVmFsdWUgICA6IHByZVZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICB9O1xuXG4gICAgICAgIC8v5omn6KGMaW5pdOS5i+WJje+8jOW6lOivpeWwseagueaNruWPguaVsO+8jOaKimNvbnRleHTnu4Tnu4flpb3nur9cbiAgICAgICAgc2VsZi5jb250ZXh0ID0gT2JzZXJ2ZSggX2NvbnRleHRBVFRSUyApO1xuICAgICAgICAvL3NlbGYuY29udGV4dCA9IF9jb250ZXh0QVRUUlNcbiAgICB9LFxuICAgIC8qIEBteXNlbGYg5piv5ZCm55Sf5oiQ6Ieq5bex55qE6ZWc5YOPIFxuICAgICAqIOWFi+mahuWPiOS4pOenje+8jOS4gOenjeaYr+mVnOWDj++8jOWPpuWkluS4gOenjeaYr+e7neWvueaEj+S5ieS4iumdoueahOaWsOS4quS9k1xuICAgICAqIOm7mOiupOS4uue7neWvueaEj+S5ieS4iumdoueahOaWsOS4quS9k++8jOaWsOWvueixoWlk5LiN6IO955u45ZCMXG4gICAgICog6ZWc5YOP5Z+65pys5LiK5piv5qGG5p625YaF6YOo5Zyo5a6e546wICDplZzlg4/nmoRpZOebuOWQjCDkuLvopoHnlKjmnaXmioroh6rlt7HnlLvliLDlj6blpJbnmoRzdGFnZemHjOmdou+8jOavlOWmglxuICAgICAqIG1vdXNlb3ZlcuWSjG1vdXNlb3V055qE5pe25YCZ6LCD55SoKi9cbiAgICBjbG9uZSA6IGZ1bmN0aW9uKCBteXNlbGYgKXtcbiAgICAgICAgdmFyIGNvbmYgICA9IHtcbiAgICAgICAgICAgIGlkICAgICAgOiB0aGlzLmlkLFxuICAgICAgICAgICAgY29udGV4dCA6IF8uY2xvbmUodGhpcy5jb250ZXh0LiRtb2RlbClcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbmV3T2JqO1xuICAgICAgICBpZiggdGhpcy50eXBlID09ICd0ZXh0JyApe1xuICAgICAgICAgICAgbmV3T2JqID0gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMudGV4dCAsIGNvbmYgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld09iaiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCBjb25mICk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdPYmouaWQgPSBjb25mLmlkO1xuXG4gICAgICAgIGlmKCB0aGlzLmNoaWxkcmVuICl7XG4gICAgICAgICAgICBuZXdPYmouY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFteXNlbGYpe1xuICAgICAgICAgICAgbmV3T2JqLmlkID0gVXRpbHMuY3JlYXRlSWQobmV3T2JqLnR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sXG4gICAgaGVhcnRCZWF0IDogZnVuY3Rpb24ob3B0KXtcbiAgICAgICAgLy9zdGFnZeWtmOWcqO+8jOaJjeivtHNlbGbku6PooajnmoRkaXNwbGF55bey57uP6KKr5re75Yqg5Yiw5LqGZGlzcGxheUxpc3TkuK3vvIznu5jlm77lvJXmk47pnIDopoHnn6XpgZPlhbbmlLnlj5jlkI5cbiAgICAgICAgLy/nmoTlsZ7mgKfvvIzmiYDku6XvvIzpgJrnn6XliLBzdGFnZS5kaXNwbGF5QXR0ckhhc0NoYW5nZVxuICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGlmKCBzdGFnZSApe1xuICAgICAgICAgICAgdGhpcy5faGVhcnRCZWF0TnVtICsrO1xuICAgICAgICAgICAgc3RhZ2UuaGVhcnRCZWF0ICYmIHN0YWdlLmhlYXJ0QmVhdCggb3B0ICk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEN1cnJlbnRXaWR0aCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuY29udGV4dC53aWR0aCAqIHRoaXMuY29udGV4dC5zY2FsZVgpO1xuICAgIH0sXG4gICAgZ2V0Q3VycmVudEhlaWdodCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuY29udGV4dC5oZWlnaHQgKiB0aGlzLmNvbnRleHQuc2NhbGVZKTtcbiAgICB9LFxuICAgIGdldFN0YWdlIDogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHRoaXMuc3RhZ2UgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFnZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICBpZiAocC50eXBlICE9IFwic3RhZ2VcIil7XG4gICAgICAgICAgd2hpbGUocC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT0gXCJzdGFnZVwiKXtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocC50eXBlICE9PSBcInN0YWdlXCIpIHtcbiAgICAgICAgICAgIC8v5aaC5p6c5b6X5Yiw55qE6aG254K5ZGlzcGxheSDnmoR0eXBl5LiN5pivU3RhZ2Us5Lmf5bCx5piv6K+05LiN5pivc3RhZ2XlhYPntKBcbiAgICAgICAgICAgIC8v6YKj5LmI5Y+q6IO96K+05piO6L+Z5LiqcOaJgOS7o+ihqOeahOmhtuerr2Rpc3BsYXkg6L+Y5rKh5pyJ5re75Yqg5YiwZGlzcGxheUxpc3TkuK3vvIzkuZ/lsLHmmK/msqHmnInmsqHmt7vliqDliLBcbiAgICAgICAgICAgIC8vc3RhZ2XoiJ7lj7DnmoRjaGlsZGVu6Zif5YiX5Lit77yM5LiN5Zyo5byV5pOO5riy5p+T6IyD5Zu05YaFXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICAvL+S4gOebtOWbnua6r+WIsOmhtuWxgm9iamVjdO+8jCDljbPmmK9zdGFnZe+8jCBzdGFnZeeahHBhcmVudOS4um51bGxcbiAgICAgICAgdGhpcy5zdGFnZSA9IHA7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgbG9jYWxUb0dsb2JhbCA6IGZ1bmN0aW9uKCBwb2ludCAsIGNvbnRhaW5lciApe1xuICAgICAgICAhcG9pbnQgJiYgKCBwb2ludCA9IG5ldyBQb2ludCggMCAsIDAgKSApO1xuICAgICAgICB2YXIgY20gPSB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCggY29udGFpbmVyICk7XG5cbiAgICAgICAgaWYgKGNtID09IG51bGwpIHJldHVybiBQb2ludCggMCAsIDAgKTtcbiAgICAgICAgdmFyIG0gPSBuZXcgTWF0cml4KDEsIDAsIDAsIDEsIHBvaW50LnggLCBwb2ludC55KTtcbiAgICAgICAgbS5jb25jYXQoY20pO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCBtLnR4ICwgbS50eSApOyAvL3t4Om0udHgsIHk6bS50eX07XG4gICAgfSxcbiAgICBnbG9iYWxUb0xvY2FsIDogZnVuY3Rpb24oIHBvaW50ICwgY29udGFpbmVyKSB7XG4gICAgICAgICFwb2ludCAmJiAoIHBvaW50ID0gbmV3IFBvaW50KCAwICwgMCApICk7XG5cbiAgICAgICAgaWYoIHRoaXMudHlwZSA9PSBcInN0YWdlXCIgKXtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY20gPSB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCggY29udGFpbmVyICk7XG5cbiAgICAgICAgaWYgKGNtID09IG51bGwpIHJldHVybiBuZXcgUG9pbnQoIDAgLCAwICk7IC8ve3g6MCwgeTowfTtcbiAgICAgICAgY20uaW52ZXJ0KCk7XG4gICAgICAgIHZhciBtID0gbmV3IE1hdHJpeCgxLCAwLCAwLCAxLCBwb2ludC54ICwgcG9pbnQueSk7XG4gICAgICAgIG0uY29uY2F0KGNtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCggbS50eCAsIG0udHkgKTsgLy97eDptLnR4LCB5Om0udHl9O1xuICAgIH0sXG4gICAgbG9jYWxUb1RhcmdldCA6IGZ1bmN0aW9uKCBwb2ludCAsIHRhcmdldCl7XG4gICAgICAgIHZhciBwID0gbG9jYWxUb0dsb2JhbCggcG9pbnQgKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5nbG9iYWxUb0xvY2FsKCBwICk7XG4gICAgfSxcbiAgICBnZXRDb25jYXRlbmF0ZWRNYXRyaXggOiBmdW5jdGlvbiggY29udGFpbmVyICl7XG4gICAgICAgIHZhciBjbSA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgZm9yICh2YXIgbyA9IHRoaXM7IG8gIT0gbnVsbDsgbyA9IG8ucGFyZW50KSB7XG4gICAgICAgICAgICBjbS5jb25jYXQoIG8uX3RyYW5zZm9ybSApO1xuICAgICAgICAgICAgaWYoICFvLnBhcmVudCB8fCAoIGNvbnRhaW5lciAmJiBvLnBhcmVudCAmJiBvLnBhcmVudCA9PSBjb250YWluZXIgKSB8fCAoIG8ucGFyZW50ICYmIG8ucGFyZW50LnR5cGU9PVwic3RhZ2VcIiApICkge1xuICAgICAgICAgICAgLy9pZiggby50eXBlID09IFwic3RhZ2VcIiB8fCAoby5wYXJlbnQgJiYgY29udGFpbmVyICYmIG8ucGFyZW50LnR5cGUgPT0gY29udGFpbmVyLnR5cGUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY207Ly9icmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY207XG4gICAgfSxcbiAgICAvKlxuICAgICAq6K6+572u5YWD57Sg55qE5piv5ZCm5ZON5bqU5LqL5Lu25qOA5rWLXG4gICAgICpAYm9vbCAgQm9vbGVhbiDnsbvlnotcbiAgICAgKi9cbiAgICBzZXRFdmVudEVuYWJsZSA6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICAgIGlmKF8uaXNCb29sZWFuKGJvb2wpKXtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50RW5hYmxlZCA9IGJvb2xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKlxuICAgICAq5p+l6K+i6Ieq5bex5ZyocGFyZW5055qE6Zif5YiX5Lit55qE5L2N572uXG4gICAgICovXG4gICAgZ2V0SW5kZXggICA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZih0aGlzLnBhcmVudC5jaGlsZHJlbiAsIHRoaXMpXG4gICAgfSxcbiAgICAvKlxuICAgICAq5YWD57Sg5Zyoeui9tOaWueWQkeWQkeS4i+enu+WKqFxuICAgICAqQG51bSDnp7vliqjnmoTlsYLnuqdcbiAgICAgKi9cbiAgICB0b0JhY2sgOiBmdW5jdGlvbiggbnVtICl7XG4gICAgICAgIGlmKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbUluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICB2YXIgdG9JbmRleCA9IDA7XG4gICAgICAgIFxuICAgICAgICBpZihfLmlzTnVtYmVyKCBudW0gKSl7XG4gICAgICAgICAgaWYoIG51bSA9PSAwICl7XG4gICAgICAgICAgICAgLy/ljp/lnLDkuI3liqhcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0b0luZGV4ID0gZnJvbUluZGV4IC0gbnVtO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSggZnJvbUluZGV4ICwgMSApWzBdO1xuICAgICAgICBpZiggdG9JbmRleCA8IDAgKXtcbiAgICAgICAgICAgIHRvSW5kZXggPSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhcmVudC5hZGRDaGlsZEF0KCBtZSAsIHRvSW5kZXggKTtcbiAgICB9LFxuICAgIC8qXG4gICAgICrlhYPntKDlnKh66L205pa55ZCR5ZCR5LiK56e75YqoXG4gICAgICpAbnVtIOenu+WKqOeahOWxguaVsOmHjyDpu5jorqTliLDpobbnq69cbiAgICAgKi9cbiAgICB0b0Zyb250IDogZnVuY3Rpb24oIG51bSApe1xuICAgICAgICBpZighdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcbiAgICAgICAgdmFyIHBjbCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIHRvSW5kZXggPSBwY2w7XG4gICAgICAgIFxuICAgICAgICBpZihfLmlzTnVtYmVyKCBudW0gKSl7XG4gICAgICAgICAgaWYoIG51bSA9PSAwICl7XG4gICAgICAgICAgICAgLy/ljp/lnLDkuI3liqhcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvSW5kZXggPSBmcm9tSW5kZXggKyBudW0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSggZnJvbUluZGV4ICwgMSApWzBdO1xuICAgICAgICBpZih0b0luZGV4ID4gcGNsKXtcbiAgICAgICAgICAgIHRvSW5kZXggPSBwY2w7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQuYWRkQ2hpbGRBdCggbWUgLCB0b0luZGV4LTEgKTtcbiAgICB9LFxuICAgIF91cGRhdGVUcmFuc2Zvcm0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF90cmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIF90cmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIC8v5piv5ZCm6ZyA6KaBVHJhbnNmb3JtXG4gICAgICAgIGlmKGNvbnRleHQuc2NhbGVYICE9PSAxIHx8IGNvbnRleHQuc2NhbGVZICE9PTEgKXtcbiAgICAgICAgICAgIC8v5aaC5p6c5pyJ57yp5pS+XG4gICAgICAgICAgICAvL+e8qeaUvueahOWOn+eCueWdkOagh1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG5ldyBQb2ludChjb250ZXh0LnNjYWxlT3JpZ2luKTtcbiAgICAgICAgICAgIGlmKCBvcmlnaW4ueCB8fCBvcmlnaW4ueSApe1xuICAgICAgICAgICAgICAgIF90cmFuc2Zvcm0udHJhbnNsYXRlKCAtb3JpZ2luLnggLCAtb3JpZ2luLnkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90cmFuc2Zvcm0uc2NhbGUoIGNvbnRleHQuc2NhbGVYICwgY29udGV4dC5zY2FsZVkgKTtcbiAgICAgICAgICAgIGlmKCBvcmlnaW4ueCB8fCBvcmlnaW4ueSApe1xuICAgICAgICAgICAgICAgIF90cmFuc2Zvcm0udHJhbnNsYXRlKCBvcmlnaW4ueCAsIG9yaWdpbi55ICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByb3RhdGlvbiA9IGNvbnRleHQucm90YXRpb247XG4gICAgICAgIGlmKCByb3RhdGlvbiApe1xuICAgICAgICAgICAgLy/lpoLmnpzmnInml4vovaxcbiAgICAgICAgICAgIC8v5peL6L2s55qE5Y6f54K55Z2Q5qCHXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gbmV3IFBvaW50KGNvbnRleHQucm90YXRlT3JpZ2luKTtcbiAgICAgICAgICAgIGlmKCBvcmlnaW4ueCB8fCBvcmlnaW4ueSApe1xuICAgICAgICAgICAgICAgIF90cmFuc2Zvcm0udHJhbnNsYXRlKCAtb3JpZ2luLnggLCAtb3JpZ2luLnkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90cmFuc2Zvcm0ucm90YXRlKCByb3RhdGlvbiAlIDM2MCAqIE1hdGguUEkvMTgwICk7XG4gICAgICAgICAgICBpZiggb3JpZ2luLnggfHwgb3JpZ2luLnkgKXtcbiAgICAgICAgICAgICAgICBfdHJhbnNmb3JtLnRyYW5zbGF0ZSggb3JpZ2luLnggLCBvcmlnaW4ueSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8v5aaC5p6c5pyJ5L2N56e7XG4gICAgICAgIHZhciB4LHk7XG4gICAgICAgIGlmKCB0aGlzLnh5VG9JbnQgJiYgIXRoaXMubW92ZWluZyApe1xuICAgICAgICAgICAgLy/lvZPov5nkuKrlhYPntKDlnKjlgZrovajov7nov5DliqjnmoTml7blgJnvvIzmr5TlpoJkcmFn77yMYW5pbWF0aW9u5aaC5p6c5a6e5pe255qE6LCD5pW06L+Z5LiqeCDvvIwgeVxuICAgICAgICAgICAgLy/pgqPkuYjor6XlhYPntKDnmoTovajov7nkvJrmnInot7Pot4PnmoTmg4XlhrXlj5HnlJ/jgILmiYDku6XliqDkuKrmnaHku7bov4fmu6TvvIxcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQoIGNvbnRleHQueCApO1xuICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludCggY29udGV4dC55ICk7XG5cbiAgICAgICAgICAgIGlmKCBwYXJzZUludChjb250ZXh0LmxpbmVXaWR0aCAsIDEwKSAlIDIgPT0gMSAmJiBjb250ZXh0LnN0cm9rZVN0eWxlICl7XG4gICAgICAgICAgICAgICAgeCArPSAwLjU7XG4gICAgICAgICAgICAgICAgeSArPSAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gY29udGV4dC54O1xuICAgICAgICAgICAgeSA9IGNvbnRleHQueTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggeCAhPSAwIHx8IHkgIT0gMCApe1xuICAgICAgICAgICAgX3RyYW5zZm9ybS50cmFuc2xhdGUoIHggLCB5ICk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IF90cmFuc2Zvcm07XG4gICAgICAgIHJldHVybiBfdHJhbnNmb3JtO1xuICAgIH0sXG4gICAgLy/ojrflj5blhajlsYDnmoTkuJbnlYzlnZDmoIfns7vlhoXnmoTnn6npmLVcbiAgICAvL+S4lueVjOWdkOagh+aYr+S7juS4iuiAjOS4i+eahO+8jOaJgOS7peWPquimgeWSjHBhcmVudOeahOebtOaOpeWdkOagh+ebuOS5mOWwseWlveS6hlxuICAgIGdldFdvcmxkVHJhbnNmb3JtOiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgY207XG4gICAgICAgIGlmKCAhdGhpcy53b3JsZFRyYW5zZm9ybSApe1xuICAgICAgICAgICAgY20gPSBuZXcgTWF0cml4KCk7XG4gICAgICAgICAgICBjbS5jb25jYXQoIHRoaXMuX3RyYW5zZm9ybSApO1xuICAgICAgICAgICAgY20uY29uY2F0KCB0aGlzLnBhcmVudC53b3JsZFRyYW5zZm9ybSApO1xuICAgICAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IGNtO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB9LFxuICAgIC8v5pi+56S65a+56LGh55qE6YCJ5Y+W5qOA5rWL5aSE55CG5Ye95pWwXG4gICAgZ2V0Q2hpbGRJblBvaW50IDogZnVuY3Rpb24oIHBvaW50ICl7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlOyAvL+ajgOa1i+eahOe7k+aenFxuXG4gICAgICAgIC8v56ys5LiA5q2l77yM5ZCnZ2xvYueahHBvaW506L2s5o2i5Yiw5a+55bqU55qEb2Jq55qE5bGC57qn5YaF55qE5Z2Q5qCH57O757ufXG4gICAgICAgIGlmKCB0aGlzLnR5cGUgIT0gXCJzdGFnZVwiICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnR5cGUgIT0gXCJzdGFnZVwiICkge1xuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLnBhcmVudC5nbG9iYWxUb0xvY2FsKCBwb2ludCApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB4ID0gcG9pbnQueDtcbiAgICAgICAgdmFyIHkgPSBwb2ludC55O1xuICAgIFxuICAgICAgICAvL+Wvuem8oOagh+eahOWdkOagh+S5n+WBmuebuOWQjOeahOWPmOaNolxuICAgICAgICBpZiggdGhpcy5fdHJhbnNmb3JtICl7XG4gICAgICAgICAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybS5jbG9uZSgpLmludmVydCgpO1xuICAgICAgICAgICAgdmFyIG9yaWdpblBvcyA9IFt4LCB5XTtcbiAgICAgICAgICAgIG9yaWdpblBvcyA9IGludmVyc2VNYXRyaXgubXVsVmVjdG9yKCBvcmlnaW5Qb3MgKTtcblxuICAgICAgICAgICAgeCA9IG9yaWdpblBvc1swXTtcbiAgICAgICAgICAgIHkgPSBvcmlnaW5Qb3NbMV07XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHRoaXMuZ3JhcGhpY3NEYXRhICl7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnRhaW5zUG9pbnQoIHt4OiB4ICwgeTogeX0gLCB0aGlzLmdyYXBoaWNzRGF0YSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50ICwgX2dyYXBoaWNzRGF0YSl7XG4gICAgICAgIGNvbnN0IGdyYXBoaWNzRGF0YSA9IF9ncmFwaGljc0RhdGEgfHwgdGhpcy5ncmFwaGljc0RhdGE7XG4gICAgICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICBpZiAoZGF0YS5zaGFwZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvL+WFiOajgOa1i2ZpbGzvvIwgZmlsbOeahOajgOa1i+amgueOh+Wkp+S6m+OAglxuICAgICAgICAgICAgICAgIC8v5YOPY2lyY2xlLGVsbGlwc2Xov5nmoLfnmoRzaGFwZSDlsLHnm7TmjqXmiopsaW5lV2lkdGjnrpflnKhmaWxs6YeM6Z2i6K6h566X5bCx5aW95LqG77yM5omA5Lul5LuW5Lus5piv5rKh5pyJaW5zaWRlTGluZeeahFxuICAgICAgICAgICAgICAgIGlmICggZGF0YS5oYXNGaWxsKCkgJiYgZGF0YS5zaGFwZS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiggaW5zaWRlICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vY2lyY2xlLGVsbGlwc2XnrYnlsLHmsqHmnIlwb2ludHNcbiAgICAgICAgICAgICAgICBpZiggZGF0YS5oYXNMaW5lKCkgJiYgZGF0YS5zaGFwZS5wb2ludHMgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy/nhLblkI7mo4DmtYvmmK/lkKblkozmj4/ovrnnorDmkp5cbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gSW5zaWRlTGluZSggZGF0YSAsIHBvaW50LnggLCBwb2ludC55ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBpbnNpZGUgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgIFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICAvKlxuICAgICogYW5pbWF0ZVxuICAgICogQHBhcmFtIHRvQ29udGVudCDopoHliqjnlLvlj5jlvaLliLDnmoTlsZ7mgKfpm4blkIhcbiAgICAqIEBwYXJhbSBvcHRpb25zIHR3ZWVuIOWKqOeUu+WPguaVsFxuICAgICovXG4gICAgYW5pbWF0ZSA6IGZ1bmN0aW9uKCB0b0NvbnRlbnQgLCBvcHRpb25zICl7XG4gICAgICAgIHZhciB0byA9IHRvQ29udGVudDtcbiAgICAgICAgdmFyIGZyb20gPSB7fTtcbiAgICAgICAgZm9yKCB2YXIgcCBpbiB0byApe1xuICAgICAgICAgICAgZnJvbVsgcCBdID0gdGhpcy5jb250ZXh0W3BdO1xuICAgICAgICB9O1xuICAgICAgICAhb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICAgICAgb3B0aW9ucy50byA9IHRvO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHVwRnVuID0gZnVuY3Rpb24oKXt9O1xuICAgICAgICBpZiggb3B0aW9ucy5vblVwZGF0ZSApe1xuICAgICAgICAgICAgdXBGdW4gPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdHdlZW47XG4gICAgICAgIG9wdGlvbnMub25VcGRhdGUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy/lpoLmnpxjb250ZXh05LiN5a2Y5Zyo6K+05piO6K+lb2Jq5bey57uP6KKrZGVzdHJveeS6hu+8jOmCo+S5iOimgeaKiuS7lueahHR3ZWVu57uZZGVzdHJveVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbnRleHQgJiYgdHdlZW4pIHtcbiAgICAgICAgICAgICAgICBBbmltYXRpb25GcmFtZS5kZXN0cm95VHdlZW4odHdlZW4pO1xuICAgICAgICAgICAgICAgIHR3ZWVuID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yKCB2YXIgcCBpbiB0aGlzICl7XG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0W3BdID0gdGhpc1twXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1cEZ1bi5hcHBseShzZWxmICwgW3RoaXNdKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbXBGdW4gPSBmdW5jdGlvbigpe307XG4gICAgICAgIGlmKCBvcHRpb25zLm9uQ29tcGxldGUgKXtcbiAgICAgICAgICAgIGNvbXBGdW4gPSBvcHRpb25zLm9uQ29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSA9IGZ1bmN0aW9uKCBvcHQgKXtcbiAgICAgICAgICAgIGNvbXBGdW4uYXBwbHkoc2VsZiAsIGFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgICAgdHdlZW4gPSBBbmltYXRpb25GcmFtZS5yZWdpc3RUd2Vlbiggb3B0aW9ucyApO1xuICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgfSxcbiAgICAvL+S7juagkeS4reWIoOmZpFxuICAgIHJlbW92ZSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCB0aGlzLnBhcmVudCApe1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8v5YWD57Sg55qE6Ieq5oiR6ZSA5q+BXG4gICAgZGVzdHJveSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZmlyZShcImRlc3Ryb3lcIik7XG4gICAgICAgIC8v5oqK6Ieq5bex5LuO54i26IqC54K55Lit5Yig6Zmk5LqG5ZCO5YGa6Ieq5oiR5riF6Zmk77yM6YeK5pS+5YaF5a2YXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHQ7XG4gICAgfVxufSApO1xuXG5leHBvcnQgZGVmYXVsdCBEaXNwbGF5T2JqZWN0O1xuXG4iLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiDmqKHmi59hczPnmoREaXNwbGF5TGlzdCDkuK3nmoTlrrnlmajnsbtcbiAqL1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gXCIuL0Rpc3BsYXlPYmplY3RcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi9Qb2ludFwiO1xuXG52YXIgRGlzcGxheU9iamVjdENvbnRhaW5lciA9IGZ1bmN0aW9uKG9wdCl7XG4gICB2YXIgc2VsZiA9IHRoaXM7XG4gICBzZWxmLmNoaWxkcmVuID0gW107XG4gICBzZWxmLm1vdXNlQ2hpbGRyZW4gPSBbXTtcbiAgIERpc3BsYXlPYmplY3RDb250YWluZXIuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAvL+aJgOacieeahOWuueWZqOm7mOiupOaUr+aMgWV2ZW50IOajgOa1i++8jOWboOS4uiDlj6/og73mnInph4zpnaLnmoRzaGFwZeaYr2V2ZW50RW5hYmxl5pivdHJ1ZeeahFxuICAgLy/lpoLmnpznlKjmiLfmnInlvLrliLbnmoTpnIDmsYLorqnlrrnlmajkuIvnmoTmiYDmnInlhYPntKDpg70g5LiN5Y+v5qOA5rWL77yM5Y+v5Lul6LCD55SoXG4gICAvL0Rpc3BsYXlPYmplY3RDb250YWluZXLnmoQgc2V0RXZlbnRFbmFibGUoKSDmlrnms5VcbiAgIHNlbGYuX2V2ZW50RW5hYmxlZCA9IHRydWU7XG59O1xuXG5VdGlscy5jcmVhdENsYXNzKCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyICwgRGlzcGxheU9iamVjdCAsIHtcbiAgICBhZGRDaGlsZCA6IGZ1bmN0aW9uKGNoaWxkICwgaW5kZXgpe1xuICAgICAgICBpZiggIWNoaWxkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBpZih0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpICE9IC0xKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9O1xuICAgICAgICAvL+WmguaenOS7luWcqOWIq+eahOWtkOWFg+e0oOS4re+8jOmCo+S5iOWwseS7juWIq+S6uumCo+mHjOWIoOmZpOS6hlxuICAgICAgICBpZihjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiggaW5kZXggPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICBpZih0aGlzLmhlYXJ0QmVhdCl7XG4gICAgICAgICAgIHRoaXMuaGVhcnRCZWF0KHtcbiAgICAgICAgICAgICBjb252ZXJ0VHlwZSA6IFwiY2hpbGRyZW5cIixcbiAgICAgICAgICAgICB0YXJnZXQgICAgICA6IGNoaWxkLFxuICAgICAgICAgICAgIHNyYyAgICAgICAgIDogdGhpc1xuICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZih0aGlzLl9hZnRlckFkZENoaWxkKXtcbiAgICAgICAgICAgdGhpcy5fYWZ0ZXJBZGRDaGlsZChjaGlsZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHRoaXMud29ybGRUcmFuc2Zvcm0gKXtcbiAgICAgICAgICAgIC8v5aaC5p6c6L+H6Ieq5bex5bey57uP5pyJ5LqG5LiW55WM5Z2Q5qCH5LqG77yM6YKj5LmI6KaB5oqK5paw5re75Yqg6L+b5p2l55qE5omA5pyJ6IqC54K55YyF5ous5YW25a2Q6IqC54K56YO96K6+572u5aW95LiW55WM5Z2Q5qCHXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkV29ybGRUcmFuc2Zvcm0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcbiAgICBhZGRDaGlsZEF0IDogZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENoaWxkKCBjaGlsZCAsIGluZGV4ICk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZCA6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNoaWxkQXQoXy5pbmRleE9mKCB0aGlzLmNoaWxkcmVuICwgY2hpbGQgKSk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEF0IDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuaGVhcnRCZWF0KXtcbiAgICAgICAgICAgdGhpcy5oZWFydEJlYXQoe1xuICAgICAgICAgICAgIGNvbnZlcnRUeXBlIDogXCJjaGlsZHJlblwiLFxuICAgICAgICAgICAgIHRhcmdldCAgICAgICA6IGNoaWxkLFxuICAgICAgICAgICAgIHNyYyAgICAgIDogdGhpc1xuICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuX2FmdGVyRGVsQ2hpbGQpe1xuICAgICAgICAgICB0aGlzLl9hZnRlckRlbENoaWxkKGNoaWxkICwgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRCeUlkIDogZnVuY3Rpb24oIGlkICkge1x0XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY2hpbGRyZW5baV0uaWQgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZEF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHJlbW92ZUFsbENoaWxkcmVuIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZEF0KDApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvL+mbhuWQiOexu+eahOiHquaIkemUgOavgVxuICAgIGRlc3Ryb3kgOiBmdW5jdGlvbigpe1xuICAgICAgICBpZiggdGhpcy5wYXJlbnQgKXtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZpcmUoXCJkZXN0cm95XCIpO1xuICAgICAgICAvL+S+neasoemUgOavgeaJgOacieWtkOWFg+e0oFxuICAgICAgICBmb3IgKHZhciBpPTAsbD10aGlzLmNoaWxkcmVuLmxlbmd0aCA7IGk8bCA7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmdldENoaWxkQXQoaSkuZGVzdHJveSgpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgbC0tO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgLypcbiAgICAgKkBpZCDlhYPntKDnmoRpZFxuICAgICAqQGJvb2xlbiDmmK/lkKbmt7Hluqbmn6Xor6LvvIzpu5jorqTlsLHlnKjnrKzkuIDlsYLlrZDlhYPntKDkuK3mn6Xor6JcbiAgICAgKiovXG4gICAgZ2V0Q2hpbGRCeUlkIDogZnVuY3Rpb24oaWQgLCBib29sZW4pe1xuICAgICAgICBpZighYm9vbGVuKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNoaWxkcmVuW2ldLmlkID09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8v5rex5bqm5p+l6K+iXG4gICAgICAgICAgICAvL1RPRE865pqC5pe25pyq5a6e546wXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0Q2hpbGRBdCA6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgfSxcbiAgICBnZXRDaGlsZEluZGV4IDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZiggdGhpcy5jaGlsZHJlbiAsIGNoaWxkICk7XG4gICAgfSxcbiAgICBzZXRDaGlsZEluZGV4IDogZnVuY3Rpb24oY2hpbGQsIGluZGV4KXtcbiAgICAgICAgaWYoY2hpbGQucGFyZW50ICE9IHRoaXMpIHJldHVybjtcbiAgICAgICAgdmFyIG9sZEluZGV4ID0gXy5pbmRleE9mKCB0aGlzLmNoaWxkcmVuICwgY2hpbGQgKTtcbiAgICAgICAgaWYoaW5kZXggPT0gb2xkSW5kZXgpIHJldHVybjtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2Uob2xkSW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgIH0sXG4gICAgZ2V0TnVtQ2hpbGRyZW4gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH0sXG4gICAgLy/ojrflj5Z4LHnngrnkuIrnmoTmiYDmnIlvYmplY3QgIG51bSDpnIDopoHov5Tlm57nmoRvYmrmlbDph49cbiAgICBnZXRPYmplY3RzVW5kZXJQb2ludCA6IGZ1bmN0aW9uKCBwb2ludCAsIG51bSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIFxuICAgICAgICBmb3IodmFyIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiggY2hpbGQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICghY2hpbGQuX2V2ZW50RW5hYmxlZCAmJiAhY2hpbGQuZHJhZ0VuYWJsZWQpIHx8IFxuICAgICAgICAgICAgICAgICFjaGlsZC5jb250ZXh0LnZpc2libGUgXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCBjaGlsZCBpbnN0YW5jZW9mIERpc3BsYXlPYmplY3RDb250YWluZXIgKSB7XG4gICAgICAgICAgICAgICAgLy/mmK/pm4blkIhcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubW91c2VDaGlsZHJlbiAmJiBjaGlsZC5nZXROdW1DaGlsZHJlbigpID4gMCl7XG4gICAgICAgICAgICAgICAgICAgdmFyIG9ianMgPSBjaGlsZC5nZXRPYmplY3RzVW5kZXJQb2ludCggcG9pbnQgKTtcbiAgICAgICAgICAgICAgICAgICBpZiAob2Jqcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KCBvYmpzICk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cdFx0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8v6Z2e6ZuG5ZCI77yM5Y+v5Lul5byA5aeL5YGaZ2V0Q2hpbGRJblBvaW505LqGXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmdldENoaWxkSW5Qb2ludCggcG9pbnQgKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW0gIT0gdW5kZWZpbmVkICYmICFpc05hTihudW0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PSBudW0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8v5pu05paw5omA5pyJ5a2Q6IqC54K555qE5LiW55WM5Z2Q5qCHXG4gICAgdXBkYXRlQ2hpbGRXb3JsZFRyYW5zZm9ybTogZnVuY3Rpb24oKXtcbiAgICAgICAgXy5lYWNoKCB0aGlzLmNoaWxkcmVuICwgZnVuY3Rpb24oIG9iaiApe1xuICAgICAgICAgICAgb2JqLmdldFdvcmxkVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBpZiggb2JqLmNoaWxkcmVuICl7XG4gICAgICAgICAgICAgICAgb2JqLnVwZGF0ZUNoaWxkV29ybGRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gKTtcbiAgICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IERpc3BsYXlPYmplY3RDb250YWluZXI7XG4iLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiBzdGFnZSDnsbvvvIwg5YaNYXMz5Lit77yMc3RhZ2XliJnku6PooajmlbTkuKroiJ7lj7DjgILmmK/llK/kuIDnmoTmoLnoioLngrlcbiAqIOS9huaYr+WGjWNhbnZheOS4re+8jOWboOS4uuWIhuWxguiuvuiuoeeahOmcgOimgeOAgnN0YWdlIOiInuWPsCDlkIzmoLfku6PooajkuIDkuKpjYW52YXPlhYPntKDvvIzkvYbmmK/kuI3mmK/lho3mlbTkuKrlvJXmk47orr7orqFcbiAqIOmHjOmdou+8jCDkuI3mmK/llK/kuIDnmoTmoLnoioLngrnjgILogIzmmK/kvJrkuqTnlLFjYW52YXjnsbvmnaXnu5/kuIDnrqHnkIblhbblsYLnuqdcbiAqL1xuaW1wb3J0IERpc3BsYXlPYmplY3RDb250YWluZXIgZnJvbSBcIi4vRGlzcGxheU9iamVjdENvbnRhaW5lclwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xuXG52YXIgU3RhZ2UgPSBmdW5jdGlvbiggb3B0ICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudHlwZSA9IFwic3RhZ2VcIjtcbiAgICBzZWxmLmNhbnZhcyA9IG51bGw7XG4gICAgc2VsZi5jdHggPSBudWxsOyAvL+a4suafk+eahOaXtuWAmeeUsXJlbmRlcmVy5Yaz5a6aLOi/memHjOS4jeWBmuWIneWni+WAvFxuICAgIC8vc3RhZ2XmraPlnKjmuLLmn5PkuK1cbiAgICBzZWxmLnN0YWdlUmVuZGluZyA9IGZhbHNlO1xuICAgIHNlbGYuX2lzUmVhZHkgPSBmYWxzZTtcbiAgICBcbiAgICBTdGFnZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbn07XG5VdGlscy5jcmVhdENsYXNzKCBTdGFnZSAsIERpc3BsYXlPYmplY3RDb250YWluZXIgLCB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uKCl7XG4gIFxuICAgIH0sXG4gICAgLy/nlLFjYW52YXjnmoRhZnRlckFkZENoaWxkIOWbnuiwg1xuICAgIGluaXRTdGFnZSA6IGZ1bmN0aW9uKCBjYW52YXMgLCB3aWR0aCAsIGhlaWdodCApe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuY2FudmFzID0gY2FudmFzO1xuICAgICAgICBzZWxmLmNvbnRleHQud2lkdGggID0gd2lkdGg7XG4gICAgICAgIHNlbGYuY29udGV4dC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHNlbGYuY29udGV4dC5zY2FsZVggPSBVdGlscy5fZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgc2VsZi5jb250ZXh0LnNjYWxlWSA9IFV0aWxzLl9kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBzZWxmLl9pc1JlYWR5ID0gdHJ1ZTtcbiAgICB9LFxuICAgIGhlYXJ0QmVhdCA6IGZ1bmN0aW9uKCBvcHQgKXtcbiAgICAgICAgLy9zaGFwZSAsIG5hbWUgLCB2YWx1ZSAsIHByZVZhbHVlIFxuICAgICAgICAvL2Rpc3BsYXlMaXN05Lit5p+Q5Liq5bGe5oCn5pS55Y+Y5LqGXG4gICAgICAgIGlmICghdGhpcy5faXNSZWFkeSkge1xuICAgICAgICAgICAvL+WcqHN0YWdl6L+Y5rKh5Yid5aeL5YyW5a6M5q+V55qE5oOF5Ya15LiL77yM5peg6ZyA5YGa5Lu75L2V5aSE55CGXG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgb3B0IHx8ICggb3B0ID0ge30gKTsgLy/lpoLmnpxvcHTkuLrnqbrvvIzor7TmmI7lsLHmmK/ml6DmnaHku7bliLfmlrBcbiAgICAgICAgb3B0LnN0YWdlICAgPSB0aGlzO1xuXG4gICAgICAgIC8vVE9ET+S4tOaXtuWFiOi/meS5iOWkhOeQhlxuICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oZWFydEJlYXQob3B0KTtcbiAgICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IFN0YWdlOyIsImltcG9ydCB7IFJFTkRFUkVSX1RZUEUgfSBmcm9tICcuLi9jb25zdCc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuaW1wb3J0IEFuaW1hdGlvbkZyYW1lIGZyb20gXCIuLi9hbmltYXRpb24vQW5pbWF0aW9uRnJhbWVcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbVJlbmRlcmVyXG57XG4gICAgY29uc3RydWN0b3IoIHR5cGU9UkVOREVSRVJfVFlQRS5VTktOT1dOICwgYXBwICwgb3B0aW9ucyApXG4gICAge1xuICAgIFx0dGhpcy50eXBlID0gdHlwZTsgLy8yY2FudmFzLDF3ZWJnbFxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcblxuICAgICAgICAvL3ByZXBhcmUgb3B0aW9uc1xuICAgICAgICBpZiAob3B0aW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIHNldHRpbmdzLlJFTkRFUl9PUFRJT05TKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1tpXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2ldID0gc2V0dGluZ3MuUkVOREVSX09QVElPTlNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHNldHRpbmdzLlJFTkRFUl9PUFRJT05TO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuXG4gICAgICAgIHRoaXMucmVxdWVzdEFpZCA9IG51bGw7XG5cblx0XHR0aGlzLl9oZWFydEJlYXQgPSBmYWxzZTsvL+W/g+i3s++8jOm7mOiupOS4umZhbHNl77yM5Y2zZmFsc2XnmoTml7blgJnlvJXmk47lpITkuo7pnZnpu5jnirbmgIEgdHJ1ZeWImeWQr+WKqOa4suafk1xuXG5cdFx0dGhpcy5fcHJlUmVuZGVyVGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy/lpoLmnpzlvJXmk47lpITkuo7pnZnpu5jnirbmgIHnmoTor53vvIzlsLHkvJrlkK/liqhcbiAgICBzdGFydEVudGVyKClcbiAgICB7XG4gICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgIGlmKCAhc2VsZi5yZXF1ZXN0QWlkICl7XG4gICAgICAgICAgIHNlbGYucmVxdWVzdEFpZCA9IEFuaW1hdGlvbkZyYW1lLnJlZ2lzdEZyYW1lKCB7XG4gICAgICAgICAgICAgICBpZCA6IFwiZW50ZXJGcmFtZVwiLCAvL+WQjOaXtuiCr+WumuWPquacieS4gOS4qmVudGVyRnJhbWXnmoR0YXNrXG4gICAgICAgICAgICAgICB0YXNrIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbnRlckZyYW1lLmFwcGx5KHNlbGYpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9ICk7XG4gICAgICAgfVxuICAgIH1cblxuICAgIGVudGVyRnJhbWUoKVxuICAgIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvL+S4jeeuoeaAjuS5iOagt++8jGVudGVyRnJhbWXmiafooYzkuoblsLHopoHmiopcbiAgICAgICAgLy9yZXF1ZXN0QWlkIG51bGwg5o6JXG4gICAgICAgIHNlbGYucmVxdWVzdEFpZCA9IG51bGw7XG4gICAgICAgIFV0aWxzLm5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBpZiggc2VsZi5faGVhcnRCZWF0ICl7XG5cbiAgICAgICAgICAgIHZhciBfYmVnaW4gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHNlbGYucmVuZGVyKCB0aGlzLmFwcCApO1xuICAgICAgICAgICAgdmFyIF9lbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBfZW5kIC0gX2JlZ2luIClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2VsZi5faGVhcnRCZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICAvL+a4suafk+WujOS6hu+8jOaJk+S4iuacgOaWsOaXtumXtOaMq1xuICAgICAgICAgICAgc2VsZi5fcHJlUmVuZGVyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jb252ZXJ0Q2FudmF4KG9wdClcbiAgICB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIF8uZWFjaCggbWUuYXBwLmNoaWxkcmVuICwgZnVuY3Rpb24oc3RhZ2Upe1xuICAgICAgICAgICAgc3RhZ2UuY29udGV4dFtvcHQubmFtZV0gPSBvcHQudmFsdWU7IFxuICAgICAgICB9ICk7ICBcbiAgICB9XG5cbiAgICBoZWFydEJlYXQoIG9wdCApXG4gICAge1xuICAgICAgICAvL2Rpc3BsYXlMaXN05Lit5p+Q5Liq5bGe5oCn5pS55Y+Y5LqGXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYoIG9wdCApe1xuICAgICAgICAgICAgLy/lv4Pot7PljIXmnInkuKTnp43vvIzkuIDnp43mmK/mn5DlhYPntKDnmoTlj6/op4blsZ7mgKfmlLnlj5jkuobjgILkuIDnp43mmK9jaGlsZHJlbuacieWPmOWKqFxuICAgICAgICAgICAgLy/liIbliKvlr7nlupRjb252ZXJ0VHlwZSAg5Li6IGNvbnRleHQgIGFuZCBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKG9wdC5jb252ZXJ0VHlwZSA9PSBcImNvbnRleHRcIil7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWdlICAgPSBvcHQuc3RhZ2U7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlICAgPSBvcHQuc2hhcGU7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgICAgPSBvcHQubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgICA9IG9wdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJlVmFsdWU9IG9wdC5wcmVWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmKCBzaGFwZS50eXBlID09IFwiY2FudmF4XCIgKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY29udmVydENhbnZheChvcHQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIXNlbGYuYXBwLmNvbnZlcnRTdGFnZXNbc3RhZ2UuaWRdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwLmNvbnZlcnRTdGFnZXNbc3RhZ2UuaWRdPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFnZSA6IHN0YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRTaGFwZXMgOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZihzaGFwZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuYXBwLmNvbnZlcnRTdGFnZXNbIHN0YWdlLmlkIF0uY29udmVydFNoYXBlc1sgc2hhcGUuaWQgXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHAuY29udmVydFN0YWdlc1sgc3RhZ2UuaWQgXS5jb252ZXJ0U2hhcGVzWyBzaGFwZS5pZCBdPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUgOiBzaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFR5cGUgOiBvcHQuY29udmVydFR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5bey57uP5LiK5oql5LqG6K+lIHNoYXBlIOeahOW/g+i3s+OAglxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAob3B0LmNvbnZlcnRUeXBlID09IFwiY2hpbGRyZW5cIil7XG4gICAgICAgICAgICAgICAgLy/lhYPntKDnu5PmnoTlj5jljJbvvIzmr5TlpoJhZGRjaGlsZCByZW1vdmVDaGlsZOetiVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBvcHQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBzdGFnZSA9IG9wdC5zcmMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgICAgICBpZiggc3RhZ2UgfHwgKHRhcmdldC50eXBlPT1cInN0YWdlXCIpICl7XG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5pON5L2c55qE55uu5qCH5YWD57Sg5pivU3RhZ2VcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UgPSBzdGFnZSB8fCB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFzZWxmLmFwcC5jb252ZXJ0U3RhZ2VzW3N0YWdlLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHAuY29udmVydFN0YWdlc1tzdGFnZS5pZF09e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdlIDogc3RhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFNoYXBlcyA6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFvcHQuY29udmVydFR5cGUpe1xuICAgICAgICAgICAgICAgIC8v5peg5p2h5Lu26KaB5rGC5Yi35pawXG4gICAgICAgICAgICAgICAgdmFyIHN0YWdlID0gb3B0LnN0YWdlO1xuICAgICAgICAgICAgICAgIGlmKCFzZWxmLmFwcC5jb252ZXJ0U3RhZ2VzW3N0YWdlLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcC5jb252ZXJ0U3RhZ2VzW3N0YWdlLmlkXT17XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFnZSA6IHN0YWdlICxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRTaGFwZXMgOiB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy/ml6DmnaHku7bopoHmsYLlhajpg6jliLfmlrDvvIzkuIDoiKznlKjlnKhyZXNpemXnrYnjgIJcbiAgICAgICAgICAgIF8uZWFjaCggc2VsZi5hcHAuY2hpbGRyZW4gLCBmdW5jdGlvbiggc3RhZ2UgLCBpICl7XG4gICAgICAgICAgICAgICAgc2VsZi5hcHAuY29udmVydFN0YWdlc1sgc3RhZ2UuaWQgXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UgOiBzdGFnZSxcbiAgICAgICAgICAgICAgICAgICAgY29udmVydFNoYXBlcyA6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXNlbGYuX2hlYXJ0QmVhdCl7XG4gICAgICAgICAgIC8v5aaC5p6c5Y+R546w5byV5pOO5Zyo6Z2Z6buY54q25oCB77yM6YKj5LmI5bCx5ZSk6YaS5byV5pOOXG4gICAgICAgICAgIHNlbGYuX2hlYXJ0QmVhdCA9IHRydWU7XG4gICAgICAgICAgIHNlbGYuc3RhcnRFbnRlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAvL+WQpuWImeaZuuaFp+e7p+e7reehruiupOW/g+i3s1xuICAgICAgICAgICBzZWxmLl9oZWFydEJlYXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnLi4vLi4vY29uc3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNHcmFwaGljc1JlbmRlcmVyXG57XG4gICBcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcilcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG4gICAgXG4gICAgIC8qKlxuICAgICAqIEBwYXJhbSBkaXNwbGF5T2JqZWN0XG4gICAgICogQHN0YWdlIOS5n+WPr+S7pWRpc3BsYXlPYmplY3QuZ2V0U3RhZ2UoKeiOt+WPluOAglxuICAgICAqL1xuICAgIHJlbmRlcihkaXNwbGF5T2JqZWN0ICwgc3RhZ2UpXG4gICAge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGNvbnN0IGdyYXBoaWNzRGF0YSA9IGRpc3BsYXlPYmplY3QuZ3JhcGhpY3NEYXRhO1xuICAgICAgICBjb25zdCBjdHggPSBzdGFnZS5jdHg7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBkaXNwbGF5T2JqZWN0LmNvbnRleHQ7XG5cbiAgICAgICAgaWYoIGRpc3BsYXlPYmplY3QucGFyZW50ICl7XG4gICAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhICo9IGRpc3BsYXlPYmplY3QucGFyZW50LmNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IGRhdGEuc2hhcGU7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGxTdHlsZSA9IGRhdGEuZmlsbFN0eWxlO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBkYXRhLnN0cm9rZVN0eWxlO1xuXG4gICAgICAgICAgICBjb25zdCBmaWxsID0gZGF0YS5oYXNGaWxsKCkgJiYgZGF0YS5maWxsQWxwaGE7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZGF0YS5oYXNMaW5lKCkgJiYgZGF0YS5saW5lQWxwaGE7XG5cbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcblxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLlBPTFkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQb2x5Z29uKHNoYXBlLnBvaW50cywgc2hhcGUuY2xvc2VkLCBjdHgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmaWxsIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGxpbmUgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuUkVDVClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIGZpbGwgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZGF0YS5maWxsQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBsaW5lICkgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBkYXRhLmxpbmVBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHNoYXBlLngsIHNoYXBlLnksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLkNJUkMpXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gbmVlZCB0byBiZSBVbmRlZmluZWQhXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoc2hhcGUueCwgc2hhcGUueSwgc2hhcGUucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmaWxsIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGxpbmUgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuRUxJUClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gc2hhcGUud2lkdGggKiAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBzaGFwZS5oZWlnaHQgKiAyO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHNoYXBlLnggLSAodyAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBzaGFwZS55IC0gKGggLyAyKTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGthcHBhID0gMC41NTIyODQ4O1xuICAgICAgICAgICAgICAgIGNvbnN0IG94ID0gKHcgLyAyKSAqIGthcHBhOyAvLyBjb250cm9sIHBvaW50IG9mZnNldCBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgY29uc3Qgb3kgPSAoaCAvIDIpICoga2FwcGE7IC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgY29uc3QgeGUgPSB4ICsgdzsgICAgICAgICAgIC8vIHgtZW5kXG4gICAgICAgICAgICAgICAgY29uc3QgeWUgPSB5ICsgaDsgICAgICAgICAgIC8vIHktZW5kXG4gICAgICAgICAgICAgICAgY29uc3QgeG0gPSB4ICsgKHcgLyAyKTsgICAgICAgLy8geC1taWRkbGVcbiAgICAgICAgICAgICAgICBjb25zdCB5bSA9IHkgKyAoaCAvIDIpOyAgICAgICAvLyB5LW1pZGRsZVxuXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5bSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuXG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmaWxsIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGRhdGEuZmlsbEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIGxpbmUgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZGF0YS5saW5lQWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyUG9seWdvbihwb2ludHMsIGNsb3NlLCBjdHgpXG4gICAge1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHBvaW50cy5sZW5ndGggLyAyOyArK2opXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ogKiAyXSwgcG9pbnRzWyhqICogMikgKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoaWNzRGF0YVxue1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXaWR0aCwgc3Ryb2tlU3R5bGUsIGxpbmVBbHBoYSwgZmlsbFN0eWxlLCBmaWxsQWxwaGEsIHNoYXBlLCBkaXNwbGF5T2JqZWN0KVxuICAgIHtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgdGhpcy5saW5lQWxwaGEgPSBsaW5lQWxwaGE7XG5cbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIHRoaXMuZmlsbEFscGhhID0gZmlsbEFscGhhO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xuXG4gICAgICAgIC8v5ZyoZ3JhcGhpY3NEYXRh5Lit5L+d5oyB5LiA5Lu95a+5ZGlzcGxheU9iamVjdOeahOW8leeUqO+8jOWQjue7reWPr+S7peS7jui/memHjOmCo+WFqOWxgOefqemYteetiVxuICAgICAgICAvL+WFtuWcqERpc3BhbHkuU2hhcGUuYWRkQ3VycmVudFBhdGgyR0TkuK3ov5vooYzorr7nva5cbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0ID0gZGlzcGxheU9iamVjdDtcblxuICAgICAgICB0aGlzLmhvbGVzID0gW107XG5cbiAgICAgICAgLy/ov5nkuKTkuKrlj6/ku6XooqvlkI7nu63kv67mlLnvvIwg5YW35pyJ5LiA56Wo5ZCm5Yaz5p2DXG4gICAgICAgIC8v5q+U5aaCcG9seWdvbueahCDomZrnur/mj4/ovrnjgILlv4XpobvlnKhmaWxs55qEcG9seeS4iumdouiuvue9rmxpbmXkuLpmYWxzZVxuICAgICAgICB0aGlzLmZpbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpbmUgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljc0RhdGEoXG4gICAgICAgICAgICB0aGlzLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICB0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgIHRoaXMuZmlsbFN0eWxlLFxuICAgICAgICAgICAgdGhpcy5maWxsQWxwaGEsXG4gICAgICAgICAgICB0aGlzLnNoYXBlLFxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYWRkSG9sZShzaGFwZSlcbiAgICB7XG4gICAgICAgIHRoaXMuaG9sZXMucHVzaChzaGFwZSk7XG4gICAgfVxuXG4gICAgLy/ku47lrr/kuLtncmFwaGljc+S4reWQjOatpeacgOaWsOeahHN0eWxl5bGe5oCnXG4gICAgc3luc1N0eWxlKCBncmFwaGljcyApXG4gICAge1xuICAgICAgICAvL+S7jnNoYXBl5Lit5oqK57uY5Zu+6ZyA6KaB55qEc3R5bGXlsZ7mgKflkIzmraXov4fmnaVcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBncmFwaGljcy5saW5lV2lkdGg7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBncmFwaGljcy5zdHJva2VTdHlsZTtcbiAgICAgICAgdGhpcy5saW5lQWxwaGEgPSBncmFwaGljcy5saW5lQWxwaGE7XG5cbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBncmFwaGljcy5maWxsU3R5bGU7XG4gICAgICAgIHRoaXMuZmlsbEFscGhhID0gZ3JhcGhpY3MuZmlsbEFscGhhO1xuXG4gICAgfVxuXG4gICAgaGFzRmlsbCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxsU3R5bGUgJiZcbiAgICAgICAgICAgICAgIHRoaXMuZmlsbCAmJiBcbiAgICAgICAgICAgICAgICggdGhpcy5zaGFwZS5jbG9zZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNoYXBlLmNsb3NlZCApXG4gICAgfVxuXG4gICAgaGFzTGluZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJva2VTdHlsZSAmJiB0aGlzLmxpbmVXaWR0aCAmJiB0aGlzLmxpbmVcbiAgICB9XG5cbiAgICBkZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhvbGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0ID0gbnVsbDtcbiAgICB9XG4gICAgXG59XG4iLCIvKipcbiAqIFRoZSBQb2ludCBvYmplY3QgcmVwcmVzZW50cyBhIGxvY2F0aW9uIGluIGEgdHdvLWRpbWVuc2lvbmFsIGNvb3JkaW5hdGUgc3lzdGVtLCB3aGVyZSB4IHJlcHJlc2VudHNcbiAqIHRoZSBob3Jpem9udGFsIGF4aXMgYW5kIHkgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgYXhpcy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50XG57XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMClcbiAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IHg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5Qb2ludH0gYSBjb3B5IG9mIHRoZSBwb2ludFxuICAgICAqL1xuICAgIGNsb25lKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB4IGFuZCB5IGZyb20gdGhlIGdpdmVuIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY29weS5cbiAgICAgKi9cbiAgICBjb3B5KHApXG4gICAge1xuICAgICAgICB0aGlzLnNldChwLngsIHAueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgICAqL1xuICAgIGVxdWFscyhwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIChwLnggPT09IHRoaXMueCkgJiYgKHAueSA9PT0gdGhpcy55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyB4IGFuZCB5IHBvc2l0aW9uLlxuICAgICAqIElmIHkgaXMgb21pdHRlZCwgYm90aCB4IGFuZCB5IHdpbGwgYmUgc2V0IHRvIHguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAgICovXG4gICAgc2V0KHgsIHkpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgICAgIHRoaXMueSA9IHkgfHwgKCh5ICE9PSAwKSA/IHRoaXMueCA6IDApO1xuICAgIH1cblxufVxuIiwiXG52YXIgYXJjVG9TZWdtZW50c0NhY2hlID0geyB9LFxuICAgIHNlZ21lbnRUb0JlemllckNhY2hlID0geyB9LFxuICAgIGJvdW5kc09mQ3VydmVDYWNoZSA9IHsgfSxcbiAgICBfam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xuXG4vKiBBZGFwdGVkIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhLWNlbnRyYWwvc291cmNlL2NvbnRlbnQvc3ZnL2NvbnRlbnQvc3JjL25zU1ZHUGF0aERhdGFQYXJzZXIuY3BwXG4gKiBieSBBbmRyZWEgQm9nYXp6aSBjb2RlIGlzIHVuZGVyIE1QTC4gaWYgeW91IGRvbid0IGhhdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIHlvdSBjYW4gdGFrZSBpdCBoZXJlXG4gKiBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC9cbiAqL1xuZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh0b1gsIHRvWSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgpIHtcbiAgdmFyIGFyZ3NTdHJpbmcgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gIGlmIChhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cmluZ10pIHtcbiAgICByZXR1cm4gYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddO1xuICB9XG5cbiAgdmFyIFBJID0gTWF0aC5QSSwgdGggPSByb3RhdGVYICogUEkgLyAxODAsXG4gICAgICBzaW5UaCA9IE1hdGguc2luKHRoKSxcbiAgICAgIGNvc1RoID0gTWF0aC5jb3ModGgpLFxuICAgICAgZnJvbVggPSAwLCBmcm9tWSA9IDA7XG5cbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuXG4gIHZhciBweCA9IC1jb3NUaCAqIHRvWCAqIDAuNSAtIHNpblRoICogdG9ZICogMC41LFxuICAgICAgcHkgPSAtY29zVGggKiB0b1kgKiAwLjUgKyBzaW5UaCAqIHRvWCAqIDAuNSxcbiAgICAgIHJ4MiA9IHJ4ICogcngsIHJ5MiA9IHJ5ICogcnksIHB5MiA9IHB5ICogcHksIHB4MiA9IHB4ICogcHgsXG4gICAgICBwbCA9IHJ4MiAqIHJ5MiAtIHJ4MiAqIHB5MiAtIHJ5MiAqIHB4MixcbiAgICAgIHJvb3QgPSAwO1xuXG4gIGlmIChwbCA8IDApIHtcbiAgICB2YXIgcyA9IE1hdGguc3FydCgxIC0gcGwgLyAocngyICogcnkyKSk7XG4gICAgcnggKj0gcztcbiAgICByeSAqPSBzO1xuICB9XG4gIGVsc2Uge1xuICAgIHJvb3QgPSAobGFyZ2UgPT09IHN3ZWVwID8gLTEuMCA6IDEuMCkgKlxuICAgICAgICAgICAgTWF0aC5zcXJ0KCBwbCAvIChyeDIgKiBweTIgKyByeTIgKiBweDIpKTtcbiAgfVxuXG4gIHZhciBjeCA9IHJvb3QgKiByeCAqIHB5IC8gcnksXG4gICAgICBjeSA9IC1yb290ICogcnkgKiBweCAvIHJ4LFxuICAgICAgY3gxID0gY29zVGggKiBjeCAtIHNpblRoICogY3kgKyB0b1ggKiAwLjUsXG4gICAgICBjeTEgPSBzaW5UaCAqIGN4ICsgY29zVGggKiBjeSArIHRvWSAqIDAuNSxcbiAgICAgIG1UaGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgxLCAwLCAocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnkpLFxuICAgICAgZHRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSwgKC1weCAtIGN4KSAvIHJ4LCAoLXB5IC0gY3kpIC8gcnkpO1xuXG4gIGlmIChzd2VlcCA9PT0gMCAmJiBkdGhldGEgPiAwKSB7XG4gICAgZHRoZXRhIC09IDIgKiBQSTtcbiAgfVxuICBlbHNlIGlmIChzd2VlcCA9PT0gMSAmJiBkdGhldGEgPCAwKSB7XG4gICAgZHRoZXRhICs9IDIgKiBQSTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgaW50byBjdWJpYyBiZXppZXIgc2VnbWVudHMgPD0gOTBkZWdcbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKGR0aGV0YSAvIFBJICogMikpLFxuICAgICAgcmVzdWx0ID0gW10sIG1EZWx0YSA9IGR0aGV0YSAvIHNlZ21lbnRzLFxuICAgICAgbVQgPSA4IC8gMyAqIE1hdGguc2luKG1EZWx0YSAvIDQpICogTWF0aC5zaW4obURlbHRhIC8gNCkgLyBNYXRoLnNpbihtRGVsdGEgLyAyKSxcbiAgICAgIHRoMyA9IG1UaGV0YSArIG1EZWx0YTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBzZWdtZW50VG9CZXppZXIobVRoZXRhLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSk7XG4gICAgZnJvbVggPSByZXN1bHRbaV1bNF07XG4gICAgZnJvbVkgPSByZXN1bHRbaV1bNV07XG4gICAgbVRoZXRhID0gdGgzO1xuICAgIHRoMyArPSBtRGVsdGE7XG4gIH1cbiAgYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJpbmddID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZWdtZW50VG9CZXppZXIodGgyLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSkge1xuICB2YXIgYXJnc1N0cmluZzIgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gIGlmIChzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyaW5nMl0pIHtcbiAgICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdO1xuICB9XG5cbiAgdmFyIGNvc3RoMiA9IE1hdGguY29zKHRoMiksXG4gICAgICBzaW50aDIgPSBNYXRoLnNpbih0aDIpLFxuICAgICAgY29zdGgzID0gTWF0aC5jb3ModGgzKSxcbiAgICAgIHNpbnRoMyA9IE1hdGguc2luKHRoMyksXG4gICAgICB0b1ggPSBjb3NUaCAqIHJ4ICogY29zdGgzIC0gc2luVGggKiByeSAqIHNpbnRoMyArIGN4MSxcbiAgICAgIHRvWSA9IHNpblRoICogcnggKiBjb3N0aDMgKyBjb3NUaCAqIHJ5ICogc2ludGgzICsgY3kxLFxuICAgICAgY3AxWCA9IGZyb21YICsgbVQgKiAoIC1jb3NUaCAqIHJ4ICogc2ludGgyIC0gc2luVGggKiByeSAqIGNvc3RoMiksXG4gICAgICBjcDFZID0gZnJvbVkgKyBtVCAqICggLXNpblRoICogcnggKiBzaW50aDIgKyBjb3NUaCAqIHJ5ICogY29zdGgyKSxcbiAgICAgIGNwMlggPSB0b1ggKyBtVCAqICggY29zVGggKiByeCAqIHNpbnRoMyArIHNpblRoICogcnkgKiBjb3N0aDMpLFxuICAgICAgY3AyWSA9IHRvWSArIG1UICogKCBzaW5UaCAqIHJ4ICogc2ludGgzIC0gY29zVGggKiByeSAqIGNvc3RoMyk7XG5cbiAgc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdID0gW1xuICAgIGNwMVgsIGNwMVksXG4gICAgY3AyWCwgY3AyWSxcbiAgICB0b1gsIHRvWVxuICBdO1xuICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cmluZzJdO1xufVxuXG4vKlxuICogUHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxjVmVjdG9yQW5nbGUodXgsIHV5LCB2eCwgdnkpIHtcbiAgdmFyIHRhID0gTWF0aC5hdGFuMih1eSwgdXgpLFxuICAgICAgdGIgPSBNYXRoLmF0YW4yKHZ5LCB2eCk7XG4gIGlmICh0YiA+PSB0YSkge1xuICAgIHJldHVybiB0YiAtIHRhO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAyICogTWF0aC5QSSAtICh0YSAtIHRiKTtcbiAgfVxufVxuXG4vKipcbiAqIERyYXdzIGFyY1xuICogQHBhcmFtIHtncmFwaGljc30gZ3JhcGhpY3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBmeFxuICogQHBhcmFtIHtOdW1iZXJ9IGZ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb29yZHNcbiAqL1xudmFyIGRyYXdBcmMgPSBmdW5jdGlvbihncmFwaGljcyAsIGZ4LCBmeSwgY29vcmRzKSB7XG4gIHZhciByeCA9IGNvb3Jkc1swXSxcbiAgICAgIHJ5ID0gY29vcmRzWzFdLFxuICAgICAgcm90ID0gY29vcmRzWzJdLFxuICAgICAgbGFyZ2UgPSBjb29yZHNbM10sXG4gICAgICBzd2VlcCA9IGNvb3Jkc1s0XSxcbiAgICAgIHR4ID0gY29vcmRzWzVdLFxuICAgICAgdHkgPSBjb29yZHNbNl0sXG4gICAgICBzZWdzID0gW1tdLCBbXSwgW10sIFtdXSxcbiAgICAgIHNlZ3NOb3JtID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vnc05vcm0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZWdzW2ldWzBdID0gc2Vnc05vcm1baV1bMF0gKyBmeDtcbiAgICBzZWdzW2ldWzFdID0gc2Vnc05vcm1baV1bMV0gKyBmeTtcbiAgICBzZWdzW2ldWzJdID0gc2Vnc05vcm1baV1bMl0gKyBmeDtcbiAgICBzZWdzW2ldWzNdID0gc2Vnc05vcm1baV1bM10gKyBmeTtcbiAgICBzZWdzW2ldWzRdID0gc2Vnc05vcm1baV1bNF0gKyBmeDtcbiAgICBzZWdzW2ldWzVdID0gc2Vnc05vcm1baV1bNV0gKyBmeTtcbiAgICBncmFwaGljcy5iZXppZXJDdXJ2ZVRvLmFwcGx5KGdyYXBoaWNzLCBzZWdzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgZWxsaXB0aWMtYXJjXG4gKiBAcGFyYW0ge051bWJlcn0gZnggc3RhcnQgcG9pbnQgb2YgYXJjXG4gKiBAcGFyYW0ge051bWJlcn0gZnlcbiAqIEBwYXJhbSB7TnVtYmVyfSByeCBob3Jpem9udGFsIHJhZGl1c1xuICogQHBhcmFtIHtOdW1iZXJ9IHJ5IHZlcnRpY2FsIHJhZGl1c1xuICogQHBhcmFtIHtOdW1iZXJ9IHJvdCBhbmdsZSBvZiBob3Jpem9udGFsIGF4ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxhcmdlIDEgb3IgMCwgd2hhdGV2ZXIgdGhlIGFyYyBpcyB0aGUgYmlnIG9yIHRoZSBzbWFsbCBvbiB0aGUgMiBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBzd2VlcCAxIG9yIDAsIDEgY2xvY2t3aXNlIG9yIGNvdW50ZXJjbG9ja3dpc2UgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdHggZW5kIHBvaW50IG9mIGFyY1xuICogQHBhcmFtIHtOdW1iZXJ9IHR5XG4gKi9cbnZhciBnZXRCb3VuZHNPZkFyYyA9IGZ1bmN0aW9uKGZ4LCBmeSwgcngsIHJ5LCByb3QsIGxhcmdlLCBzd2VlcCwgdHgsIHR5KSB7XG5cbiAgdmFyIGZyb21YID0gMCwgZnJvbVkgPSAwLCBib3VuZCwgYm91bmRzID0gW10sXG4gICAgICBzZWdzID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJvdW5kID0gZ2V0Qm91bmRzT2ZDdXJ2ZShmcm9tWCwgZnJvbVksIHNlZ3NbaV1bMF0sIHNlZ3NbaV1bMV0sIHNlZ3NbaV1bMl0sIHNlZ3NbaV1bM10sIHNlZ3NbaV1bNF0sIHNlZ3NbaV1bNV0pO1xuICAgIGJvdW5kcy5wdXNoKHsgeDogYm91bmRbMF0ueCArIGZ4LCB5OiBib3VuZFswXS55ICsgZnkgfSk7XG4gICAgYm91bmRzLnB1c2goeyB4OiBib3VuZFsxXS54ICsgZngsIHk6IGJvdW5kWzFdLnkgKyBmeSB9KTtcbiAgICBmcm9tWCA9IHNlZ3NbaV1bNF07XG4gICAgZnJvbVkgPSBzZWdzW2ldWzVdO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggb2YgYSBiZXppZXJjdXJ2ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHgwIHN0YXJ0aW5nIHBvaW50XG4gKiBAcGFyYW0ge051bWJlcn0geTBcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MSBmaXJzdCBjb250cm9sIHBvaW50XG4gKiBAcGFyYW0ge051bWJlcn0geTFcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzZWNvbmRvIGNvbnRyb2wgcG9pbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICogQHBhcmFtIHtOdW1iZXJ9IHgzIGVuZCBvZiBiZWl6ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICovXG4vLyB0YWtlbiBmcm9tIGh0dHA6Ly9qc2Jpbi5jb20vaXZvbWlxLzU2L2VkaXQgIG5vIGNyZWRpdHMgYXZhaWxhYmxlIGZvciB0aGF0LlxuZnVuY3Rpb24gZ2V0Qm91bmRzT2ZDdXJ2ZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIGFyZ3NTdHJpbmcgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gIGlmIChib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10pIHtcbiAgICByZXR1cm4gYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddO1xuICB9XG5cbiAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXgsXG4gICAgICBhYnMgPSBNYXRoLmFicywgdHZhbHVlcyA9IFtdLFxuICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuXG4gIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgfVxuXG4gICAgaWYgKGFicyhhKSA8IDFlLTEyKSB7XG4gICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gLWMgLyBiO1xuICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3FydGIyYWMgPSBzcXJ0KGIyYWMpO1xuICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICB9XG4gICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB4LCB5LCBqID0gdHZhbHVlcy5sZW5ndGgsIGpsZW4gPSBqLCBtdDtcbiAgd2hpbGUgKGotLSkge1xuICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgIG10ID0gMSAtIHQ7XG4gICAgeCA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICBib3VuZHNbMF1bal0gPSB4O1xuXG4gICAgeSA9IChtdCAqIG10ICogbXQgKiB5MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeTEpICsgKDMgKiBtdCAqIHQgKiB0ICogeTIpICsgKHQgKiB0ICogdCAqIHkzKTtcbiAgICBib3VuZHNbMV1bal0gPSB5O1xuICB9XG5cbiAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgdmFyIHJlc3VsdCA9IFtcbiAgICB7XG4gICAgICB4OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgIHk6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgfSxcbiAgICB7XG4gICAgICB4OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgIHk6IG1heC5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgfVxuICBdO1xuICBib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10gPSByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGRyYXdBcmM6IGRyYXdBcmMsXG4gICAgZ2V0Qm91bmRzT2ZDdXJ2ZTogZ2V0Qm91bmRzT2ZDdXJ2ZSxcbiAgICBnZXRCb3VuZHNPZkFyYzogZ2V0Qm91bmRzT2ZBcmNcbn1cblxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnLi4vLi4vY29uc3QnO1xuXG4vKipcbiAqIFJlY3RhbmdsZSBvYmplY3QgaXMgYW4gYXJlYSBkZWZpbmVkIGJ5IGl0cyBwb3NpdGlvbiwgYXMgaW5kaWNhdGVkIGJ5IGl0cyB0b3AtbGVmdCBjb3JuZXJcbiAqIHBvaW50ICh4LCB5KSBhbmQgYnkgaXRzIHdpZHRoIGFuZCBpdHMgaGVpZ2h0LlxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWElcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdGFuZ2xlXG57XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gVGhlIG92ZXJhbGwgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIFRoZSBvdmVyYWxsIGhlaWdodCBvZiB0aGlzIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKVxuICAgIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSB5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5SRUNUXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFNIQVBFUy5SRUNUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGxlZnQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGxlZnQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSByaWdodCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcmlnaHQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgdG9wIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0b3AoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGJvdHRvbSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjb25zdGFudCBlbXB0eSByZWN0YW5nbGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgc3RhdGljIGdldCBFTVBUWSgpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBSZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGNsb25lKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGFub3RoZXIgcmVjdGFuZ2xlIHRvIHRoaXMgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5LlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICBjb3B5KHJlY3RhbmdsZSlcbiAgICB7XG4gICAgICAgIHRoaXMueCA9IHJlY3RhbmdsZS54O1xuICAgICAgICB0aGlzLnkgPSByZWN0YW5nbGUueTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSByZWN0YW5nbGUuaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHkpXG4gICAge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDwgdGhpcy54ICsgdGhpcy53aWR0aClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIHRoZSByZWN0YW5nbGUgbWFraW5nIGl0IGdyb3cgaW4gYWxsIGRpcmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1ggLSBUaGUgaG9yaXpvbnRhbCBwYWRkaW5nIGFtb3VudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1kgLSBUaGUgdmVydGljYWwgcGFkZGluZyBhbW91bnQuXG4gICAgICovXG4gICAgcGFkKHBhZGRpbmdYLCBwYWRkaW5nWSlcbiAgICB7XG4gICAgICAgIHBhZGRpbmdYID0gcGFkZGluZ1ggfHwgMDtcbiAgICAgICAgcGFkZGluZ1kgPSBwYWRkaW5nWSB8fCAoKHBhZGRpbmdZICE9PSAwKSA/IHBhZGRpbmdYIDogMCk7XG5cbiAgICAgICAgdGhpcy54IC09IHBhZGRpbmdYO1xuICAgICAgICB0aGlzLnkgLT0gcGFkZGluZ1k7XG5cbiAgICAgICAgdGhpcy53aWR0aCArPSBwYWRkaW5nWCAqIDI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICs9IHBhZGRpbmdZICogMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXRzIHRoaXMgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgcGFzc2VkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gZml0LlxuICAgICAqL1xuICAgIGZpdChyZWN0YW5nbGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy54IDwgcmVjdGFuZ2xlLngpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggKz0gdGhpcy54O1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPCAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnggPSByZWN0YW5nbGUueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnkgPCByZWN0YW5nbGUueSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgKz0gdGhpcy55O1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0IDwgMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnkgPSByZWN0YW5nbGUueTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnggKyB0aGlzLndpZHRoID4gcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGggLSB0aGlzLng7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy55ICsgdGhpcy5oZWlnaHQgPiByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodCAtIHRoaXMueTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCA8IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gaW5jbHVkZS5cbiAgICAgKi9cbiAgICBlbmxhcmdlKHJlY3RhbmdsZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgICAgIGNvbnN0IHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpO1xuICAgICAgICBjb25zdCB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xuICAgICAgICBjb25zdCB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuXG4gICAgICAgIHRoaXMueCA9IHgxO1xuICAgICAgICB0aGlzLndpZHRoID0geDIgLSB4MTtcbiAgICAgICAgdGhpcy55ID0geTE7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0geTIgLSB5MTtcbiAgICB9XG59XG4iLCJpbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4vUmVjdGFuZ2xlJztcbmltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uLy4uL2NvbnN0JztcblxuLyoqXG4gKiBUaGUgQ2lyY2xlIG9iamVjdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgaGl0IGFyZWEgZm9yIGRpc3BsYXlPYmplY3RzXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGVcbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0wXSAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMClcbiAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IHg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5DSVJDXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFNIQVBFUy5DSVJDO1xuXG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBDaXJjbGUgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuQ2lyY2xlfSBhIGNvcHkgb2YgdGhlIENpcmNsZVxuICAgICAqL1xuICAgIGNsb25lKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBjaXJjbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXG4gICAgICovXG4gICAgY29udGFpbnMoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnJhZGl1cyA8PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG4gICAgICAgIGxldCBkeCA9ICh0aGlzLnggLSB4KTtcbiAgICAgICAgbGV0IGR5ID0gKHRoaXMueSAtIHkpO1xuXG4gICAgICAgIGR4ICo9IGR4O1xuICAgICAgICBkeSAqPSBkeTtcblxuICAgICAgICByZXR1cm4gKGR4ICsgZHkgPD0gcjIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGNpcmNsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICAqXG4gICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAgKi9cbiAgICBnZXRCb3VuZHMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gdGhpcy5yYWRpdXMsIHRoaXMueSAtIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMik7XG4gICAgfVxufVxuIiwiaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuL1JlY3RhbmdsZSc7XG5pbXBvcnQgeyBTSEFQRVMgfSBmcm9tICcuLi8uLi9jb25zdCc7XG5cbi8qKlxuICogVGhlIEVsbGlwc2Ugb2JqZWN0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYSBoaXQgYXJlYSBmb3IgZGlzcGxheU9iamVjdHNcbiAqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsbGlwc2VcbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhpcyBlbGxpcHNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MF0gLSBUaGUgaGFsZiBoZWlnaHQgb2YgdGhpcyBlbGxpcHNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApXG4gICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLkVMSVBcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gU0hBUEVTLkVMSVA7XG5cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIEVsbGlwc2UgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuRWxsaXBzZX0gYSBjb3B5IG9mIHRoZSBlbGxpcHNlXG4gICAgICovXG4gICAgY2xvbmUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXG4gICAgICovXG4gICAgY29udGFpbnMoeCwgeSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDBcbiAgICAgICAgbGV0IG5vcm14ID0gKCh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGgpO1xuICAgICAgICBsZXQgbm9ybXkgPSAoKHkgLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIG5vcm14ICo9IG5vcm14O1xuICAgICAgICBub3JteSAqPSBub3JteTtcblxuICAgICAgICByZXR1cm4gKG5vcm14ICsgbm9ybXkgPD0gMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGVsbGlwc2UgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgZ2V0Qm91bmRzKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMud2lkdGgsIHRoaXMueSAtIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBvaW50IGZyb20gJy4uL1BvaW50JztcbmltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uLy4uL2NvbnN0JztcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25cbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnRbXXxudW1iZXJbXX0gcG9pbnRzIC0gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb2YgUG9pbnRzXG4gICAgICogIHRoYXQgZm9ybSB0aGUgcG9seWdvbiwgYSBmbGF0IGFycmF5IG9mIG51bWJlcnMgdGhhdCB3aWxsIGJlIGludGVycHJldGVkIGFzIFt4LHksIHgseSwgLi4uXSwgb3JcbiAgICAgKiAgdGhlIGFyZ3VtZW50cyBwYXNzZWQgY2FuIGJlIGFsbCB0aGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIGUuZy5cbiAgICAgKiAgYG5ldyBQSVhJLlBvbHlnb24obmV3IFBJWEkuUG9pbnQoKSwgbmV3IFBJWEkuUG9pbnQoKSwgLi4uKWAsIG9yIHRoZSBhcmd1bWVudHMgcGFzc2VkIGNhbiBiZSBmbGF0XG4gICAgICogIHgseSB2YWx1ZXMgZS5nLiBgbmV3IFBvbHlnb24oeCx5LCB4LHksIHgseSwgLi4uKWAgd2hlcmUgYHhgIGFuZCBgeWAgYXJlIE51bWJlcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4ucG9pbnRzKVxuICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBhcnJheSBvZiBwb2ludHMsIGNvbnZlcnQgaXQgdG8gYSBmbGF0IGFycmF5IG9mIG51bWJlcnNcbiAgICAgICAgaWYgKHBvaW50c1swXSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBwID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHAucHVzaChwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb2ludHMgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB0aGUgcG9pbnRzIG9mIHRoaXMgcG9seWdvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlBPTFlcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gU0hBUEVTLlBPTFk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9seWdvblxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5Qb2x5Z29ufSBhIGNvcHkgb2YgdGhlIHBvbHlnb25cbiAgICAgKi9cbiAgICBjbG9uZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24odGhpcy5wb2ludHMuc2xpY2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBwb2x5Z29uLCBhZGRpbmcgcG9pbnRzIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICBpZiAocG9pbnRzWzBdICE9PSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdIHx8IHBvaW50c1sxXSAhPT0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSlcbiAgICAgICAge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb250YWlucyh4LCB5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5zaWRlUG9seWdvbl9XaW5kaW5nTnVtYmVyKHgseSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDlpJrovrnlvaLljIXlkKvliKTmlq0gTm9uemVybyBXaW5kaW5nIE51bWJlciBSdWxlXG4gICAgICovXG4gICAgX2lzSW5zaWRlUG9seWdvbl9XaW5kaW5nTnVtYmVyKHgsIHkpIFxuICAgIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgd24gPSAwO1xuICAgICAgICBmb3IgKHZhciBzaGlmdFAsIHNoaWZ0ID0gcG9pbnRzWzFdID4geSwgaSA9IDM7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHNoaWZ0UCA9IHNoaWZ0O1xuICAgICAgICAgICAgc2hpZnQgPSBwb2ludHNbaV0gPiB5O1xuICAgICAgICAgICAgaWYgKHNoaWZ0UCAhPSBzaGlmdCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gKHNoaWZ0UCA/IDEgOiAwKSAtIChzaGlmdCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBpZiAobiAqICgocG9pbnRzW2kgLSAzXSAtIHgpICogKHBvaW50c1tpIC0gMF0gLSB5KSAtIChwb2ludHNbaSAtIDJdIC0geSkgKiAocG9pbnRzW2kgLSAxXSAtIHgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd24gKz0gbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd25cbiAgICB9XG59XG4iLCIvKipcbiAqIE1hdGggY2xhc3NlcyBhbmQgdXRpbGl0aWVzIG1peGVkIGludG8gUElYSSBuYW1lc3BhY2UuXG4gKlxuICogQGxlbmRzIFBJWElcbiAqL1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2ludCB9IGZyb20gJy4vUG9pbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBcmMgfSBmcm9tICcuL0FyYyc7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2lyY2xlIH0gZnJvbSAnLi9zaGFwZXMvQ2lyY2xlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRWxsaXBzZSB9IGZyb20gJy4vc2hhcGVzL0VsbGlwc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5Z29uIH0gZnJvbSAnLi9zaGFwZXMvUG9seWdvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlY3RhbmdsZSB9IGZyb20gJy4vc2hhcGVzL1JlY3RhbmdsZSc7XG5cblxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmV6aWVyQ3VydmVUbyhmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgcGF0aCA9IFtdKVxue1xuICAgIGNvbnN0IG4gPSAyMDtcbiAgICBsZXQgZHQgPSAwO1xuICAgIGxldCBkdDIgPSAwO1xuICAgIGxldCBkdDMgPSAwO1xuICAgIGxldCB0MiA9IDA7XG4gICAgbGV0IHQzID0gMDtcblxuICAgIHBhdGgucHVzaChmcm9tWCwgZnJvbVkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDw9IG47ICsraSlcbiAgICB7XG4gICAgICAgIGogPSBpIC8gbjtcblxuICAgICAgICBkdCA9ICgxIC0gaik7XG4gICAgICAgIGR0MiA9IGR0ICogZHQ7XG4gICAgICAgIGR0MyA9IGR0MiAqIGR0O1xuXG4gICAgICAgIHQyID0gaiAqIGo7XG4gICAgICAgIHQzID0gdDIgKiBqO1xuXG4gICAgICAgIHBhdGgucHVzaChcbiAgICAgICAgICAgIChkdDMgKiBmcm9tWCkgKyAoMyAqIGR0MiAqIGogKiBjcFgpICsgKDMgKiBkdCAqIHQyICogY3BYMikgKyAodDMgKiB0b1gpLFxuICAgICAgICAgICAgKGR0MyAqIGZyb21ZKSArICgzICogZHQyICogaiAqIGNwWSkgKyAoMyAqIGR0ICogdDIgKiBjcFkyKSArICh0MyAqIHRvWSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbn1cbiIsIi8qXG4qIEdyYXBoaWNz57uY5Zu+5rOV5YiZXG4qIOWNleS4qmdyYWhpY3Plrp7kvovph4znmoRmaWxsIGxpbmUg5qC35byP5bGe5oCn77yM6YO95LuO5a+55bqUc2hhcGUuY29udGV4dOS4reiOt+WPllxuKiBcbiovXG5cbmltcG9ydCBHcmFwaGljc0RhdGEgZnJvbSAnLi9HcmFwaGljc0RhdGEnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlLCBFbGxpcHNlLCBQb2x5Z29uLCBDaXJjbGUgfSBmcm9tICcuLi9tYXRoL2luZGV4JztcbmltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uL2NvbnN0JztcbmltcG9ydCBiZXppZXJDdXJ2ZVRvIGZyb20gJy4vdXRpbHMvYmV6aWVyQ3VydmVUbyc7XG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaGljcyBcbntcbiAgICBjb25zdHJ1Y3Rvciggc2hhcGUgKVxuICAgIHtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSAxO1xuICAgICAgICB0aGlzLnN0cm9rZVN0eWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5lQWxwaGEgPSAxO1xuICAgICAgICB0aGlzLmZpbGxTdHlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsbEFscGhhID0gMTtcblxuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblxuICAgICAgICB0aGlzLmRpcnR5ID0gMDsgLy/nlKjkuo7mo4DmtYvlm77lvaLlr7nosaHmmK/lkKblt7Lmm7TmlLnjgIIg5aaC5p6c6L+Z5piv6K6+572u5Li6dHJ1Ze+8jOmCo+S5iOWbvuW9ouWvueixoeWwhuiiq+mHjeaWsOiuoeeul+OAglxuICAgICAgICB0aGlzLmNsZWFyRGlydHkgPSAwOyAvL+eUqOS6juajgOa1i+aIkeS7rOaYr+WQpua4hemZpOS6huWbvuW9ondlYkdM5pWw5o2uXG5cbiAgICAgICAgdGhpcy5fd2ViR0wgPSB7fTtcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gMTtcbiAgICAgICAgdGhpcy50aW50ID0gMHhGRkZGRkY7IC8v55uu5qCH5a+56LGh6ZmE5Yqg6aKc6ImyXG4gICAgfVxuXG4gICAgc2V0U3R5bGUoIGNvbnRleHQgKVxuICAgIHtcbiAgICAgICAgLy/ku44gc2hhcGUg5Lit5oqK57uY5Zu+6ZyA6KaB55qEc3R5bGXlsZ7mgKflkIzmraXov4fmnaVcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5zdHJva2VTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICAgIHRoaXMubGluZUFscGhhID0gY29udGV4dC5saW5lQWxwaGEgKiBjb250ZXh0Lmdsb2JhbEFscGhhO1xuXG4gICAgICAgIHRoaXMuZmlsbFN0eWxlID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgIHRoaXMuZmlsbEFscGhhID0gY29udGV4dC5maWxsQWxwaGEgKiBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgIH1cblxuICAgIGNsb25lKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEdyYXBoaWNzKCk7XG5cbiAgICAgICAgY2xvbmUuZGlydHkgPSAwO1xuXG4gICAgICAgIC8vIGNvcHkgZ3JhcGhpY3MgZGF0YVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjbG9uZS5ncmFwaGljc0RhdGEucHVzaCh0aGlzLmdyYXBoaWNzRGF0YVtpXS5jbG9uZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lLmN1cnJlbnRQYXRoID0gY2xvbmUuZ3JhcGhpY3NEYXRhW2Nsb25lLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuXG4gICAgbW92ZVRvKHgsIHkpXG4gICAge1xuICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBQb2x5Z29uKFt4LCB5XSk7XG5cbiAgICAgICAgc2hhcGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd1NoYXBlKHNoYXBlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgXG4gICAgbGluZVRvKHgsIHkpXG4gICAge1xuICAgICAgICBpZiggdGhpcy5jdXJyZW50UGF0aCApe1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMucHVzaCh4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKDAsMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcXVhZHJhdGljQ3VydmVUbyhjcFgsIGNwWSwgdG9YLCB0b1kpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cyA9IFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbiA9IDIwO1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcbiAgICAgICAgbGV0IHhhID0gMDtcbiAgICAgICAgbGV0IHlhID0gMDtcblxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgICAgIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBuOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBpIC8gbjtcblxuICAgICAgICAgICAgeGEgPSBmcm9tWCArICgoY3BYIC0gZnJvbVgpICogaik7XG4gICAgICAgICAgICB5YSA9IGZyb21ZICsgKChjcFkgLSBmcm9tWSkgKiBqKTtcblxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeGEgKyAoKChjcFggKyAoKHRvWCAtIGNwWCkgKiBqKSkgLSB4YSkgKiBqKSxcbiAgICAgICAgICAgICAgICB5YSArICgoKGNwWSArICgodG9ZIC0gY3BZKSAqIGopKSAtIHlhKSAqIGopKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBiZXppZXJDdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzID0gWzAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcblxuICAgICAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgICAgIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBwb2ludHMubGVuZ3RoIC09IDI7XG5cbiAgICAgICAgYmV6aWVyQ3VydmVUbyhmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgcG9pbnRzKTtcblxuICAgICAgICB0aGlzLmRpcnR5Kys7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLnB1c2goeDEsIHkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cztcbiAgICAgICAgY29uc3QgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGExID0gZnJvbVkgLSB5MTtcbiAgICAgICAgY29uc3QgYjEgPSBmcm9tWCAtIHgxO1xuICAgICAgICBjb25zdCBhMiA9IHkyIC0geTE7XG4gICAgICAgIGNvbnN0IGIyID0geDIgLSB4MTtcbiAgICAgICAgY29uc3QgbW0gPSBNYXRoLmFicygoYTEgKiBiMikgLSAoYjEgKiBhMikpO1xuXG4gICAgICAgIGlmIChtbSA8IDEuMGUtOCB8fCByYWRpdXMgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdICE9PSB4MSB8fCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICE9PSB5MSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZGQgPSAoYTEgKiBhMSkgKyAoYjEgKiBiMSk7XG4gICAgICAgICAgICBjb25zdCBjYyA9IChhMiAqIGEyKSArIChiMiAqIGIyKTtcbiAgICAgICAgICAgIGNvbnN0IHR0ID0gKGExICogYTIpICsgKGIxICogYjIpO1xuICAgICAgICAgICAgY29uc3QgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW07XG4gICAgICAgICAgICBjb25zdCBrMiA9IHJhZGl1cyAqIE1hdGguc3FydChjYykgLyBtbTtcbiAgICAgICAgICAgIGNvbnN0IGoxID0gazEgKiB0dCAvIGRkO1xuICAgICAgICAgICAgY29uc3QgajIgPSBrMiAqIHR0IC8gY2M7XG4gICAgICAgICAgICBjb25zdCBjeCA9IChrMSAqIGIyKSArIChrMiAqIGIxKTtcbiAgICAgICAgICAgIGNvbnN0IGN5ID0gKGsxICogYTIpICsgKGsyICogYTEpO1xuICAgICAgICAgICAgY29uc3QgcHggPSBiMSAqIChrMiArIGoxKTtcbiAgICAgICAgICAgIGNvbnN0IHB5ID0gYTEgKiAoazIgKyBqMSk7XG4gICAgICAgICAgICBjb25zdCBxeCA9IGIyICogKGsxICsgajIpO1xuICAgICAgICAgICAgY29uc3QgcXkgPSBhMiAqIChrMSArIGoyKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpO1xuICAgICAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBNYXRoLmF0YW4yKHF5IC0gY3ksIHF4IC0gY3gpO1xuXG4gICAgICAgICAgICB0aGlzLmFyYyhjeCArIHgxLCBjeSArIHkxLCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBiMSAqIGEyID4gYjIgKiBhMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5Kys7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYXJjKGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSA9IGZhbHNlKVxuICAgIHtcbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYW50aWNsb2Nrd2lzZSAmJiBlbmRBbmdsZSA8PSBzdGFydEFuZ2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICBlbmRBbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbnRpY2xvY2t3aXNlICYmIHN0YXJ0QW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICAgICAgY29uc3Qgc2VncyA9IE1hdGguY2VpbChNYXRoLmFicyhzd2VlcCkgLyAoTWF0aC5QSSAqIDIpKSAqIDQwO1xuXG4gICAgICAgIGlmIChzd2VlcCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydFggPSBjeCArIChNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgKE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzKTtcblxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudFBhdGggZXhpc3RzLCB0YWtlIGl0cyBwb2ludHMuIE90aGVyd2lzZSBjYWxsIGBtb3ZlVG9gIHRvIHN0YXJ0IGEgcGF0aC5cbiAgICAgICAgbGV0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGggPyB0aGlzLmN1cnJlbnRQYXRoLnNoYXBlLnBvaW50cyA6IG51bGw7XG5cbiAgICAgICAgaWYgKHBvaW50cylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gIT09IHN0YXJ0WCB8fCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICE9PSBzdGFydFkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zaGFwZS5wb2ludHM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aGV0YSA9IHN3ZWVwIC8gKHNlZ3MgKiAyKTtcbiAgICAgICAgY29uc3QgdGhldGEyID0gdGhldGEgKiAyO1xuXG4gICAgICAgIGNvbnN0IGNUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgY29uc3Qgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgIGNvbnN0IHNlZ01pbnVzID0gc2VncyAtIDE7XG5cbiAgICAgICAgY29uc3QgcmVtYWluZGVyID0gKHNlZ01pbnVzICUgMSkgLyBzZWdNaW51cztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzZWdNaW51czsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZWFsID0gaSArIChyZW1haW5kZXIgKiBpKTtcblxuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSAoKHRoZXRhKSArIHN0YXJ0QW5nbGUgKyAodGhldGEyICogcmVhbCkpO1xuXG4gICAgICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgY29uc3QgcyA9IC1NYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICAgICAgICAgICgoKGNUaGV0YSAqIGMpICsgKHNUaGV0YSAqIHMpKSAqIHJhZGl1cykgKyBjeCxcbiAgICAgICAgICAgICAgICAoKChjVGhldGEgKiAtcykgKyAoc1RoZXRhICogYykpICogcmFkaXVzKSArIGN5XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRyYXdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZHJhd0NpcmNsZSh4LCB5LCByYWRpdXMpXG4gICAge1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShuZXcgQ2lyY2xlKHgsIHksIHJhZGl1cykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRyYXdFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShuZXcgRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZHJhd1BvbHlnb24ocGF0aClcbiAgICB7XG4gICAgICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGFzc2lnbm1lbnQgZGVvcHRcbiAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4xOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcbiAgICAgICAgbGV0IHBvaW50cyA9IHBhdGg7XG5cbiAgICAgICAgbGV0IGNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHBvaW50cyBpbnN0YW5jZW9mIFBvbHlnb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsb3NlZCA9IHBvaW50cy5jbG9zZWQ7XG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHMucG9pbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGxlYWsgZGVvcHRcbiAgICAgICAgICAgIC8vIHNlZSBzZWN0aW9uIDMuMjogaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXG4gICAgICAgICAgICBwb2ludHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IGFyZ3VtZW50c1tpXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNoYXBlID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcblxuICAgICAgICBzaGFwZS5jbG9zZWQgPSBjbG9zZWQ7XG5cbiAgICAgICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5Kys7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRGlydHkrKztcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkcmF3U2hhcGUoc2hhcGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGguc2hhcGUucG9pbnRzLmxlbmd0aCA8PSAyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGEoXG4gICAgICAgICAgICB0aGlzLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgICB0aGlzLmxpbmVBbHBoYSxcbiAgICAgICAgICAgIHRoaXMuZmlsbFN0eWxlLFxuICAgICAgICAgICAgdGhpcy5maWxsQWxwaGEsXG4gICAgICAgICAgICBzaGFwZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2goZGF0YSk7XG5cbiAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLlBPTFkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEuc2hhcGUuY2xvc2VkID0gZGF0YS5zaGFwZS5jbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlydHkrKztcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBiZWdpblBhdGgoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xvc2VQYXRoKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcblxuICAgICAgICBpZiAoY3VycmVudFBhdGggJiYgY3VycmVudFBhdGguc2hhcGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoLnNoYXBlLmNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBib3VuZHMgb2YgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTG9jYWxCb3VuZHMoKVxuICAgIHtcbiAgICAgICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IG1heFggPSAtSW5maW5pdHk7XG5cbiAgICAgICAgbGV0IG1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHNoYXBlID0gMDtcbiAgICAgICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgICAgIGxldCB3ID0gMDtcbiAgICAgICAgICAgIGxldCBoID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBkYXRhLmxpbmVXaWR0aDtcblxuICAgICAgICAgICAgICAgIHNoYXBlID0gZGF0YS5zaGFwZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBTSEFQRVMuUkVDVCB8fCB0eXBlID09PSBTSEFQRVMuUlJFQylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54IC0gKGxpbmVXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueSAtIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLndpZHRoICsgbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgbGluZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBTSEFQRVMuQ0lSQylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcblxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCAtIHcgPCBtaW5YID8geCAtIHcgOiBtaW5YO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5IC0gaCA8IG1pblkgPyB5IC0gaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFNIQVBFUy5FTElQKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyAobGluZVdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGggPSBzaGFwZS5oZWlnaHQgKyAobGluZVdpZHRoIC8gMik7XG5cbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcblxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBQT0xZXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHgyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJ3ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN5ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiArIDIgPCBwb2ludHMubGVuZ3RoOyBqICs9IDIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gcG9pbnRzW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gcG9pbnRzW2ogKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoeDIgLSB4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gTWF0aC5hYnMoeTIgLSB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5zcXJ0KChkeCAqIGR4KSArIChkeSAqIGR5KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3IDwgMWUtOSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcncgPSAoKGggLyB3ICogZHkpICsgZHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJoID0gKChoIC8gdyAqIGR4KSArIGR5KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9ICh4MiArIHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gKHkyICsgeSkgLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5YID0gY3ggLSBydyA8IG1pblggPyBjeCAtIHJ3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSBjeCArIHJ3ID4gbWF4WCA/IGN4ICsgcncgOiBtYXhYO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5ZID0gY3kgLSByaCA8IG1pblkgPyBjeSAtIHJoIDogbWluWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBjeSArIHJoID4gbWF4WSA/IGN5ICsgcmggOiBtYXhZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbWluWCA9IDA7XG4gICAgICAgICAgICBtYXhYID0gMDtcbiAgICAgICAgICAgIG1pblkgPSAwO1xuICAgICAgICAgICAgbWF4WSA9IDA7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuQm91bmQubWluWCA9IG1pblggXG4gICAgICAgIHRoaXMuQm91bmQubWF4WCA9IG1heFg7XG5cbiAgICAgICAgdGhpcy5Cb3VuZC5taW5ZID0gbWluWTtcbiAgICAgICAgdGhpcy5Cb3VuZC5tYXhZID0gbWF4WTtcbiAgICB9XG5cbiAgICBkZXN0cm95KG9wdGlvbnMpXG4gICAge1xuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuX3dlYkdMKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3dlYkdMW2lkXS5kYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYkdMW2lkXS5kYXRhW2pdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dlYkdMID0gbnVsbDtcbiAgICB9XG5cbn0iLCJpbXBvcnQgU3lzdGVtUmVuZGVyZXIgZnJvbSAnLi4vU3lzdGVtUmVuZGVyZXInO1xuaW1wb3J0IHsgUkVOREVSRVJfVFlQRSB9IGZyb20gJy4uLy4uL2NvbnN0JztcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgQ0dSIGZyb20gXCIuLi8uLi9ncmFwaGljcy9jYW52YXMvR3JhcGhpY3NSZW5kZXJlclwiO1xuaW1wb3J0IEdyYXBoaWNzIGZyb20gXCIuLi8uLi9ncmFwaGljcy9HcmFwaGljc1wiO1xuaW1wb3J0IF8gZnJvbSBcIi4uLy4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBTeXN0ZW1SZW5kZXJlclxue1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgb3B0aW9ucz17fSlcbiAgICB7XG4gICAgICAgIHN1cGVyKFJFTkRFUkVSX1RZUEUuQ0FOVkFTLCBhcHAsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLkNHUiA9IG5ldyBDR1IodGhpcyk7XG4gICAgICAgIC8v5LiA5Liqc3RhZ2XnlKjkuIDkuKpncmFwaGljc+adpee7mOWItuaJgOacieeahHNoYXBlXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoIGFwcCApXG4gICAge1xuICAgIFx0dmFyIG1lID0gdGhpcztcbiAgICAgICAgbWUuYXBwID0gYXBwO1xuICAgIFx0Xy5lYWNoKF8udmFsdWVzKCBhcHAuY29udmVydFN0YWdlcyApICwgZnVuY3Rpb24oY29udmVydFN0YWdlKXtcbiAgICAgICAgICAgIG1lLnJlbmRlclN0YWdlKCBjb252ZXJ0U3RhZ2Uuc3RhZ2UgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcC5jb252ZXJ0U3RhZ2VzID0ge307XG4gICAgfVxuXG4gICAgcmVuZGVyU3RhZ2UoIHN0YWdlIClcbiAgICB7XG4gICAgICAgIGlmKCFzdGFnZS5jdHgpe1xuICAgICAgICAgICAgc3RhZ2UuY3R4ID0gc3RhZ2UuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFnZS5zdGFnZVJlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbGVhciggc3RhZ2UgKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyKCBzdGFnZSApO1xuICAgICAgICBzdGFnZS5zdGFnZVJlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfcmVuZGVyKCBzdGFnZSAsIGRpc3BsYXlPYmplY3QgKVxuICAgIHtcbiAgICAgICAgaWYoICFkaXNwbGF5T2JqZWN0ICl7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0ID0gc3RhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoICFkaXNwbGF5T2JqZWN0LmNvbnRleHQudmlzaWJsZSB8fCBkaXNwbGF5T2JqZWN0LmNvbnRleHQuZ2xvYmFsQWxwaGEgPD0gMCApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjdHggPSBzdGFnZS5jdHg7XG4gICAgICAgIFxuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5ncmFwaGljc0RhdGEgKXtcbiAgICAgICAgICAgIC8v5b2T5riy5p+T5Zmo5byA5aeL5riy5p+TYXBw55qE5pe25YCZ77yMYXBw5LiL6Z2i55qE5omA5pyJZGlzcGxheU9iamVjdOmDveW3sue7j+WHhuWkh+WlveS6huWvueW6lOeahOS4lueVjOefqemYtVxuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybS5hcHBseSggY3R4ICwgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS50b0FycmF5KCkgKTtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuX2RyYXcoIHN0YWdlLCB0aGlzICk7Ly9fZHJhd+S8muWujOaIkOe7mOWItuWHhuWkh+WlvSBncmFwaGljc0RhdGFcbiAgICAgICAgICAgIHRoaXMuQ0dSLnJlbmRlciggZGlzcGxheU9iamVjdCAsIHN0YWdlLCB0aGlzICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGRpc3BsYXlPYmplY3QuY2hpbGRyZW4gKXtcblx0ICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgXHR0aGlzLl9yZW5kZXIoIHN0YWdlICwgZGlzcGxheU9iamVjdC5jaGlsZHJlbltpXSApO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cbiAgICB9XG5cbiAgICBfY2xlYXIoIHN0YWdlIClcbiAgICB7XG4gICAgICAgIHZhciBjdHggPSBzdGFnZS5jdHg7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0uYXBwbHkoIGN0eCAsIHN0YWdlLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkoKSApO1xuICAgICAgICBjdHguY2xlYXJSZWN0KCAwLCAwLCB0aGlzLmFwcC53aWR0aCAsIHRoaXMuYXBwLmhlaWdodCApO1xuICAgIH1cbn1cblxuIiwiXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSB3ZWJHTCBDb250ZXh0XG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGdldCB0aGUgY29udGV4dCBmcm9tXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBBbiBvcHRpb25zIG9iamVjdCB0aGF0IGdldHMgcGFzc2VkIGluIHRvIHRoZSBjYW52YXMgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250ZXh0IGF0dHJpYnV0ZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L2dldENvbnRleHQgZm9yIHRoZSBvcHRpb25zIGF2YWlsYWJsZVxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxuICovXG52YXIgY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcywgb3B0aW9ucylcbntcbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fCBcbiAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcblxuICAgIGlmICghZ2wpXG4gICAge1xuICAgICAgICAvLyBmYWlsLCBub3QgYWJsZSB0byBnZXQgYSBjb250ZXh0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd2ViR0wuIFRyeSB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDb250ZXh0O1xuIiwiLy8gdmFyIEdMX01BUCA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0XG4gKiBAcGFyYW0gYXR0cmlicyB7Kn1cbiAqIEBwYXJhbSBzdGF0ZSB7Kn1cbiAqL1xudmFyIHNldFZlcnRleEF0dHJpYkFycmF5cyA9IGZ1bmN0aW9uIChnbCwgYXR0cmlicywgc3RhdGUpXG57XG4gICAgdmFyIGk7XG4gICAgaWYoc3RhdGUpXG4gICAge1xuICAgICAgICB2YXIgdGVtcEF0dHJpYlN0YXRlID0gc3RhdGUudGVtcEF0dHJpYlN0YXRlLFxuICAgICAgICAgICAgYXR0cmliU3RhdGUgPSBzdGF0ZS5hdHRyaWJTdGF0ZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcEF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0ZW1wQXR0cmliU3RhdGVbaV0gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbmV3IGF0dHJpYnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRlbXBBdHRyaWJTdGF0ZVthdHRyaWJzW2ldLmF0dHJpYnV0ZS5sb2NhdGlvbl0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYlN0YXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYXR0cmliU3RhdGVbaV0gIT09IHRlbXBBdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJTdGF0ZVtpXSA9IHRlbXBBdHRyaWJTdGF0ZVtpXTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hdHRyaWJTdGF0ZVtpXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBhdHRyaWJzW2ldO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmliLmF0dHJpYnV0ZS5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFZlcnRleEF0dHJpYkFycmF5cztcbiIsInZhciBFTVBUWV9BUlJBWV9CVUZGRVIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIHdlYkdMIGJ1ZmZlclxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSB0eXBlIHtnbC5BUlJBWV9CVUZGRVIgfCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUn0gQG1hdFxuICogQHBhcmFtIGRhdGEge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGFuIGFycmF5IG9mIGRhdGFcbiAqIEBwYXJhbSBkcmF3VHlwZSB7Z2wuU1RBVElDX0RSQVd8Z2wuRFlOQU1JQ19EUkFXfGdsLlNUUkVBTV9EUkFXfVxuICovXG52YXIgQnVmZmVyID0gZnVuY3Rpb24oZ2wsIHR5cGUsIGRhdGEsIGRyYXdUeXBlKVxue1xuXG5cdC8qKlxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG5cdHRoaXMuZ2wgPSBnbDtcblxuXHQvKipcbiAgICAgKiBUaGUgV2ViR0wgYnVmZmVyLCBjcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICovXG5cdHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0LyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7Z2wuQVJSQVlfQlVGRkVSfGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSfVxuICAgICAqL1xuXHR0aGlzLnR5cGUgPSB0eXBlIHx8IGdsLkFSUkFZX0JVRkZFUjtcblxuXHQvKipcbiAgICAgKiBUaGUgZHJhdyB0eXBlIG9mIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2dsLlNUQVRJQ19EUkFXfGdsLkRZTkFNSUNfRFJBV3xnbC5TVFJFQU1fRFJBV31cbiAgICAgKi9cblx0dGhpcy5kcmF3VHlwZSA9IGRyYXdUeXBlIHx8IGdsLlNUQVRJQ19EUkFXO1xuXG5cdC8qKlxuICAgICAqIFRoZSBkYXRhIGluIHRoZSBidWZmZXIsIGFzIGEgdHlwZWQgYXJyYXlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9XG4gICAgICovXG5cdHRoaXMuZGF0YSA9IEVNUFRZX0FSUkFZX0JVRkZFUjtcblxuXHRpZihkYXRhKVxuXHR7XG5cdFx0dGhpcy51cGxvYWQoZGF0YSk7XG5cdH1cblxuXHR0aGlzLl91cGRhdGVJRCA9IDA7XG59O1xuXG4vKipcbiAqIFVwbG9hZHMgdGhlIGJ1ZmZlciB0byB0aGUgR1BVXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXlCdWZmZXJ8IFNoYXJlZEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gYW4gYXJyYXkgb2YgZGF0YSB0byB1cGxvYWRcbiAqIEBwYXJhbSBvZmZzZXQge051bWJlcn0gaWYgb25seSBhIHN1YnNldCBvZiB0aGUgZGF0YSBzaG91bGQgYmUgdXBsb2FkZWQsIHRoaXMgaXMgdGhlIGFtb3VudCBvZiBkYXRhIHRvIHN1YnRyYWN0XG4gKiBAcGFyYW0gZG9udEJpbmQge0Jvb2xlYW59IHdoZXRoZXIgdG8gYmluZCB0aGUgYnVmZmVyIGJlZm9yZSB1cGxvYWRpbmcgaXRcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIGRvbnRCaW5kKVxue1xuXHQvLyB0b2RvIC0gbmVlZGVkP1xuXHRpZighZG9udEJpbmQpIHRoaXMuYmluZCgpO1xuXG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0ZGF0YSA9IGRhdGEgfHwgdGhpcy5kYXRhO1xuXHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuXHRpZih0aGlzLmRhdGEuYnl0ZUxlbmd0aCA+PSBkYXRhLmJ5dGVMZW5ndGgpXG5cdHtcblx0XHRnbC5idWZmZXJTdWJEYXRhKHRoaXMudHlwZSwgb2Zmc2V0LCBkYXRhKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRnbC5idWZmZXJEYXRhKHRoaXMudHlwZSwgZGF0YSwgdGhpcy5kcmF3VHlwZSk7XG5cdH1cblxuXHR0aGlzLmRhdGEgPSBkYXRhO1xufTtcbi8qKlxuICogQmluZHMgdGhlIGJ1ZmZlclxuICpcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXHRnbC5iaW5kQnVmZmVyKHRoaXMudHlwZSwgdGhpcy5idWZmZXIpO1xufTtcblxuQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uKGdsLCBkYXRhLCBkcmF3VHlwZSlcbntcblx0cmV0dXJuIG5ldyBCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZHJhd1R5cGUpO1xufTtcblxuQnVmZmVyLmNyZWF0ZUluZGV4QnVmZmVyID0gZnVuY3Rpb24oZ2wsIGRhdGEsIGRyYXdUeXBlKVxue1xuXHRyZXR1cm4gbmV3IEJ1ZmZlcihnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGRhdGEsIGRyYXdUeXBlKTtcbn07XG5cbkJ1ZmZlci5jcmVhdGUgPSBmdW5jdGlvbihnbCwgdHlwZSwgZGF0YSwgZHJhd1R5cGUpXG57XG5cdHJldHVybiBuZXcgQnVmZmVyKGdsLCB0eXBlLCBkYXRhLCBkcmF3VHlwZSk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBidWZmZXJcbiAqXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuIiwiXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSBXZWJHTCBUZXh0dXJlXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0XG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBmb3JtYXQge251bWJlcn0gdGhlIHBpeGVsIGZvcm1hdCBvZiB0aGUgdGV4dHVyZS4gZGVmYXVsdHMgdG8gZ2wuUkdCQVxuICogQHBhcmFtIHR5cGUge251bWJlcn0gdGhlIGdsIHR5cGUgb2YgdGhlIHRleHR1cmUuIGRlZmF1bHRzIHRvIGdsLlVOU0lHTkVEX0JZVEVcbiAqL1xudmFyIFRleHR1cmUgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKVxue1xuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcblx0ICpcblx0ICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuXHQgKi9cblx0dGhpcy5nbCA9IGdsO1xuXG5cblx0LyoqXG5cdCAqIFRoZSBXZWJHTCB0ZXh0dXJlXG5cdCAqXG5cdCAqIEBtZW1iZXIge1dlYkdMVGV4dHVyZX1cblx0ICovXG5cdHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHQvKipcblx0ICogSWYgbWlwbWFwcGluZyB3YXMgdXNlZCBmb3IgdGhpcyB0ZXh0dXJlLCBlbmFibGUgYW5kIGRpc2FibGUgd2l0aCBlbmFibGVNaXBtYXAoKVxuXHQgKlxuXHQgKiBAbWVtYmVyIHtCb29sZWFufVxuXHQgKi9cblx0Ly8gc29tZSBzZXR0aW5ncy4uXG5cdHRoaXMubWlwbWFwID0gZmFsc2U7XG5cblxuXHQvKipcblx0ICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHByZS1tdWx0aXBsaWVkIGFscGhhXG5cdCAqXG5cdCAqIEBtZW1iZXIge0Jvb2xlYW59XG5cdCAqL1xuXHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcblxuXHQvKipcblx0ICogVGhlIHdpZHRoIG9mIHRleHR1cmVcblx0ICpcblx0ICogQG1lbWJlciB7TnVtYmVyfVxuXHQgKi9cblx0dGhpcy53aWR0aCA9IHdpZHRoIHx8IC0xO1xuXHQvKipcblx0ICogVGhlIGhlaWdodCBvZiB0ZXh0dXJlXG5cdCAqXG5cdCAqIEBtZW1iZXIge051bWJlcn1cblx0ICovXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IC0xO1xuXG5cdC8qKlxuXHQgKiBUaGUgcGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLiBkZWZhdWx0cyB0byBnbC5SR0JBXG5cdCAqXG5cdCAqIEBtZW1iZXIge051bWJlcn1cblx0ICovXG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0IHx8IGdsLlJHQkE7XG5cblx0LyoqXG5cdCAqIFRoZSBnbCB0eXBlIG9mIHRoZSB0ZXh0dXJlLiBkZWZhdWx0cyB0byBnbC5VTlNJR05FRF9CWVRFXG5cdCAqXG5cdCAqIEBtZW1iZXIge051bWJlcn1cblx0ICovXG5cdHRoaXMudHlwZSA9IHR5cGUgfHwgZ2wuVU5TSUdORURfQllURTtcblxuXG59O1xuXG4vKipcbiAqIFVwbG9hZHMgdGhpcyB0ZXh0dXJlIHRvIHRoZSBHUFVcbiAqIEBwYXJhbSBzb3VyY2Uge0hUTUxJbWFnZUVsZW1lbnR8SW1hZ2VEYXRhfEhUTUxWaWRlb0VsZW1lbnR9IHRoZSBzb3VyY2UgaW1hZ2Ugb2YgdGhlIHRleHR1cmVcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24oc291cmNlKVxue1xuXHR0aGlzLmJpbmQoKTtcblxuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cblx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnByZW11bHRpcGx5QWxwaGEpO1xuXG5cdHZhciBuZXdXaWR0aCA9IHNvdXJjZS52aWRlb1dpZHRoIHx8IHNvdXJjZS53aWR0aDtcblx0dmFyIG5ld0hlaWdodCA9IHNvdXJjZS52aWRlb0hlaWdodCB8fCBzb3VyY2UuaGVpZ2h0O1xuXG5cdGlmKG5ld0hlaWdodCAhPT0gdGhpcy5oZWlnaHQgfHwgbmV3V2lkdGggIT09IHRoaXMud2lkdGgpXG5cdHtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBzb3VyY2UpO1xuXHR9XG5cdGVsc2Vcblx0e1xuICAgIFx0Z2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBzb3VyY2UpO1xuXHR9XG5cblx0Ly8gaWYgdGhlIHNvdXJjZSBpcyBhIHZpZGVvLCB3ZSBuZWVkIHRvIHVzZSB0aGUgdmlkZW9XaWR0aCAvIHZpZGVvSGVpZ2h0IHByb3BlcnRpZXMgYXMgd2lkdGggLyBoZWlnaHQgd2lsbCBiZSBpbmNvcnJlY3QuXG5cdHRoaXMud2lkdGggPSBuZXdXaWR0aDtcblx0dGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cbn07XG5cbnZhciBGTE9BVElOR19QT0lOVF9BVkFJTEFCTEUgPSBmYWxzZTtcblxuLyoqXG4gKiBVc2UgYSBkYXRhIHNvdXJjZSBhbmQgdXBsb2FkcyB0aGlzIHRleHR1cmUgdG8gdGhlIEdQVVxuICogQHBhcmFtIGRhdGEge1R5cGVkQXJyYXl9IHRoZSBkYXRhIHRvIHVwbG9hZCB0byB0aGUgdGV4dHVyZVxuICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IHRoZSBuZXcgd2lkdGggb2YgdGhlIHRleHR1cmVcbiAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUudXBsb2FkRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIHdpZHRoLCBoZWlnaHQpXG57XG5cdHRoaXMuYmluZCgpO1xuXG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblxuXHRpZihkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxuXHR7XG5cdFx0aWYoIUZMT0FUSU5HX1BPSU5UX0FWQUlMQUJMRSlcblx0XHR7XG5cdFx0XHR2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIik7XG5cblx0XHRcdGlmKGV4dClcblx0XHRcdHtcblx0XHRcdFx0RkxPQVRJTkdfUE9JTlRfQVZBSUxBQkxFID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdmbG9hdGluZyBwb2ludCB0ZXh0dXJlcyBub3QgYXZhaWxhYmxlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50eXBlID0gZ2wuRkxPQVQ7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0Ly8gVE9ETyBzdXBwb3J0IGZvciBvdGhlciB0eXBlc1xuXHRcdHRoaXMudHlwZSA9IHRoaXMudHlwZSB8fCBnbC5VTlNJR05FRF9CWVRFO1xuXHR9XG5cblx0Ly8gd2hhdCB0eXBlIG9mIGRhdGE/XG5cdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVtdWx0aXBseUFscGhhKTtcblxuXG5cdGlmKHdpZHRoICE9PSB0aGlzLndpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5oZWlnaHQpXG5cdHtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCAgd2lkdGgsIGhlaWdodCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGF0YSB8fCBudWxsKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGRhdGEgfHwgbnVsbCk7XG5cdH1cblxuXHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cbi8vXHR0ZXhTdWJJbWFnZTJEXG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gIGxvY2F0aW9uXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihsb2NhdGlvbilcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHRpZihsb2NhdGlvbiAhPT0gdW5kZWZpbmVkKVxuXHR7XG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcblx0fVxuXG5cdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG59O1xuXG4vKipcbiAqIFVuYmluZHMgdGhlIHRleHR1cmVcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGxpbmVhciB7Qm9vbGVhbn0gaWYgd2Ugd2FudCB0byB1c2UgbGluZWFyIGZpbHRlcmluZyBvciBuZWFyZXN0IG5laWdoYm91ciBpbnRlcnBvbGF0aW9uXG4gKi9cblRleHR1cmUucHJvdG90eXBlLm1pbkZpbHRlciA9IGZ1bmN0aW9uKCBsaW5lYXIgKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdGlmKHRoaXMubWlwbWFwKVxuXHR7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGxpbmVhciA/IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIDogZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCk7XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGxpbmVhciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSBsaW5lYXIge0Jvb2xlYW59IGlmIHdlIHdhbnQgdG8gdXNlIGxpbmVhciBmaWx0ZXJpbmcgb3IgbmVhcmVzdCBuZWlnaGJvdXIgaW50ZXJwb2xhdGlvblxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5tYWdGaWx0ZXIgPSBmdW5jdGlvbiggbGluZWFyIClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbGluZWFyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgbWlwbWFwcGluZ1xuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVNaXBtYXAgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0dGhpcy5taXBtYXAgPSB0cnVlO1xuXG5cdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIGxpbmVhciBmaWx0ZXJpbmdcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuZW5hYmxlTGluZWFyU2NhbGluZyA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5taW5GaWx0ZXIodHJ1ZSk7XG5cdHRoaXMubWFnRmlsdGVyKHRydWUpO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIG5lYXJlc3QgbmVpZ2hib3VyIGludGVycG9sYXRpb25cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuZW5hYmxlTmVhcmVzdFNjYWxpbmcgPSBmdW5jdGlvbigpXG57XG5cdHRoaXMubWluRmlsdGVyKGZhbHNlKTtcblx0dGhpcy5tYWdGaWx0ZXIoZmFsc2UpO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIGNsYW1waW5nIG9uIHRoZSB0ZXh0dXJlIHNvIFdlYkdMIHdpbGwgbm90IHJlcGVhdCBpdFxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVXcmFwQ2xhbXAgPSBmdW5jdGlvbigpXG57XG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cblx0dGhpcy5iaW5kKCk7XG5cblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0aWxpbmcgb24gdGhlIHRleHR1cmVcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuZW5hYmxlV3JhcFJlcGVhdCA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblxuXHR0aGlzLmJpbmQoKTtcblxuXHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5lbmFibGVXcmFwTWlycm9yUmVwZWF0ID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZ2wgPSB0aGlzLmdsO1xuXG5cdHRoaXMuYmluZCgpO1xuXG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLk1JUlJPUkVEX1JFUEVBVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuTUlSUk9SRURfUkVQRUFUKTtcbn07XG5cblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcblx0dmFyIGdsID0gdGhpcy5nbDtcblx0Ly9UT0RPXG5cdGdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSBzb3VyY2Uge0hUTUxJbWFnZUVsZW1lbnR8SW1hZ2VEYXRhfSB0aGUgc291cmNlIGltYWdlIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gcHJlbXVsdGlwbHlBbHBoYSB7Qm9vbGVhbn0gSWYgd2Ugd2FudCB0byB1c2UgcHJlLW11bHRpcGxpZWQgYWxwaGFcbiAqL1xuVGV4dHVyZS5mcm9tU291cmNlID0gZnVuY3Rpb24oZ2wsIHNvdXJjZSwgcHJlbXVsdGlwbHlBbHBoYSlcbntcblx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCk7XG5cdHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHByZW11bHRpcGx5QWxwaGEgfHwgZmFsc2U7XG5cdHRleHR1cmUudXBsb2FkKHNvdXJjZSk7XG5cblx0cmV0dXJuIHRleHR1cmU7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0XG4gKiBAcGFyYW0gZGF0YSB7VHlwZWRBcnJheX0gdGhlIGRhdGEgdG8gdXBsb2FkIHRvIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0gd2lkdGgge251bWJlcn0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21EYXRhID0gZnVuY3Rpb24oZ2wsIGRhdGEsIHdpZHRoLCBoZWlnaHQpXG57XG5cdC8vY29uc29sZS5sb2coZGF0YSwgd2lkdGgsIGhlaWdodCk7XG5cdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoZ2wpO1xuXHR0ZXh0dXJlLnVwbG9hZERhdGEoZGF0YSwgd2lkdGgsIGhlaWdodCk7XG5cblx0cmV0dXJuIHRleHR1cmU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZTtcbiIsIlxudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL0dMVGV4dHVyZScpO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSB3ZWJHTCBGcmFtZWJ1ZmZlclxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSB3aWR0aCB7TnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKiBAcGFyYW0gaGVpZ2h0IHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgZnJhbWUgYnVmZmVyXG4gKi9cbnZhciBGcmFtZWJ1ZmZlciA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0KVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xGcmFtZWJ1ZmZlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJidWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdGVuY2lsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5nbENvcmUuR0xUZXh0dXJlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGRyYXdpbmcgYXJlYSBvZiB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDEwMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDEwMDtcbn07XG5cbi8qKlxuICogQWRkcyBhIHRleHR1cmUgdG8gdGhlIGZyYW1lIGJ1ZmZlclxuICogQHBhcmFtIHRleHR1cmUge1BJWEkuZ2xDb3JlLkdMVGV4dHVyZX1cbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLmVuYWJsZVRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlIHx8IG5ldyBUZXh0dXJlKGdsKTtcblxuICAgIHRoaXMudGV4dHVyZS5iaW5kKCk7XG5cbiAgICAvL2dsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgIHRoaXMuYmluZCgpO1xuXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUudGV4dHVyZSwgMCk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpc2VzIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuZW5hYmxlU3RlbmNpbCA9IGZ1bmN0aW9uKClcbntcbiAgICBpZih0aGlzLnN0ZW5jaWwpcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMuc3RlbmNpbCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbCk7XG5cbiAgICAvLyBUT0RPLi4gdGhpcyBpcyBkZXB0aCBBTkQgc3RlbmNpbD9cbiAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbCk7XG4gICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsICB0aGlzLndpZHRoICAsIHRoaXMuaGVpZ2h0ICk7XG5cblxufTtcblxuLyoqXG4gKiBFcmFzZXMgdGhlIGRyYXdpbmcgYXJlYSBhbmQgZmlsbHMgaXQgd2l0aCBhIGNvbG91clxuICogQHBhcmFtICByIHtOdW1iZXJ9IHRoZSByZWQgdmFsdWUgb2YgdGhlIGNsZWFyaW5nIGNvbG91clxuICogQHBhcmFtICBnIHtOdW1iZXJ9IHRoZSBncmVlbiB2YWx1ZSBvZiB0aGUgY2xlYXJpbmcgY29sb3VyXG4gKiBAcGFyYW0gIGIge051bWJlcn0gdGhlIGJsdWUgdmFsdWUgb2YgdGhlIGNsZWFyaW5nIGNvbG91clxuICogQHBhcmFtICBhIHtOdW1iZXJ9IHRoZSBhbHBoYSB2YWx1ZSBvZiB0aGUgY2xlYXJpbmcgY29sb3VyXG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCByLCBnLCBiLCBhIClcbntcbiAgICB0aGlzLmJpbmQoKTtcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIGZyYW1lIGJ1ZmZlciB0byB0aGUgV2ViR0wgY29udGV4dFxuICovXG5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlciApO1xufTtcblxuLyoqXG4gKiBVbmJpbmRzIHRoZSBmcmFtZSBidWZmZXIgdG8gdGhlIFdlYkdMIGNvbnRleHRcbiAqL1xuRnJhbWVidWZmZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xufTtcbi8qKlxuICogUmVzaXplcyB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBidWZmZXIgdG8gdGhlIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAqIEBwYXJhbSAgd2lkdGggIHtOdW1iZXJ9IHRoZSBuZXcgd2lkdGhcbiAqIEBwYXJhbSAgaGVpZ2h0IHtOdW1iZXJ9IHRoZSBuZXcgaGVpZ2h0XG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBpZiAoIHRoaXMudGV4dHVyZSApXG4gICAge1xuICAgICAgICB0aGlzLnRleHR1cmUudXBsb2FkRGF0YShudWxsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuc3RlbmNpbCApXG4gICAge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0ZW5jaWwgYnVmZmVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbCk7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgYnVmZmVyXG4gKi9cbkZyYW1lYnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICAvL1RPRE9cbiAgICBpZih0aGlzLnRleHR1cmUpXG4gICAge1xuICAgICAgICB0aGlzLnRleHR1cmUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuXG4gICAgdGhpcy5nbCA9IG51bGw7XG5cbiAgICB0aGlzLnN0ZW5jaWwgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmcmFtZSBidWZmZXIgd2l0aCBhIHRleHR1cmUgY29udGFpbmluZyB0aGUgZ2l2ZW4gZGF0YVxuICogQHN0YXRpY1xuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gd2lkdGgge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICogQHBhcmFtIGhlaWdodCB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBkcmF3aW5nIGFyZWEgb2YgdGhlIGZyYW1lIGJ1ZmZlclxuICogQHBhcmFtIGRhdGEge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGFuIGFycmF5IG9mIGRhdGFcbiAqL1xuRnJhbWVidWZmZXIuY3JlYXRlUkdCQSA9IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCBkYXRhKVxue1xuICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tRGF0YShnbCwgbnVsbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGV4dHVyZS5lbmFibGVOZWFyZXN0U2NhbGluZygpO1xuICAgIHRleHR1cmUuZW5hYmxlV3JhcENsYW1wKCk7XG5cbiAgICAvL25vdyBjcmVhdGUgdGhlIGZyYW1lYnVmZmVyIG9iamVjdCBhbmQgYXR0YWNoIHRoZSB0ZXh0dXJlIHRvIGl0LlxuICAgIHZhciBmYm8gPSBuZXcgRnJhbWVidWZmZXIoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZiby5lbmFibGVUZXh0dXJlKHRleHR1cmUpO1xuXG4gICAgLy9mYm8uZW5hYmxlU3RlbmNpbCgpOyAvLyBnZXQgdGhpcyBiYWNrIG9uIHNvb24hXG5cbiAgICBmYm8udW5iaW5kKCk7XG5cbiAgICByZXR1cm4gZmJvO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJhbWUgYnVmZmVyIHdpdGggYSB0ZXh0dXJlIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGRhdGFcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICogQHBhcmFtIHdpZHRoIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSBoZWlnaHQge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgZHJhd2luZyBhcmVhIG9mIHRoZSBmcmFtZSBidWZmZXJcbiAqIEBwYXJhbSBkYXRhIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBhbiBhcnJheSBvZiBkYXRhXG4gKi9cbkZyYW1lYnVmZmVyLmNyZWF0ZUZsb2F0MzIgPSBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgZGF0YSlcbntcbiAgICAvLyBjcmVhdGUgYSBuZXcgdGV4dHVyZS4uXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZS5mcm9tRGF0YShnbCwgZGF0YSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGV4dHVyZS5lbmFibGVOZWFyZXN0U2NhbGluZygpO1xuICAgIHRleHR1cmUuZW5hYmxlV3JhcENsYW1wKCk7XG5cbiAgICAvL25vdyBjcmVhdGUgdGhlIGZyYW1lYnVmZmVyIG9iamVjdCBhbmQgYXR0YWNoIHRoZSB0ZXh0dXJlIHRvIGl0LlxuICAgIHZhciBmYm8gPSBuZXcgRnJhbWVidWZmZXIoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZiby5lbmFibGVUZXh0dXJlKHRleHR1cmUpO1xuXG4gICAgZmJvLnVuYmluZCgpO1xuXG4gICAgcmV0dXJuIGZibztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWVidWZmZXI7XG4iLCJcbi8qKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCB7V2ViR0xQcm9ncmFtfVxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBmcmFnbWVudFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIGF0dHJpYnV0ZUxvY2F0aW9ucyB7T2JqZWN0fSBBbiBhdHRyaWJ1dGUgbG9jYXRpb24gbWFwIHRoYXQgbGV0cyB5b3UgbWFudWFsbHkgc2V0IHRoZSBhdHRyaWJ1dGUgbG9jYXRpb25zXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19IHRoZSBzaGFkZXIgcHJvZ3JhbVxuICovXG52YXIgY29tcGlsZVByb2dyYW0gPSBmdW5jdGlvbihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmlidXRlTG9jYXRpb25zKVxue1xuICAgIHZhciBnbFZlcnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTcmMpO1xuICAgIHZhciBnbEZyYWdTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U3JjKTtcblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsVmVydFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsRnJhZ1NoYWRlcik7XG5cbiAgICAvLyBvcHRpb25hbGx5LCBzZXQgdGhlIGF0dHJpYnV0ZXMgbWFudWFsbHkgZm9yIHRoZSBwcm9ncmFtIHJhdGhlciB0aGFuIGxldHRpbmcgV2ViR0wgZGVjaWRlLi5cbiAgICBpZihhdHRyaWJ1dGVMb2NhdGlvbnMpXG4gICAge1xuICAgICAgICBmb3IodmFyIGkgaW4gYXR0cmlidXRlTG9jYXRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlTG9jYXRpb25zW2ldLCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBpZiBsaW5raW5nIGZhaWxzLCB0aGVuIGxvZyBhbmQgY2xlYW51cFxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpXG4gICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdQaXhpLmpzIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLmdldEVycm9yKCknLCBnbC5nZXRFcnJvcigpKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHByb2dyYW0gaW5mbyBsb2csIGxvZyBpdFxuICAgICAgICBpZiAoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkgIT09ICcnKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpeGkuanMgV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGNsZWFuIHVwIHNvbWUgc2hhZGVyc1xuICAgIGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRTaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdTaGFkZXIpO1xuXG4gICAgcmV0dXJuIHByb2dyYW07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCB7V2ViR0xQcm9ncmFtfVxuICogQHBhcmFtIHR5cGUge051bWJlcn0gdGhlIHR5cGUsIGNhbiBiZSBlaXRoZXIgVkVSVEVYX1NIQURFUiBvciBGUkFHTUVOVF9TSEFERVJcbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gdGhlIHNoYWRlclxuICovXG52YXIgY29tcGlsZVNoYWRlciA9IGZ1bmN0aW9uIChnbCwgdHlwZSwgc3JjKVxue1xuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZVByb2dyYW07XG4iLCJcblxudmFyIG1hcFNpemUgPSBmdW5jdGlvbihnbCwgdHlwZSkgXG57XG4gICAgaWYoIUdMX1RBQkxFKSBcbiAgICB7XG4gICAgICAgIHZhciB0eXBlTmFtZXMgPSBPYmplY3Qua2V5cyhHTF9UT19HTFNMX1RZUEVTKTtcblxuICAgICAgICBHTF9UQUJMRSA9IHt9O1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0eXBlTmFtZXMubGVuZ3RoOyArK2kpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdG4gPSB0eXBlTmFtZXNbaV07XG4gICAgICAgICAgICBHTF9UQUJMRVsgZ2xbdG5dIF0gPSBHTF9UT19HTFNMX1RZUEVTW3RuXTtcbiAgICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gR0xfVEFCTEVbdHlwZV07XG59O1xuXG52YXIgR0xfVEFCTEUgPSBudWxsO1xuXG52YXIgR0xfVE9fR0xTTF9UWVBFUyA9IHtcbiAgJ0ZMT0FUJzogICAgICAgJ2Zsb2F0JyxcbiAgJ0ZMT0FUX1ZFQzInOiAgJ3ZlYzInLFxuICAnRkxPQVRfVkVDMyc6ICAndmVjMycsXG4gICdGTE9BVF9WRUM0JzogICd2ZWM0JyxcblxuICAnSU5UJzogICAgICAgICAnaW50JyxcbiAgJ0lOVF9WRUMyJzogICAgJ2l2ZWMyJyxcbiAgJ0lOVF9WRUMzJzogICAgJ2l2ZWMzJyxcbiAgJ0lOVF9WRUM0JzogICAgJ2l2ZWM0JyxcbiAgXG4gICdCT09MJzogICAgICAgICdib29sJyxcbiAgJ0JPT0xfVkVDMic6ICAgJ2J2ZWMyJyxcbiAgJ0JPT0xfVkVDMyc6ICAgJ2J2ZWMzJyxcbiAgJ0JPT0xfVkVDNCc6ICAgJ2J2ZWM0JyxcbiAgXG4gICdGTE9BVF9NQVQyJzogICdtYXQyJyxcbiAgJ0ZMT0FUX01BVDMnOiAgJ21hdDMnLFxuICAnRkxPQVRfTUFUNCc6ICAnbWF0NCcsXG4gIFxuICAnU0FNUExFUl8yRCc6ICAnc2FtcGxlcjJEJyAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFNpemU7XG4iLCIvKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlLnNoYWRlclxuICogQHBhcmFtIHR5cGUge1N0cmluZ31cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIG1hcFNpemUgPSBmdW5jdGlvbih0eXBlKSBcbnsgXG4gICAgcmV0dXJuIEdMU0xfVE9fU0laRVt0eXBlXTtcbn07XG5cblxudmFyIEdMU0xfVE9fU0laRSA9IHtcbiAgICAnZmxvYXQnOiAgICAxLFxuICAgICd2ZWMyJzogICAgIDIsXG4gICAgJ3ZlYzMnOiAgICAgMyxcbiAgICAndmVjNCc6ICAgICA0LFxuXG4gICAgJ2ludCc6ICAgICAgMSxcbiAgICAnaXZlYzInOiAgICAyLFxuICAgICdpdmVjMyc6ICAgIDMsXG4gICAgJ2l2ZWM0JzogICAgNCxcblxuICAgICdib29sJzogICAgIDEsXG4gICAgJ2J2ZWMyJzogICAgMixcbiAgICAnYnZlYzMnOiAgICAzLFxuICAgICdidmVjNCc6ICAgIDQsXG5cbiAgICAnbWF0Mic6ICAgICA0LFxuICAgICdtYXQzJzogICAgIDksXG4gICAgJ21hdDQnOiAgICAgMTYsXG5cbiAgICAnc2FtcGxlcjJEJzogIDFcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwU2l6ZTtcbiIsIlxudmFyIG1hcFR5cGUgPSByZXF1aXJlKCcuL21hcFR5cGUnKTtcbnZhciBtYXBTaXplID0gcmVxdWlyZSgnLi9tYXBTaXplJyk7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGF0dHJpYnV0ZXNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlLnNoYWRlclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gcHJvZ3JhbSB7V2ViR0xQcm9ncmFtfSBUaGUgc2hhZGVyIHByb2dyYW0gdG8gZ2V0IHRoZSBhdHRyaWJ1dGVzIGZyb21cbiAqIEByZXR1cm4gYXR0cmlidXRlcyB7T2JqZWN0fVxuICovXG52YXIgZXh0cmFjdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSlcbntcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgdmFyIHRvdGFsQXR0cmlidXRlcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbEF0dHJpYnV0ZXM7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWJEYXRhID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpO1xuICAgICAgICB2YXIgdHlwZSA9IG1hcFR5cGUoZ2wsIGF0dHJpYkRhdGEudHlwZSk7XG5cbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJEYXRhLm5hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTp0eXBlLFxuICAgICAgICAgICAgc2l6ZTptYXBTaXplKHR5cGUpLFxuICAgICAgICAgICAgbG9jYXRpb246Z2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmliRGF0YS5uYW1lKSxcbiAgICAgICAgICAgIC8vVE9ETyAtIG1ha2UgYW4gYXR0cmlidXRlIG9iamVjdFxuICAgICAgICAgICAgcG9pbnRlcjogcG9pbnRlclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxudmFyIHBvaW50ZXIgPSBmdW5jdGlvbih0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIHN0YXJ0KXtcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmxvY2F0aW9uKVxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5sb2NhdGlvbix0aGlzLnNpemUsIHR5cGUgfHwgZ2wuRkxPQVQsIG5vcm1hbGl6ZWQgfHwgZmFsc2UsIHN0cmlkZSB8fCAwLCBzdGFydCB8fCAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0cmFjdEF0dHJpYnV0ZXM7XG4iLCIvKipcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlLnNoYWRlclxuICogQHBhcmFtIHR5cGUge1N0cmluZ30gVHlwZSBvZiB2YWx1ZVxuICogQHBhcmFtIHNpemUge051bWJlcn1cbiAqL1xudmFyIGRlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIFxue1xuICAgIHN3aXRjaCAodHlwZSlcbiAgICB7XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGNhc2UgJ3ZlYzInOiBcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDIgKiBzaXplKTtcblxuICAgICAgICBjYXNlICd2ZWMzJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDMgKiBzaXplKTtcblxuICAgICAgICBjYXNlICd2ZWM0JzogICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCAqIHNpemUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ2ludCc6XG4gICAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBjYXNlICdpdmVjMic6ICAgXG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMiAqIHNpemUpO1xuXG4gICAgICAgIGNhc2UgJ2l2ZWMzJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgzICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAnaXZlYzQnOiBcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSg0ICogc2l6ZSk7XG5cbiAgICAgICAgY2FzZSAnYm9vbCc6ICAgICBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjYXNlICdidmVjMic6XG5cbiAgICAgICAgICAgIHJldHVybiBib29sZWFuQXJyYXkoIDIgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdidmVjMyc6XG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDMgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdidmVjNCc6XG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDQgKiBzaXplKTtcblxuICAgICAgICBjYXNlICdtYXQyJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDFdKTtcblxuICAgICAgICBjYXNlICdtYXQzJzogXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDFdKTtcblxuICAgICAgICBjYXNlICdtYXQ0JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAxXSk7XG4gICAgfVxufTtcblxudmFyIGJvb2xlYW5BcnJheSA9IGZ1bmN0aW9uKHNpemUpXG57XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgXG4gICAge1xuICAgICAgICBhcnJheVtpXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdFZhbHVlO1xuIiwidmFyIG1hcFR5cGUgPSByZXF1aXJlKCcuL21hcFR5cGUnKTtcbnZhciBkZWZhdWx0VmFsdWUgPSByZXF1aXJlKCcuL2RlZmF1bHRWYWx1ZScpO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSB1bmlmb3Jtc1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBwYXJhbSBwcm9ncmFtIHtXZWJHTFByb2dyYW19IFRoZSBzaGFkZXIgcHJvZ3JhbSB0byBnZXQgdGhlIHVuaWZvcm1zIGZyb21cbiAqIEByZXR1cm4gdW5pZm9ybXMge09iamVjdH1cbiAqL1xudmFyIGV4dHJhY3RVbmlmb3JtcyA9IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKVxue1xuXHR2YXIgdW5pZm9ybXMgPSB7fTtcblxuICAgIHZhciB0b3RhbFVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbFVuaWZvcm1zOyBpKyspXG4gICAge1xuICAgIFx0dmFyIHVuaWZvcm1EYXRhID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcbiAgICBcdHZhciBuYW1lID0gdW5pZm9ybURhdGEubmFtZS5yZXBsYWNlKC9cXFsuKj9cXF0vLCBcIlwiKTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXBUeXBlKGdsLCB1bmlmb3JtRGF0YS50eXBlICk7XG5cbiAgICBcdHVuaWZvcm1zW25hbWVdID0ge1xuICAgIFx0XHR0eXBlOnR5cGUsXG4gICAgXHRcdHNpemU6dW5pZm9ybURhdGEuc2l6ZSxcbiAgICBcdFx0bG9jYXRpb246Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxuICAgIFx0XHR2YWx1ZTpkZWZhdWx0VmFsdWUodHlwZSwgdW5pZm9ybURhdGEuc2l6ZSlcbiAgICBcdH07XG4gICAgfVxuXG5cdHJldHVybiB1bmlmb3Jtcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0cmFjdFVuaWZvcm1zO1xuIiwiLyoqXG4gKiBTZXRzIHRoZSBmbG9hdCBwcmVjaXNpb24gb24gdGhlIHNoYWRlci4gSWYgdGhlIHByZWNpc2lvbiBpcyBhbHJlYWR5IHByZXNlbnQgdGhpcyBmdW5jdGlvbiB3aWxsIGRvIG5vdGhpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgICAgICAgdGhlIHNoYWRlciBzb3VyY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVjaXNpb24gVGhlIGZsb2F0IHByZWNpc2lvbiBvZiB0aGUgc2hhZGVyLiBPcHRpb25zIGFyZSAnbG93cCcsICdtZWRpdW1wJyBvciAnaGlnaHAnLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gbW9kaWZpZWQgc2hhZGVyIHNvdXJjZVxuICovXG52YXIgc2V0UHJlY2lzaW9uID0gZnVuY3Rpb24oc3JjLCBwcmVjaXNpb24pXG57XG4gICAgaWYoc3JjLnN1YnN0cmluZygwLCA5KSAhPT0gJ3ByZWNpc2lvbicpXG4gICAge1xuICAgICAgICByZXR1cm4gJ3ByZWNpc2lvbiAnICsgcHJlY2lzaW9uICsgJyBmbG9hdDtcXG4nICsgc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBzcmM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFByZWNpc2lvbjtcbiIsIi8qKlxuICogRXh0cmFjdHMgdGhlIGF0dHJpYnV0ZXNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlLnNoYWRlclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gKiBAcGFyYW0gdW5pZm9ybXMge0FycmF5fSBAbWF0ID9cbiAqIEByZXR1cm4gYXR0cmlidXRlcyB7T2JqZWN0fVxuICovXG52YXIgZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0ID0gZnVuY3Rpb24oZ2wsIHVuaWZvcm1EYXRhKVxue1xuICAgIC8vIHRoaXMgaXMgdGhlIG9iamVjdCB3ZSB3aWxsIGJlIHNlbmRpbmcgYmFjay5cbiAgICAvLyBhbiBvYmplY3QgaGllcmFjaHkgd2lsbCBiZSBjcmVhdGVkIGZvciBzdHJ1Y3RzXG4gICAgdmFyIHVuaWZvcm1zID0ge2RhdGE6e319O1xuXG4gICAgdW5pZm9ybXMuZ2wgPSBnbDtcblxuICAgIHZhciB1bmlmb3JtS2V5cz0gT2JqZWN0LmtleXModW5pZm9ybURhdGEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3JtS2V5cy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHZhciBmdWxsTmFtZSA9IHVuaWZvcm1LZXlzW2ldO1xuXG4gICAgICAgIHZhciBuYW1lVG9rZW5zID0gZnVsbE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lVG9rZW5zW25hbWVUb2tlbnMubGVuZ3RoIC0gMV07XG5cblxuICAgICAgICB2YXIgdW5pZm9ybUdyb3VwID0gZ2V0VW5pZm9ybUdyb3VwKG5hbWVUb2tlbnMsIHVuaWZvcm1zKTtcblxuICAgICAgICB2YXIgdW5pZm9ybSA9ICB1bmlmb3JtRGF0YVtmdWxsTmFtZV07XG4gICAgICAgIHVuaWZvcm1Hcm91cC5kYXRhW25hbWVdID0gdW5pZm9ybTtcblxuICAgICAgICB1bmlmb3JtR3JvdXAuZ2wgPSBnbDtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodW5pZm9ybUdyb3VwLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGdlbmVyYXRlR2V0dGVyKG5hbWUpLFxuICAgICAgICAgICAgc2V0OiBnZW5lcmF0ZVNldHRlcihuYW1lLCB1bmlmb3JtKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pZm9ybXM7XG59O1xuXG52YXIgZ2VuZXJhdGVHZXR0ZXIgPSBmdW5jdGlvbihuYW1lKVxue1xuXHR2YXIgdGVtcGxhdGUgPSBnZXR0ZXJUZW1wbGF0ZS5yZXBsYWNlKCclJScsIG5hbWUpO1xuXHRyZXR1cm4gbmV3IEZ1bmN0aW9uKHRlbXBsYXRlKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59O1xuXG52YXIgZ2VuZXJhdGVTZXR0ZXIgPSBmdW5jdGlvbihuYW1lLCB1bmlmb3JtKVxue1xuICAgIHZhciB0ZW1wbGF0ZSA9IHNldHRlclRlbXBsYXRlLnJlcGxhY2UoLyUlL2csIG5hbWUpO1xuICAgIHZhciBzZXRUZW1wbGF0ZTtcblxuICAgIGlmKHVuaWZvcm0uc2l6ZSA9PT0gMSlcbiAgICB7XG4gICAgICAgIHNldFRlbXBsYXRlID0gR0xTTF9UT19TSU5HTEVfU0VUVEVSU1t1bmlmb3JtLnR5cGVdO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBzZXRUZW1wbGF0ZSA9IEdMU0xfVE9fQVJSQVlfU0VUVEVSU1t1bmlmb3JtLnR5cGVdO1xuICAgIH1cblxuICAgIGlmKHNldFRlbXBsYXRlKVxuICAgIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gXCJcXG50aGlzLmdsLlwiICsgc2V0VGVtcGxhdGUgKyBcIjtcIjtcbiAgICB9XG5cbiAgXHRyZXR1cm4gbmV3IEZ1bmN0aW9uKCd2YWx1ZScsIHRlbXBsYXRlKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59O1xuXG52YXIgZ2V0VW5pZm9ybUdyb3VwID0gZnVuY3Rpb24obmFtZVRva2VucywgdW5pZm9ybSlcbntcbiAgICB2YXIgY3VyID0gdW5pZm9ybTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZVRva2Vucy5sZW5ndGggLSAxOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgbyA9IGN1cltuYW1lVG9rZW5zW2ldXSB8fCB7ZGF0YTp7fX07XG4gICAgICAgIGN1cltuYW1lVG9rZW5zW2ldXSA9IG87XG4gICAgICAgIGN1ciA9IG87XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cjtcbn07XG5cbnZhciBnZXR0ZXJUZW1wbGF0ZSA9IFtcbiAgICAncmV0dXJuIHRoaXMuZGF0YS4lJS52YWx1ZTsnLFxuXS5qb2luKCdcXG4nKTtcblxudmFyIHNldHRlclRlbXBsYXRlID0gW1xuICAgICd0aGlzLmRhdGEuJSUudmFsdWUgPSB2YWx1ZTsnLFxuICAgICd2YXIgbG9jYXRpb24gPSB0aGlzLmRhdGEuJSUubG9jYXRpb247J1xuXS5qb2luKCdcXG4nKTtcblxuXG52YXIgR0xTTF9UT19TSU5HTEVfU0VUVEVSUyA9IHtcblxuICAgICdmbG9hdCc6ICAgICd1bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKScsXG5cbiAgICAndmVjMic6ICAgICAndW5pZm9ybTJmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0pJyxcbiAgICAndmVjMyc6ICAgICAndW5pZm9ybTNmKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdKScsXG4gICAgJ3ZlYzQnOiAgICAgJ3VuaWZvcm00Zihsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbM10pJyxcblxuICAgICdpbnQnOiAgICAgICd1bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ2l2ZWMyJzogICAgJ3VuaWZvcm0yaShsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdKScsXG4gICAgJ2l2ZWMzJzogICAgJ3VuaWZvcm0zaShsb2NhdGlvbiwgdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSknLFxuICAgICdpdmVjNCc6ICAgICd1bmlmb3JtNGkobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzNdKScsXG5cbiAgICAnYm9vbCc6ICAgICAndW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdidmVjMic6ICAgICd1bmlmb3JtMmkobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSknLFxuICAgICdidmVjMyc6ICAgICd1bmlmb3JtM2kobG9jYXRpb24sIHZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0pJyxcbiAgICAnYnZlYzQnOiAgICAndW5pZm9ybTRpKGxvY2F0aW9uLCB2YWx1ZVswXSwgdmFsdWVbMV0sIHZhbHVlWzJdLCB2YWx1ZVszXSknLFxuXG4gICAgJ21hdDInOiAgICAgJ3VuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSknLFxuICAgICdtYXQzJzogICAgICd1bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpJyxcbiAgICAnbWF0NCc6ICAgICAndW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKScsXG5cbiAgICAnc2FtcGxlcjJEJzondW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSknXG59O1xuXG52YXIgR0xTTF9UT19BUlJBWV9TRVRURVJTID0ge1xuXG4gICAgJ2Zsb2F0JzogICAgJ3VuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKScsXG5cbiAgICAndmVjMic6ICAgICAndW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAndmVjMyc6ICAgICAndW5pZm9ybTNmdihsb2NhdGlvbiwgdmFsdWUpJyxcbiAgICAndmVjNCc6ICAgICAndW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpJyxcblxuICAgICdpbnQnOiAgICAgICd1bmlmb3JtMWl2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdpdmVjMic6ICAgICd1bmlmb3JtMml2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdpdmVjMyc6ICAgICd1bmlmb3JtM2l2KGxvY2F0aW9uLCB2YWx1ZSknLFxuICAgICdpdmVjNCc6ICAgICd1bmlmb3JtNGl2KGxvY2F0aW9uLCB2YWx1ZSknLFxuXG4gICAgJ2Jvb2wnOiAgICAgJ3VuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ2J2ZWMyJzogICAgJ3VuaWZvcm0yaXYobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ2J2ZWMzJzogICAgJ3VuaWZvcm0zaXYobG9jYXRpb24sIHZhbHVlKScsXG4gICAgJ2J2ZWM0JzogICAgJ3VuaWZvcm00aXYobG9jYXRpb24sIHZhbHVlKScsXG5cbiAgICAnc2FtcGxlcjJEJzondW5pZm9ybTFpdihsb2NhdGlvbiwgdmFsdWUpJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3Q7XG4iLCJcbnZhciBjb21waWxlUHJvZ3JhbSA9IHJlcXVpcmUoJy4vc2hhZGVyL2NvbXBpbGVQcm9ncmFtJyksXG5cdGV4dHJhY3RBdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9zaGFkZXIvZXh0cmFjdEF0dHJpYnV0ZXMnKSxcblx0ZXh0cmFjdFVuaWZvcm1zID0gcmVxdWlyZSgnLi9zaGFkZXIvZXh0cmFjdFVuaWZvcm1zJyksXG5cdHNldFByZWNpc2lvbiA9IHJlcXVpcmUoJy4vc2hhZGVyL3NldFByZWNpc2lvbicpLFxuXHRnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QgPSByZXF1aXJlKCcuL3NoYWRlci9nZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QnKTtcblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gY3JlYXRlIGEgd2ViR0wgU2hhZGVyXG4gKlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBmcmFnbWVudFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIHByZWNpc2lvbiB7cHJlY2lzaW9uXX0gVGhlIGZsb2F0IHByZWNpc2lvbiBvZiB0aGUgc2hhZGVyLiBPcHRpb25zIGFyZSAnbG93cCcsICdtZWRpdW1wJyBvciAnaGlnaHAnLlxuICogQHBhcmFtIGF0dHJpYnV0ZUxvY2F0aW9ucyB7b2JqZWN0fSBBIGtleSB2YWx1ZSBwYWlyIHNob3dpbmcgd2hpY2ggbG9jYXRpb24gZWFjdCBhdHRyaWJ1dGUgc2hvdWxkIHNpdCBlZyB7cG9zaXRpb246MCwgdXZzOjF9XG4gKi9cbnZhciBTaGFkZXIgPSBmdW5jdGlvbihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgcHJlY2lzaW9uLCBhdHRyaWJ1dGVMb2NhdGlvbnMpXG57XG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKlxuXHQgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG5cdCAqL1xuXHR0aGlzLmdsID0gZ2w7XG5cblx0aWYocHJlY2lzaW9uKVxuXHR7XG5cdFx0dmVydGV4U3JjID0gc2V0UHJlY2lzaW9uKHZlcnRleFNyYywgcHJlY2lzaW9uKTtcblx0XHRmcmFnbWVudFNyYyA9IHNldFByZWNpc2lvbihmcmFnbWVudFNyYywgcHJlY2lzaW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgc2hhZGVyIHByb2dyYW1cblx0ICpcblx0ICogQG1lbWJlciB7V2ViR0xQcm9ncmFtfVxuXHQgKi9cblx0Ly8gRmlyc3QgY29tcGlsZSB0aGUgcHJvZ3JhbS4uXG5cdHRoaXMucHJvZ3JhbSA9IGNvbXBpbGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJ1dGVMb2NhdGlvbnMpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYXR0cmlidXRlcyBvZiB0aGUgc2hhZGVyIGFzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuXHQgKiB7XG5cdCAqIFx0dHlwZSxcblx0ICogXHRzaXplLFxuXHQgKiBcdGxvY2F0aW9uLFxuXHQgKiBcdHBvaW50ZXJcblx0ICogfVxuXHQgKiBAbWVtYmVyIHtPYmplY3R9XG5cdCAqL1xuXHQvLyBuZXh0IGV4dHJhY3QgdGhlIGF0dHJpYnV0ZXNcblx0dGhpcy5hdHRyaWJ1dGVzID0gZXh0cmFjdEF0dHJpYnV0ZXMoZ2wsIHRoaXMucHJvZ3JhbSk7XG5cbiAgICB0aGlzLnVuaWZvcm1EYXRhID0gZXh0cmFjdFVuaWZvcm1zKGdsLCB0aGlzLnByb2dyYW0pO1xuXG5cdC8qKlxuXHQgKiBUaGUgdW5pZm9ybXMgb2YgdGhlIHNoYWRlciBhcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcblx0ICoge1xuXHQgKiBcdGdsLFxuXHQgKiBcdGRhdGFcblx0ICogfVxuXHQgKiBAbWVtYmVyIHtPYmplY3R9XG5cdCAqL1xuXHR0aGlzLnVuaWZvcm1zID0gZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0KCBnbCwgdGhpcy51bmlmb3JtRGF0YSApO1xuXG59O1xuLyoqXG4gKiBVc2VzIHRoaXMgc2hhZGVyXG4gKi9cblNoYWRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoaXMgc2hhZGVyXG4gKiBUT0RPXG4gKi9cblNoYWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKClcbntcblx0dGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcblx0dGhpcy51bmlmb3JtRGF0YSA9IG51bGw7XG5cdHRoaXMudW5pZm9ybXMgPSBudWxsO1xuXG5cdHZhciBnbCA9IHRoaXMuZ2w7XG5cdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFkZXI7XG4iLCJcbi8vIHN0YXRlIG9iamVjdC8vXG52YXIgc2V0VmVydGV4QXR0cmliQXJyYXlzID0gcmVxdWlyZSggJy4vc2V0VmVydGV4QXR0cmliQXJyYXlzJyApO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byB3b3JrIHdpdGggV2ViR0wgVmVydGV4QXJyYXlPYmplY3RzICh2YW9zKVxuICogT25seSB3b3JrcyBpZiBXZWJHTCBleHRlbnNpb25zIGFyZSBlbmFibGVkICh0aGV5IHVzdWFsbHkgYXJlKVxuICpcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gVmVydGV4QXJyYXlPYmplY3QoZ2wsIHN0YXRlKVxue1xuICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uID0gbnVsbDtcblxuICAgIGlmKCFWZXJ0ZXhBcnJheU9iamVjdC5GT1JDRV9OQVRJVkUpXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignTU9aX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlU3RhdGUgPSBzdGF0ZTtcblxuICAgIGlmKHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYXRpdmVWYW8gPSB0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuXG4gICAgICAgIHZhciBtYXhBdHRyaWJzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUyk7XG5cbiAgICAgICAgLy8gVkFPIC0gb3ZlcndyaXRlIHRoZSBzdGF0ZS4uXG4gICAgICAgIHRoaXMubmF0aXZlU3RhdGUgPSB7XG4gICAgICAgICAgICB0ZW1wQXR0cmliU3RhdGU6IG5ldyBBcnJheShtYXhBdHRyaWJzKSxcbiAgICAgICAgICAgIGF0dHJpYlN0YXRlOiBuZXcgQXJyYXkobWF4QXR0cmlicylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7UElYSS5nbENvcmUuR0xCdWZmZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGJvb2xlYW4gZmxhZ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlcnRleEFycmF5T2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBWZXJ0ZXhBcnJheU9iamVjdDtcblxuLyoqXG4qIFNvbWUgZGV2aWNlcyBiZWhhdmUgYSBiaXQgZnVubnkgd2hlbiB1c2luZyB0aGUgbmV3ZXIgZXh0ZW5zaW9ucyAoaW0gbG9va2luZyBhdCB5b3UgaXBhZCAyISlcbiogSWYgeW91IGZpbmQgb24gb2xkZXIgZGV2aWNlcyB0aGF0IHRoaW5ncyBoYXZlIGdvbmUgYSBiaXQgd2VpcmQgdGhlbiBzZXQgdGhpcyB0byB0cnVlLlxuKi9cbi8qKlxuICogTGV0cyB0aGUgVkFPIGtub3cgaWYgeW91IHNob3VsZCB1c2UgdGhlIFdlYkdMIGV4dGVuc2lvbiBvciB0aGUgbmF0aXZlIG1ldGhvZHMuXG4gKiBTb21lIGRldmljZXMgYmVoYXZlIGEgYml0IGZ1bm55IHdoZW4gdXNpbmcgdGhlIG5ld2VyIGV4dGVuc2lvbnMgKGltIGxvb2tpbmcgYXQgeW91IGlwYWQgMiEpXG4gKiBJZiB5b3UgZmluZCBvbiBvbGRlciBkZXZpY2VzIHRoYXQgdGhpbmdzIGhhdmUgZ29uZSBhIGJpdCB3ZWlyZCB0aGVuIHNldCB0aGlzIHRvIHRydWUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IEZPUkNFX05BVElWRVxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5GT1JDRV9OQVRJVkUgPSBmYWxzZTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgYnVmZmVyXG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKHRoaXMubmF0aXZlVmFvKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKHRoaXMubmF0aXZlVmFvKTtcblxuICAgICAgICBpZih0aGlzLmRpcnR5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcblxuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVuYmluZHMgdGhlIGJ1ZmZlclxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oKVxue1xuICAgIGlmKHRoaXMubmF0aXZlVmFvKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVc2VzIHRoaXMgdmFvXG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKClcbntcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGxhc3RCdWZmZXIgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgYXR0cmliID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuXG4gICAgICAgIGlmKGxhc3RCdWZmZXIgIT09IGF0dHJpYi5idWZmZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF0dHJpYi5idWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgbGFzdEJ1ZmZlciA9IGF0dHJpYi5idWZmZXI7XG4gICAgICAgIH1cblxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYi5hdHRyaWJ1dGUubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliLmF0dHJpYnV0ZS5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYi50eXBlIHx8IGdsLkZMT0FULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYi5ub3JtYWxpemVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYi5zdHJpZGUgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWIuc3RhcnQgfHwgMCk7XG4gICAgfVxuXG4gICAgc2V0VmVydGV4QXR0cmliQXJyYXlzKGdsLCB0aGlzLmF0dHJpYnV0ZXMsIHRoaXMubmF0aXZlU3RhdGUpO1xuXG4gICAgaWYodGhpcy5pbmRleEJ1ZmZlcilcbiAgICB7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuYmluZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAgICAge1BJWEkuZ2wuR0xCdWZmZXJ9XG4gKiBAcGFyYW0gYXR0cmlidXRlICB7Kn1cbiAqIEBwYXJhbSB0eXBlICAgICAgIHtTdHJpbmd9XG4gKiBAcGFyYW0gbm9ybWFsaXplZCB7Qm9vbGVhbn1cbiAqIEBwYXJhbSBzdHJpZGUgICAgIHtOdW1iZXJ9XG4gKiBAcGFyYW0gc3RhcnQgICAgICB7TnVtYmVyfVxuICovXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYnVmZmVyLCBhdHRyaWJ1dGUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgc3RhcnQpXG57XG4gICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICBidWZmZXI6ICAgICBidWZmZXIsXG4gICAgICAgIGF0dHJpYnV0ZTogIGF0dHJpYnV0ZSxcblxuICAgICAgICBsb2NhdGlvbjogICBhdHRyaWJ1dGUubG9jYXRpb24sXG4gICAgICAgIHR5cGU6ICAgICAgIHR5cGUgfHwgdGhpcy5nbC5GTE9BVCxcbiAgICAgICAgbm9ybWFsaXplZDogbm9ybWFsaXplZCB8fCBmYWxzZSxcbiAgICAgICAgc3RyaWRlOiAgICAgc3RyaWRlIHx8IDAsXG4gICAgICAgIHN0YXJ0OiAgICAgIHN0YXJ0IHx8IDBcbiAgICB9KTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gYnVmZmVyICAge1BJWEkuZ2wuR0xCdWZmZXJ9XG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5hZGRJbmRleCA9IGZ1bmN0aW9uKGJ1ZmZlci8qLCBvcHRpb25zKi8pXG57XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGJ1ZmZlcjtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVuYmluZHMgdGhpcyB2YW8gYW5kIGRpc2FibGVzIGl0XG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKClcbntcbiAgICAvLyB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgLy8gVE9ETyAtIHNob3VsZCB0aGlzIGZ1bmN0aW9uIHVuYmluZCBhZnRlciBjbGVhcj9cbiAgICAvLyBmb3Igbm93LCBubyBidXQgbGV0cyBzZWUgd2hhdCBoYXBwZW5zIGluIHRoZSByZWFsIHdvcmxkIVxuICAgIGlmKHRoaXMubmF0aXZlVmFvKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKHRoaXMubmF0aXZlVmFvKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gdHlwZSAge051bWJlcn1cbiAqIEBwYXJhbSBzaXplICB7TnVtYmVyfVxuICogQHBhcmFtIHN0YXJ0IHtOdW1iZXJ9XG4gKi9cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24odHlwZSwgc2l6ZSwgc3RhcnQpXG57XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIGlmKHRoaXMuaW5kZXhCdWZmZXIpXG4gICAge1xuICAgICAgICBnbC5kcmF3RWxlbWVudHModHlwZSwgc2l6ZSB8fCB0aGlzLmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgKHN0YXJ0IHx8IDApICogMiApO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyBUT0RPIG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGNhbGN1bGF0ZSBzaXplLi5cbiAgICAgICAgZ2wuZHJhd0FycmF5cyh0eXBlLCBzdGFydCwgc2l6ZSB8fCB0aGlzLmdldFNpemUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhpcyB2YW9cbiAqL1xuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXG57XG4gICAgLy8gbG9zZSByZWZlcmVuY2VzXG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZVN0YXRlID0gbnVsbDtcblxuICAgIGlmKHRoaXMubmF0aXZlVmFvKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy5uYXRpdmVWYW8pO1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlVmFvRXh0ZW5zaW9uID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZVZhbyA9IG51bGw7XG59O1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgYXR0cmliID0gdGhpcy5hdHRyaWJ1dGVzWzBdO1xuICAgIHJldHVybiBhdHRyaWIuYnVmZmVyLmRhdGEubGVuZ3RoIC8gKCggYXR0cmliLnN0cmlkZS80ICkgfHwgYXR0cmliLmF0dHJpYnV0ZS5zaXplKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb21waWxlUHJvZ3JhbTogcmVxdWlyZSgnLi9jb21waWxlUHJvZ3JhbScpLFxuICAgIGRlZmF1bHRWYWx1ZTogcmVxdWlyZSgnLi9kZWZhdWx0VmFsdWUnKSxcbiAgICBleHRyYWN0QXR0cmlidXRlczogcmVxdWlyZSgnLi9leHRyYWN0QXR0cmlidXRlcycpLFxuICAgIGV4dHJhY3RVbmlmb3JtczogcmVxdWlyZSgnLi9leHRyYWN0VW5pZm9ybXMnKSxcbiAgICBnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3Q6IHJlcXVpcmUoJy4vZ2VuZXJhdGVVbmlmb3JtQWNjZXNzT2JqZWN0JyksXG4gICAgc2V0UHJlY2lzaW9uOiByZXF1aXJlKCcuL3NldFByZWNpc2lvbicpLFxuICAgIG1hcFNpemU6IHJlcXVpcmUoJy4vbWFwU2l6ZScpLFxuICAgIG1hcFR5cGU6IHJlcXVpcmUoJy4vbWFwVHlwZScpXG59OyIsInZhciBnbCA9IHtcbiAgICBjcmVhdGVDb250ZXh0OiAgICAgICAgICByZXF1aXJlKCcuL2NyZWF0ZUNvbnRleHQnKSxcbiAgICBzZXRWZXJ0ZXhBdHRyaWJBcnJheXM6ICByZXF1aXJlKCcuL3NldFZlcnRleEF0dHJpYkFycmF5cycpLFxuICAgIEdMQnVmZmVyOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vR0xCdWZmZXInKSxcbiAgICBHTEZyYW1lYnVmZmVyOiAgICAgICAgICByZXF1aXJlKCcuL0dMRnJhbWVidWZmZXInKSxcbiAgICBHTFNoYWRlcjogICAgICAgICAgICAgICByZXF1aXJlKCcuL0dMU2hhZGVyJyksXG4gICAgR0xUZXh0dXJlOiAgICAgICAgICAgICAgcmVxdWlyZSgnLi9HTFRleHR1cmUnKSxcbiAgICBWZXJ0ZXhBcnJheU9iamVjdDogICAgICByZXF1aXJlKCcuL1ZlcnRleEFycmF5T2JqZWN0JyksXG4gICAgc2hhZGVyOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFkZXInKVxufTtcblxuLy8gRXhwb3J0IGZvciBOb2RlLWNvbXBhdGlibGUgZW52aXJvbm1lbnRzXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG57XG4gICAgLy8gRXhwb3J0IHRoZSBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsO1xufVxuXG4vLyBBZGQgdG8gdGhlIGJyb3dzZXIgd2luZG93IHBpeGkuZ2xcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbntcbiAgICAvLyBhZGQgdGhlIHdpbmRvdyBvYmplY3RcbiAgICB3aW5kb3cuUElYSSA9IHdpbmRvdy5QSVhJIHx8IHt9O1xuICAgIHdpbmRvdy5QSVhJLmdsQ29yZSA9IGdsO1xufVxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC9pbmRleCc7XG5pbXBvcnQgTWF0cml4IGZyb20gJy4uLy4uLy4uL2dlb20vTWF0cml4J1xuaW1wb3J0IHsgU0NBTEVfTU9ERVMgfSBmcm9tICcuLi8uLi8uLi9jb25zdCc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0IGdsQ29yZSBmcm9tICdwaXhpLWdsLWNvcmUnO1xuXG5jb25zdCBHTEZyYW1lYnVmZmVyID0gZ2xDb3JlLkdMRnJhbWVidWZmZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlclRhcmdldFxue1xuICAgIGNvbnN0cnVjdG9yKGdsLCB3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uLCByb290KVxuICAgIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgICAgIC8vIGZyYW1lYnVmZmVyIOaYr1dlYkdM5riy5p+T55qE57uI54K544CC5b2T5L2g55yL5bGP5bmV5pe277yM5YW25LuW5bCx5piv5Zyo55yLIGZyYW1lYnVmZmVyIOS4reeahOWGheWuueOAglxuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBbMCwgMCwgMCwgMF07XG5cbiAgICAgICAgdGhpcy5zaXplID0gbmV3IFJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+5aSH5YiG6L6o546HXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHNldHRpbmdzLlJFU09MVVRJT047XG5cbiAgICAgICAgLy/mipXlvbHnn6npmLXvvIzmiormiYDmnInnmoTpobbngrnmipXlsITliLB3ZWJnbOeahFstMSwxXeeahOWdkOagh+ezu+WGhVxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbiAgICAgICAgdGhpcy5mcmFtZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0RnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdGhpcy5mcmFtZUJ1ZmZlciA9IG5ldyBHTEZyYW1lYnVmZmVyKGdsLCAxMDAsIDEwMCk7XG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgICBcbiAgICAgICAgdGhpcy5zZXRGcmFtZSgpO1xuXG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGNsZWFyKGNsZWFyQ29sb3IpXG4gICAge1xuICAgICAgICBjb25zdCBjYyA9IGNsZWFyQ29sb3IgfHwgdGhpcy5jbGVhckNvbG9yO1xuXG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIuY2xlYXIoY2NbMF0sIGNjWzFdLCBjY1syXSwgY2NbM10pOy8vIHIsZyxiLGEpO1xuICAgIH1cblxuICAgIHNldEZyYW1lKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZWZhdWx0RnJhbWU7XG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUgPSBzb3VyY2VGcmFtZSB8fCB0aGlzLnNvdXJjZUZyYW1lIHx8IGRlc3RpbmF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgLy/lnKhXZWJHTFJlbmRlcmVy5Lit6KKr6LCD55SoXG4gICAgYWN0aXZhdGUoKVxuICAgIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIuYmluZCgpO1xuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbih0aGlzLmRlc3RpbmF0aW9uRnJhbWUsIHRoaXMuc291cmNlRnJhbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRlc3RpbmF0aW9uRnJhbWUgIT09IHRoaXMuc291cmNlRnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICAgICAgZ2wuc2Npc3NvcihcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueCB8IDAsXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLnkgfCAwLFxuICAgICAgICAgICAgICAgICh0aGlzLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiB0aGlzLnJlc29sdXRpb24pIHwgMCxcbiAgICAgICAgICAgICAgICAodGhpcy5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbikgfCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2wudmlld3BvcnQoXG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueCB8IDAsXG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueSB8IDAsXG4gICAgICAgICAgICAodGhpcy5kZXN0aW5hdGlvbkZyYW1lLndpZHRoICogdGhpcy5yZXNvbHV0aW9uKSB8IDAsXG4gICAgICAgICAgICAodGhpcy5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbikgfCAwXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy/orqHnrpfmipXlvbHnn6npmLXvvIzmiormiYDmnInnmoTpobbngrnmlbDmja7mipXlsITliLAgd2ViZ2wg55qEIFstMSwxXSDlnZDmoIfns7vlhoXmnaVcbiAgICBjYWxjdWxhdGVQcm9qZWN0aW9uKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lKVxuICAgIHtcbiAgICAgICAgY29uc3QgcG0gPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG5cbiAgICAgICAgc291cmNlRnJhbWUgPSBzb3VyY2VGcmFtZSB8fCBkZXN0aW5hdGlvbkZyYW1lO1xuXG4gICAgICAgIHBtLmlkZW50aXR5KCk7XG5cbiAgICAgICAgcG0uYSA9IDEgLyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoICogMjtcbiAgICAgICAgcG0uZCA9IC0xIC8gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiAyO1xuXG4gICAgICAgIHBtLnR4ID0gLTEgLSAoc291cmNlRnJhbWUueCAqIHBtLmEpO1xuICAgICAgICBwbS50eSA9IDEgLSAoc291cmNlRnJhbWUueSAqIHBtLmQpO1xuICAgIH1cblxuICAgIC8vc3RhZ2Ug55qEIHNpemXlj5HnlJ/lj5jljJbvvIzpnIDopoHph43mlrDliJ3lp4vljJbov5nkupvlr7nosaHnmoRzaXpl77yM5bCk5YW25pivIHByb2plY3Rpb25NYXRyaXgg5oqV5b2x5Li+6K+BXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB3aWR0aCA9IHdpZHRoIHwgMDtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHwgMDtcblxuICAgICAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSB3aWR0aCAmJiB0aGlzLnNpemUuaGVpZ2h0ID09PSBoZWlnaHQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2l6ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuZGVmYXVsdEZyYW1lLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZGVmYXVsdEZyYW1lLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyLnJlc2l6ZSh3aWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcblxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uRnJhbWUgPSB0aGlzLmZyYW1lIHx8IHRoaXMuc2l6ZTtcblxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVByb2plY3Rpb24ocHJvamVjdGlvbkZyYW1lKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyID0gbnVsbDtcbiAgICB9XG59XG4iLCJcbmNvbnN0IERFUFRIX1RFU1QgPSAxO1xuY29uc3QgRlJPTlRfRkFDRSA9IDI7XG5jb25zdCBDVUxMX0ZBQ0UgPSAzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFN0YXRlXG57XG4gICAgY29uc3RydWN0b3IoZ2wpXG4gICAge1xuXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGUgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGVbMF0gPSAxO1xuXG4gICAgICAgIHRoaXMuc3RhY2tJbmRleCA9IDA7XG5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcblxuICAgICAgICB0aGlzLm1heEF0dHJpYnMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTKTtcblxuICAgICAgICB0aGlzLmF0dHJpYlN0YXRlID0ge1xuICAgICAgICAgICAgdGVtcEF0dHJpYlN0YXRlOiBuZXcgQXJyYXkodGhpcy5tYXhBdHRyaWJzKSxcbiAgICAgICAgICAgIGF0dHJpYlN0YXRlOiBuZXcgQXJyYXkodGhpcy5tYXhBdHRyaWJzKSxcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8vIGNoZWNrIHdlIGhhdmUgdmFvLi5cbiAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24gPSAoXG4gICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcbiAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcbiAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdXNoKClcbiAgICB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhY2tbKyt0aGlzLnN0YWNrSW5kZXhdO1xuXG4gICAgICAgIGlmICghc3RhdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrSW5kZXhdID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZVN0YXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW2ldID0gc3RhdGVbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwb3AoKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YWNrWy0tdGhpcy5zdGFja0luZGV4XTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBzZXRTdGF0ZShzdGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0RGVwdGhUZXN0KHN0YXRlW0RFUFRIX1RFU1RdKTtcbiAgICAgICAgdGhpcy5zZXRGcm9udEZhY2Uoc3RhdGVbRlJPTlRfRkFDRV0pO1xuICAgICAgICB0aGlzLnNldEN1bGxGYWNlKHN0YXRlW0NVTExfRkFDRV0pO1xuICAgIH1cblxuICAgIHNldERlcHRoVGVzdCh2YWx1ZSlcbiAgICB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyAxIDogMDtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVTdGF0ZVtERVBUSF9URVNUXSA9PT0gdmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbREVQVEhfVEVTVF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgIH1cblxuICAgIHNldEN1bGxGYWNlKHZhbHVlKVxuICAgIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IDEgOiAwO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVN0YXRlW0NVTExfRkFDRV0gPT09IHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlW0NVTExfRkFDRV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gICAgfVxuXG4gICAgc2V0RnJvbnRGYWNlKHZhbHVlKVxuICAgIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IDEgOiAwO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVN0YXRlW0ZST05UX0ZBQ0VdID09PSB2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZVtGUk9OVF9GQUNFXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmdsLmZyb250RmFjZSh0aGlzLmdsW3ZhbHVlID8gJ0NXJyA6ICdDQ1cnXSk7XG4gICAgfVxuXG4gICAgcmVzZXRBdHRyaWJ1dGVzKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJTdGF0ZS50ZW1wQXR0cmliU3RhdGUubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmliU3RhdGUudGVtcEF0dHJpYlN0YXRlW2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hdHRyaWJTdGF0ZS5hdHRyaWJTdGF0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJTdGF0ZS5hdHRyaWJTdGF0ZVtpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMubWF4QXR0cmliczsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0VG9EZWZhdWx0KClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm5hdGl2ZVZhb0V4dGVuc2lvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVWYW9FeHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNldEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWN0aXZlU3RhdGUubGVuZ3RoOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU3RhdGVbaV0gPSAzMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmRlZmF1bHRTdGF0ZSk7XG4gICAgfVxufVxuIiwiXG5leHBvcnQgZnVuY3Rpb24gaGV4MnJnYihoZXgsIG91dCl7XG5cdC8vaGV45Y+v6IO95piv4oCcI2ZmMDAwMOKAnSDkuZ/lj6/og73mmK8gMHhmZjAwMDBcblx0aWYoIGhleC5yZXBsYWNlICl7XG5cdCAgIGhleCA9IHBhcnNlSW50KCBoZXgucmVwbGFjZShcIiNcIiAsIFwiMFhcIikgLCAxNiApO1xuICAgIH07XG5cbiAgICBvdXQgPSBvdXQgfHwgW107XG5cbiAgICBvdXRbMF0gPSAoKGhleCA+PiAxNikgJiAweEZGKSAvIDI1NTtcbiAgICBvdXRbMV0gPSAoKGhleCA+PiA4KSAmIDB4RkYpIC8gMjU1O1xuICAgIG91dFsyXSA9IChoZXggJiAweEZGKSAvIDI1NTtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXgyc3RyaW5nKGhleCl7XG4gICAgIGhleCA9IGhleC50b1N0cmluZygxNik7XG4gICAgIGhleCA9ICcwMDAwMDAnLnN1YnN0cigwLCA2IC0gaGV4Lmxlbmd0aCkgKyBoZXg7XG5cbiAgICAgcmV0dXJuIGAjJHtoZXh9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYjJoZXgocmdiKXtcblx0cmV0dXJuICgoKHJnYlswXSAqIDI1NSkgPDwgMTYpICsgKChyZ2JbMV0gKiAyNTUpIDw8IDgpICsgKHJnYlsyXSAqIDI1NSkpO1xufSIsImltcG9ydCBnbENvcmUgZnJvbSAncGl4aS1nbC1jb3JlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xHcmFwaGljc0RhdGFcbntcbiAgICBjb25zdHJ1Y3RvcihnbCwgc2hhZGVyLCBhdHRyaWJzU3RhdGUpXG4gICAge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG5cbiAgICAgICAgdGhpcy5jb2xvciA9IFswLCAwLCAwXTsgLy8gY29sb3Igc3BsaXQhXG5cblxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXNcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYWluIGJ1ZmZlclxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTEJ1ZmZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gZ2xDb3JlLkdMQnVmZmVyLmNyZWF0ZVZlcnRleEJ1ZmZlcihnbCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBidWZmZXJcbiAgICAgICAgICogQG1lbWJlciB7V2ViR0xCdWZmZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gZ2xDb3JlLkdMQnVmZmVyLmNyZWF0ZUluZGV4QnVmZmVyKGdsKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGdyYXBoaWNzIGlzIGRpcnR5IG9yIG5vdFxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5nbFBvaW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2xJbmRpY2VzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcblxuICAgICAgICB0aGlzLnZhbyA9IG5ldyBnbENvcmUuVmVydGV4QXJyYXlPYmplY3QoZ2wsIGF0dHJpYnNTdGF0ZSlcbiAgICAgICAgLmFkZEluZGV4KHRoaXMuaW5kZXhCdWZmZXIpXG4gICAgICAgIC5hZGRBdHRyaWJ1dGUodGhpcy5idWZmZXIsIHNoYWRlci5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogNiwgMClcbiAgICAgICAgLmFkZEF0dHJpYnV0ZSh0aGlzLmJ1ZmZlciwgc2hhZGVyLmF0dHJpYnV0ZXMuYUNvbG9yLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiA2LCAyICogNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSB2ZXJ0aWNlcyBhbmQgdGhlIGluZGljZXNcbiAgICAgKi9cbiAgICByZXNldCgpXG4gICAge1xuICAgICAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgYnVmZmVycyBhbmQgdXBsb2FkcyB0aGUgZGF0YVxuICAgICAqL1xuICAgIHVwbG9hZCgpXG4gICAge1xuICAgICAgICB0aGlzLmdsUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBvaW50cyk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnVwbG9hZCh0aGlzLmdsUG9pbnRzKTtcblxuICAgICAgICB0aGlzLmdsSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLnVwbG9hZCh0aGlzLmdsSW5kaWNlcyk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgYWxsIHRoZSBkYXRhXG4gICAgICovXG4gICAgZGVzdHJveSgpXG4gICAge1xuICAgICAgICB0aGlzLmNvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmFvLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZ2xQb2ludHMgPSBudWxsO1xuICAgICAgICB0aGlzLmdsSW5kaWNlcyA9IG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IGdsQ29yZSBmcm9tICdwaXhpLWdsLWNvcmUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuXG5jb25zdCB7IFBSRUNJU0lPTiB9ID0gc2V0dGluZ3M7XG5jb25zdCBHTFNoYWRlciA9IGdsQ29yZS5HTFNoYWRlclxuXG5mdW5jdGlvbiBjaGVja1ByZWNpc2lvbihzcmMpXG57XG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5KVxuICAgIHtcbiAgICAgICAgaWYgKHNyY1swXS5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gc3JjLnNsaWNlKDApO1xuXG4gICAgICAgICAgICBjb3B5LnVuc2hpZnQoYHByZWNpc2lvbiAke1BSRUNJU0lPTn0gZmxvYXQ7YCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNyYy5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGBwcmVjaXNpb24gJHtQUkVDSVNJT059IGZsb2F0O1xcbiR7c3JjfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNyYztcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzLCB3ZWJHTCBTaGFkZXIgZm9yIFBpeGkuXG4gKiBBZGRzIHByZWNpc2lvbiBzdHJpbmcgaWYgdmVydGV4U3JjIG9yIGZyYWdtZW50U3JjIGhhdmUgbm8gbWVudGlvbiBvZiBpdC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEdMU2hhZGVyXG4gKiBAbWVtYmVyb2YgUElYSVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXIgZXh0ZW5kcyBHTFNoYWRlclxue1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdmVydGV4U3JjIC0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZyYWdtZW50U3JjIC0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYylcbiAgICB7XG4gICAgICAgIHN1cGVyKGdsLCBjaGVja1ByZWNpc2lvbih2ZXJ0ZXhTcmMpLCBjaGVja1ByZWNpc2lvbihmcmFnbWVudFNyYykpO1xuICAgIH1cbn1cbiIsImltcG9ydCBTaGFkZXIgZnJvbSAnLi4vLi4vLi4vU2hhZGVyJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaW1pdGl2ZVNoYWRlciBleHRlbmRzIFNoYWRlclxue1xuICAgIGNvbnN0cnVjdG9yKGdsKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZ2wsXG4gICAgICAgICAgICAvL3ZlcnRleCBzaGFkZXJcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uOycsXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGFDb2xvcjsnLFxuXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDsnLFxuICAgICAgICAgICAgICAgICd1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsnLFxuXG4gICAgICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgYWxwaGE7JyxcbiAgICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMzIHRpbnQ7JyxcblxuICAgICAgICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG5cbiAgICAgICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgICAgICAgICAgICAgJyAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7JyxcbiAgICAgICAgICAgICAgICAnICAgdkNvbG9yID0gYUNvbG9yICogdmVjNCh0aW50ICogYWxwaGEsIGFscGhhKTsnLFxuICAgICAgICAgICAgICAgICd9JyxcbiAgICAgICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgICAgICAvLyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuXG4gICAgICAgICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICAgICAgICAgICAgICcgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7JyxcbiAgICAgICAgICAgICAgICAnfScsXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi8uLi9tYXRoL2luZGV4JztcbmltcG9ydCB7IGhleDJyZ2IgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb2xvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkTGluZShncmFwaGljc0RhdGEsIHdlYkdMRGF0YSlcbntcbiAgICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBuZXcgUG9pbnQocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgIGxldCBsYXN0UG9pbnQgPSBuZXcgUG9pbnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cbiAgICBpZiAoZmlyc3RQb2ludC54ID09PSBsYXN0UG9pbnQueCAmJiBmaXJzdFBvaW50LnkgPT09IGxhc3RQb2ludC55KVxuICAgIHtcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG5cbiAgICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgICBwb2ludHMucG9wKCk7XG5cbiAgICAgICAgbGFzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXG4gICAgICAgIGNvbnN0IG1pZFBvaW50WCA9IGxhc3RQb2ludC54ICsgKChmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgKiAwLjUpO1xuICAgICAgICBjb25zdCBtaWRQb2ludFkgPSBsYXN0UG9pbnQueSArICgoZmlyc3RQb2ludC55IC0gbGFzdFBvaW50LnkpICogMC41KTtcblxuICAgICAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgICAgIHBvaW50cy5wdXNoKG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcbiAgICB9XG5cbiAgICBjb25zdCB2ZXJ0cyA9IHdlYkdMRGF0YS5wb2ludHM7XG4gICAgY29uc3QgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIGxldCBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICBjb25zdCB3aWR0aCA9IGdyYXBoaWNzRGF0YS5saW5lV2lkdGggLyAyO1xuXG4gICAgY29uc3QgY29sb3IgPSBoZXgycmdiKGdyYXBoaWNzRGF0YS5zdHJva2VTdHlsZSk7XG4gICAgY29uc3QgYWxwaGEgPSBncmFwaGljc0RhdGEubGluZUFscGhhO1xuICAgIGNvbnN0IHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgIGNvbnN0IGcgPSBjb2xvclsxXSAqIGFscGhhO1xuICAgIGNvbnN0IGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgbGV0IHAxeCA9IHBvaW50c1swXTtcbiAgICBsZXQgcDF5ID0gcG9pbnRzWzFdO1xuICAgIGxldCBwMnggPSBwb2ludHNbMl07XG4gICAgbGV0IHAyeSA9IHBvaW50c1szXTtcbiAgICBsZXQgcDN4ID0gMDtcbiAgICBsZXQgcDN5ID0gMDtcblxuICAgIGxldCBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICBsZXQgcGVycHkgPSBwMXggLSBwMng7XG4gICAgbGV0IHBlcnAyeCA9IDA7XG4gICAgbGV0IHBlcnAyeSA9IDA7XG4gICAgbGV0IHBlcnAzeCA9IDA7XG4gICAgbGV0IHBlcnAzeSA9IDA7XG5cbiAgICBsZXQgZGlzdCA9IE1hdGguc3FydCgocGVycHggKiBwZXJweCkgKyAocGVycHkgKiBwZXJweSkpO1xuXG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuXG4gICAgLy8gc3RhcnRcbiAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICBwMXggLSBwZXJweCxcbiAgICAgICAgcDF5IC0gcGVycHksXG4gICAgICAgIHIsIGcsIGIsIGFscGhhXG4gICAgKTtcblxuICAgIHZlcnRzLnB1c2goXG4gICAgICAgIHAxeCArIHBlcnB4LFxuICAgICAgICBwMXkgKyBwZXJweSxcbiAgICAgICAgciwgZywgYiwgYWxwaGFcbiAgICApO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpXG4gICAge1xuICAgICAgICBwMXggPSBwb2ludHNbKGkgLSAxKSAqIDJdO1xuICAgICAgICBwMXkgPSBwb2ludHNbKChpIC0gMSkgKiAyKSArIDFdO1xuXG4gICAgICAgIHAyeCA9IHBvaW50c1tpICogMl07XG4gICAgICAgIHAyeSA9IHBvaW50c1soaSAqIDIpICsgMV07XG5cbiAgICAgICAgcDN4ID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgICAgcDN5ID0gcG9pbnRzWygoaSArIDEpICogMikgKyAxXTtcblxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycHggKiBwZXJweCkgKyAocGVycHkgKiBwZXJweSkpO1xuICAgICAgICBwZXJweCAvPSBkaXN0O1xuICAgICAgICBwZXJweSAvPSBkaXN0O1xuICAgICAgICBwZXJweCAqPSB3aWR0aDtcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICAgICAgcGVycDJ4ID0gLShwMnkgLSBwM3kpO1xuICAgICAgICBwZXJwMnkgPSBwMnggLSBwM3g7XG5cbiAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycDJ4ICogcGVycDJ4KSArIChwZXJwMnkgKiBwZXJwMnkpKTtcbiAgICAgICAgcGVycDJ4IC89IGRpc3Q7XG4gICAgICAgIHBlcnAyeSAvPSBkaXN0O1xuICAgICAgICBwZXJwMnggKj0gd2lkdGg7XG4gICAgICAgIHBlcnAyeSAqPSB3aWR0aDtcblxuICAgICAgICBjb25zdCBhMSA9ICgtcGVycHkgKyBwMXkpIC0gKC1wZXJweSArIHAyeSk7XG4gICAgICAgIGNvbnN0IGIxID0gKC1wZXJweCArIHAyeCkgLSAoLXBlcnB4ICsgcDF4KTtcbiAgICAgICAgY29uc3QgYzEgPSAoKC1wZXJweCArIHAxeCkgKiAoLXBlcnB5ICsgcDJ5KSkgLSAoKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KSk7XG4gICAgICAgIGNvbnN0IGEyID0gKC1wZXJwMnkgKyBwM3kpIC0gKC1wZXJwMnkgKyBwMnkpO1xuICAgICAgICBjb25zdCBiMiA9ICgtcGVycDJ4ICsgcDJ4KSAtICgtcGVycDJ4ICsgcDN4KTtcbiAgICAgICAgY29uc3QgYzIgPSAoKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpKSAtICgoLXBlcnAyeCArIHAyeCkgKiAoLXBlcnAyeSArIHAzeSkpO1xuXG4gICAgICAgIGxldCBkZW5vbSA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoZGVub20pIDwgMC4xKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZW5vbSArPSAxMC4xO1xuICAgICAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICAgICAgICBwMnggLSBwZXJweCxcbiAgICAgICAgICAgICAgICBwMnkgLSBwZXJweSxcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChcbiAgICAgICAgICAgICAgICBwMnggKyBwZXJweCxcbiAgICAgICAgICAgICAgICBwMnkgKyBwZXJweSxcbiAgICAgICAgICAgICAgICByLCBnLCBiLCBhbHBoYVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBweCA9ICgoYjEgKiBjMikgLSAoYjIgKiBjMSkpIC8gZGVub207XG4gICAgICAgIGNvbnN0IHB5ID0gKChhMiAqIGMxKSAtIChhMSAqIGMyKSkgLyBkZW5vbTtcbiAgICAgICAgY29uc3QgcGRpc3QgPSAoKHB4IC0gcDJ4KSAqIChweCAtIHAyeCkpICsgKChweSAtIHAyeSkgKiAocHkgLSBwMnkpKTtcblxuICAgICAgICBpZiAocGRpc3QgPiAoMTk2ICogd2lkdGggKiB3aWR0aCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBlcnAzeCA9IHBlcnB4IC0gcGVycDJ4O1xuICAgICAgICAgICAgcGVycDN5ID0gcGVycHkgLSBwZXJwMnk7XG5cbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnAzeCAqIHBlcnAzeCkgKyAocGVycDN5ICogcGVycDN5KSk7XG4gICAgICAgICAgICBwZXJwM3ggLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnAzeSAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDN4ICo9IHdpZHRoO1xuICAgICAgICAgICAgcGVycDN5ICo9IHdpZHRoO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC0gcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnAzeCwgcDJ5ICsgcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnAzeCwgcDJ5IC0gcGVycDN5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICBpbmRleENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHB4LCBweSk7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocHggLSBwMngpLCBwMnkgLSAocHkgLSBwMnkpKTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcDF4ID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDJdO1xuICAgIHAxeSA9IHBvaW50c1soKGxlbmd0aCAtIDIpICogMikgKyAxXTtcblxuICAgIHAyeCA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgICBwMnkgPSBwb2ludHNbKChsZW5ndGggLSAxKSAqIDIpICsgMV07XG5cbiAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICBwZXJweSA9IHAxeCAtIHAyeDtcblxuICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcbiAgICBwZXJweCAvPSBkaXN0O1xuICAgIHBlcnB5IC89IGRpc3Q7XG4gICAgcGVycHggKj0gd2lkdGg7XG4gICAgcGVycHkgKj0gd2lkdGg7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCAtIHBlcnB4LCBwMnkgLSBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICB2ZXJ0cy5wdXNoKHAyeCArIHBlcnB4LCBwMnkgKyBwZXJweSk7XG4gICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4Q291bnQ7ICsraSlcbiAgICB7XG4gICAgICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0KyspO1xuICAgIH1cblxuICAgIGluZGljZXMucHVzaChpbmRleFN0YXJ0IC0gMSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlKSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBzaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBzaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKHNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICAvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB2YXIgcCA9IGVhci5uZXh0WjtcblxuICAgIHdoaWxlIChwICYmIHAueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICBwID0gZWFyLnByZXZaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgICAgIHZhciBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICAgIH1cbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGh4ID09PSBxeCkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbS5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFTaXplID09PSAwIHx8ICFxKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHAueiA8PSBxLnopIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIHNpemUgb2YgdGhlIGRhdGEgYm91bmRpbmcgYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpIC8gc2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpIC8gc2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LngpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpO1xufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIGlmICgoZXF1YWxzKHAxLCBxMSkgJiYgZXF1YWxzKHAyLCBxMikpIHx8XG4gICAgICAgIChlcXVhbHMocDEsIHEyKSAmJiBlcXVhbHMocDIsIHExKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgICAgYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IGFyZWEocDIsIHEyLCBxMSkgPiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRpY2UgaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSBudWxsO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsImltcG9ydCBidWlsZExpbmUgZnJvbSAnLi9idWlsZExpbmUnO1xuaW1wb3J0IHsgaGV4MnJnYiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRQb2x5KGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKVxue1xuICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBncmFwaGljc0RhdGEuc2hhcGUucG9pbnRzLnNsaWNlKCk7XG5cbiAgICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgIGlmIChncmFwaGljc0RhdGEuaGFzRmlsbCgpICYmIGdyYXBoaWNzRGF0YS5maWxsQWxwaGEgJiYgcG9pbnRzLmxlbmd0aCA+PSA2KVxuICAgIHtcbiAgICAgICAgY29uc3QgaG9sZUFycmF5ID0gW107XG4gICAgICAgIGNvbnN0IGhvbGVzID0gZ3JhcGhpY3NEYXRhLmhvbGVzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGhvbGUgPSBob2xlc1tpXTtcblxuICAgICAgICAgICAgaG9sZUFycmF5LnB1c2gocG9pbnRzLmxlbmd0aCAvIDIpO1xuXG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGhvbGUucG9pbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuXG4gICAgICAgIGNvbnN0IGNvbG9yID0gaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbFN0eWxlKTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuICAgICAgICBjb25zdCByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgY29uc3QgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIGNvbnN0IGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IGVhcmN1dChwb2ludHMsIGhvbGVBcnJheSwgMik7XG5cbiAgICAgICAgaWYgKCF0cmlhbmdsZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kgKyAxXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMl0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVydFBvcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpICogMl0sIHBvaW50c1soaSAqIDIpICsgMV0sXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5oYXNMaW5lKCkgJiYgZ3JhcGhpY3NEYXRhLmxpbmVBbHBoYSApXG4gICAge1xuICAgICAgICBidWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xuICAgIH1cbn1cbiIsImltcG9ydCBidWlsZExpbmUgZnJvbSAnLi9idWlsZExpbmUnO1xuaW1wb3J0IHsgaGV4MnJnYiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRSZWN0YW5nbGUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG5cbiAgICBjb25zdCByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICBjb25zdCB4ID0gcmVjdERhdGEueDtcbiAgICBjb25zdCB5ID0gcmVjdERhdGEueTtcbiAgICBjb25zdCB3aWR0aCA9IHJlY3REYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlY3REYXRhLmhlaWdodDtcblxuICAgIGlmIChncmFwaGljc0RhdGEuaGFzRmlsbCgpICYmIGdyYXBoaWNzRGF0YS5maWxsQWxwaGEpXG4gICAge1xuICAgICAgICBjb25zdCBjb2xvciA9IGhleDJyZ2IoZ3JhcGhpY3NEYXRhLmZpbGxTdHlsZSk7XG4gICAgICAgIGNvbnN0IGFscGhhID0gZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYTtcblxuICAgICAgICBjb25zdCByID0gY29sb3JbMF0gKiBhbHBoYTtcbiAgICAgICAgY29uc3QgZyA9IGNvbG9yWzFdICogYWxwaGE7XG4gICAgICAgIGNvbnN0IGIgPSBjb2xvclsyXSAqIGFscGhhO1xuXG4gICAgICAgIGNvbnN0IHZlcnRzID0gd2ViR0xEYXRhLnBvaW50cztcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHdlYkdMRGF0YS5pbmRpY2VzO1xuXG4gICAgICAgIGNvbnN0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyA2O1xuXG4gICAgICAgIC8vIHN0YXJ0XG4gICAgICAgIHZlcnRzLnB1c2goeCwgeSk7XG4gICAgICAgIHZlcnRzLnB1c2gociwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgIHZlcnRzLnB1c2goeCArIHdpZHRoLCB5KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgdmVydHMucHVzaChyLCBnLCBiLCBhbHBoYSk7XG5cbiAgICAgICAgdmVydHMucHVzaCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHIsIGcsIGIsIGFscGhhKTtcblxuICAgICAgICAvLyBpbnNlcnQgMiBkZWFkIHRyaWFuZ2xlcy4uXG4gICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAzLCB2ZXJ0UG9zICsgMyk7XG4gICAgfVxuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5oYXNMaW5lKCkgJiYgZ3JhcGhpY3NEYXRhLmxpbmVBbHBoYSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHRlbXBQb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBbeCwgeSxcbiAgICAgICAgICAgIHggKyB3aWR0aCwgeSxcbiAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCxcbiAgICAgICAgICAgIHgsIHkgKyBoZWlnaHQsXG4gICAgICAgICAgICB4LCB5XTtcblxuICAgICAgICBidWlsZExpbmUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpO1xuXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSB0ZW1wUG9pbnRzO1xuICAgIH1cbn1cbiIsImltcG9ydCBidWlsZExpbmUgZnJvbSAnLi9idWlsZExpbmUnO1xuaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnLi4vLi4vLi4vY29uc3QnO1xuaW1wb3J0IHsgaGV4MnJnYiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbG9yJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRDaXJjbGUoZ3JhcGhpY3NEYXRhLCB3ZWJHTERhdGEpXG57XG4gICAgXG4gICAgY29uc3QgY2lyY2xlRGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICBjb25zdCB4ID0gY2lyY2xlRGF0YS54O1xuICAgIGNvbnN0IHkgPSBjaXJjbGVEYXRhLnk7XG4gICAgbGV0IHdpZHRoO1xuICAgIGxldCBoZWlnaHQ7XG5cbiAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IFNIQVBFUy5DSVJDKVxuICAgIHtcbiAgICAgICAgd2lkdGggPSBjaXJjbGVEYXRhLnJhZGl1cztcbiAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5yYWRpdXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxTZWdzID0gTWF0aC5mbG9vcigzMCAqIE1hdGguc3FydChjaXJjbGVEYXRhLnJhZGl1cykpXG4gICAgICAgIHx8IE1hdGguZmxvb3IoMTUgKiBNYXRoLnNxcnQoY2lyY2xlRGF0YS53aWR0aCArIGNpcmNsZURhdGEuaGVpZ2h0KSk7XG5cbiAgICBjb25zdCBzZWcgPSAoTWF0aC5QSSAqIDIpIC8gdG90YWxTZWdzO1xuXG4gICAgaWYgKGdyYXBoaWNzRGF0YS5oYXNGaWxsKCkgJiYgZ3JhcGhpY3NEYXRhLmZpbGxBbHBoYSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gaGV4MnJnYihncmFwaGljc0RhdGEuZmlsbFN0eWxlKTtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBncmFwaGljc0RhdGEuZmlsbEFscGhhO1xuXG4gICAgICAgIGNvbnN0IHIgPSBjb2xvclswXSAqIGFscGhhO1xuICAgICAgICBjb25zdCBnID0gY29sb3JbMV0gKiBhbHBoYTtcbiAgICAgICAgY29uc3QgYiA9IGNvbG9yWzJdICogYWxwaGE7XG5cbiAgICAgICAgY29uc3QgdmVydHMgPSB3ZWJHTERhdGEucG9pbnRzO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gd2ViR0xEYXRhLmluZGljZXM7XG5cbiAgICAgICAgbGV0IHZlY1BvcyA9IHZlcnRzLmxlbmd0aCAvIDY7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1Bvcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFNlZ3MgKyAxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeCwgeSwgciwgZywgYiwgYWxwaGEpO1xuXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKFxuICAgICAgICAgICAgICAgIHggKyAoTWF0aC5zaW4oc2VnICogaSkgKiB3aWR0aCksXG4gICAgICAgICAgICAgICAgeSArIChNYXRoLmNvcyhzZWcgKiBpKSAqIGhlaWdodCksXG4gICAgICAgICAgICAgICAgciwgZywgYiwgYWxwaGFcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ZWNQb3MrKywgdmVjUG9zKyspO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKHZlY1BvcyAtIDEpO1xuICAgIH1cblxuICAgIGlmIChncmFwaGljc0RhdGEuaGFzTGluZSgpICYmIGdyYXBoaWNzRGF0YS5saW5lQWxwaGEpXG4gICAge1xuICAgICAgICBjb25zdCB0ZW1wUG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFNlZ3MgKyAxOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMucHVzaChcbiAgICAgICAgICAgICAgICB4ICsgKE1hdGguc2luKHNlZyAqIGkpICogd2lkdGgpLFxuICAgICAgICAgICAgICAgIHkgKyAoTWF0aC5jb3Moc2VnICogaSkgKiBoZWlnaHQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgd2ViR0xEYXRhKTtcblxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gdGVtcFBvaW50cztcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoZXgycmdiIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29sb3InO1xuaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnLi4vLi4vY29uc3QnO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyZXInO1xuaW1wb3J0IFdlYkdMR3JhcGhpY3NEYXRhIGZyb20gJy4vV2ViR0xHcmFwaGljc0RhdGEnO1xuaW1wb3J0IFByaW1pdGl2ZVNoYWRlciBmcm9tICcuL3NoYWRlcnMvUHJpbWl0aXZlU2hhZGVyJztcblxuaW1wb3J0IGJ1aWxkUG9seSBmcm9tICcuL3V0aWxzL2J1aWxkUG9seSc7XG5pbXBvcnQgYnVpbGRSZWN0YW5nbGUgZnJvbSAnLi91dGlscy9idWlsZFJlY3RhbmdsZSc7XG5pbXBvcnQgYnVpbGRDaXJjbGUgZnJvbSAnLi91dGlscy9idWlsZENpcmNsZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhpY3NSZW5kZXJlclxue1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2wgPSBbXTtcbiAgICAgICAgdGhpcy5wcmltaXRpdmVTaGFkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSAwO1xuICAgIH1cblxuICAgIG9uQ29udGV4dENoYW5nZSgpXG4gICAge1xuICAgICAgICB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgICAgIHRoaXMucHJpbWl0aXZlU2hhZGVyID0gbmV3IFByaW1pdGl2ZVNoYWRlcih0aGlzLmdsKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGFQb29sLmxlbmd0aDsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2xbaV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFQb29sID0gbnVsbDtcbiAgICB9XG5cbiAgICByZW5kZXIoIGRpc3BsYXlPYmplY3QsIHN0YWdlICwgZ3JhcGhpY3MgKVxuICAgIHtcbiAgICAgICAgLy9jb25zdCBncmFwaGljcyA9IGRpc3BsYXlPYmplY3QuZ3JhcGhpY3M7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcblxuICAgICAgICBsZXQgd2ViR0xEYXRhO1xuICAgICAgICBsZXQgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbdGhpcy5DT05URVhUX1VJRF07XG5cbiAgICAgICAgaWYgKCF3ZWJHTCB8fCBncmFwaGljcy5kaXJ0eSAhPT0gd2ViR0wuZGlydHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR3JhcGhpY3MoZ3JhcGhpY3MgLCBkaXNwbGF5T2JqZWN0KTtcblxuICAgICAgICAgICAgd2ViR0wgPSBncmFwaGljcy5fd2ViR0xbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLnByaW1pdGl2ZVNoYWRlcjtcblxuICAgICAgICByZW5kZXJlci5iaW5kU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB3ZWJHTC5kYXRhLmxlbmd0aDsgaSA8IG47IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gd2ViR0wuZGF0YVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlclRlbXAgPSB3ZWJHTERhdGEuc2hhZGVyO1xuXG4gICAgICAgICAgICByZW5kZXJlci5iaW5kU2hhZGVyKHNoYWRlclRlbXApO1xuICAgICAgICAgICAgc2hhZGVyVGVtcC51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm07XG4gICAgICAgICAgICBzaGFkZXJUZW1wLnVuaWZvcm1zLnRpbnQgPSBoZXgycmdiKGdyYXBoaWNzLnRpbnQpO1xuICAgICAgICAgICAgc2hhZGVyVGVtcC51bmlmb3Jtcy5hbHBoYSA9IGdyYXBoaWNzLndvcmxkQWxwaGE7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLmJpbmRWYW8od2ViR0xEYXRhLnZhbyk7XG4gICAgICAgICAgICB3ZWJHTERhdGEudmFvLmRyYXcoZ2wuVFJJQU5HTEVfU1RSSVAsIHdlYkdMRGF0YS5pbmRpY2VzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVHcmFwaGljcyhncmFwaGljcyAsIGRpc3BsYXlPYmplY3QpXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG5cbiAgICAgICAgbGV0IHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW3RoaXMuQ09OVEVYVF9VSURdO1xuXG4gICAgICAgIGlmICghd2ViR0wpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMID0gZ3JhcGhpY3MuX3dlYkdMW3RoaXMuQ09OVEVYVF9VSURdID0geyBsYXN0SW5kZXg6IDAsIGRhdGE6IFtdLCBnbCwgY2xlYXJEaXJ0eTogLTEsIGRpcnR5OiAtMSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2ViR0wuZGlydHkgPSBncmFwaGljcy5kaXJ0eTtcblxuICAgICAgICBpZiAoZ3JhcGhpY3MuY2xlYXJEaXJ0eSAhPT0gd2ViR0wuY2xlYXJEaXJ0eSlcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0wuY2xlYXJEaXJ0eSA9IGdyYXBoaWNzLmNsZWFyRGlydHk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2ViR0wuZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVBvb2wucHVzaCh3ZWJHTC5kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2ViR0wuZGF0YS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgd2ViR0wubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3ZWJHTERhdGE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHdlYkdMLmxhc3RJbmRleDsgaSA8IGRpc3BsYXlPYmplY3QuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZGlzcGxheU9iamVjdC5ncmFwaGljc0RhdGFbaV07XG5cbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IHRoaXMuZ2V0V2ViR0xEYXRhKHdlYkdMLCAwKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLlBPTFkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnVpbGRQb2x5KGRhdGEsIHdlYkdMRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSBTSEFQRVMuUkVDVClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBidWlsZFJlY3RhbmdsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gU0hBUEVTLkNJUkMgfHwgZGF0YS50eXBlID09PSBTSEFQRVMuRUxJUClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBidWlsZENpcmNsZShkYXRhLCB3ZWJHTERhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ZWJHTC5sYXN0SW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYmluZFZhbyhudWxsKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlYkdMLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdlYkdMRGF0YSA9IHdlYkdMLmRhdGFbaV07XG5cbiAgICAgICAgICAgIGlmICh3ZWJHTERhdGEuZGlydHkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2ViR0xEYXRhLnVwbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0V2ViR0xEYXRhKGdsLCB0eXBlKVxuICAgIHtcbiAgICAgICAgbGV0IHdlYkdMRGF0YSA9IGdsLmRhdGFbZ2wuZGF0YS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoIXdlYkdMRGF0YSB8fCB3ZWJHTERhdGEucG9pbnRzLmxlbmd0aCA+IDMyMDAwMClcbiAgICAgICAge1xuICAgICAgICAgICAgd2ViR0xEYXRhID0gdGhpcy5ncmFwaGljc0RhdGFQb29sLnBvcCgpXG4gICAgICAgICAgICAgICAgfHwgbmV3IFdlYkdMR3JhcGhpY3NEYXRhKHRoaXMucmVuZGVyZXIuZ2wsIHRoaXMucHJpbWl0aXZlU2hhZGVyLCB0aGlzLnJlbmRlcmVyLnN0YXRlLmF0dHJpYnNTdGF0ZSk7XG5cbiAgICAgICAgICAgIHdlYkdMRGF0YS5yZXNldCh0eXBlKTtcbiAgICAgICAgICAgIGdsLmRhdGEucHVzaCh3ZWJHTERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2ViR0xEYXRhLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gd2ViR0xEYXRhO1xuICAgIH1cbn0iLCJpbXBvcnQgUmVuZGVyVGFyZ2V0IGZyb20gJy4vdXRpbHMvUmVuZGVyVGFyZ2V0JztcbmltcG9ydCBXZWJHTFN0YXRlIGZyb20gJy4vV2ViR0xTdGF0ZSc7XG5pbXBvcnQgZ2xDb3JlIGZyb20gJ3BpeGktZ2wtY29yZSc7XG5pbXBvcnQgeyBSRU5ERVJFUl9UWVBFICwgRFJBV19NT0RFU30gZnJvbSAnLi4vLi4vY29uc3QnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCBHcmFwaGljc1JlbmRlcmVyIGZyb20gJy4uLy4uL2dyYXBoaWNzL3dlYmdsL0dyYXBoaWNzUmVuZGVyZXInO1xuXG5sZXQgQ09OVEVYVF9VSUQgPSAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFN0YWdlUmVuZGVyZXJcbntcbiAgICBjb25zdHJ1Y3Rvciggc3RhZ2UgLCBhcHAgLCBvcHRpb25zID0ge30gKVxuICAgIHtcbiAgICAgICAgdGhpcy50eXBlID0gUkVOREVSRVJfVFlQRS5XRUJHTDtcbiAgICAgICAgdGhpcy53aWR0aCA9IGFwcC53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBhcHAuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhcyA9IHN0YWdlLmNhbnZhcztcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICogV2ViR0znqIvluo/lv4XpobvmnInkuIDkuKrnlKjkuo7lpITnkIbkuIrkuIvmlofkuKLlpLHvvIhMb3N0IENvbnRleHTvvInnmoTmnLrliLZcbiAgICAgICAgKiDlr7zoh7TkuIrkuIvmlofkuKLlpLHnmoTljp/lm6DvvJpcbiAgICAgICAgKiDnp7vliqjorr7lpIfnlLXlipvkuI3otrNcbiAgICAgICAgKiDlhbbku5blpJblm6Dlr7zoh7RHUFXph43nva5cbiAgICAgICAgKiDlvZPmtY/op4jlmajmoIfnrb7pobXlpITkuo7lkI7lj7Dml7bvvIzmtY/op4jlmajmipvlvIPkuobkuIrkuIvmlodcbiAgICAgICAgKiDogJfotLnotYTmupDov4flpJrvvIzmtY/op4jlmajmipvlvIPkuobkuIrkuIvmlodcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IHRoaXMuaGFuZGxlQ29udGV4dExvc3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQgPSB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICB0aGlzLl9jb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFscGhhOiBvcHRpb25zLnRyYW5zcGFyZW50LFxuICAgICAgICAgICAgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogb3B0aW9ucy50cmFuc3BhcmVudCAmJiBvcHRpb25zLnRyYW5zcGFyZW50ICE9PSAnbm90TXVsdGlwbGllZCcsXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcixcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdsID0gb3B0aW9ucy5jb250ZXh0IHx8IGdsQ29yZS5jcmVhdGVDb250ZXh0KCB0aGlzLmNhbnZhcyAsIHRoaXMuX2NvbnRleHRPcHRpb25zKTtcblxuICAgICAgICB0aGlzLkNPTlRFWFRfVUlEID0gQ09OVEVYVF9VSUQrKztcblxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFdlYkdMU3RhdGUodGhpcy5nbCk7XG5cbiAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPSBudWxsO1xuXG5cbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmRyYXdNb2RlcyA9IHRoaXMubWFwV2ViR0xEcmF3TW9kZXMoKTtcblxuICAgICAgICB0aGlzLndlYmdsR1IgPSBuZXcgR3JhcGhpY3NSZW5kZXJlcih0aGlzKTtcblxuICAgICAgICB0aGlzLl9pbml0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIF9pbml0Q29udGV4dCgpXG4gICAge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgLy8gcmVzdG9yZSBhIGNvbnRleHQgaWYgaXQgd2FzIHByZXZpb3VzbHkgbG9zdFxuICAgICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpICYmIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykucmVzdG9yZUNvbnRleHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLnJvb3RSZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KGdsLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgc2V0dGluZ3MuUkVTT0xVVElPTiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldC5jbGVhckNvbG9yID0gdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYTtcblxuICAgICAgICB0aGlzLmJpbmRSZW5kZXJUYXJnZXQodGhpcy5yb290UmVuZGVyVGFyZ2V0KTtcblxuICAgICAgICB0aGlzLndlYmdsR1Iub25Db250ZXh0Q2hhbmdlKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGRpc3BsYXlPYmplY3QsIHN0YWdlICwgZ3JhcGhpY3MpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndlYmdsR1IucmVuZGVyKCBkaXNwbGF5T2JqZWN0LCBzdGFnZSAsIGdyYXBoaWNzICk7XG4gICAgfVxuXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAge1xuICAgICAgICB0aGlzLnJvb3RSZW5kZXJUYXJnZXQucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID09PSB0aGlzLnJvb3RSZW5kZXJUYXJnZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2hhZGVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNoYWRlci51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5yb290UmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKGNsZWFyQ29sb3IpXG4gICAge1xuICAgICAgICB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQuY2xlYXIoY2xlYXJDb2xvcik7XG4gICAgfVxuXG4gICAgYmluZFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpXG4gICAge1xuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlU2hhZGVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNoYWRlci51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gcmVuZGVyVGFyZ2V0LnByb2plY3Rpb25NYXRyaXgudG9BcnJheSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGJpbmRTaGFkZXIoc2hhZGVyKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVNoYWRlciAhPT0gc2hhZGVyKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVTaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQucHJvamVjdGlvbk1hdHJpeC50b0FycmF5KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY3JlYXRlVmFvKClcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgZ2xDb3JlLlZlcnRleEFycmF5T2JqZWN0KHRoaXMuZ2wsIHRoaXMuc3RhdGUuYXR0cmliU3RhdGUpO1xuICAgIH1cblxuICAgIGJpbmRWYW8odmFvKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVZhbyA9PT0gdmFvKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YW8pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhby5iaW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYWN0aXZlVmFvKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWYW8udW5iaW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPSB2YW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlU2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0ID0gdGhpcy5yb290UmVuZGVyVGFyZ2V0O1xuXG4gICAgICAgIHRoaXMucm9vdFJlbmRlclRhcmdldC5hY3RpdmF0ZSgpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBoYW5kbGVDb250ZXh0TG9zdChldmVudClcbiAgICB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ29udGV4dFJlc3RvcmVkKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2luaXRDb250ZXh0KCk7XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIucmVtb3ZlQWxsKCk7XG4gICAgfVxuXG4gICAgbWFwV2ViR0xEcmF3TW9kZXMoIG9iamVjdD17fSApXG4gICAge1xuICAgICAgICBvYmplY3RbRFJBV19NT0RFUy5QT0lOVFNdID0gdGhpcy5nbC5QT0lOVFM7XG4gICAgICAgIG9iamVjdFtEUkFXX01PREVTLkxJTkVTXSA9IHRoaXMuZ2wuTElORVM7XG4gICAgICAgIG9iamVjdFtEUkFXX01PREVTLkxJTkVfTE9PUF0gPSB0aGlzLmdsLkxJTkVfTE9PUDtcbiAgICAgICAgb2JqZWN0W0RSQVdfTU9ERVMuTElORV9TVFJJUF0gPSB0aGlzLmdsLkxJTkVfU1RSSVA7XG4gICAgICAgIG9iamVjdFtEUkFXX01PREVTLlRSSUFOR0xFU10gPSB0aGlzLmdsLlRSSUFOR0xFUztcbiAgICAgICAgb2JqZWN0W0RSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVBdID0gdGhpcy5nbC5UUklBTkdMRV9TVFJJUDtcbiAgICAgICAgb2JqZWN0W0RSQVdfTU9ERVMuVFJJQU5HTEVfRkFOXSA9IHRoaXMuZ2wuVFJJQU5HTEVfRkFOO1xuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgZGVzdHJveShyZW1vdmVWaWV3KVxuICAgIHtcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2lucygpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveShyZW1vdmVWaWV3KTtcblxuICAgICAgICB0aGlzLnVpZCA9IDA7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9jb250ZXh0T3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShudWxsKTtcblxuICAgICAgICBpZiAodGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykubG9zZUNvbnRleHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIH1cbn0iLCJpbXBvcnQgU3lzdGVtUmVuZGVyZXIgZnJvbSAnLi4vU3lzdGVtUmVuZGVyZXInO1xuaW1wb3J0IHsgUkVOREVSRVJfVFlQRSB9IGZyb20gJy4uLy4uL2NvbnN0JztcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgV2ViR0xTdGFnZVJlbmRlcmVyIGZyb20gXCIuL1dlYkdMU3RhZ2VSZW5kZXJlclwiO1xuaW1wb3J0IEdyYXBoaWNzIGZyb20gXCIuLi8uLi9ncmFwaGljcy9HcmFwaGljc1wiO1xuaW1wb3J0IF8gZnJvbSBcIi4uLy4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIFN5c3RlbVJlbmRlcmVyXG57XG4gICAgY29uc3RydWN0b3IoYXBwICwgb3B0aW9ucyA9IHt9KVxuICAgIHtcbiAgICAgICAgc3VwZXIoUkVOREVSRVJfVFlQRS5DQU5WQVMsIGFwcCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoIGFwcCAsIG9wdGlvbnMgPSB7fSApXG4gICAge1xuICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgbWUuYXBwID0gYXBwO1xuICAgICAgICBfLmV4dGVuZCggdGhpcy5vcHRpb25zICwgb3B0aW9ucyApO1xuXG4gICAgICAgIF8uZWFjaChfLnZhbHVlcyggYXBwLmNvbnZlcnRTdGFnZXMgKSAsIGZ1bmN0aW9uKGNvbnZlcnRTdGFnZSl7XG4gICAgICAgICAgICBtZS5yZW5kZXJTdGFnZSggY29udmVydFN0YWdlLnN0YWdlICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwcC5jb252ZXJ0U3RhZ2VzID0ge307XG4gICAgfVxuXG4gICAgcmVuZGVyU3RhZ2UoIHN0YWdlIClcbiAgICB7XG4gICAgICAgIGlmKCFzdGFnZS53ZWJHTFN0YWdlUmVuZGVyZXIpe1xuICAgICAgICAgICAgc3RhZ2Uud2ViR0xTdGFnZVJlbmRlcmVyID0gbmV3IFdlYkdMU3RhZ2VSZW5kZXJlciggc3RhZ2UgLCBhcHAgLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBzdGFnZS5zdGFnZVJlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbGVhciggc3RhZ2UgKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyKCBzdGFnZSApO1xuICAgICAgICBzdGFnZS5zdGFnZVJlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfcmVuZGVyKCBzdGFnZSAsIGRpc3BsYXlPYmplY3QgKVxuICAgIHtcbiAgICAgICAgaWYoICFkaXNwbGF5T2JqZWN0ICl7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0ID0gc3RhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoICFkaXNwbGF5T2JqZWN0LmNvbnRleHQudmlzaWJsZSB8fCBkaXNwbGF5T2JqZWN0LmNvbnRleHQuZ2xvYmFsQWxwaGEgPD0gMCApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBkaXNwbGF5T2JqZWN0LmdyYXBoaWNzRGF0YSApe1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kcmF3KCBzdGFnZSwgdGhpcyApO1xuICAgICAgICAgICAgc3RhZ2Uud2ViR0xTdGFnZVJlbmRlcmVyLnJlbmRlciggZGlzcGxheU9iamVjdCwgc3RhZ2UgLCB0aGlzLmdyYXBoaWNzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggZGlzcGxheU9iamVjdC5jaGlsZHJlbiApe1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlciggc3RhZ2UgLCBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuW2ldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2NsZWFyKCBzdGFnZSApXG4gICAge1xuICAgICAgICBzdGFnZS53ZWJHTFN0YWdlUmVuZGVyZXIuY2xlYXIoKTtcbiAgICB9XG59XG5cbiIsImltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy9pbmRleCc7XG5pbXBvcnQgQ2FudmFzUmVuZGVyZXIgZnJvbSAnLi9jYW52YXMvQ2FudmFzUmVuZGVyZXInO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi93ZWJnbC9XZWJHTFJlbmRlcmVyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b1JlbmRlcmVyKCBhcHAgLCBvcHRpb25zKVxue1xuICAgIGlmIChhcHAud2ViR0wgJiYgdXRpbHMuaXNXZWJHTFN1cHBvcnRlZCgpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTFJlbmRlcmVyKCBhcHAgLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgQ2FudmFzUmVuZGVyZXIoIGFwcCAsIG9wdGlvbnMpO1xufVxuIiwiLyoqXG4gKiBBcHBsaWNhdGlvbiB7e1BLR19WRVJTSU9OfX1cbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICog5Li75byV5pOOIOexu1xuICpcbiAqIOi0n+i0o+aJgOaciWNhbnZhc+eahOWxgue6p+euoeeQhu+8jOWSjOW/g+i3s+acuuWItueahOWunueOsCzmjZXojrfliLDlv4Pot7PljIXlkI4gXG4gKiDliIblj5HliLDlr7nlupTnmoRzdGFnZShjYW52YXMp5p2l57uY5Yi25a+55bqU55qE5pS55YqoXG4gKiDnhLblkI4g6buY6K6k5pyJ5a6e546w5LqGc2hhcGXnmoQgbW91c2VvdmVyICBtb3VzZW91dCAgZHJhZyDkuovku7ZcbiAqXG4gKiovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi91dGlscy9pbmRleFwiO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tIFwiLi9ldmVudC9FdmVudEhhbmRsZXJcIjtcbmltcG9ydCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIGZyb20gXCIuL2Rpc3BsYXkvRGlzcGxheU9iamVjdENvbnRhaW5lclwiO1xuaW1wb3J0IFN0YWdlIGZyb20gXCIuL2Rpc3BsYXkvU3RhZ2VcIjtcbmltcG9ydCBhdXRvUmVuZGVyZXIgZnJvbSBcIi4vcmVuZGVyZXJzL2F1dG9SZW5kZXJlclwiO1xuaW1wb3J0IE1hdHJpeCBmcm9tIFwiLi9nZW9tL01hdHJpeFwiO1xuXG5cbi8vdXRpbHNcbmltcG9ydCBfIGZyb20gXCIuL3V0aWxzL3VuZGVyc2NvcmVcIjtcbmltcG9ydCAkIGZyb20gXCIuL3V0aWxzL2RvbVwiO1xuXG5cbnZhciBBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uKCBvcHQgLCBvcHRpb25zID0ge30pe1xuICAgIHRoaXMudHlwZSA9IFwiY2FudmF4XCI7XG4gICAgdGhpcy5fY2lkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBcIl9cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDApOyBcbiAgICBcbiAgICB0aGlzLmVsID0gJC5xdWVyeShvcHQuZWwpO1xuXG4gICAgdGhpcy53aWR0aCA9IHBhcnNlSW50KFwid2lkdGhcIiAgaW4gb3B0IHx8IHRoaXMuZWwub2Zmc2V0V2lkdGggICwgMTApOyBcbiAgICB0aGlzLmhlaWdodCA9IHBhcnNlSW50KFwiaGVpZ2h0XCIgaW4gb3B0IHx8IHRoaXMuZWwub2Zmc2V0SGVpZ2h0ICwgMTApOyBcblxuICAgIHZhciB2aWV3T2JqID0gJC5jcmVhdGVWaWV3KHRoaXMud2lkdGggLCB0aGlzLmhlaWdodCwgdGhpcy5fY2lkKTtcbiAgICB0aGlzLnZpZXcgPSB2aWV3T2JqLnZpZXc7XG4gICAgdGhpcy5zdGFnZV9jID0gdmlld09iai5zdGFnZV9jO1xuICAgIHRoaXMuZG9tX2MgPSB2aWV3T2JqLmRvbV9jO1xuICAgIFxuICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKCB0aGlzLnZpZXcgKTtcblxuICAgIHRoaXMudmlld09mZnNldCA9ICQub2Zmc2V0KHRoaXMudmlldyk7XG4gICAgdGhpcy5sYXN0R2V0Uk8gPSAwOy8v5pyA5ZCO5LiA5qyh6I635Y+WIHZpZXdPZmZzZXQg55qE5pe26Ze0XG5cbiAgICB0aGlzLndlYkdMICA9IG9wdC53ZWJHTDtcbiAgICB0aGlzLnJlbmRlcmVyID0gYXV0b1JlbmRlcmVyKHRoaXMgLCBvcHRpb25zKTtcblxuICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fYnVmZmVyU3RhZ2UgPSBudWxsO1xuXG4gICAgLy/mmK/lkKbpmLvmraLmtY/op4jlmajpu5jorqTkuovku7bnmoTmiafooYxcbiAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICBpZiggb3B0LnByZXZlbnREZWZhdWx0ID09PSBmYWxzZSApe1xuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gZmFsc2VcbiAgICB9O1xuXG4gICAgLy/or6XlsZ7mgKflnKhzeXN0ZW5SZW5kZXLph4zpnaLmk43kvZzvvIzmr4/luKfnlLHlv4Pot7PkuIrmiqXnmoQg6ZyA6KaB6YeN57uY55qEc3RhZ2VzIOWIl+ihqFxuICAgIHRoaXMuY29udmVydFN0YWdlcyA9IHt9O1xuXG4gICAgQXBwbGljYXRpb24uc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuVXRpbHMuY3JlYXRDbGFzcyhBcHBsaWNhdGlvbiAsIERpc3BsYXlPYmplY3RDb250YWluZXIgLCB7XG4gICAgaW5pdCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuY29udGV4dC53aWR0aCAgPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmNvbnRleHQuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7IFxuXG4gICAgICAgIC8v54S25ZCO5Yib5bu65LiA5Liq55So5LqO57uY5Yi25r+A5rS7IHNoYXBlIOeahCBzdGFnZSDliLBhY3RpdmF0aW9uXG4gICAgICAgIHRoaXMuX2NyZWF0SG92ZXJTdGFnZSgpO1xuXG4gICAgICAgIC8v5Yib5bu65LiA5Liq5aaC5p6c6KaB55So5YOP57Sg5qOA5rWL55qE5pe25YCZ55qE5a655ZmoXG4gICAgICAgIHRoaXMuX2NyZWF0ZVBpeGVsQ29udGV4dCgpO1xuXG4gICAgICAgIC8v6K6+572u5LiA5Liq6buY6K6k55qEbWF0cml45YGa5Li6YXBw55qE5LiW55WM5qC56IqC54K55Z2Q5qCHXG4gICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCkuaWRlbnRpdHkoKTtcbiAgICAgICAgXG4gICAgfSxcbiAgICByZWdpc3RFdmVudCA6IGZ1bmN0aW9uKG9wdCl7XG4gICAgICAgIC8v5Yid5aeL5YyW5LqL5Lu25aeU5omY5Yiwcm9vdOWFg+e0oOS4iumdolxuICAgICAgICB0aGlzLmV2ZW50ID0gbmV3IEV2ZW50SGFuZGxlciggdGhpcyAsIG9wdCk7O1xuICAgICAgICB0aGlzLmV2ZW50LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnQ7XG4gICAgfSxcbiAgICByZXNpemUgOiBmdW5jdGlvbiggb3B0ICl7XG4gICAgICAgIC8v6YeN5paw6K6+572u5Z2Q5qCH57O757ufIOmrmOWuvSDnrYnjgIJcbiAgICAgICAgdGhpcy53aWR0aCAgICAgID0gcGFyc2VJbnQoKG9wdCAmJiBcIndpZHRoXCIgaW4gb3B0KSB8fCB0aGlzLmVsLm9mZnNldFdpZHRoICAsIDEwKTsgXG4gICAgICAgIHRoaXMuaGVpZ2h0ICAgICA9IHBhcnNlSW50KChvcHQgJiYgXCJoZWlnaHRcIiBpbiBvcHQpIHx8IHRoaXMuZWwub2Zmc2V0SGVpZ2h0ICwgMTApOyBcblxuICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggID0gdGhpcy53aWR0aCArXCJweFwiO1xuICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQrXCJweFwiO1xuXG4gICAgICAgIHRoaXMudmlld09mZnNldCAgICAgPSAkLm9mZnNldCh0aGlzLnZpZXcpO1xuICAgICAgICB0aGlzLl9ub3RXYXRjaCAgICAgID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LndpZHRoICA9IHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMuY29udGV4dC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy5fbm90V2F0Y2ggICAgICA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciByZVNpemVDYW52YXMgICAgPSBmdW5jdGlvbihjdHgpe1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBtZS53aWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQ9IG1lLmhlaWdodCsgXCJweFwiO1xuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIgICwgbWUud2lkdGggKiBVdGlscy5fZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIgLCBtZS5oZWlnaHQqIFV0aWxzLl9kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgICAgICAgLy/lpoLmnpzmmK9zd2bnmoTor53lsLHov5jopoHosIPnlKjov5nkuKrmlrnms5XjgIJcbiAgICAgICAgICAgIGlmIChjdHgucmVzaXplKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlc2l6ZShtZS53aWR0aCAsIG1lLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07IFxuICAgICAgICBfLmVhY2godGhpcy5jaGlsZHJlbiAsIGZ1bmN0aW9uKHMgLCBpKXtcbiAgICAgICAgICAgIHMuX25vdFdhdGNoICAgICA9IHRydWU7XG4gICAgICAgICAgICBzLmNvbnRleHQud2lkdGggPSBtZS53aWR0aDtcbiAgICAgICAgICAgIHMuY29udGV4dC5oZWlnaHQ9IG1lLmhlaWdodDtcbiAgICAgICAgICAgIHJlU2l6ZUNhbnZhcyhzLmNhbnZhcyk7XG4gICAgICAgICAgICBzLl9ub3RXYXRjaCAgICAgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kb21fYy5zdHlsZS53aWR0aCAgPSB0aGlzLndpZHRoICArIFwicHhcIjtcbiAgICAgICAgdGhpcy5kb21fYy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcblxuICAgICAgICB0aGlzLmhlYXJ0QmVhdCgpO1xuXG4gICAgfSxcbiAgICBnZXRIb3ZlclN0YWdlIDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlclN0YWdlO1xuICAgIH0sXG4gICAgX2NyZWF0SG92ZXJTdGFnZSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vVE9ETzrliJvlu7pzdGFnZeeahOaXtuWAmeS4gOWumuimgeS8oOWFpXdpZHRoIGhlaWdodCAg5Lik5Liq5Y+C5pWwXG4gICAgICAgIHRoaXMuX2J1ZmZlclN0YWdlID0gbmV3IFN0YWdlKCB7XG4gICAgICAgICAgICBpZCA6IFwiYWN0aXZDYW52YXNcIisobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgY29udGV4dCA6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCA6IHRoaXMuY29udGV4dC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY29udGV4dC5oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgICAgICAvL+ivpXN0YWdl5LiN5Y+C5LiO5LqL5Lu25qOA5rWLXG4gICAgICAgIHRoaXMuX2J1ZmZlclN0YWdlLl9ldmVudEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggdGhpcy5fYnVmZmVyU3RhZ2UgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIOeUqOadpeajgOa1i+aWh+acrHdpZHRoIGhlaWdodCBcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOS4iuS4i+aWh1xuICAgICovXG4gICAgX2NyZWF0ZVBpeGVsQ29udGV4dCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3BpeGVsQ2FudmFzID0gJC5xdWVyeShcIl9waXhlbENhbnZhc1wiKTtcbiAgICAgICAgaWYoIV9waXhlbENhbnZhcyl7XG4gICAgICAgICAgICBfcGl4ZWxDYW52YXMgPSAkLmNyZWF0ZUNhbnZhcygwLCAwLCBcIl9waXhlbENhbnZhc1wiKTsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL+WmguaenOWPiOeahOivnSDlsLHkuI3pnIDopoHlnKjliJvlu7rkuoZcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggX3BpeGVsQ2FudmFzICk7XG4gICAgICAgIFV0aWxzLmluaXRFbGVtZW50KCBfcGl4ZWxDYW52YXMgKTtcbiAgICAgICAgaWYoIFV0aWxzLmNhbnZhc1N1cHBvcnQoKSApe1xuICAgICAgICAgICAgLy9jYW52YXPnmoTor53vvIzlk6rmgJXmmK9kaXNwbGF5Om5vbmXnmoTpobXlj6/ku6XnlKjmnaXlt6blg4/ntKDmo4DmtYvlkoxtZWFzdXJlVGV4dOaWh+acrHdpZHRo5qOA5rWLXG4gICAgICAgICAgICBfcGl4ZWxDYW52YXMuc3R5bGUuZGlzcGxheSAgICA9IFwibm9uZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9mbGFzaENhbnZhcyDnmoTor53vvIxzd2blpoLmnpxkaXNwbGF5Om5vbmXkuobjgILlsLHlgZrkuI3kuoZtZWFzdXJlVGV4dCDmlofmnKzlrr3luqYg5qOA5rWL5LqGXG4gICAgICAgICAgICBfcGl4ZWxDYW52YXMuc3R5bGUuekluZGV4ICAgICA9IC0xO1xuICAgICAgICAgICAgX3BpeGVsQ2FudmFzLnN0eWxlLnBvc2l0aW9uICAgPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICBfcGl4ZWxDYW52YXMuc3R5bGUubGVmdCAgICAgICA9IC10aGlzLmNvbnRleHQud2lkdGggICsgXCJweFwiO1xuICAgICAgICAgICAgX3BpeGVsQ2FudmFzLnN0eWxlLnRvcCAgICAgICAgPSAtdGhpcy5jb250ZXh0LmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIF9waXhlbENhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgICBVdGlscy5fcGl4ZWxDdHggPSBfcGl4ZWxDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlld09mZnNldCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgaWYoIG5vdyAtIHRoaXMubGFzdEdldFJPID4gMTAwMCApe1xuICAgICAgICAgICAgdGhpcy52aWV3T2Zmc2V0ICAgICAgPSAkLm9mZnNldCh0aGlzLnZpZXcpO1xuICAgICAgICAgICAgdGhpcy5sYXN0R2V0Uk8gICAgICAgPSBub3c7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIF9hZnRlckFkZENoaWxkIDogZnVuY3Rpb24oIHN0YWdlICwgaW5kZXggKXtcbiAgICAgICAgdmFyIGNhbnZhcztcblxuICAgICAgICBpZighc3RhZ2UuY2FudmFzKXtcbiAgICAgICAgICAgIGNhbnZhcyA9ICQuY3JlYXRlQ2FudmFzKCB0aGlzLmNvbnRleHQud2lkdGggLCB0aGlzLmNvbnRleHQuaGVpZ2h0LCBzdGFnZS5pZCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICB0aGlzLnN0YWdlX2MuYXBwZW5kQ2hpbGQoIGNhbnZhcyApO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5jaGlsZHJlbi5sZW5ndGg+MSkge1xuICAgICAgICAgICAgaWYoIGluZGV4ID09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAvL+WmguaenOayoeacieaMh+WumuS9jee9ru+8jOmCo+S5iOWwseaUvuWIsF9idWZmZXJTdGFnZeeahOS4i+mdouOAglxuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2VfYy5pbnNlcnRCZWZvcmUoIGNhbnZhcyAsIHRoaXMuX2J1ZmZlclN0YWdlLmNhbnZhcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8v5aaC5p6c5pyJ5oyH5a6a55qE5L2N572u77yM6YKj5LmI5bCx5oyH5a6a55qE5L2N572u5p2lXG4gICAgICAgICAgICAgICAgaWYoIGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoLTEgKXtcbiAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWdlX2MuYXBwZW5kQ2hpbGQoIGNhbnZhcyApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgdGhpcy5zdGFnZV9jLmluc2VydEJlZm9yZSggY2FudmFzICwgdGhpcy5jaGlsZHJlblsgaW5kZXggXS5jYW52YXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgVXRpbHMuaW5pdEVsZW1lbnQoIGNhbnZhcyApO1xuICAgICAgICBzdGFnZS5pbml0U3RhZ2UoIGNhbnZhcyAsIHRoaXMuY29udGV4dC53aWR0aCAsIHRoaXMuY29udGV4dC5oZWlnaHQgKTsgXG4gICAgfSxcbiAgICBfYWZ0ZXJEZWxDaGlsZCA6IGZ1bmN0aW9uKHN0YWdlKXtcbiAgICAgICAgdGhpcy5zdGFnZV9jLnJlbW92ZUNoaWxkKCBzdGFnZS5jYW52YXMgKTtcbiAgICB9LFxuICAgIFxuICAgIGhlYXJ0QmVhdCA6IGZ1bmN0aW9uKG9wdCl7XG4gICAgICAgIGlmKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuaGVhcnRCZWF0KG9wdCk7XG4gICAgICAgIH1cbiAgICB9XG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcGxpY2F0aW9uOyIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOaooeaLn2FzMyDkuK0g55qEc3ByaXRl57G777yM55uu5YmN6L+Y5Y+q5piv5Liq566A5Y2V55qE5a655piT44CCXG4gKi9cbmltcG9ydCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIGZyb20gXCIuL0Rpc3BsYXlPYmplY3RDb250YWluZXJcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcblxudmFyIFNwcml0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy50eXBlID0gXCJzcHJpdGVcIjtcbiAgICBTcHJpdGUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuVXRpbHMuY3JlYXRDbGFzcyhTcHJpdGUgLCBEaXNwbGF5T2JqZWN0Q29udGFpbmVyICwge1xuICAgIGluaXQgOiBmdW5jdGlvbigpe1xuICAgIFxuICAgIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTcHJpdGU7XG4iLCIvKipcbiAqIENhbnZheFxuICpcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcbiAqXG4gKiDmqKHmi59hczMgRGlzcGxheUxpc3Qg5Lit55qEc2hhcGUg57G7XG4gKi9cbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gXCIuL0Rpc3BsYXlPYmplY3RcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XG5pbXBvcnQge1NIQVBFX0NPTlRFWFRfREVGQVVMVCwgU1RZTEVfUFJPUFN9IGZyb20gXCIuLi9jb25zdFwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlIGV4dGVuZHMgRGlzcGxheU9iamVjdFxue1xuICAgIGNvbnN0cnVjdG9yKG9wdCl7XG5cbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQob3B0KTtcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gXy5leHRlbmQoIF8uY2xvbmUoU0hBUEVfQ09OVEVYVF9ERUZBVUxUKSAsIG9wdC5jb250ZXh0ICk7XG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XG5cbiAgICAgICAgc3VwZXIoIG9wdCApO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XG5cbiAgICAgICAgLy/lhYPntKDmmK/lkKbmnIlob3ZlcuS6i+S7tiDlkowgY2hpY2vkuovku7bvvIznlLFhZGRFdmVuZXRMaXN0ZXLlkoxyZW1pdmVFdmVudExpc3RlcuadpeinpuWPkeS/ruaUuVxuICAgICAgICB0aGlzLl9ob3ZlcmFibGUgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NsaWNrYWJsZSAgPSBmYWxzZTtcblxuICAgICAgICAvL292ZXLnmoTml7blgJnlpoLmnpzmnInkv67mlLnmoLflvI/vvIzlsLHkuLp0cnVlXG4gICAgICAgIHRoaXMuX2hvdmVyQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ob3ZlckNsb25lICA9IHRydWU7ICAgIC8v5piv5ZCm5byA5ZCv5ZyoaG92ZXLnmoTml7blgJljbG9uZeS4gOS7veWIsGFjdGl2ZSBzdGFnZSDkuK0gXG4gICAgICAgIHRoaXMucG9pbnRDaGtQcmlvcml0eSA9IHRydWU7IC8v5Zyo6byg5qCHbW91c2VvdmVy5Yiw6K+l6IqC54K577yM54S25ZCObW91c2Vtb3Zl55qE5pe25YCZ77yM5piv5ZCm5LyY5YWI5qOA5rWL6K+l6IqC54K5XG5cbiAgICAgICAgLy/mi5bmi71kcmFn55qE5pe25YCZ5pi+56S65ZyoYWN0aXZTaGFwZeeahOWJr+acrFxuICAgICAgICB0aGlzLl9kcmFnRHVwbGljYXRlID0gbnVsbDtcblxuICAgICAgICAvL+WFg+e0oOaYr+WQpiDlvIDlkK8gZHJhZyDmi5bliqjvvIzov5nkuKrmnInnlKjmiLforr7nva7kvKDlhaVcbiAgICAgICAgLy9zZWxmLmRyYWdnYWJsZSA9IG9wdC5kcmFnZ2FibGUgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy50eXBlIHx8IFwic2hhcGVcIiA7XG4gICAgICAgIG9wdC5kcmF3ICYmICh0aGlzLmRyYXcgPSBvcHQuZHJhdyk7XG4gICAgICAgIFxuICAgICAgICAvL+WkhOeQhuaJgOacieeahOWbvuW9ouS4gOS6m+WFseacieeahOWxnuaAp+mFjee9rizmiorpmaTlvIBpZCxjb250ZXh05LmL5aSW55qE5omA5pyJ5bGe5oCn77yM5YWo6YOo5oyC6L295YiwdGhpc+S4iumdolxuICAgICAgICB0aGlzLmluaXRDb21wUHJvcGVydHkob3B0KTtcblxuICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBfZHJhdyhzdGFnZSAsIHJlbmRlcmVyKVxuICAgIHtcbiAgICAgICAgaWYodGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgLy/lhYjorr7nva7lpb3lvZPliY1ncmFwaGljc+eahHN0eWxlXG4gICAgICAgICAgICByZW5kZXJlci5ncmFwaGljcy5zZXRTdHlsZSggdGhpcy5jb250ZXh0ICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsYXN0R0RpbmQgPSByZW5kZXJlci5ncmFwaGljcy5ncmFwaGljc0RhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kcmF3KCByZW5kZXJlci5ncmFwaGljcyApO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEgPSByZW5kZXJlci5ncmFwaGljcy5ncmFwaGljc0RhdGEuc2xpY2UoIGxhc3RHRGluZCApO1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIF8uZWFjaCggdGhpcy5ncmFwaGljc0RhdGEgLCBmdW5jdGlvbiggZ2QgKXtcbiAgICAgICAgICAgICAgICBnZC5kaXNwbGF5T2JqZWN0ID0gbWU7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhckdyYXBoaWNzRGF0YSgpXG4gICAge1xuICAgICAgICBfLmVhY2goIHRoaXMuZ3JhcGhpY3NEYXRhICwgZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICBkLmRlc3Ryb3koKTtcbiAgICAgICAgfSApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgICR3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpIFxuICAgIHtcbiAgICAgICAgdGhpcy53YXRjaCggbmFtZSwgdmFsdWUsIHByZVZhbHVlICk7XG4gICAgfVxuXG4gICAgaW5pdENvbXBQcm9wZXJ0eShvcHQpXG4gICAge1xuICAgICAgICBmb3IoIHZhciBpIGluIG9wdCApe1xuICAgICAgICAgICBpZiggaSAhPSBcImlkXCIgJiYgaSAhPSBcImNvbnRleHRcIil7XG4gICAgICAgICAgICAgICB0aGlzW2ldID0gb3B0W2ldO1xuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgIC8qXG4gICAgKiDnlLvomZrnur9cbiAgICAqL1xuICAgZGFzaGVkTGluZVRvKGdyYXBoaWNzLCB4MSwgeTEsIHgyLCB5MiwgZGFzaExlbmd0aCApIFxuICAge1xuICAgICAgICAgZGFzaExlbmd0aCA9IHR5cGVvZiBkYXNoTGVuZ3RoID09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgPyAzIDogZGFzaExlbmd0aDtcbiAgICAgICAgIGRhc2hMZW5ndGggPSBNYXRoLm1heCggZGFzaExlbmd0aCAsIHRoaXMuY29udGV4dC5saW5lV2lkdGggKTtcbiAgICAgICAgIHZhciBkZWx0YVggPSB4MiAtIHgxO1xuICAgICAgICAgdmFyIGRlbHRhWSA9IHkyIC0geTE7XG4gICAgICAgICB2YXIgbnVtRGFzaGVzID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSAvIGRhc2hMZW5ndGhcbiAgICAgICAgICk7XG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhc2hlczsgKytpKSB7XG4gICAgICAgICAgICAgdmFyIHggPSBwYXJzZUludCh4MSArIChkZWx0YVggLyBudW1EYXNoZXMpICogaSk7XG4gICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUludCh5MSArIChkZWx0YVkgLyBudW1EYXNoZXMpICogaSk7XG4gICAgICAgICAgICAgZ3JhcGhpY3NbaSAlIDIgPT09IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXSggeCAsIHkgKTtcbiAgICAgICAgICAgICBpZiggaSA9PSAobnVtRGFzaGVzLTEpICYmIGklMiA9PT0gMCl7XG4gICAgICAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVUbyggeDIgLCB5MiApO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgIH1cblxuICAgLypcbiAgICAq5LuOY3Bs6IqC54K55Lit6I635Y+W5YiwNOS4quaWueWQkeeahOi+ueeVjOiKgueCuVxuICAgICpAcGFyYW0gIGNvbnRleHQgXG4gICAgKlxuICAgICoqL1xuICAgZ2V0UmVjdEZvcm1Qb2ludExpc3QoIGNvbnRleHQgKVxuICAge1xuICAgICAgIHZhciBtaW5YID0gIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgdmFyIG1heFggPSAgTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgICB2YXIgbWluWSA9ICBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgIHZhciBtYXhZID0gIE51bWJlci5NSU5fVkFMVUU7XG5cbiAgICAgICB2YXIgY3BsID0gY29udGV4dC5wb2ludExpc3Q7IC8vdGhpcy5nZXRjcGwoKTtcbiAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gY3BsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICBpZiAoY3BsW2ldWzBdIDwgbWluWCkge1xuICAgICAgICAgICAgICAgbWluWCA9IGNwbFtpXVswXTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoY3BsW2ldWzBdID4gbWF4WCkge1xuICAgICAgICAgICAgICAgbWF4WCA9IGNwbFtpXVswXTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoY3BsW2ldWzFdIDwgbWluWSkge1xuICAgICAgICAgICAgICAgbWluWSA9IGNwbFtpXVsxXTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBpZiAoY3BsW2ldWzFdID4gbWF4WSkge1xuICAgICAgICAgICAgICAgbWF4WSA9IGNwbFtpXVsxXTtcbiAgICAgICAgICAgfVxuICAgICAgIH07XG5cbiAgICAgICB2YXIgbGluZVdpZHRoO1xuICAgICAgIGlmIChjb250ZXh0LnN0cm9rZVN0eWxlIHx8IGNvbnRleHQuZmlsbFN0eWxlICApIHtcbiAgICAgICAgICAgbGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGggfHwgMTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBsaW5lV2lkdGggPSAwO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4ge1xuICAgICAgICAgICB4ICAgICAgOiBNYXRoLnJvdW5kKG1pblggLSBsaW5lV2lkdGggLyAyKSxcbiAgICAgICAgICAgeSAgICAgIDogTWF0aC5yb3VuZChtaW5ZIC0gbGluZVdpZHRoIC8gMiksXG4gICAgICAgICAgIHdpZHRoICA6IG1heFggLSBtaW5YICsgbGluZVdpZHRoLFxuICAgICAgICAgICBoZWlnaHQgOiBtYXhZIC0gbWluWSArIGxpbmVXaWR0aFxuICAgICAgIH07XG4gICB9XG59IiwiLyoqXHJcbiAqIENhbnZheC0tVGV4dFxyXG4gKlxyXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXHJcbiAqXHJcbiAqIOaWh+acrCDnsbtcclxuICoqL1xyXG5pbXBvcnQgRGlzcGxheU9iamVjdCBmcm9tIFwiLi9EaXNwbGF5T2JqZWN0XCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuXHJcbnZhciBUZXh0ID0gZnVuY3Rpb24odGV4dCwgb3B0KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBzZWxmLnR5cGUgPSBcInRleHRcIjtcclxuICAgIHNlbGYuX3JlTmV3bGluZSA9IC9cXHI/XFxuLztcclxuICAgIHNlbGYuZm9udFByb3BlcnRzID0gW1wiZm9udFN0eWxlXCIsIFwiZm9udFZhcmlhbnRcIiwgXCJmb250V2VpZ2h0XCIsIFwiZm9udFNpemVcIiwgXCJmb250RmFtaWx5XCJdO1xyXG5cclxuICAgIC8v5YGa5LiA5qyh566A5Y2V55qEb3B05Y+C5pWw5qCh6aqM77yM5L+d6K+B5Zyo55So5oi35LiN5Lygb3B055qE5pe25YCZIOaIluiAheS8oOS6hm9wdOS9huaYr+mHjOmdouayoeaciWNvbnRleHTnmoTml7blgJnmiqXplJlcclxuICAgIG9wdCA9IFV0aWxzLmNoZWNrT3B0KG9wdCk7XHJcblxyXG4gICAgc2VsZi5fY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICBmb250U2l6ZTogMTMsIC8v5a2X5L2T5aSn5bCP6buY6K6kMTNcclxuICAgICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxyXG4gICAgICAgIGZvbnRGYW1pbHk6IFwi5b6u6L2v6ZuF6buRLHNhbnMtc2VyaWZcIixcclxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogbnVsbCxcclxuICAgICAgICBmaWxsU3R5bGU6ICdibGFuaycsXHJcbiAgICAgICAgc3Ryb2tlU3R5bGU6IG51bGwsXHJcbiAgICAgICAgbGluZVdpZHRoOiAwLFxyXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEuMixcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXHJcbiAgICAgICAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbFxyXG4gICAgfSwgb3B0LmNvbnRleHQpO1xyXG5cclxuICAgIHNlbGYuX2NvbnRleHQuZm9udCA9IHNlbGYuX2dldEZvbnREZWNsYXJhdGlvbigpO1xyXG5cclxuICAgIHNlbGYudGV4dCA9IHRleHQudG9TdHJpbmcoKTtcclxuXHJcbiAgICBUZXh0LnN1cGVyY2xhc3MuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW29wdF0pO1xyXG59O1xyXG5cclxuVXRpbHMuY3JlYXRDbGFzcyhUZXh0LCBEaXNwbGF5T2JqZWN0LCB7XHJcbiAgICAkd2F0Y2g6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkge1xyXG4gICAgICAgIC8vY29udGV4dOWxnuaAp+acieWPmOWMlueahOebkeWQrOWHveaVsFxyXG4gICAgICAgIGlmIChfLmluZGV4T2YodGhpcy5mb250UHJvcGVydHMsIG5hbWUpID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAvL+WmguaenOS/ruaUueeahOaYr2ZvbnTnmoTmn5DkuKrlhoXlrrnvvIzlsLHph43mlrDnu4Too4XkuIDpgY1mb25055qE5YC877yMXHJcbiAgICAgICAgICAgIC8v54S25ZCO6YCa55+l5byV5pOO6L+Z5qyh5a+5Y29udGV4dOeahOS/ruaUueS4jemcgOimgeS4iuaKpeW/g+i3s1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RXYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQud2lkdGggPSB0aGlzLmdldFRleHRXaWR0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaGVpZ2h0ID0gdGhpcy5nZXRUZXh0SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGluaXQ6IGZ1bmN0aW9uKHRleHQsIG9wdCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICBjLndpZHRoID0gdGhpcy5nZXRUZXh0V2lkdGgoKTtcclxuICAgICAgICBjLmhlaWdodCA9IHRoaXMuZ2V0VGV4dEhlaWdodCgpO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiB0aGlzLmNvbnRleHQuJG1vZGVsKSB7XHJcbiAgICAgICAgICAgIGlmIChwIGluIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAgIT0gXCJ0ZXh0QmFzZWxpbmVcIiAmJiB0aGlzLmNvbnRleHQuJG1vZGVsW3BdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W3BdID0gdGhpcy5jb250ZXh0LiRtb2RlbFtwXTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0KGN0eCwgdGhpcy5fZ2V0VGV4dExpbmVzKCkpO1xyXG4gICAgfSxcclxuICAgIHJlc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmhlYXJ0QmVhdCgpO1xyXG4gICAgfSxcclxuICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcclxuICAgICAgICBVdGlscy5fcGl4ZWxDdHguc2F2ZSgpO1xyXG4gICAgICAgIFV0aWxzLl9waXhlbEN0eC5mb250ID0gdGhpcy5jb250ZXh0LmZvbnQ7XHJcbiAgICAgICAgd2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgoVXRpbHMuX3BpeGVsQ3R4LCB0aGlzLl9nZXRUZXh0TGluZXMoKSk7XHJcbiAgICAgICAgVXRpbHMuX3BpeGVsQ3R4LnJlc3RvcmUoKTtcclxuICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICB9LFxyXG4gICAgZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRleHRIZWlnaHQoVXRpbHMuX3BpeGVsQ3R4LCB0aGlzLl9nZXRUZXh0TGluZXMoKSk7XHJcbiAgICB9LFxyXG4gICAgX2dldFRleHRMaW5lczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dC5zcGxpdCh0aGlzLl9yZU5ld2xpbmUpO1xyXG4gICAgfSxcclxuICAgIF9yZW5kZXJUZXh0OiBmdW5jdGlvbihjdHgsIHRleHRMaW5lcykge1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgsIHRleHRMaW5lcyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4LCB0ZXh0TGluZXMpO1xyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9LFxyXG4gICAgX2dldEZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBmb250QXJyID0gW107XHJcblxyXG4gICAgICAgIF8uZWFjaCh0aGlzLmZvbnRQcm9wZXJ0cywgZnVuY3Rpb24ocCkge1xyXG4gICAgICAgICAgICB2YXIgZm9udFAgPSBzZWxmLl9jb250ZXh0W3BdO1xyXG4gICAgICAgICAgICBpZiAocCA9PSBcImZvbnRTaXplXCIpIHtcclxuICAgICAgICAgICAgICAgIGZvbnRQID0gcGFyc2VGbG9hdChmb250UCkgKyBcInB4XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb250UCAmJiBmb250QXJyLnB1c2goZm9udFApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZm9udEFyci5qb2luKCcgJyk7XHJcblxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJUZXh0RmlsbDogZnVuY3Rpb24oY3R4LCB0ZXh0TGluZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5maWxsU3R5bGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5fYm91bmRhcmllcyA9IFtdO1xyXG4gICAgICAgIHZhciBsaW5lSGVpZ2h0cyA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0T2ZMaW5lID0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKGN0eCwgaSwgdGV4dExpbmVzKTtcclxuICAgICAgICAgICAgbGluZUhlaWdodHMgKz0gaGVpZ2h0T2ZMaW5lO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmUoXHJcbiAgICAgICAgICAgICAgICAnZmlsbFRleHQnLFxyXG4gICAgICAgICAgICAgICAgY3R4LFxyXG4gICAgICAgICAgICAgICAgdGV4dExpbmVzW2ldLFxyXG4gICAgICAgICAgICAgICAgMCwgLy90aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRUb3BPZmZzZXQoKSArIGxpbmVIZWlnaHRzLFxyXG4gICAgICAgICAgICAgICAgaVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfcmVuZGVyVGV4dFN0cm9rZTogZnVuY3Rpb24oY3R4LCB0ZXh0TGluZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5zdHJva2VTdHlsZSB8fCAhdGhpcy5jb250ZXh0LmxpbmVXaWR0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgbGluZUhlaWdodHMgPSAwO1xyXG5cclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0cm9rZURhc2hBcnJheSkge1xyXG4gICAgICAgICAgICBpZiAoMSAmIHRoaXMuc3Ryb2tlRGFzaEFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2VEYXNoQXJyYXkucHVzaC5hcHBseSh0aGlzLnN0cm9rZURhc2hBcnJheSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1cHBvcnRzTGluZURhc2ggJiYgY3R4LnNldExpbmVEYXNoKHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHRPZkxpbmUgPSB0aGlzLl9nZXRIZWlnaHRPZkxpbmUoY3R4LCBpLCB0ZXh0TGluZXMpO1xyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0cyArPSBoZWlnaHRPZkxpbmU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZShcclxuICAgICAgICAgICAgICAgICdzdHJva2VUZXh0JyxcclxuICAgICAgICAgICAgICAgIGN0eCxcclxuICAgICAgICAgICAgICAgIHRleHRMaW5lc1tpXSxcclxuICAgICAgICAgICAgICAgIDAsIC8vdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VG9wT2Zmc2V0KCkgKyBsaW5lSGVpZ2h0cyxcclxuICAgICAgICAgICAgICAgIGlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9LFxyXG4gICAgX3JlbmRlclRleHRMaW5lOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcclxuICAgICAgICB0b3AgLT0gdGhpcy5fZ2V0SGVpZ2h0T2ZMaW5lKCkgLyA0O1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQudGV4dEFsaWduICE9PSAnanVzdGlmeScpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcnMobWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aDtcclxuICAgICAgICB2YXIgdG90YWxXaWR0aCA9IHRoaXMuY29udGV4dC53aWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHRvdGFsV2lkdGggPiBsaW5lV2lkdGgpIHtcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgICAgICB2YXIgd29yZHNXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsaW5lLnJlcGxhY2UoL1xccysvZywgJycpKS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoRGlmZiA9IHRvdGFsV2lkdGggLSB3b3Jkc1dpZHRoO1xyXG4gICAgICAgICAgICB2YXIgbnVtU3BhY2VzID0gd29yZHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdmFyIHNwYWNlV2lkdGggPSB3aWR0aERpZmYgLyBudW1TcGFjZXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGVmdE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB3b3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcnMobWV0aG9kLCBjdHgsIHdvcmRzW2ldLCBsZWZ0ICsgbGVmdE9mZnNldCwgdG9wLCBsaW5lSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgbGVmdE9mZnNldCArPSBjdHgubWVhc3VyZVRleHQod29yZHNbaV0pLndpZHRoICsgc3BhY2VXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJDaGFyczogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGNoYXJzLCBsZWZ0LCB0b3ApIHtcclxuICAgICAgICBjdHhbbWV0aG9kXShjaGFycywgMCwgdG9wKTtcclxuICAgIH0sXHJcbiAgICBfZ2V0SGVpZ2h0T2ZMaW5lOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmZvbnRTaXplICogdGhpcy5jb250ZXh0LmxpbmVIZWlnaHQ7XHJcbiAgICB9LFxyXG4gICAgX2dldFRleHRXaWR0aDogZnVuY3Rpb24oY3R4LCB0ZXh0TGluZXMpIHtcclxuICAgICAgICB2YXIgbWF4V2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dExpbmVzWzBdIHx8ICd8Jykud2lkdGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudExpbmVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0TGluZXNbaV0pLndpZHRoO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVXaWR0aCA+IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnRMaW5lV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heFdpZHRoO1xyXG4gICAgfSxcclxuICAgIF9nZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbihjdHgsIHRleHRMaW5lcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZm9udFNpemUgKiB0ZXh0TGluZXMubGVuZ3RoICogdGhpcy5jb250ZXh0LmxpbmVIZWlnaHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVG9wIG9mZnNldFxyXG4gICAgICovXHJcbiAgICBfZ2V0VG9wT2Zmc2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdCA9IDA7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbnRleHQudGV4dEJhc2VsaW5lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcclxuICAgICAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtaWRkbGVcIjpcclxuICAgICAgICAgICAgICAgIHQgPSAtdGhpcy5jb250ZXh0LmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxyXG4gICAgICAgICAgICAgICAgdCA9IC10aGlzLmNvbnRleHQuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfSxcclxuICAgIGdldFJlY3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgLy/mm7Tlhbd0ZXh0QWxpZ24g5ZKMIHRleHRCYXNlbGluZSDph43mlrDnn6vmraMgeHlcclxuICAgICAgICBpZiAoYy50ZXh0QWxpZ24gPT0gXCJjZW50ZXJcIikge1xyXG4gICAgICAgICAgICB4ID0gLWMud2lkdGggLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGMudGV4dEFsaWduID09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICB4ID0gLWMud2lkdGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYy50ZXh0QmFzZWxpbmUgPT0gXCJtaWRkbGVcIikge1xyXG4gICAgICAgICAgICB5ID0gLWMuaGVpZ2h0IC8gMjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjLnRleHRCYXNlbGluZSA9PSBcImJvdHRvbVwiKSB7XHJcbiAgICAgICAgICAgIHkgPSAtYy5oZWlnaHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgd2lkdGg6IGMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYy5oZWlnaHRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5leHBvcnQgZGVmYXVsdCBUZXh0OyIsIlxuLyoqXG4gKiBDYW52YXhcbiAqXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXG4gKlxuICog5ZCR6YeP5pON5L2c57G7XG4gKiAqL1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxuZnVuY3Rpb24gVmVjdG9yKHgsIHkpIHtcbiAgICB2YXIgdnggPSAwLHZ5ID0gMDtcbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBfLmlzT2JqZWN0KCB4ICkgKXtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYoIF8uaXNBcnJheSggYXJnICkgKXtcbiAgICAgICAgICAgdnggPSBhcmdbMF07XG4gICAgICAgICAgIHZ5ID0gYXJnWzFdO1xuICAgICAgICB9IGVsc2UgaWYoIGFyZy5oYXNPd25Qcm9wZXJ0eShcInhcIikgJiYgYXJnLmhhc093blByb3BlcnR5KFwieVwiKSApIHtcbiAgICAgICAgICAgdnggPSBhcmcueDtcbiAgICAgICAgICAgdnkgPSBhcmcueTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9heGVzID0gW3Z4LCB2eV07XG59O1xuVmVjdG9yLnByb3RvdHlwZSA9IHtcbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLl9heGVzWzBdIC0gdi5fYXhlc1swXTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLl9heGVzWzFdIC0gdi5fYXhlc1sxXTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgVmVjdG9yOyIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOWkhOeQhuS4uuW5s+a7kee6v+adoVxuICovXG5pbXBvcnQgVmVjdG9yIGZyb20gXCIuL1ZlY3RvclwiO1xuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcblxuLyoqXG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuMjU7XG4gICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC4yNTtcbiAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzIFxuICAgICAgICAgICArICgtIDMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICArIHYwICogdCArIHAxO1xufVxuLyoqXG4gKiDlpJrnur/mrrXlubPmu5Hmm7Lnur8gXG4gKiBvcHQgPT0+IHBvaW50cyAsIGlzTG9vcFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoIG9wdCApIHtcbiAgICB2YXIgcG9pbnRzID0gb3B0LnBvaW50cztcbiAgICB2YXIgaXNMb29wID0gb3B0LmlzTG9vcDtcbiAgICB2YXIgc21vb3RoRmlsdGVyID0gb3B0LnNtb290aEZpbHRlcjtcblxuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmKCBsZW4gPT0gMSApe1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIGRpc3RhbmNlICA9IDA7XG4gICAgdmFyIHByZVZlcnRvciA9IG5ldyBWZWN0b3IoIHBvaW50c1swXSApO1xuICAgIHZhciBpVnRvciAgICAgPSBudWxsXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpVnRvciA9IG5ldyBWZWN0b3IocG9pbnRzW2ldKTtcbiAgICAgICAgZGlzdGFuY2UgKz0gcHJlVmVydG9yLmRpc3RhbmNlKCBpVnRvciApO1xuICAgICAgICBwcmVWZXJ0b3IgPSBpVnRvcjtcbiAgICB9XG5cbiAgICBwcmVWZXJ0b3IgPSBudWxsO1xuICAgIGlWdG9yICAgICA9IG51bGw7XG5cblxuICAgIC8v5Z+65pys5LiK562J5LqO5puy546HXG4gICAgdmFyIHNlZ3MgPSBkaXN0YW5jZSAvIDY7XG5cbiAgICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzOyBpKyspIHtcbiAgICAgICAgdmFyIHBvcyA9IGkgLyAoc2Vncy0xKSAqIChpc0xvb3AgPyBsZW4gOiBsZW4gLSAxKTtcbiAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IocG9zKTtcblxuICAgICAgICB2YXIgdyA9IHBvcyAtIGlkeDtcblxuICAgICAgICB2YXIgcDA7XG4gICAgICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgICAgICB2YXIgcDI7XG4gICAgICAgIHZhciBwMztcbiAgICAgICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgICAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgICAgICAgcDIgPSBwb2ludHNbaWR4ID4gbGVuIC0gMiA/IGxlbiAtIDEgOiBpZHggKyAxXTtcbiAgICAgICAgICAgIHAzID0gcG9pbnRzW2lkeCA+IGxlbiAtIDMgPyBsZW4gLSAxIDogaWR4ICsgMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwMCA9IHBvaW50c1soaWR4IC0xICsgbGVuKSAlIGxlbl07XG4gICAgICAgICAgICBwMiA9IHBvaW50c1soaWR4ICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgcDMgPSBwb2ludHNbKGlkeCArIDIpICUgbGVuXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3MiA9IHcgKiB3O1xuICAgICAgICB2YXIgdzMgPSB3ICogdzI7XG5cbiAgICAgICAgdmFyIHJwID0gW1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXG4gICAgICAgICAgICAgICAgXTtcblxuICAgICAgICBfLmlzRnVuY3Rpb24oc21vb3RoRmlsdGVyKSAmJiBzbW9vdGhGaWx0ZXIoIHJwICk7XG5cbiAgICAgICAgcmV0LnB1c2goIHJwICk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59OyIsIi8qKlxuICogQ2FudmF4XG4gKlxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxuICpcbiAqIOaVsOWtpiDnsbtcbiAqXG4gKiovXG5cbmltcG9ydCBTbW9vdGhTcGxpbmUgZnJvbSBcIi4uL2dlb20vU21vb3RoU3BsaW5lXCI7XG5cblxudmFyIF9jYWNoZSA9IHtcbiAgICBzaW4gOiB7fSwgICAgIC8vc2lu57yT5a2YXG4gICAgY29zIDoge30gICAgICAvL2Nvc+e8k+WtmFxufTtcbnZhciBfcmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuICogQHBhcmFtIGFuZ2xlIOW8p+W6pu+8iOinkuW6pu+8ieWPguaVsFxuICogQHBhcmFtIGlzRGVncmVlcyBhbmdsZeWPguaVsOaYr+WQpuS4uuinkuW6puiuoeeul++8jOm7mOiupOS4umZhbHNl77yMYW5nbGXkuLrku6XlvKfluqborqHph4/nmoTop5LluqZcbiAqL1xuZnVuY3Rpb24gc2luKGFuZ2xlLCBpc0RlZ3JlZXMpIHtcbiAgICBhbmdsZSA9IChpc0RlZ3JlZXMgPyBhbmdsZSAqIF9yYWRpYW5zIDogYW5nbGUpLnRvRml4ZWQoNCk7XG4gICAgaWYodHlwZW9mIF9jYWNoZS5zaW5bYW5nbGVdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9jYWNoZS5zaW5bYW5nbGVdID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIH1cbiAgICByZXR1cm4gX2NhY2hlLnNpblthbmdsZV07XG59XG5cbi8qKlxuICogQHBhcmFtIHJhZGlhbnMg5byn5bqm5Y+C5pWwXG4gKi9cbmZ1bmN0aW9uIGNvcyhhbmdsZSwgaXNEZWdyZWVzKSB7XG4gICAgYW5nbGUgPSAoaXNEZWdyZWVzID8gYW5nbGUgKiBfcmFkaWFucyA6IGFuZ2xlKS50b0ZpeGVkKDQpO1xuICAgIGlmKHR5cGVvZiBfY2FjaGUuY29zW2FuZ2xlXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfY2FjaGUuY29zW2FuZ2xlXSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jYWNoZS5jb3NbYW5nbGVdO1xufVxuXG4vKipcbiAqIOinkuW6pui9rOW8p+W6plxuICogQHBhcmFtIHtPYmplY3R9IGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGRlZ3JlZVRvUmFkaWFuKGFuZ2xlKSB7XG4gICAgcmV0dXJuIGFuZ2xlICogX3JhZGlhbnM7XG59XG5cbi8qKlxuICog5byn5bqm6L2s6KeS5bqmXG4gKiBAcGFyYW0ge09iamVjdH0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gcmFkaWFuVG9EZWdyZWUoYW5nbGUpIHtcbiAgICByZXR1cm4gYW5nbGUgLyBfcmFkaWFucztcbn1cblxuLypcbiAqIOagoemqjOinkuW6puWIsDM2MOW6puWGhVxuICogQHBhcmFtIHthbmdsZX0gbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGRlZ3JlZVRvMzYwKCBhbmdsZSApIHtcbiAgICB2YXIgcmVBbmcgPSAoMzYwICsgIGFuZ2xlICAlIDM2MCkgJSAzNjA7Ly9NYXRoLmFicygzNjAgKyBNYXRoLmNlaWwoIGFuZ2xlICkgJSAzNjApICUgMzYwO1xuICAgIGlmKCByZUFuZyA9PSAwICYmIGFuZ2xlICE9PSAwICl7XG4gICAgICAgIHJlQW5nID0gMzYwXG4gICAgfVxuICAgIHJldHVybiByZUFuZztcbn1cblxuZnVuY3Rpb24gZ2V0SXNnb25Qb2ludExpc3QoIG4gLCByICl7XG4gICAgdmFyIHBvaW50TGlzdCA9IFtdO1xuICAgIHZhciBkU3RlcCA9IDIgKiBNYXRoLlBJIC8gbjtcbiAgICB2YXIgYmVnaW5EZWcgPSAtTWF0aC5QSSAvIDI7XG4gICAgdmFyIGRlZyA9IGJlZ2luRGVnO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbmQgPSBuOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgcG9pbnRMaXN0LnB1c2goW3IgKiBNYXRoLmNvcyhkZWcpLCByICogTWF0aC5zaW4oZGVnKV0pO1xuICAgICAgICBkZWcgKz0gZFN0ZXA7XG4gICAgfTtcbiAgICByZXR1cm4gcG9pbnRMaXN0O1xufVxuXG5mdW5jdGlvbiBnZXRTbW9vdGhQb2ludExpc3QoIHBMaXN0LCBzbW9vdGhGaWx0ZXIgKXtcbiAgICAvL3Ntb290aEZpbHRlciAtLSDmr5TlpoLlnKjmipjnur/lm77kuK3jgILkvJrkvKDkuIDkuKpzbW9vdGhGaWx0ZXLov4fmnaXlgZpwb2ludOeahOe6oOato+OAglxuICAgIC8v6K6peeS4jeiDvei2hei/h+W6lemDqOeahOWOn+eCuVxuICAgIHZhciBvYmogPSB7XG4gICAgICAgIHBvaW50czogcExpc3RcbiAgICB9XG4gICAgaWYgKF8uaXNGdW5jdGlvbihzbW9vdGhGaWx0ZXIpKSB7XG4gICAgICAgIG9iai5zbW9vdGhGaWx0ZXIgPSBzbW9vdGhGaWx0ZXI7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJMID0gU21vb3RoU3BsaW5lKG9iaik7XG4gICAgaWYgKHBMaXN0ICYmIHBMaXN0Lmxlbmd0aD4wKSB7XG4gICAgICAgIGN1cnJMLnB1c2goIHBMaXN0W3BMaXN0Lmxlbmd0aCAtIDFdICk7XG4gICAgfTtcblxuICAgIHJldHVybiBjdXJyTDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFBJICA6IE1hdGguUEkgICxcbiAgICBzaW4gOiBzaW4gICAgICAsXG4gICAgY29zIDogY29zICAgICAgLFxuICAgIGRlZ3JlZVRvUmFkaWFuIDogZGVncmVlVG9SYWRpYW4sXG4gICAgcmFkaWFuVG9EZWdyZWUgOiByYWRpYW5Ub0RlZ3JlZSxcbiAgICBkZWdyZWVUbzM2MCAgICA6IGRlZ3JlZVRvMzYwLFxuICAgIGdldElzZ29uUG9pbnRMaXN0IDogZ2V0SXNnb25Qb2ludExpc3QsXG4gICAgZ2V0U21vb3RoUG9pbnRMaXN0OiBnZXRTbW9vdGhQb2ludExpc3QgICBcbn07XG5cbiIsIi8qKlxyXG4gKiBDYW52YXhcclxuICpcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDmipjnur8g57G7XHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQHBvaW50TGlzdCDlkITkuKrpobbop5LlnZDmoIdcclxuICoqL1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL2Rpc3BsYXkvU2hhcGVcIjtcclxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xyXG5pbXBvcnQgX01hdGggZnJvbSBcIi4uL2dlb20vTWF0aFwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcm9rZW5MaW5lIGV4dGVuZHMgU2hhcGVcclxue1xyXG4gICAgY29uc3RydWN0b3Iob3B0ICwgYXR5cGUpe1xyXG4gICAgICAgIG9wdCA9IFV0aWxzLmNoZWNrT3B0KG9wdCk7XHJcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gXy5leHRlbmQoe1xyXG4gICAgICAgICAgICBsaW5lVHlwZTogbnVsbCxcclxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcclxuICAgICAgICAgICAgcG9pbnRMaXN0OiBbXSwgLy97QXJyYXl9ICAvLyDlv4XpobvvvIzlkITkuKrpobbop5LlnZDmoIdcclxuICAgICAgICAgICAgc21vb3RoRmlsdGVyOiBVdGlscy5fX2VtcHR5RnVuY1xyXG4gICAgICAgIH0sIG9wdC5jb250ZXh0ICk7XHJcblxyXG4gICAgICAgIGlmKCBhdHlwZSAhPT0gXCJjbG9uZVwiICYmIF9jb250ZXh0LnNtb290aCApe1xyXG4gICAgICAgICAgICBfY29udGV4dC5wb2ludExpc3QgPSBfTWF0aC5nZXRTbW9vdGhQb2ludExpc3QoIF9jb250ZXh0LnBvaW50TGlzdCApO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3VwZXIob3B0KTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJicm9rZW5saW5lXCI7XHJcbiAgICAgICAgdGhpcy5pZCA9IFV0aWxzLmNyZWF0ZUlkKHRoaXMudHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2F0Y2gobmFtZSwgdmFsdWUsIHByZVZhbHVlKSBcclxuICAgIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInBvaW50TGlzdFwiIHx8IG5hbWUgPT0gXCJzbW9vdGhcIiB8fCBuYW1lID09IFwibGluZVR5cGVcIikge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyR3JhcGhpY3NEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBkcmF3KCBncmFwaGljcyApIFxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMaXN0ID0gY29udGV4dC5wb2ludExpc3Q7XHJcbiAgICAgICAgaWYgKHBvaW50TGlzdC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIC8v5bCR5LqOMuS4queCueWwseS4jeeUu+S6hn5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWNvbnRleHQubGluZVR5cGUgfHwgY29udGV4dC5saW5lVHlwZSA9PSAnc29saWQnKSB7XHJcbiAgICAgICAgICAgIC8v6buY6K6k5Li65a6e57q/XHJcbiAgICAgICAgICAgIC8vVE9ETzrnm67liY3lpoLmnpwg5pyJ6K6+572uc21vb3RoIOeahOaDheWGteS4i+aYr+S4jeaUr+aMgeiZmue6v+eahFxyXG4gICAgICAgICAgICBncmFwaGljcy5tb3ZlVG8ocG9pbnRMaXN0WzBdWzBdLCBwb2ludExpc3RbMF1bMV0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50TGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVUbyhwb2ludExpc3RbaV1bMF0sIHBvaW50TGlzdFtpXVsxXSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5saW5lVHlwZSA9PSAnZGFzaGVkJyB8fCBjb250ZXh0LmxpbmVUeXBlID09ICdkb3R0ZWQnKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNtb290aCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwLCBzbCA9IHBvaW50TGlzdC5sZW5ndGg7IHNpIDwgc2w7IHNpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2kgPT0gc2wtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLm1vdmVUbyggcG9pbnRMaXN0W3NpXVswXSAsIHBvaW50TGlzdFtzaV1bMV0gKTtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5saW5lVG8oIHBvaW50TGlzdFtzaSsxXVswXSAsIHBvaW50TGlzdFtzaSsxXVsxXSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpKz0xO1xyXG5cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+eUu+iZmue6v+eahOaWueazlSAgXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50TGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVggPSBwb2ludExpc3RbaSAtIDFdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b1ggPSBwb2ludExpc3RbaV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRMaXN0W2kgLSAxXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9ZID0gcG9pbnRMaXN0W2ldWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGFzaGVkTGluZVRvKGdyYXBoaWNzLCBmcm9tWCwgZnJvbVksIHRvWCwgdG9ZLCA1KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiLyoqXHJcbiAqIENhbnZheFxyXG4gKlxyXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXHJcbiAqXHJcbiAqIOWchuW9oiDnsbtcclxuICpcclxuICog5Z2Q5qCH5Y6f54K55YaN5ZyG5b+DXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQHIg5ZyG5Y2K5b6EXHJcbiAqKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENpcmNsZSBleHRlbmRzIFNoYXBlXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKCBvcHQgKVxyXG4gICAge1xyXG4gICAgICAgIG9wdCA9IFV0aWxzLmNoZWNrT3B0KCBvcHQgKTtcclxuICAgICAgICAvL+m7mOiupOaDheWGteS4i+mdou+8jGNpcmNsZeS4jemcgOimgeaKinh56L+b6KGMcGFyZW50SW506L2s5o2iXHJcbiAgICAgICAgKCBcInh5VG9JbnRcIiBpbiBvcHQgKSB8fCAoIG9wdC54eVRvSW50ID0gZmFsc2UgKTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIHIgOiAwICAgLy97bnVtYmVyfSwgIC8vIOW/hemhu++8jOWchuWNiuW+hFxyXG4gICAgICAgIH0gLCBvcHQuY29udGV4dCk7XHJcblxyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICAgIHN1cGVyKCBvcHQgKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCBuYW1lID09IFwiclwiICkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyR3JhcGhpY3NEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXcoIGdyYXBoaWNzICkgXHJcbiAgICB7XHJcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgZ3JhcGhpY3MuZHJhd0NpcmNsZSgwLCAwLCB0aGlzLmNvbnRleHQucik7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4iLCIvKipcclxuICogQ2FudmF4XHJcbiAqXHJcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcclxuICpcclxuICogUGF0aCDnsbvvvIxQYXRo5Li76KaB55So5LqO5oqKc3ZncGF0aCDlrZfnrKbkuLLovazmjaLkuLpwb2ludExpc3TvvIznhLblkI7mnoTlu7pncmFwaGljc0RhdGFcclxuICpcclxuICog5a+55bqUY29udGV4dOeahOWxnuaAp+aciVxyXG4gKiBAcGF0aCBwYXRo5LiyXHJcbiAqKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuaW1wb3J0IE1hdHJpeCBmcm9tIFwiLi4vZ2VvbS9NYXRyaXhcIjtcclxuaW1wb3J0IHsgQXJjIH0gZnJvbSAnLi4vbWF0aC9pbmRleCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoIGV4dGVuZHMgU2hhcGVcclxue1xyXG4gICAgY29uc3RydWN0b3Iob3B0KXtcclxuICAgICAgICBcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdChvcHQpO1xyXG4gICAgICAgIHZhciBfY29udGV4dCA9IF8uZXh0ZW5kKHtcclxuICAgICAgICAgICAgcG9pbnRMaXN0OiBbXSwgLy/ku47kuIvpnaLnmoRwYXRo5Lit6K6h566X5b6X5Yiw55qE6L6555WM54K555qE6ZuG5ZCIXHJcbiAgICAgICAgICAgIHBhdGg6IFwiXCIgLy/lrZfnrKbkuLIg5b+F6aG777yM6Lev5b6E44CC5L6L5aaCOk0gMCAwIEwgMCAxMCBMIDEwIDEwIFogKOS4gOS4quS4ieinkuW9oilcclxuICAgICAgICAgICAgICAgIC8vTSA9IG1vdmV0b1xyXG4gICAgICAgICAgICAgICAgLy9MID0gbGluZXRvXHJcbiAgICAgICAgICAgICAgICAvL0ggPSBob3Jpem9udGFsIGxpbmV0b1xyXG4gICAgICAgICAgICAgICAgLy9WID0gdmVydGljYWwgbGluZXRvXHJcbiAgICAgICAgICAgICAgICAvL0MgPSBjdXJ2ZXRvXHJcbiAgICAgICAgICAgICAgICAvL1MgPSBzbW9vdGggY3VydmV0b1xyXG4gICAgICAgICAgICAgICAgLy9RID0gcXVhZHJhdGljIEJlbHppZXIgY3VydmVcclxuICAgICAgICAgICAgICAgIC8vVCA9IHNtb290aCBxdWFkcmF0aWMgQmVsemllciBjdXJ2ZXRvXHJcbiAgICAgICAgICAgICAgICAvL1ogPSBjbG9zZXBhdGhcclxuICAgICAgICB9ICwgb3B0LmNvbnRleHQpO1xyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICAgIHN1cGVyKCBvcHQgKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoXCJkcmF3VHlwZU9ubHlcIiBpbiBvcHQpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3VHlwZU9ubHkgPSBvcHQuZHJhd1R5cGVPbmx5O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX19wYXJzZVBhdGhEYXRhID0gbnVsbDtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInBhdGhcIjtcclxuICAgICAgICB0aGlzLmlkID0gVXRpbHMuY3JlYXRlSWQodGhpcy50eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICB3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpIFxyXG4gICAge1xyXG4gICAgICAgIGlmIChuYW1lID09IFwicGF0aFwiKSB7IC8v5aaC5p6ccGF0aOacieWPmOWKqO+8jOmcgOimgeiHquWKqOiuoeeul+aWsOeahHBvaW50TGlzdFxyXG4gICAgICAgICAgICB0aGlzLmNsZWFyR3JhcGhpY3NEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9wYXJzZVBhdGhEYXRhKGRhdGEpIFxyXG4gICAge1xyXG4gICAgICAgIGlmICh0aGlzLl9fcGFyc2VQYXRoRGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3BhcnNlUGF0aERhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy/liIbmi4blrZDliIbnu4RcclxuICAgICAgICB0aGlzLl9fcGFyc2VQYXRoRGF0YSA9IFtdO1xyXG4gICAgICAgIHZhciBwYXRocyA9IF8uY29tcGFjdChkYXRhLnJlcGxhY2UoL1tNbV0vZywgXCJcXFxcciQmXCIpLnNwbGl0KCdcXFxccicpKTtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIF8uZWFjaChwYXRocywgZnVuY3Rpb24ocGF0aFN0cikge1xyXG4gICAgICAgICAgICBtZS5fX3BhcnNlUGF0aERhdGEucHVzaChtZS5fcGFyc2VDaGlsZFBhdGhEYXRhKHBhdGhTdHIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX3BhcnNlUGF0aERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgX3BhcnNlQ2hpbGRQYXRoRGF0YShkYXRhKVxyXG4gICAge1xyXG4gICAgICAgIC8vIGNvbW1hbmQgc3RyaW5nXHJcbiAgICAgICAgdmFyIGNzID0gZGF0YTtcclxuICAgICAgICAvLyBjb21tYW5kIGNoYXJzXHJcbiAgICAgICAgdmFyIGNjID0gW1xyXG4gICAgICAgICAgICAnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsXHJcbiAgICAgICAgICAgICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgY3MgPSBjcy5yZXBsYWNlKC8gIC9nLCAnICcpO1xyXG4gICAgICAgIGNzID0gY3MucmVwbGFjZSgvIC9nLCAnLCcpO1xyXG4gICAgICAgIC8vY3MgPSBjcy5yZXBsYWNlKC8oLiktL2csIFwiJDEsLVwiKTtcclxuICAgICAgICBjcyA9IGNzLnJlcGxhY2UoLyhcXGQpLS9nLCAnJDEsLScpO1xyXG4gICAgICAgIGNzID0gY3MucmVwbGFjZSgvLCwvZywgJywnKTtcclxuICAgICAgICB2YXIgbjtcclxuICAgICAgICAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcclxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcclxuICAgICAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3JlYXRlIGFycmF5XHJcbiAgICAgICAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgdmFyIGNhID0gW107XHJcbiAgICAgICAgLy8gaW5pdCBjb250ZXh0IHBvaW50XHJcbiAgICAgICAgdmFyIGNweCA9IDA7XHJcbiAgICAgICAgdmFyIGNweSA9IDA7XHJcbiAgICAgICAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICB2YXIgc3RyID0gYXJyW25dO1xyXG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcclxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnZSwtJywgJ2cnKSwgJ2UtJyk7XHJcblxyXG4gICAgICAgICAgICAvL+acieeahOaXtuWAme+8jOavlOWmguKAnDIy77yMLTIy4oCdIOaVsOaNruWPr+iDveS8mue7j+W4uOeahOiiq+WGmeaIkDIyLTIy77yM6YKj5LmI6ZyA6KaB5omL5Yqo5L+u5pS5XHJcbiAgICAgICAgICAgIC8vc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnLScsICdnJyksICcsLScpO1xyXG4gICAgICAgICAgICAvL3N0ciA9IHN0ci5yZXBsYWNlKC8oLiktL2csIFwiJDEsLVwiKVxyXG4gICAgICAgICAgICB2YXIgcCA9IHN0ci5zcGxpdCgnLCcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMCAmJiBwWzBdID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9IFxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAocC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocFswXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjdGxQdHg7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZDbWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJ4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJ5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBzaTtcclxuICAgICAgICAgICAgICAgIHZhciBmYTtcclxuICAgICAgICAgICAgICAgIHZhciBmcztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBjcHg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSBjcHk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ00nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ00nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnTCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kLmNvbW1hbmQgPT09ICdDJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1szXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdDJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4LCBjdGxQdHkgPSBjcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ0MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCwgY3RsUHR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0MnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdRJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4LCBjdGxQdHkgPSBjcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ1EnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ1EnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4LCBjdGxQdHkgPSBjcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ1EnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHAuc2hpZnQoKTsgLy945Y2K5b6EXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcC5zaGlmdCgpOyAvL3nljYrlvoRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcC5zaGlmdCgpOyAvL+aXi+i9rOinkuW6plxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHAuc2hpZnQoKTsgLy/op5LluqblpKflsI8gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpOyAvL+aXtumSiOaWueWQkVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCksIGNweSA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0EnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBbIHJ4ICwgcnkgLHBzaSAsIGZhICxmcyAsY3B4ICwgY3B5ICwgeDEgLCB5MSBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IFsgcnggLCByeSAscHNpICwgZmEgLGZzICxjcHggLCBjcHkgLCB4MSAsIHkxIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNtZCB8fCBjLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcclxuICAgICAgICAgICAgICAgIGNhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd6JyxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IFtdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGNhO1xyXG4gICAgfVxyXG5cclxuICAgIC8v6YeN5paw5qC555qEcGF0aOe7mOWItiBncmFwaGljc1xyXG4gICAgZHJhdyggZ3JhcGhpY3MgKVxyXG4gICAge1xyXG4gICAgICAgIGdyYXBoaWNzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX19wYXJzZVBhdGhEYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbnRleHQucG9pbnRMaXN0ID0gW107XHJcblxyXG4gICAgICAgIHZhciBwYXRoQXJyYXkgPSB0aGlzLl9wYXJzZVBhdGhEYXRhKHRoaXMuY29udGV4dC5wYXRoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgZyA9IDAsIGdsID0gcGF0aEFycmF5Lmxlbmd0aDsgZyA8IGdsOyBnKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoQXJyYXlbZ10ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHBhdGhBcnJheVtnXVtpXS5jb21tYW5kLCBwID0gcGF0aEFycmF5W2ddW2ldLnBvaW50cztcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5saW5lVG8ocFswXSwgcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5tb3ZlVG8ocFswXSwgcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5iZXppZXJDdXJ2ZVRvKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MucXVhZHJhdGljQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5YmN6Z2iNuS4quWFg+e0oOeUqOadpeaUvnBhdGjnmoRBIDbkuKrlj4LmlbDvvIxwYXRoIEHlkb3ku6Tor6bop4FcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJjLmRyYXdBcmMoIGdyYXBoaWNzICwgcFs3XSAsIHBbOF0gLCBwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufSIsIi8qKlxyXG4gKiBDYW52YXhcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDmsLTmu7TlvaIg57G7XHJcbiAqIOa0vueUn+iHqlBhdGjnsbtcclxuICpcclxuICog5a+55bqUY29udGV4dOeahOWxnuaAp+aciVxyXG4gKiBAaHIg5rC05ru05qiq5a6977yI5Lit5b+D5Yiw5rC05bmz6L6557yY5pyA5a695aSE6Led56a777yJXHJcbiAqIEB2ciDmsLTmu7TnurXpq5jvvIjkuK3lv4PliLDlsJbnq6/ot53nprvvvIlcclxuICoqL1xyXG5pbXBvcnQgUGF0aCBmcm9tIFwiLi9QYXRoXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyb3BsZXQgZXh0ZW5kcyBQYXRoXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdClcclxuICAgIHtcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdCggb3B0ICk7XHJcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gXy5leHRlbmQoe1xyXG4gICAgICAgICAgICBociA6IDAsIC8ve251bWJlcn0sICAvLyDlv4XpobvvvIzmsLTmu7TmqKrlrr3vvIjkuK3lv4PliLDmsLTlubPovrnnvJjmnIDlrr3lpITot53nprvvvIlcclxuICAgICAgICAgICAgdnIgOiAwICAgLy97bnVtYmVyfSwgIC8vIOW/hemhu++8jOawtOa7tOe6temrmO+8iOS4reW/g+WIsOWwluerr+i3neemu++8iVxyXG4gICAgICAgIH0gLCBvcHQuY29udGV4dCk7XHJcblxyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICAgIHZhciBteSA9IHN1cGVyKG9wdCk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZHJvcGxldFwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRleHQucGF0aCA9IHRoaXMuY3JlYXRlUGF0aCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCBuYW1lID09IFwiaHJcIiB8fCBuYW1lID09IFwidnJcIiApIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnBhdGggPSB0aGlzLmNyZWF0ZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNyZWF0ZVBhdGgoKSBcclxuICAgIHtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICB2YXIgcHMgPSBcIk0gMCBcIitjb250ZXh0LmhyK1wiIEMgXCIrY29udGV4dC5ocitcIiBcIitjb250ZXh0LmhyK1wiIFwiKyggY29udGV4dC5ociozLzIgKSArXCIgXCIrKC1jb250ZXh0LmhyLzMpK1wiIDAgXCIrKC1jb250ZXh0LnZyKTtcclxuICAgICAgICBwcyArPSBcIiBDIFwiKygtY29udGV4dC5ociAqIDMvIDIpK1wiIFwiKygtY29udGV4dC5ociAvIDMpK1wiIFwiKygtY29udGV4dC5ocikrXCIgXCIrY29udGV4dC5ocitcIiAwIFwiKyBjb250ZXh0LmhyKyBcInpcIjtcclxuICAgICAgICByZXR1cm4gcHM7XHJcbiAgICB9XHJcbn0iLCJcclxuLyoqXHJcbiAqIENhbnZheFxyXG4gKlxyXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXHJcbiAqXHJcbiAqIOakreWchuW9oiDnsbtcclxuICpcclxuICog5a+55bqUY29udGV4dOeahOWxnuaAp+aciSBcclxuICpcclxuICogQGhyIOakreWchuaoqui9tOWNiuW+hFxyXG4gKiBAdnIg5qSt5ZyG57q16L205Y2K5b6EXHJcbiAqL1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL2Rpc3BsYXkvU2hhcGVcIjtcclxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxsaXBzZSBleHRlbmRzIFNoYXBlXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdClcclxuICAgIHtcclxuICAgICAgICBvcHQgPSBVdGlscy5jaGVja09wdCggb3B0ICk7XHJcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gXy5leHRlbmQoe1xyXG4gICAgICAgICAgICAvL3ggICAgICAgICAgICAgOiAwICwgLy97bnVtYmVyfSwgIC8vIOS4ouW8g1xyXG4gICAgICAgICAgICAvL3kgICAgICAgICAgICAgOiAwICwgLy97bnVtYmVyfSwgIC8vIOS4ouW8g++8jOWOn+WboOWQjGNpcmNsZVxyXG4gICAgICAgICAgICBociA6IDAsICAvL3tudW1iZXJ9LCAgLy8g5b+F6aG777yM5qSt5ZyG5qiq6L205Y2K5b6EXHJcbiAgICAgICAgICAgIHZyIDogMCAgIC8ve251bWJlcn0sICAvLyDlv4XpobvvvIzmpK3lnIbnurXovbTljYrlvoRcclxuICAgICAgICB9ICwgb3B0LmNvbnRleHQpO1xyXG5cclxuICAgICAgICBvcHQuY29udGV4dCA9IF9jb250ZXh0O1xyXG5cclxuICAgICAgICBzdXBlciggb3B0ICk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZWxsaXBzZVwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCBuYW1lID09IFwiaHJcIiB8fCBuYW1lID09IFwidnJcIiApIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckdyYXBoaWNzRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KGdyYXBoaWNzKVxyXG4gICAgeyAgICBcclxuICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICBncmFwaGljcy5kcmF3RWxsaXBzZSgwLDAsIHRoaXMuY29udGV4dC5ocioyICwgdGhpcy5jb250ZXh0LnZyKjIpO1xyXG4gICAgfVxyXG59O1xyXG4iLCIvKipcclxuICogQ2FudmF4XHJcbiAqXHJcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcclxuICpcclxuICog5aSa6L655b2iIOexuyAg77yI5LiN6KeE5YiZ77yJXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQHBvaW50TGlzdCDlpJrovrnlvaLlkITkuKrpobbop5LlnZDmoIdcclxuICoqL1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL2Rpc3BsYXkvU2hhcGVcIjtcclxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgXyBmcm9tIFwiLi4vdXRpbHMvdW5kZXJzY29yZVwiO1xyXG5pbXBvcnQgX01hdGggZnJvbSBcIi4uL2dlb20vTWF0aFwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIGV4dGVuZHMgU2hhcGUgXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKG9wdCwgYXR5cGUpXHJcbiAgICB7XHJcbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQob3B0KTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGxpbmVUeXBlOiBudWxsLFxyXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxyXG4gICAgICAgICAgICBwb2ludExpc3Q6IFtdLCAvL3tBcnJheX0gIC8vIOW/hemhu++8jOWQhOS4qumhtuinkuWdkOagh1xyXG4gICAgICAgICAgICBzbW9vdGhGaWx0ZXI6IFV0aWxzLl9fZW1wdHlGdW5jXHJcbiAgICAgICAgfSwgb3B0LmNvbnRleHQgKTtcclxuXHJcbiAgICAgICAgaWYoYXR5cGUgIT09IFwiY2xvbmVcIil7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IF9jb250ZXh0LnBvaW50TGlzdFswXTtcclxuICAgICAgICAgICAgdmFyIGVuZCAgID0gX2NvbnRleHQucG9pbnRMaXN0LnNsaWNlKCAtIDEgKVswXTtcclxuICAgICAgICAgICAgaWYoIF9jb250ZXh0LnNtb290aCApe1xyXG4gICAgICAgICAgICAgICAgX2NvbnRleHQucG9pbnRMaXN0LnVuc2hpZnQoIGVuZCApO1xyXG4gICAgICAgICAgICAgICAgX2NvbnRleHQucG9pbnRMaXN0ID0gX01hdGguZ2V0U21vb3RoUG9pbnRMaXN0KCBfY29udGV4dC5wb2ludExpc3QgKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgLy9lbHNlIHtcclxuICAgICAgICAgICAgLy8gICAgX2NvbnRleHQucG9pbnRMaXN0LnB1c2goIHN0YXJ0ICk7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3VwZXIob3B0LCBhdHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2RyYXdUeXBlT25seSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwb2x5Z29uXCI7XHJcbiAgICAgICAgdGhpcy5pZCA9IFV0aWxzLmNyZWF0ZUlkKHRoaXMudHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2F0Y2gobmFtZSwgdmFsdWUsIHByZVZhbHVlKSBcclxuICAgIHtcclxuICAgICAgICAvL+iwg+eUqHBhcmVudOeahHNldEdyYXBoaWNzXHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwb2ludExpc3RcIiB8fCBuYW1lID09IFwic21vb3RoXCIgfHwgbmFtZSA9PSBcImxpbmVUeXBlXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckdyYXBoaWNzRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCBncmFwaGljcyApIFxyXG4gICAge1xyXG4gICAgICAgIGdyYXBoaWNzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMaXN0ID0gY29udGV4dC5wb2ludExpc3Q7XHJcbiAgICAgICAgaWYgKHBvaW50TGlzdC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIC8v5bCR5LqOMuS4queCueWwseS4jeeUu+S6hn5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGdyYXBoaWNzLm1vdmVUbyhwb2ludExpc3RbMF1bMF0sIHBvaW50TGlzdFswXVsxXSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwb2ludExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVUbyhwb2ludExpc3RbaV1bMF0sIHBvaW50TGlzdFtpXVsxXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBncmFwaGljcy5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgICAgLy/lpoLmnpzkuLromZrnur9cclxuICAgICAgICBpZiAoY29udGV4dC5saW5lVHlwZSA9PSAnZGFzaGVkJyB8fCBjb250ZXh0LmxpbmVUeXBlID09ICdkb3R0ZWQnKSB7XHJcbiAgICAgICAgICAgIC8v6aaW5YWI5oqK5YmN6Z2i55qEZHJhcGhpY3NEYXRh6K6+572u5Li6ZmlsbCBvbmx5XHJcbiAgICAgICAgICAgIC8v5Lmf5bCx5piv5oqKbGluZeW8uuWItuiuvue9ruS4umZhbHNl77yM6L+Z54K55b6I6YeN6KaB77yM5ZCm5YiZ5L2g6Jma57q/55S75LiN5Ye65p2l77yM5Lya5ZKM6L+Z5Liq5a6e546w6YeN5Y+g5LqGXHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmN1cnJlbnRQYXRoLmxpbmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnNtb290aCkge1xyXG4gICAgICAgICAgICAgICAgLy/lpoLmnpzmmK9zbW9vdGjvvIzmnKzouqvlt7Lnu4/ooqvnlKjmm7LnjofmiZPmlaPov4fkuobvvIzkuI3pnIDopoHph4fnlKjpl7TpmpTms5VcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gMCwgc2wgPSBwb2ludExpc3QubGVuZ3RoOyBzaSA8IHNsOyBzaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpID09IHNsLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5tb3ZlVG8oIHBvaW50TGlzdFtzaV1bMF0gLCBwb2ludExpc3Rbc2ldWzFdICk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MubGluZVRvKCBwb2ludExpc3Rbc2krMV1bMF0gLCBwb2ludExpc3Rbc2krMV1bMV0gKTtcclxuICAgICAgICAgICAgICAgICAgICBzaSs9MTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+eUu+iZmue6v+eahOaWueazlSAgXHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5tb3ZlVG8ocG9pbnRMaXN0WzBdWzBdLCBwb2ludExpc3RbMF1bMV0pO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwb2ludExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21YID0gcG9pbnRMaXN0W2kgLSAxXVswXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9YID0gcG9pbnRMaXN0W2ldWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tWSA9IHBvaW50TGlzdFtpIC0gMV1bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvWSA9IHBvaW50TGlzdFtpXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhc2hlZExpbmVUbyhncmFwaGljcywgZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgNSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZ3JhcGhpY3MuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59OyIsIi8qKlxyXG4gKiBDYW52YXhcclxuICpcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDmraNu6L655b2i77yIbj49M++8iVxyXG4gKlxyXG4gKiDlr7nlupRjb250ZXh055qE5bGe5oCn5pyJIFxyXG4gKlxyXG4gKiBAciDmraNu6L655b2i5aSW5o6l5ZyG5Y2K5b6EXHJcbiAqIEByIOaMh+aYjuato+WHoOi+ueW9olxyXG4gKlxyXG4gKiBAcG9pbnRMaXN0IOengeacie+8jOS7juS4iumdoueahHLlkoxu6K6h566X5b6X5Yiw55qE6L6555WM5YC855qE6ZuG5ZCIXHJcbiAqL1xyXG5pbXBvcnQgUG9seWdvbiBmcm9tIFwiLi9Qb2x5Z29uXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuaW1wb3J0IF9NYXRoIGZyb20gXCIuLi9nZW9tL01hdGhcIlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXNvZ29uIGV4dGVuZHMgUG9seWdvblxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihvcHQpXHJcbiAgICB7XHJcbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQob3B0KTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIHBvaW50TGlzdDogW10sIC8v5LuO5LiL6Z2i55qEcuWSjG7orqHnrpflvpfliLDnmoTovrnnlYzlgLznmoTpm4blkIhcclxuICAgICAgICAgICAgcjogMCwgLy97bnVtYmVyfSwgIC8vIOW/hemhu++8jOato27ovrnlvaLlpJbmjqXlnIbljYrlvoRcclxuICAgICAgICAgICAgbjogMCAvL3tudW1iZXJ9LCAgLy8g5b+F6aG777yM5oyH5piO5q2j5Yeg6L655b2iXHJcbiAgICAgICAgfSAsIG9wdC5jb250ZXh0KTtcclxuICAgICAgICBfY29udGV4dC5wb2ludExpc3QgPSBfTWF0aC5nZXRJc2dvblBvaW50TGlzdCggX2NvbnRleHQubiAsIF9jb250ZXh0LnIgKTtcclxuXHJcbiAgICAgICAgb3B0LmNvbnRleHQgPSBfY29udGV4dDtcclxuXHJcbiAgICAgICAgc3VwZXIoIG9wdCApO1xyXG5cclxuICAgICAgICB0aGlzLnR5cGUgPSBcImlzb2dvblwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSlcclxuICAgIHtcclxuICAgICAgICBpZiAobmFtZSA9PSBcInJcIiB8fCBuYW1lID09IFwiblwiKXsgLy/lpoLmnpxwYXRo5pyJ5Y+Y5Yqo77yM6ZyA6KaB6Ieq5Yqo6K6h566X5paw55qEcG9pbnRMaXN0XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5wb2ludExpc3QgPSBfTWF0aC5nZXRJc2dvblBvaW50TGlzdCggc3R5bGUubiAsIHN0eWxlLnIgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuYW1lID09IFwicG9pbnRMaXN0XCIgfHwgbmFtZSA9PSBcInNtb290aFwiIHx8IG5hbWUgPT0gXCJsaW5lVHlwZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJHcmFwaGljc0RhdGEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59OyIsIi8qKlxyXG4gKiBDYW52YXhcclxuICpcclxuICogQGF1dGhvciDph4rliZEgKOadjua2mywgbGl0YW8ubHRAYWxpYmFiYS1pbmMuY29tKVxyXG4gKlxyXG4gKiDnur/mnaEg57G7XHJcbiAqXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQGxpbmVUeXBlICDlj6/pgIkg6Jma57q/IOWunueOsCDnmoQg57G75Z6LXHJcbiAqIEB4U3RhcnQgICAg5b+F6aG777yM6LW354K55qiq5Z2Q5qCHXHJcbiAqIEB5U3RhcnQgICAg5b+F6aG777yM6LW354K557q15Z2Q5qCHXHJcbiAqIEB4RW5kICAgICAg5b+F6aG777yM57uI54K55qiq5Z2Q5qCHXHJcbiAqIEB5RW5kICAgICAg5b+F6aG777yM57uI54K557q15Z2Q5qCHXHJcbiAqKi9cclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9kaXNwbGF5L1NoYXBlXCI7XHJcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IF8gZnJvbSBcIi4uL3V0aWxzL3VuZGVyc2NvcmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmUgZXh0ZW5kcyBTaGFwZVxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihvcHQpXHJcbiAgICB7XHJcbiAgICAgICAgb3B0ID0gVXRpbHMuY2hlY2tPcHQob3B0KTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGxpbmVUeXBlOiBudWxsLCAvL+WPr+mAiSDomZrnur8g5a6e546wIOeahCDnsbvlnotcclxuICAgICAgICAgICAgc3RhcnQ6IHtcclxuICAgICAgICAgICAgICAgIHggOiAwLCAgICAgIC8vIOW/hemhu++8jOi1t+eCueaoquWdkOagh1xyXG4gICAgICAgICAgICAgICAgeSA6IDAgICAgICAgLy8g5b+F6aG777yM6LW354K557q15Z2Q5qCHXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVuZDoge1xyXG4gICAgICAgICAgICAgICAgeCA6IDAsICAgICAgLy8g5b+F6aG777yM57uI54K55qiq5Z2Q5qCHXHJcbiAgICAgICAgICAgICAgICB5IDogMCAgICAgICAvLyDlv4XpobvvvIznu4jngrnnurXlnZDmoIdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGFzaExlbmd0aDogMyAgICAvLyDomZrnur/pl7TpmpRcclxuICAgICAgICB9ICwgb3B0LmNvbnRleHQpO1xyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICAgIHN1cGVyKCBvcHQgKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJsaW5lXCI7XHJcbiAgICAgICAgdGhpcy5pZCA9IFV0aWxzLmNyZWF0ZUlkKHRoaXMudHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2F0Y2gobmFtZSwgdmFsdWUsIHByZVZhbHVlKVxyXG4gICAge1xyXG4gICAgICAgIC8v5bm25LiN5riF5qWa5pivc3RhcnQueCDov5jmmK9lbmQueO+8jCDlvZPnhLbvvIzov5nlubbkuI3ph43opoFcclxuICAgICAgICBpZiAobmFtZSA9PSBcInhcIiB8fCBuYW1lID09IFwieVwiKXtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckdyYXBoaWNzRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCBncmFwaGljcyApIFxyXG4gICAge1xyXG4gICAgICAgIGdyYXBoaWNzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgaWYgKCFjb250ZXh0LmxpbmVUeXBlIHx8IGNvbnRleHQubGluZVR5cGUgPT0gJ3NvbGlkJykge1xyXG4gICAgICAgICAgICBncmFwaGljcy5tb3ZlVG8oIGNvbnRleHQuc3RhcnQueCAsIGNvbnRleHQuc3RhcnQueSApOyBcclxuICAgICAgICAgICAgZ3JhcGhpY3MubGluZVRvKCBjb250ZXh0LmVuZC54ICAgLCBjb250ZXh0LmVuZC55ICk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmxpbmVUeXBlID09ICdkYXNoZWQnIHx8IGNvbnRleHQubGluZVR5cGUgPT0gJ2RvdHRlZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXNoZWRMaW5lVG8oXHJcbiAgICAgICAgICAgICAgICBncmFwaGljcyxcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhcnQueCwgY29udGV4dC5zdGFydC55LFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5lbmQueCAgLCBjb250ZXh0LmVuZC55LCBcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5kYXNoTGVuZ3RoXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiBcclxufTsiLCIvKipcclxuICogQ2FudmF4XHJcbiAqXHJcbiAqIEBhdXRob3Ig6YeK5YmRICjmnY7mtpssIGxpdGFvLmx0QGFsaWJhYmEtaW5jLmNvbSlcclxuICpcclxuICog55+p546wIOexuyAg77yI5LiN6KeE5YiZ77yJXHJcbiAqXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQHdpZHRoIOWuveW6plxyXG4gKiBAaGVpZ2h0IOmrmOW6plxyXG4gKiBAcmFkaXVzIOWmguaenOaYr+WchuinkueahO+8jOWImeS4uuOAkOS4iuWPs+S4i+W3puOAkemhuuW6j+eahOWchuinkuWNiuW+hOaVsOe7hFxyXG4gKiovXHJcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vZGlzcGxheS9TaGFwZVwiO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0IGV4dGVuZHMgU2hhcGVcclxue1xyXG4gICAgY29uc3RydWN0b3Iob3B0KVxyXG4gICAge1xyXG4gICAgICAgIG9wdCA9IFV0aWxzLmNoZWNrT3B0KCBvcHQgKTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIHdpZHRoIDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxyXG4gICAgICAgICAgICByYWRpdXM6IFtdLFxyXG4gICAgICAgIH0gLCBvcHQuY29udGV4dCk7XHJcbiAgICAgICAgb3B0LmNvbnRleHQgPSBfY29udGV4dDtcclxuXHJcbiAgICAgICAgc3VwZXIoIG9wdCApO1xyXG5cclxuICAgICAgICB0aGlzLnR5cGUgPSBcInJlY3RcIjtcclxuICAgICAgICB0aGlzLmlkID0gVXRpbHMuY3JlYXRlSWQodGhpcy50eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICB3YXRjaChuYW1lLCB2YWx1ZSwgcHJlVmFsdWUpIFxyXG4gICAge1xyXG4gICAgICAgIGlmICggbmFtZSA9PSBcIndpZHRoXCIgfHwgbmFtZSA9PSBcImhlaWdodFwiIHx8IG5hbWUgPT0gXCJyYWRpdXNcIiApIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckdyYXBoaWNzRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe7mOWItuWchuinkuefqeW9olxyXG4gICAgICovXHJcbiAgICBfYnVpbGRSYWRpdXNQYXRoKCBncmFwaGljcyApXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgLy/lt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxyXG4gICAgICAgIC8vcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXHJcbiAgICAgICAgLy9y57yp5YaZ5Li6WzFdICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cclxuICAgICAgICAvL3LnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxyXG4gICAgICAgIC8vcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNvbnRleHQud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY29udGV4dC5oZWlnaHQ7XHJcbiAgICBcclxuICAgICAgICB2YXIgciA9IFV0aWxzLmdldENzc09yZGVyQXJyKGNvbnRleHQucmFkaXVzKTtcclxuICAgICAgICB2YXIgRyA9IGdyYXBoaWNzO1xyXG4gICAgIFxyXG4gICAgICAgIEcubW92ZVRvKCBwYXJzZUludCh4ICsgclswXSksIHBhcnNlSW50KHkpKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCArIHdpZHRoIC0gclsxXSksIHBhcnNlSW50KHkpKTtcclxuICAgICAgICByWzFdICE9PSAwICYmIEcucXVhZHJhdGljQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgclsxXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCArIHdpZHRoKSwgcGFyc2VJbnQoeSArIGhlaWdodCAtIHJbMl0pKTtcclxuICAgICAgICByWzJdICE9PSAwICYmIEcucXVhZHJhdGljQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gclsyXSwgeSArIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCArIHJbM10pLCBwYXJzZUludCh5ICsgaGVpZ2h0KSk7XHJcbiAgICAgICAgclszXSAhPT0gMCAmJiBHLnF1YWRyYXRpY0N1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gclszXVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICBHLmxpbmVUbyggcGFyc2VJbnQoeCksIHBhcnNlSW50KHkgKyByWzBdKSk7XHJcbiAgICAgICAgclswXSAhPT0gMCAmJiBHLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJbMF0sIHkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnn6nlvaLot6/lvoRcclxuICAgICAqIEBwYXJhbSB7Q29udGV4dDJEfSBjdHggQ2FudmFzIDJE5LiK5LiL5paHXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCDmoLflvI9cclxuICAgICAqL1xyXG4gICAgZHJhdyggZ3JhcGhpY3MgKSBcclxuICAgIHtcclxuICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICBpZighdGhpcy5jb250ZXh0LnJhZGl1cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoMCwwLHRoaXMuY29udGV4dC53aWR0aCAsIHRoaXMuY29udGV4dC5oZWlnaHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkUmFkaXVzUGF0aCggZ3JhcGhpY3MgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JhcGhpY3MuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59IiwiLyoqXHJcbiAqIENhbnZheFxyXG4gKlxyXG4gKiBAYXV0aG9yIOmHiuWJkSAo5p2O5rabLCBsaXRhby5sdEBhbGliYWJhLWluYy5jb20pXHJcbiAqXHJcbiAqIOaJh+W9oiDnsbtcclxuICpcclxuICog5Z2Q5qCH5Y6f54K55YaN5ZyG5b+DXHJcbiAqXHJcbiAqIOWvueW6lGNvbnRleHTnmoTlsZ7mgKfmnIlcclxuICogQHIwIOm7mOiupOS4ujDvvIzlhoXlnIbljYrlvoTmjIflrprlkI7lsIblh7rnjrDlhoXlvKfvvIzlkIzml7bmiYfovrnplb/luqYgPSByIC0gcjBcclxuICogQHIgIOW/hemhu++8jOWkluWchuWNiuW+hFxyXG4gKiBAc3RhcnRBbmdsZSDotbflp4vop5LluqYoMCwgMzYwKVxyXG4gKiBAZW5kQW5nbGUgICDnu5PmnZ/op5LluqYoMCwgMzYwKVxyXG4gKiovXHJcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vZGlzcGxheS9TaGFwZVwiO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCBfIGZyb20gXCIuLi91dGlscy91bmRlcnNjb3JlXCI7XHJcbmltcG9ydCBteU1hdGggZnJvbSBcIi4uL2dlb20vTWF0aFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VjdG9yIGV4dGVuZHMgU2hhcGVcclxue1xyXG4gICAgY29uc3RydWN0b3Iob3B0KVxyXG4gICAge1xyXG4gICAgICAgIG9wdCA9IFV0aWxzLmNoZWNrT3B0KCBvcHQgKTtcclxuICAgICAgICB2YXIgX2NvbnRleHQgPSBfLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIHBvaW50TGlzdCAgOiBbXSwvL+i+ueeVjOeCueeahOmbhuWQiCznp4HmnInvvIzku47kuIvpnaLnmoTlsZ7mgKforqHnrpfnmoTmnaVcclxuICAgICAgICAgICAgcjAgICAgICAgICA6IDAsLy8g6buY6K6k5Li6MO+8jOWGheWchuWNiuW+hOaMh+WumuWQjuWwhuWHuueOsOWGheW8p++8jOWQjOaXtuaJh+i+uemVv+W6piA9IHIgLSByMFxyXG4gICAgICAgICAgICByICAgICAgICAgIDogMCwvL3tudW1iZXJ9LCAgLy8g5b+F6aG777yM5aSW5ZyG5Y2K5b6EXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgOiAwLC8ve251bWJlcn0sICAvLyDlv4XpobvvvIzotbflp4vop5LluqZbMCwgMzYwKVxyXG4gICAgICAgICAgICBlbmRBbmdsZSAgIDogMCwgLy97bnVtYmVyfSwgIC8vIOW/hemhu++8jOe7k+adn+inkuW6pigwLCAzNjBdXHJcbiAgICAgICAgICAgIGNsb2Nrd2lzZSAgOiBmYWxzZSAvL+aYr+WQpumhuuaXtumSiO+8jOm7mOiupOS4umZhbHNlKOmhuuaXtumSiClcclxuICAgICAgICB9ICwgb3B0LmNvbnRleHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG9wdC5jb250ZXh0ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICAgIHN1cGVyKG9wdCk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLnJlZ0FuZ2xlICA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNSaW5nICAgID0gZmFsc2U7Ly/mmK/lkKbkuLrkuIDkuKrlnIbnjq9cclxuICAgICAgICB0aGlzLnR5cGUgPSBcInNlY3RvclwiO1xyXG4gICAgICAgIHRoaXMuaWQgPSBVdGlscy5jcmVhdGVJZCh0aGlzLnR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHdhdGNoKG5hbWUsIHZhbHVlLCBwcmVWYWx1ZSkgXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCBuYW1lID09IFwicjBcIiB8fCBuYW1lID09IFwiclwiIHx8IG5hbWUgPT0gXCJzdGFydEFuZ2xlXCIgfHwgbmFtZSA9PVwiZW5kQW5nbGVcIiB8fCBuYW1lID09XCJjbG9ja3dpc2VcIiApIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckdyYXBoaWNzRGF0YSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZHJhdyggZ3JhcGhpY3MgKVxyXG4gICAge1xyXG4gICAgICAgIGdyYXBoaWNzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIC8vIOW9ouWGheWNiuW+hFswLHIpXHJcbiAgICAgICAgdmFyIHIwID0gdHlwZW9mIGNvbnRleHQucjAgPT0gJ3VuZGVmaW5lZCcgPyAwIDogY29udGV4dC5yMDtcclxuICAgICAgICB2YXIgciAgPSBjb250ZXh0LnI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOaJh+W9ouWkluWNiuW+hCgwLHJdXHJcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBteU1hdGguZGVncmVlVG8zNjAoY29udGV4dC5zdGFydEFuZ2xlKTsgICAgICAgICAgLy8g6LW35aeL6KeS5bqmWzAsMzYwKVxyXG4gICAgICAgIHZhciBlbmRBbmdsZSAgID0gbXlNYXRoLmRlZ3JlZVRvMzYwKGNvbnRleHQuZW5kQW5nbGUpOyAgICAgICAgICAgICAgLy8g57uT5p2f6KeS5bqmKDAsMzYwXVxyXG5cclxuICAgICAgICAvL3ZhciBpc1JpbmcgICAgID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgICAvL+aYr+WQpuS4uuWchueOr1xyXG5cclxuICAgICAgICAvL2lmKCBzdGFydEFuZ2xlICE9IGVuZEFuZ2xlICYmIE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkgJSAzNjAgPT0gMCApIHtcclxuICAgICAgICBpZiggc3RhcnRBbmdsZSA9PSBlbmRBbmdsZSAmJiBjb250ZXh0LnN0YXJ0QW5nbGUgIT0gY29udGV4dC5lbmRBbmdsZSApIHtcclxuICAgICAgICAgICAgLy/lpoLmnpzkuKTkuKrop5Lluqbnm7jnrYnvvIzpgqPkuYjlsLHorqTkuLrmmK/kuKrlnIbnjq/kuoZcclxuICAgICAgICAgICAgdGhpcy5pc1JpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydEFuZ2xlICA9IDAgO1xyXG4gICAgICAgICAgICBlbmRBbmdsZSAgICA9IDM2MDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBteU1hdGguZGVncmVlVG9SYWRpYW4oc3RhcnRBbmdsZSk7XHJcbiAgICAgICAgZW5kQW5nbGUgICA9IG15TWF0aC5kZWdyZWVUb1JhZGlhbihlbmRBbmdsZSk7XHJcbiAgICAgXHJcbiAgICAgICAgLy/lpITnkIbkuIvmnoHlsI/lpLnop5LnmoTmg4XlhrVcclxuICAgICAgICBpZiggZW5kQW5nbGUgLSBzdGFydEFuZ2xlIDwgMC4wMjUgKXtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSAtPSAwLjAwM1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIEcgPSBncmFwaGljcztcclxuXHJcbiAgICAgICAgRy5hcmMoIDAgLCAwICwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRoaXMuY29udGV4dC5jbG9ja3dpc2UpO1xyXG4gICAgICAgIGlmIChyMCAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiggdGhpcy5pc1JpbmcgKXtcclxuICAgICAgICAgICAgICAgIC8v5Yqg5LiK6L+Z5LiqaXNSaW5n55qE6YC76L6R5piv5Li65LqG5YW85a65Zmxhc2hjYW52YXPkuIvnu5jliLblnIbnjq/nmoTnmoTpl67pophcclxuICAgICAgICAgICAgICAgIC8v5LiN5Yqg6L+Z5Liq6YC76L6RZmxhc2hjYW52YXPkvJrnu5jliLbkuIDkuKrlpKflnIYg77yMIOiAjOS4jeaYr+WchueOr1xyXG4gICAgICAgICAgICAgICAgRy5tb3ZlVG8oIHIwICwgMCApO1xyXG4gICAgICAgICAgICAgICAgRy5hcmMoIDAgLCAwICwgcjAgLCBzdGFydEFuZ2xlICwgZW5kQW5nbGUgLCAhdGhpcy5jb250ZXh0LmNsb2Nrd2lzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBHLmFyYyggMCAsIDAgLCByMCAsIGVuZEFuZ2xlICwgc3RhcnRBbmdsZSAsICF0aGlzLmNvbnRleHQuY2xvY2t3aXNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vVE9ETzrlnKhyMOS4ujDnmoTml7blgJnvvIzlpoLmnpzkuI3liqBsaW5lVG8oMCwwKeadpeaKiui3r+W+hOmXreWQiO+8jOS8muWHuueOsOacieaQnueskeeahOS4gOS4qmJ1Z1xyXG4gICAgICAgICAgICAvL+aVtOS4quWchuS8muWHuueOsOS4gOS4quS7peavj+S4quaJh+W9ouS4pOerr+S4uuiKgueCueeahOmVguepuu+8jOaIkeWPr+iDveaPj+i/sOS4jea4healmu+8jOWPjeato+i/meS4quWKoOS4iuWwseWlveS6hlxyXG4gICAgICAgICAgICBHLmxpbmVUbygwLDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgRy5jbG9zZVBhdGgoKTtcclxuICAgICB9XHJcblxyXG4gICAgIGdldFJlY3QoY29udGV4dClcclxuICAgICB7XHJcbiAgICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dCA/IGNvbnRleHQgOiB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgIHZhciByMCA9IHR5cGVvZiBjb250ZXh0LnIwID09ICd1bmRlZmluZWQnICAgICAvLyDlvaLlhoXljYrlvoRbMCxyKVxyXG4gICAgICAgICAgICAgPyAwIDogY29udGV4dC5yMDtcclxuICAgICAgICAgdmFyIHIgPSBjb250ZXh0LnI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOaJh+W9ouWkluWNiuW+hCgwLHJdXHJcbiAgICAgICAgIFxyXG4gICAgICAgICB0aGlzLmdldFJlZ0FuZ2xlKCk7XHJcblxyXG4gICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IG15TWF0aC5kZWdyZWVUbzM2MChjb250ZXh0LnN0YXJ0QW5nbGUpOyAgICAgICAgICAvLyDotbflp4vop5LluqZbMCwzNjApXHJcbiAgICAgICAgIHZhciBlbmRBbmdsZSAgID0gbXlNYXRoLmRlZ3JlZVRvMzYwKGNvbnRleHQuZW5kQW5nbGUpOyAgICAgICAgICAgIC8vIOe7k+adn+inkuW6pigwLDM2MF1cclxuXHJcbiAgICAgICAgIHZhciBwb2ludExpc3QgID0gW107XHJcblxyXG4gICAgICAgICB2YXIgcDREaXJlY3Rpb249IHtcclxuICAgICAgICAgICAgIFwiOTBcIiA6IFsgMCAsIHIgXSxcclxuICAgICAgICAgICAgIFwiMTgwXCI6IFsgLXIsIDAgXSxcclxuICAgICAgICAgICAgIFwiMjcwXCI6IFsgMCAsIC1yXSxcclxuICAgICAgICAgICAgIFwiMzYwXCI6IFsgciAsIDAgXSBcclxuICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgIGZvciAoIHZhciBkIGluIHA0RGlyZWN0aW9uICl7XHJcbiAgICAgICAgICAgICB2YXIgaW5BbmdsZVJlZyA9IHBhcnNlSW50KGQpID4gdGhpcy5yZWdBbmdsZVswXSAmJiBwYXJzZUludChkKSA8IHRoaXMucmVnQW5nbGVbMV07XHJcbiAgICAgICAgICAgICBpZiggdGhpcy5pc1JpbmcgfHwgKGluQW5nbGVSZWcgJiYgdGhpcy5yZWdJbikgfHwgKCFpbkFuZ2xlUmVnICYmICF0aGlzLnJlZ0luKSApe1xyXG4gICAgICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKCBwNERpcmVjdGlvblsgZCBdICk7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGlmKCAhdGhpcy5pc1JpbmcgKSB7XHJcbiAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbXlNYXRoLmRlZ3JlZVRvUmFkaWFuKCBzdGFydEFuZ2xlICk7XHJcbiAgICAgICAgICAgICBlbmRBbmdsZSAgID0gbXlNYXRoLmRlZ3JlZVRvUmFkaWFuKCBlbmRBbmdsZSAgICk7XHJcblxyXG4gICAgICAgICAgICAgcG9pbnRMaXN0LnB1c2goW1xyXG4gICAgICAgICAgICAgICAgIG15TWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByMCAsIG15TWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByMFxyXG4gICAgICAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICBteU1hdGguY29zKHN0YXJ0QW5nbGUpICogciAgLCBteU1hdGguc2luKHN0YXJ0QW5nbGUpICogclxyXG4gICAgICAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICBteU1hdGguY29zKGVuZEFuZ2xlKSAgICogciAgLCAgbXlNYXRoLnNpbihlbmRBbmdsZSkgICogclxyXG4gICAgICAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgIHBvaW50TGlzdC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICBteU1hdGguY29zKGVuZEFuZ2xlKSAgICogcjAgLCAgbXlNYXRoLnNpbihlbmRBbmdsZSkgICogcjBcclxuICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgY29udGV4dC5wb2ludExpc3QgPSBwb2ludExpc3Q7XHJcbiAgICAgICAgIHJldHVybiB0aGlzLmdldFJlY3RGb3JtUG9pbnRMaXN0KCBjb250ZXh0ICk7XHJcbiAgICAgfVxyXG5cclxuICAgICBnZXRSZWdBbmdsZSgpXHJcbiAgICAge1xyXG4gICAgICAgICB0aGlzLnJlZ0luICAgICAgPSB0cnVlOyAgLy/lpoLmnpzlnKhzdGFydOWSjGVuZOeahOaVsOWAvOS4re+8jGVuZOWkp+S6jnN0YXJ06ICM5LiU5piv6aG65pe26ZKI5YiZcmVnSW7kuLp0cnVlXHJcbiAgICAgICAgIHZhciBjICAgICAgICAgICA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBteU1hdGguZGVncmVlVG8zNjAoYy5zdGFydEFuZ2xlKTsgICAgICAgICAgLy8g6LW35aeL6KeS5bqmWzAsMzYwKVxyXG4gICAgICAgICB2YXIgZW5kQW5nbGUgICA9IG15TWF0aC5kZWdyZWVUbzM2MChjLmVuZEFuZ2xlKTsgICAgICAgICAgICAvLyDnu5PmnZ/op5LluqYoMCwzNjBdXHJcblxyXG4gICAgICAgICBpZiAoICggc3RhcnRBbmdsZSA+IGVuZEFuZ2xlICYmICFjLmNsb2Nrd2lzZSApIHx8ICggc3RhcnRBbmdsZSA8IGVuZEFuZ2xlICYmIGMuY2xvY2t3aXNlICkgKSB7XHJcbiAgICAgICAgICAgICB0aGlzLnJlZ0luICA9IGZhbHNlOyAvL291dFxyXG4gICAgICAgICB9O1xyXG4gICAgICAgICAvL+W6pueahOiMg+WbtO+8jOS7juWwj+WIsOWkp1xyXG4gICAgICAgICB0aGlzLnJlZ0FuZ2xlICAgPSBbIFxyXG4gICAgICAgICAgICAgTWF0aC5taW4oIHN0YXJ0QW5nbGUgLCBlbmRBbmdsZSApICwgXHJcbiAgICAgICAgICAgICBNYXRoLm1heCggc3RhcnRBbmdsZSAsIGVuZEFuZ2xlICkgXHJcbiAgICAgICAgIF07XHJcbiAgICAgfVxyXG59XHJcbiIsIlxuaW1wb3J0IEFwcGxpY2F0aW9uIGZyb20gXCIuL0FwcGxpY2F0aW9uXCI7XG5pbXBvcnQgRXZlbnREaXNwYXRjaGVyIGZyb20gXCIuL2V2ZW50L0V2ZW50RGlzcGF0Y2hlclwiO1xuaW1wb3J0IEV2ZW50TWFuYWdlciBmcm9tIFwiLi9ldmVudC9FdmVudE1hbmFnZXJcIjtcbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gXCIuL2Rpc3BsYXkvRGlzcGxheU9iamVjdFwiO1xuaW1wb3J0IERpc3BsYXlPYmplY3RDb250YWluZXIgZnJvbSBcIi4vZGlzcGxheS9EaXNwbGF5T2JqZWN0Q29udGFpbmVyXCI7XG5pbXBvcnQgU3RhZ2UgZnJvbSBcIi4vZGlzcGxheS9TdGFnZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9kaXNwbGF5L1Nwcml0ZVwiO1xuaW1wb3J0IFNoYXBlIGZyb20gXCIuL2Rpc3BsYXkvU2hhcGVcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi9kaXNwbGF5L1BvaW50XCI7XG5pbXBvcnQgVGV4dCBmcm9tIFwiLi9kaXNwbGF5L1RleHRcIjtcblxuLy9zaGFwZXNcbmltcG9ydCBCcm9rZW5MaW5lIGZyb20gXCIuL3NoYXBlL0Jyb2tlbkxpbmVcIjtcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4vc2hhcGUvQ2lyY2xlXCI7XG5pbXBvcnQgRHJvcGxldCBmcm9tIFwiLi9zaGFwZS9Ecm9wbGV0XCI7XG5pbXBvcnQgRWxsaXBzZSBmcm9tIFwiLi9zaGFwZS9FbGxpcHNlXCI7XG5pbXBvcnQgSXNvZ29uIGZyb20gXCIuL3NoYXBlL0lzb2dvblwiO1xuaW1wb3J0IExpbmUgZnJvbSBcIi4vc2hhcGUvTGluZVwiO1xuaW1wb3J0IFBhdGggZnJvbSBcIi4vc2hhcGUvUGF0aFwiO1xuaW1wb3J0IFBvbHlnb24gZnJvbSBcIi4vc2hhcGUvUG9seWdvblwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4vc2hhcGUvUmVjdFwiO1xuaW1wb3J0IFNlY3RvciBmcm9tIFwiLi9zaGFwZS9TZWN0b3JcIjtcblxudmFyIENhbnZheCA9IHtcbiAgICBBcHA6IEFwcGxpY2F0aW9uXG59O1xuXG5DYW52YXguRGlzcGxheSA9IHtcbiAgICBEaXNwbGF5T2JqZWN0IDogRGlzcGxheU9iamVjdCxcbiAgICBEaXNwbGF5T2JqZWN0Q29udGFpbmVyIDogRGlzcGxheU9iamVjdENvbnRhaW5lcixcbiAgICBTdGFnZSAgOiBTdGFnZSxcbiAgICBTcHJpdGUgOiBTcHJpdGUsXG4gICAgU2hhcGUgIDogU2hhcGUsXG4gICAgUG9pbnQgIDogUG9pbnQsXG4gICAgVGV4dCAgIDogVGV4dFxufVxuXG5DYW52YXguU2hhcGVzID0ge1xuICAgIEJyb2tlbkxpbmUgOiBCcm9rZW5MaW5lLFxuICAgIENpcmNsZSA6IENpcmNsZSxcbiAgICBEcm9wbGV0IDogRHJvcGxldCxcbiAgICBFbGxpcHNlIDogRWxsaXBzZSxcbiAgICBJc29nb24gOiBJc29nb24sXG4gICAgTGluZSA6IExpbmUsXG4gICAgUGF0aCA6IFBhdGgsXG4gICAgUG9seWdvbiA6IFBvbHlnb24sXG4gICAgUmVjdCA6IFJlY3QsXG4gICAgU2VjdG9yIDogU2VjdG9yXG59XG5cbkNhbnZheC5FdmVudCA9IHtcbiAgICBFdmVudERpc3BhdGNoZXIgOiBFdmVudERpc3BhdGNoZXIsXG4gICAgRXZlbnRNYW5hZ2VyICAgIDogRXZlbnRNYW5hZ2VyXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZheDsiXSwibmFtZXMiOlsiXyIsImJyZWFrZXIiLCJBcnJheVByb3RvIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJPYmpQcm90byIsIk9iamVjdCIsInRvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJuYXRpdmVGb3JFYWNoIiwiZm9yRWFjaCIsIm5hdGl2ZUZpbHRlciIsImZpbHRlciIsIm5hdGl2ZUluZGV4T2YiLCJpbmRleE9mIiwibmF0aXZlSXNBcnJheSIsImlzQXJyYXkiLCJuYXRpdmVLZXlzIiwia2V5cyIsInZhbHVlcyIsIm9iaiIsImxlbmd0aCIsImkiLCJUeXBlRXJyb3IiLCJrZXkiLCJoYXMiLCJwdXNoIiwiY2FsbCIsImVhY2giLCJpdGVyYXRvciIsImNvbnRleHQiLCJjb21wYWN0IiwiYXJyYXkiLCJpZGVudGl0eSIsInNlbGVjdCIsInJlc3VsdHMiLCJ2YWx1ZSIsImluZGV4IiwibGlzdCIsIm5hbWUiLCJpc0Z1bmN0aW9uIiwiaXNGaW5pdGUiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc051bWJlciIsImlzQm9vbGVhbiIsImlzTnVsbCIsImlzRW1wdHkiLCJpc1N0cmluZyIsImlzRWxlbWVudCIsIm5vZGVUeXBlIiwiaXNPYmplY3QiLCJpdGVtIiwiaXNTb3J0ZWQiLCJNYXRoIiwibWF4Iiwic29ydGVkSW5kZXgiLCJpc1dpbmRvdyIsIndpbmRvdyIsImlzUGxhaW5PYmplY3QiLCJjb25zdHJ1Y3RvciIsImhhc093biIsImUiLCJ1bmRlZmluZWQiLCJleHRlbmQiLCJvcHRpb25zIiwic3JjIiwiY29weSIsImNvcHlJc0FycmF5IiwiY2xvbmUiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJkZWVwIiwic2xpY2UiLCJVdGlscyIsImRldmljZVBpeGVsUmF0aW8iLCJfVUlEIiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwiZ2V0VUlEIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsInByb3RvIiwibmV3UHJvdG8iLCJPYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJfX2VtcHR5RnVuYyIsInIiLCJzIiwicHgiLCJzcCIsInJwIiwiY3JlYXRlT2JqZWN0Iiwic3VwZXJjbGFzcyIsImNhbnZhcyIsIkZsYXNoQ2FudmFzIiwiaW5pdEVsZW1lbnQiLCJvcHQiLCJyMSIsInIyIiwicjMiLCJyNCIsImNvbnRleHRPcHRpb25zIiwic3RlbmNpbCIsIldlYkdMUmVuZGVyaW5nQ29udGV4dCIsImdsIiwiZ2V0Q29udGV4dEF0dHJpYnV0ZXMiLCJQb2ludCIsIngiLCJ5IiwiYmFiZWxIZWxwZXJzLnR5cGVvZiIsImFyZyIsInAiLCJDYW52YXhFdmVudCIsImV2dCIsInBhcmFtcyIsImV2ZW50VHlwZSIsInR5cGUiLCJjdXJyZW50VGFyZ2V0IiwicG9pbnQiLCJfc3RvcFByb3BhZ2F0aW9uIiwiYWRkT3JSbW92ZUV2ZW50SGFuZCIsImRvbUhhbmQiLCJpZUhhbmQiLCJldmVudERvbUZuIiwiZWwiLCJmbiIsImV2ZW50Rm4iLCJldmVudCIsImdldEVsZW1lbnRCeUlkIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZG9jIiwib3duZXJEb2N1bWVudCIsImJvZHkiLCJkb2NFbGVtIiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImJvdW5kIiwicmlnaHQiLCJsZWZ0IiwiY2xpZW50V2lkdGgiLCJ6b29tIiwidG9wIiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJwYWdlWE9mZnNldCIsInNjcm9sbExlZnQiLCJwYWdlWCIsImNsaWVudFgiLCJwYWdlWSIsImNsaWVudFkiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiaWQiLCJzdHlsZSIsInBvc2l0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJzZXRBdHRyaWJ1dGUiLCJzZXR0aW5ncyIsIlJFU09MVVRJT04iLCJ2aWV3IiwiY2xhc3NOYW1lIiwiY3NzVGV4dCIsInN0YWdlX2MiLCJkb21fYyIsImFwcGVuZENoaWxkIiwiX21vdXNlRXZlbnRUeXBlcyIsIl9oYW1tZXJFdmVudFR5cGVzIiwiRXZlbnRIYW5kbGVyIiwiY2FudmF4IiwiY3VyUG9pbnRzIiwiY3VyUG9pbnRzVGFyZ2V0IiwiX3RvdWNoaW5nIiwiX2RyYWdpbmciLCJfY3Vyc29yIiwidHlwZXMiLCJkcmFnIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsInBhcmVudCIsImNoaWxkIiwibWUiLCJhZGRFdmVudCIsIl9fbW91c2VIYW5kbGVyIiwib24iLCJfX2xpYkhhbmRsZXIiLCJyb290IiwidXBkYXRlVmlld09mZnNldCIsIiQiLCJ2aWV3T2Zmc2V0IiwiY3VyTW91c2VQb2ludCIsImN1ck1vdXNlVGFyZ2V0IiwiZ2V0T2JqZWN0c1VuZGVyUG9pbnQiLCJkcmFnRW5hYmxlZCIsInRvRWxlbWVudCIsInJlbGF0ZWRUYXJnZXQiLCJfZHJhZ0VuZCIsImZpcmUiLCJfX2dldGN1clBvaW50c1RhcmdldCIsImdsb2JhbEFscGhhIiwiY2xvbmVPYmplY3QiLCJfY2xvbmUyaG92ZXJTdGFnZSIsIl9nbG9iYWxBbHBoYSIsIl9kcmFnTW92ZUhhbmRlciIsIl9fZGlzcGF0Y2hFdmVudEluQ2hpbGRzIiwiX2N1cnNvckhhbmRlciIsInByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJvbGRPYmoiLCJfaG92ZXJDbGFzcyIsInBvaW50Q2hrUHJpb3JpdHkiLCJnZXRDaGlsZEluUG9pbnQiLCJnbG9iYWxUb0xvY2FsIiwiZGlzcGF0Y2hFdmVudCIsInRvVGFyZ2V0IiwiZnJvbVRhcmdldCIsIl9zZXRDdXJzb3IiLCJjdXJzb3IiLCJfX2dldENhbnZheFBvaW50SW5Ub3VjaHMiLCJfX2dldENoaWxkSW5Ub3VjaHMiLCJzdGFydCIsIm1vdmUiLCJlbmQiLCJjdXJUb3VjaHMiLCJ0b3VjaCIsInRvdWNocyIsInRvdWNoZXNUYXJnZXQiLCJjaGlsZHMiLCJoYXNDaGlsZCIsImNlIiwic3RhZ2VQb2ludCIsIl9kcmFnRHVwbGljYXRlIiwiX2J1ZmZlclN0YWdlIiwiZ2V0Q2hpbGRCeUlkIiwiX3RyYW5zZm9ybSIsImdldENvbmNhdGVuYXRlZE1hdHJpeCIsImFkZENoaWxkQXQiLCJfZHJhZ1BvaW50IiwiX3BvaW50IiwiX25vdFdhdGNoIiwiX21vdmVTdGFnZSIsIm1vdmVpbmciLCJoZWFydEJlYXQiLCJkZXN0cm95IiwiRXZlbnRNYW5hZ2VyIiwiX2V2ZW50TWFwIiwibGlzdGVuZXIiLCJhZGRSZXN1bHQiLCJzZWxmIiwic3BsaXQiLCJtYXAiLCJfZXZlbnRFbmFibGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lckJ5VHlwZSIsImxpIiwic3BsaWNlIiwiX2Rpc3BhdGNoRXZlbnQiLCJFdmVudERpc3BhdGNoZXIiLCJjcmVhdENsYXNzIiwiX2FkZEV2ZW50TGlzdGVuZXIiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9yZW1vdmVFdmVudExpc3RlbmVyQnlUeXBlIiwiX3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzIiwibG9nIiwiZVR5cGUiLCJjaGlsZHJlbiIsInByZUhlYXJ0QmVhdCIsIl9oZWFydEJlYXROdW0iLCJwcmVnQWxwaGEiLCJob3ZlckNsb25lIiwiZ2V0U3RhZ2UiLCJhY3RpdlNoYXBlIiwicmVtb3ZlQ2hpbGRCeUlkIiwiX2hhc0V2ZW50TGlzdGVuZXIiLCJvdmVyRnVuIiwib3V0RnVuIiwib25jZUhhbmRsZSIsImFwcGx5IiwidW4iLCJNYXRyaXgiLCJhIiwiYiIsImMiLCJkIiwidHgiLCJ0eSIsIm10eCIsInNjYWxlWCIsInNjYWxlWSIsInJvdGF0aW9uIiwiY29zIiwic2luIiwiUEkiLCJjb25jYXQiLCJhbmdsZSIsInN0IiwiYWJzIiwiY3QiLCJzeCIsInN5IiwiZHgiLCJkeSIsInRyYW5zcG9zZSIsIm91dCIsIkZsb2F0MzJBcnJheSIsInYiLCJhYSIsImFjIiwiYXR4IiwiYWIiLCJhZCIsImF0eSIsIlRXRUVOIiwiX3R3ZWVucyIsInR3ZWVuIiwidGltZSIsInByZXNlcnZlIiwibm93IiwiX3QiLCJfdXBkYXRlUmVzIiwidXBkYXRlIiwicHJvY2VzcyIsImhydGltZSIsInBlcmZvcm1hbmNlIiwiYmluZCIsIkRhdGUiLCJnZXRUaW1lIiwiVHdlZW4iLCJvYmplY3QiLCJfb2JqZWN0IiwiX3ZhbHVlc1N0YXJ0IiwiX3ZhbHVlc0VuZCIsIl92YWx1ZXNTdGFydFJlcGVhdCIsIl9kdXJhdGlvbiIsIl9yZXBlYXQiLCJfcmVwZWF0RGVsYXlUaW1lIiwiX3lveW8iLCJfaXNQbGF5aW5nIiwiX3JldmVyc2VkIiwiX2RlbGF5VGltZSIsIl9zdGFydFRpbWUiLCJfZWFzaW5nRnVuY3Rpb24iLCJFYXNpbmciLCJMaW5lYXIiLCJOb25lIiwiX2ludGVycG9sYXRpb25GdW5jdGlvbiIsIkludGVycG9sYXRpb24iLCJfY2hhaW5lZFR3ZWVucyIsIl9vblN0YXJ0Q2FsbGJhY2siLCJfb25TdGFydENhbGxiYWNrRmlyZWQiLCJfb25VcGRhdGVDYWxsYmFjayIsIl9vbkNvbXBsZXRlQ2FsbGJhY2siLCJfb25TdG9wQ2FsbGJhY2siLCJ0byIsInByb3BlcnRpZXMiLCJkdXJhdGlvbiIsImFkZCIsInByb3BlcnR5Iiwic3RvcCIsInJlbW92ZSIsInN0b3BDaGFpbmVkVHdlZW5zIiwibnVtQ2hhaW5lZFR3ZWVucyIsImRlbGF5IiwiYW1vdW50IiwicmVwZWF0IiwidGltZXMiLCJyZXBlYXREZWxheSIsInlveW8iLCJlYXNpbmciLCJpbnRlcnBvbGF0aW9uIiwiY2hhaW4iLCJvblN0YXJ0IiwiY2FsbGJhY2siLCJvblVwZGF0ZSIsIm9uQ29tcGxldGUiLCJvblN0b3AiLCJlbGFwc2VkIiwiY2hhckF0IiwidG1wIiwiayIsInBvdyIsInNxcnQiLCJCb3VuY2UiLCJPdXQiLCJJbiIsIm0iLCJmIiwiZmxvb3IiLCJuIiwicHciLCJibiIsIkJlcm5zdGVpbiIsIkNhdG11bGxSb20iLCJwMCIsInAxIiwidCIsImZjIiwiRmFjdG9yaWFsIiwicDIiLCJwMyIsInYwIiwidjEiLCJ0MiIsInQzIiwibGFzdFRpbWUiLCJ2ZW5kb3JzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJlbGVtZW50IiwiY3VyclRpbWUiLCJ0aW1lVG9DYWxsIiwic2V0VGltZW91dCIsIl90YXNrTGlzdCIsIl9yZXF1ZXN0QWlkIiwiZW5hYmxlZEFuaW1hdGlvbkZyYW1lIiwiY3VyclRhc2tMaXN0Iiwic2hpZnQiLCJ0YXNrIiwicmVnaXN0RnJhbWUiLCIkZnJhbWUiLCJkZXN0cm95RnJhbWUiLCJkX3Jlc3VsdCIsImwiLCJyZWdpc3RUd2VlbiIsInRpZCIsImZyb20iLCJhbmltYXRlIiwiX2lzQ29tcGxldGVlZCIsIl9pc1N0b3BlZCIsImRlc2MiLCJkZXN0cm95VHdlZW4iLCJtc2ciLCJ1bndhdGNoT25lIiwiT2JzZXJ2ZSIsInNjb3BlIiwibW9kZWwiLCJ3YXRjaE1vcmUiLCJzdG9wUmVwZWF0QXNzaWduIiwic2tpcEFycmF5IiwiJHNraXBBcnJheSIsIlZCUHVibGljcyIsImxvb3AiLCJ2YWwiLCJ2YWx1ZVR5cGUiLCJhY2Nlc3NvciIsIm5lbyIsInByZVZhbHVlIiwiY29tcGxleFZhbHVlIiwibmVvVHlwZSIsImFkZENvbG9yU3RvcCIsIiRtb2RlbCIsIiRmaXJlIiwicG1vZGVsIiwiaGFzV2F0Y2hNb2RlbCIsIiR3YXRjaCIsIiRwYXJlbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYWNjZXNzb3JlcyIsIiRhY2Nlc3NvciIsImRlZmluZVByb3BlcnR5IiwicHJvcCIsIl9fZGVmaW5lR2V0dGVyX18iLCJnZXQiLCJfX2RlZmluZVNldHRlcl9fIiwic2V0IiwiZGVzY3MiLCJWQkFycmF5IiwiVkJNZWRpYXRvciIsImRlc2NyaXB0aW9uIiwiZXhlY1NjcmlwdCIsImpvaW4iLCJwdWJsaWNzIiwib3duZXIiLCJidWZmZXIiLCJwYXJzZVZCIiwiUkVOREVSRVJfVFlQRSIsIkRSQVdfTU9ERVMiLCJTSEFQRVMiLCJDT05URVhUX0RFRkFVTFQiLCJTSEFQRV9DT05URVhUX0RFRkFVTFQiLCJUUkFOU0ZPUk1fUFJPUFMiLCJfaXNJbnNpZGVMaW5lIiwicG9pbnRzIiwibGluZVdpZHRoIiwieDAiLCJ5MCIsIngxIiwieTEiLCJfbCIsIl9hIiwiX2IiLCJfcyIsImluc2lkZUxpbmUiLCJkYXRhIiwibGluZSIsInNoYXBlIiwiaW5zaWRlQ2F0Y2giLCJEaXNwbGF5T2JqZWN0IiwiY2hlY2tPcHQiLCJ3b3JsZFRyYW5zZm9ybSIsInN0YWdlIiwieHlUb0ludCIsIl9jcmVhdGVDb250ZXh0IiwiY3JlYXRlSWQiLCJpbml0IiwiX3VwZGF0ZVRyYW5zZm9ybSIsIl9jb250ZXh0QVRUUlMiLCIkb3duZXIiLCJnZXRXb3JsZFRyYW5zZm9ybSIsInVwZGF0ZUNoaWxkV29ybGRUcmFuc2Zvcm0iLCJteXNlbGYiLCJjb25mIiwibmV3T2JqIiwidGV4dCIsImNvbnRhaW5lciIsImNtIiwiaW52ZXJ0IiwibG9jYWxUb0dsb2JhbCIsIm8iLCJib29sIiwibnVtIiwiZnJvbUluZGV4IiwiZ2V0SW5kZXgiLCJ0b0luZGV4IiwicGNsIiwib3JpZ2luIiwic2NhbGVPcmlnaW4iLCJ0cmFuc2xhdGUiLCJzY2FsZSIsInJvdGF0ZU9yaWdpbiIsInJvdGF0ZSIsInBhcnNlSW50Iiwic3Ryb2tlU3R5bGUiLCJyZXN1bHQiLCJpbnZlcnNlTWF0cml4Iiwib3JpZ2luUG9zIiwibXVsVmVjdG9yIiwiZ3JhcGhpY3NEYXRhIiwiY29udGFpbnNQb2ludCIsIl9ncmFwaGljc0RhdGEiLCJpbnNpZGUiLCJoYXNGaWxsIiwiaGFzTGluZSIsIkluc2lkZUxpbmUiLCJ0b0NvbnRlbnQiLCJ1cEZ1biIsImNvbXBGdW4iLCJBbmltYXRpb25GcmFtZSIsInJlbW92ZUNoaWxkIiwiRGlzcGxheU9iamVjdENvbnRhaW5lciIsIm1vdXNlQ2hpbGRyZW4iLCJnZXRDaGlsZEluZGV4IiwiX2FmdGVyQWRkQ2hpbGQiLCJhZGRDaGlsZCIsInJlbW92ZUNoaWxkQXQiLCJfYWZ0ZXJEZWxDaGlsZCIsImxlbiIsImdldENoaWxkQXQiLCJib29sZW4iLCJvbGRJbmRleCIsInZpc2libGUiLCJnZXROdW1DaGlsZHJlbiIsIm9ianMiLCJTdGFnZSIsImN0eCIsInN0YWdlUmVuZGluZyIsIl9pc1JlYWR5IiwiX2RldmljZVBpeGVsUmF0aW8iLCJTeXN0ZW1SZW5kZXJlciIsIlVOS05PV04iLCJhcHAiLCJSRU5ERVJfT1BUSU9OUyIsInJlcXVlc3RBaWQiLCJfaGVhcnRCZWF0IiwiX3ByZVJlbmRlclRpbWUiLCJlbnRlckZyYW1lIiwiX2JlZ2luIiwicmVuZGVyIiwiX2VuZCIsImNvbnZlcnRUeXBlIiwiX2NvbnZlcnRDYW52YXgiLCJjb252ZXJ0U3RhZ2VzIiwiY29udmVydFNoYXBlcyIsInN0YXJ0RW50ZXIiLCJDYW52YXNHcmFwaGljc1JlbmRlcmVyIiwicmVuZGVyZXIiLCJkaXNwbGF5T2JqZWN0IiwiZmlsbFN0eWxlIiwiZmlsbCIsImZpbGxBbHBoYSIsImxpbmVBbHBoYSIsIlBPTFkiLCJiZWdpblBhdGgiLCJyZW5kZXJQb2x5Z29uIiwiY2xvc2VkIiwic3Ryb2tlIiwiUkVDVCIsImZpbGxSZWN0Iiwic3Ryb2tlUmVjdCIsIkNJUkMiLCJhcmMiLCJyYWRpdXMiLCJjbG9zZVBhdGgiLCJFTElQIiwidyIsImgiLCJrYXBwYSIsIm94Iiwib3kiLCJ4ZSIsInllIiwieG0iLCJ5bSIsIm1vdmVUbyIsImJlemllckN1cnZlVG8iLCJjbG9zZSIsImoiLCJsaW5lVG8iLCJHcmFwaGljc0RhdGEiLCJob2xlcyIsImdyYXBoaWNzIiwiYXJjVG9TZWdtZW50c0NhY2hlIiwic2VnbWVudFRvQmV6aWVyQ2FjaGUiLCJib3VuZHNPZkN1cnZlQ2FjaGUiLCJfam9pbiIsImFyY1RvU2VnbWVudHMiLCJ0b1giLCJ0b1kiLCJyeCIsInJ5IiwibGFyZ2UiLCJzd2VlcCIsInJvdGF0ZVgiLCJhcmdzU3RyaW5nIiwidGgiLCJzaW5UaCIsImNvc1RoIiwiZnJvbVgiLCJmcm9tWSIsInB5IiwicngyIiwicnkyIiwicHkyIiwicHgyIiwicGwiLCJjeCIsImN5IiwiY3gxIiwiY3kxIiwibVRoZXRhIiwiY2FsY1ZlY3RvckFuZ2xlIiwiZHRoZXRhIiwic2VnbWVudHMiLCJjZWlsIiwibURlbHRhIiwibVQiLCJ0aDMiLCJzZWdtZW50VG9CZXppZXIiLCJ0aDIiLCJhcmdzU3RyaW5nMiIsImNvc3RoMiIsInNpbnRoMiIsImNvc3RoMyIsInNpbnRoMyIsImNwMVgiLCJjcDFZIiwiY3AyWCIsImNwMlkiLCJ1eCIsInV5IiwidngiLCJ2eSIsInRhIiwiYXRhbjIiLCJ0YiIsImRyYXdBcmMiLCJmeCIsImZ5IiwiY29vcmRzIiwicm90Iiwic2VncyIsInNlZ3NOb3JtIiwiZ2V0Qm91bmRzT2ZBcmMiLCJib3VuZHMiLCJnZXRCb3VuZHNPZkN1cnZlIiwieDIiLCJ5MiIsIngzIiwieTMiLCJtaW4iLCJ0dmFsdWVzIiwidDEiLCJiMmFjIiwic3FydGIyYWMiLCJqbGVuIiwibXQiLCJSZWN0YW5nbGUiLCJyZWN0YW5nbGUiLCJwYWRkaW5nWCIsInBhZGRpbmdZIiwiQ2lyY2xlIiwiRWxsaXBzZSIsIm5vcm14Iiwibm9ybXkiLCJQb2x5Z29uIiwiaWwiLCJfaXNJbnNpZGVQb2x5Z29uX1dpbmRpbmdOdW1iZXIiLCJ3biIsInNoaWZ0UCIsImNwWCIsImNwWSIsImNwWDIiLCJjcFkyIiwicGF0aCIsImR0IiwiZHQyIiwiZHQzIiwiR3JhcGhpY3MiLCJjdXJyZW50UGF0aCIsImRpcnR5IiwiY2xlYXJEaXJ0eSIsIl93ZWJHTCIsIndvcmxkQWxwaGEiLCJ0aW50IiwiZHJhd1NoYXBlIiwieGEiLCJ5YSIsImExIiwiYjEiLCJhMiIsImIyIiwibW0iLCJkZCIsImNjIiwidHQiLCJrMSIsImsyIiwiajEiLCJqMiIsInF4IiwicXkiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhbnRpY2xvY2t3aXNlIiwic3RhcnRYIiwic3RhcnRZIiwidGhldGEiLCJ0aGV0YTIiLCJjVGhldGEiLCJzVGhldGEiLCJzZWdNaW51cyIsInJlbWFpbmRlciIsInJlYWwiLCJwb3AiLCJtaW5YIiwiSW5maW5pdHkiLCJtYXhYIiwibWluWSIsIm1heFkiLCJSUkVDIiwicnciLCJyaCIsIkJvdW5kIiwiQ2FudmFzUmVuZGVyZXIiLCJDQU5WQVMiLCJDR1IiLCJjb252ZXJ0U3RhZ2UiLCJyZW5kZXJTdGFnZSIsIl9jbGVhciIsIl9yZW5kZXIiLCJzZXRUcmFuc2Zvcm0iLCJ0b0FycmF5IiwiX2RyYXciLCJjbGVhclJlY3QiLCJUZXh0dXJlIiwibWFwU2l6ZSIsImRlZmF1bHRWYWx1ZSIsInNldFByZWNpc2lvbiIsImNvbXBpbGVQcm9ncmFtIiwiZXh0cmFjdEF0dHJpYnV0ZXMiLCJleHRyYWN0VW5pZm9ybXMiLCJnZW5lcmF0ZVVuaWZvcm1BY2Nlc3NPYmplY3QiLCJzZXRWZXJ0ZXhBdHRyaWJBcnJheXMiLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkNCIsInJlcXVpcmUkJDUiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsIkdMRnJhbWVidWZmZXIiLCJnbENvcmUiLCJSZW5kZXJUYXJnZXQiLCJyZXNvbHV0aW9uIiwiZnJhbWVCdWZmZXIiLCJjbGVhckNvbG9yIiwic2l6ZSIsInByb2plY3Rpb25NYXRyaXgiLCJmcmFtZSIsImRlZmF1bHRGcmFtZSIsImRlc3RpbmF0aW9uRnJhbWUiLCJzb3VyY2VGcmFtZSIsImZyYW1lYnVmZmVyIiwic2V0RnJhbWUiLCJyZXNpemUiLCJjbGVhciIsImNhbGN1bGF0ZVByb2plY3Rpb24iLCJlbmFibGUiLCJTQ0lTU09SX1RFU1QiLCJzY2lzc29yIiwiZGlzYWJsZSIsInZpZXdwb3J0IiwicG0iLCJwcm9qZWN0aW9uRnJhbWUiLCJERVBUSF9URVNUIiwiRlJPTlRfRkFDRSIsIkNVTExfRkFDRSIsIldlYkdMU3RhdGUiLCJhY3RpdmVTdGF0ZSIsIlVpbnQ4QXJyYXkiLCJkZWZhdWx0U3RhdGUiLCJzdGFja0luZGV4Iiwic3RhY2siLCJtYXhBdHRyaWJzIiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1ZFUlRFWF9BVFRSSUJTIiwiYXR0cmliU3RhdGUiLCJuYXRpdmVWYW9FeHRlbnNpb24iLCJnZXRFeHRlbnNpb24iLCJzdGF0ZSIsInNldFN0YXRlIiwic2V0RGVwdGhUZXN0Iiwic2V0RnJvbnRGYWNlIiwic2V0Q3VsbEZhY2UiLCJmcm9udEZhY2UiLCJ0ZW1wQXR0cmliU3RhdGUiLCJkaXNhYmxlVmVydGV4QXR0cmliQXJyYXkiLCJiaW5kVmVydGV4QXJyYXlPRVMiLCJyZXNldEF0dHJpYnV0ZXMiLCJwaXhlbFN0b3JlaSIsIlVOUEFDS19GTElQX1lfV0VCR0wiLCJoZXgycmdiIiwiaGV4IiwicmVwbGFjZSIsIldlYkdMR3JhcGhpY3NEYXRhIiwic2hhZGVyIiwiYXR0cmlic1N0YXRlIiwiY29sb3IiLCJpbmRpY2VzIiwiR0xCdWZmZXIiLCJjcmVhdGVWZXJ0ZXhCdWZmZXIiLCJpbmRleEJ1ZmZlciIsImNyZWF0ZUluZGV4QnVmZmVyIiwiZ2xQb2ludHMiLCJnbEluZGljZXMiLCJ2YW8iLCJWZXJ0ZXhBcnJheU9iamVjdCIsImFkZEluZGV4IiwiYWRkQXR0cmlidXRlIiwiYXR0cmlidXRlcyIsImFWZXJ0ZXhQb3NpdGlvbiIsIkZMT0FUIiwiYUNvbG9yIiwidXBsb2FkIiwiVWludDE2QXJyYXkiLCJQUkVDSVNJT04iLCJHTFNoYWRlciIsImNoZWNrUHJlY2lzaW9uIiwic3Vic3RyaW5nIiwidW5zaGlmdCIsIlNoYWRlciIsInZlcnRleFNyYyIsImZyYWdtZW50U3JjIiwiUHJpbWl0aXZlU2hhZGVyIiwiYnVpbGRMaW5lIiwid2ViR0xEYXRhIiwiZmlyc3RQb2ludCIsImxhc3RQb2ludCIsIm1pZFBvaW50WCIsIm1pZFBvaW50WSIsInZlcnRzIiwiaW5kZXhDb3VudCIsImluZGV4U3RhcnQiLCJhbHBoYSIsImciLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJwM3giLCJwM3kiLCJwZXJweCIsInBlcnB5IiwicGVycDJ4IiwicGVycDJ5IiwicGVycDN4IiwicGVycDN5IiwiZGlzdCIsImMxIiwiYzIiLCJkZW5vbSIsInBkaXN0IiwiYnVpbGRQb2x5IiwiaG9sZUFycmF5IiwiaG9sZSIsInRyaWFuZ2xlcyIsImVhcmN1dCIsInZlcnRQb3MiLCJidWlsZFJlY3RhbmdsZSIsInJlY3REYXRhIiwidGVtcFBvaW50cyIsImJ1aWxkQ2lyY2xlIiwiY2lyY2xlRGF0YSIsInRvdGFsU2VncyIsInNlZyIsInZlY1BvcyIsIkdyYXBoaWNzUmVuZGVyZXIiLCJncmFwaGljc0RhdGFQb29sIiwicHJpbWl0aXZlU2hhZGVyIiwiQ09OVEVYVF9VSUQiLCJ3ZWJHTCIsInVwZGF0ZUdyYXBoaWNzIiwiYmluZFNoYWRlciIsInNoYWRlclRlbXAiLCJ1bmlmb3JtcyIsInRyYW5zbGF0aW9uTWF0cml4IiwiYmluZFZhbyIsImRyYXciLCJUUklBTkdMRV9TVFJJUCIsImxhc3RJbmRleCIsImdldFdlYkdMRGF0YSIsInJlc2V0IiwiV2ViR0xTdGFnZVJlbmRlcmVyIiwiV0VCR0wiLCJoYW5kbGVDb250ZXh0TG9zdCIsImhhbmRsZUNvbnRleHRSZXN0b3JlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfYmFja2dyb3VuZENvbG9yUmdiYSIsIl9jb250ZXh0T3B0aW9ucyIsInRyYW5zcGFyZW50IiwiYW50aWFsaWFzIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiY3JlYXRlQ29udGV4dCIsIl9hY3RpdmVTaGFkZXIiLCJfYWN0aXZlVmFvIiwiX2FjdGl2ZVJlbmRlclRhcmdldCIsImRyYXdNb2RlcyIsIm1hcFdlYkdMRHJhd01vZGVzIiwid2ViZ2xHUiIsIl9pbml0Q29udGV4dCIsImlzQ29udGV4dExvc3QiLCJyZXN0b3JlQ29udGV4dCIsInJlc2V0VG9EZWZhdWx0Iiwicm9vdFJlbmRlclRhcmdldCIsImJpbmRSZW5kZXJUYXJnZXQiLCJvbkNvbnRleHRDaGFuZ2UiLCJhY3RpdmF0ZSIsInJlbmRlclRhcmdldCIsInVuYmluZCIsInRleHR1cmVNYW5hZ2VyIiwicmVtb3ZlQWxsIiwiUE9JTlRTIiwiTElORVMiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiVFJJQU5HTEVTIiwiVFJJQU5HTEVfRkFOIiwicmVtb3ZlVmlldyIsImRlc3Ryb3lQbHVnaW5zIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVpZCIsInVzZVByb2dyYW0iLCJsb3NlQ29udGV4dCIsIldlYkdMUmVuZGVyZXIiLCJ3ZWJHTFN0YWdlUmVuZGVyZXIiLCJhdXRvUmVuZGVyZXIiLCJ1dGlscyIsImlzV2ViR0xTdXBwb3J0ZWQiLCJBcHBsaWNhdGlvbiIsIl9jaWQiLCJyYW5kb20iLCJxdWVyeSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwidmlld09iaiIsImNyZWF0ZVZpZXciLCJpbm5lckhUTUwiLCJvZmZzZXQiLCJsYXN0R2V0Uk8iLCJfY3JlYXRIb3ZlclN0YWdlIiwiX2NyZWF0ZVBpeGVsQ29udGV4dCIsInJlU2l6ZUNhbnZhcyIsIl9waXhlbENhbnZhcyIsImNyZWF0ZUNhbnZhcyIsImNhbnZhc1N1cHBvcnQiLCJkaXNwbGF5IiwiekluZGV4IiwidmlzaWJpbGl0eSIsIl9waXhlbEN0eCIsImluc2VydEJlZm9yZSIsImluaXRTdGFnZSIsIlNwcml0ZSIsIlNoYXBlIiwiX2NvbnRleHQiLCJfaG92ZXJhYmxlIiwiX2NsaWNrYWJsZSIsImluaXRDb21wUHJvcGVydHkiLCJfcmVjdCIsInNldFN0eWxlIiwibGFzdEdEaW5kIiwiZ2QiLCJ3YXRjaCIsImRhc2hMZW5ndGgiLCJkZWx0YVgiLCJkZWx0YVkiLCJudW1EYXNoZXMiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJNSU5fVkFMVUUiLCJjcGwiLCJwb2ludExpc3QiLCJyb3VuZCIsIlRleHQiLCJfcmVOZXdsaW5lIiwiZm9udFByb3BlcnRzIiwiZm9udCIsIl9nZXRGb250RGVjbGFyYXRpb24iLCJnZXRUZXh0V2lkdGgiLCJnZXRUZXh0SGVpZ2h0IiwiX3JlbmRlclRleHQiLCJfZ2V0VGV4dExpbmVzIiwic2F2ZSIsIl9nZXRUZXh0V2lkdGgiLCJyZXN0b3JlIiwiX2dldFRleHRIZWlnaHQiLCJ0ZXh0TGluZXMiLCJfcmVuZGVyVGV4dFN0cm9rZSIsIl9yZW5kZXJUZXh0RmlsbCIsImZvbnRBcnIiLCJmb250UCIsIl9ib3VuZGFyaWVzIiwibGluZUhlaWdodHMiLCJoZWlnaHRPZkxpbmUiLCJfZ2V0SGVpZ2h0T2ZMaW5lIiwiX3JlbmRlclRleHRMaW5lIiwiX2dldFRvcE9mZnNldCIsInN0cm9rZURhc2hBcnJheSIsInNldExpbmVEYXNoIiwibWV0aG9kIiwibGluZUluZGV4IiwidGV4dEFsaWduIiwiX3JlbmRlckNoYXJzIiwibWVhc3VyZVRleHQiLCJ0b3RhbFdpZHRoIiwid29yZHMiLCJ3b3Jkc1dpZHRoIiwid2lkdGhEaWZmIiwibnVtU3BhY2VzIiwic3BhY2VXaWR0aCIsImxlZnRPZmZzZXQiLCJjaGFycyIsImZvbnRTaXplIiwibGluZUhlaWdodCIsIm1heFdpZHRoIiwiY3VycmVudExpbmVXaWR0aCIsInRleHRCYXNlbGluZSIsIlZlY3RvciIsIl9heGVzIiwiaW50ZXJwb2xhdGUiLCJpc0xvb3AiLCJzbW9vdGhGaWx0ZXIiLCJyZXQiLCJkaXN0YW5jZSIsInByZVZlcnRvciIsImlWdG9yIiwicG9zIiwiaWR4IiwidzIiLCJ3MyIsIl9jYWNoZSIsIl9yYWRpYW5zIiwiaXNEZWdyZWVzIiwidG9GaXhlZCIsImRlZ3JlZVRvUmFkaWFuIiwicmFkaWFuVG9EZWdyZWUiLCJkZWdyZWVUbzM2MCIsInJlQW5nIiwiZ2V0SXNnb25Qb2ludExpc3QiLCJkU3RlcCIsImJlZ2luRGVnIiwiZGVnIiwiZ2V0U21vb3RoUG9pbnRMaXN0IiwicExpc3QiLCJjdXJyTCIsIlNtb290aFNwbGluZSIsIkJyb2tlbkxpbmUiLCJhdHlwZSIsInNtb290aCIsIl9NYXRoIiwiY2xlYXJHcmFwaGljc0RhdGEiLCJsaW5lVHlwZSIsInNpIiwic2wiLCJkYXNoZWRMaW5lVG8iLCJkcmF3Q2lyY2xlIiwiUGF0aCIsImRyYXdUeXBlT25seSIsIl9fcGFyc2VQYXRoRGF0YSIsInBhdGhzIiwicGF0aFN0ciIsIl9wYXJzZUNoaWxkUGF0aERhdGEiLCJjcyIsIlJlZ0V4cCIsImFyciIsImNhIiwiY3B4IiwiY3B5Iiwic3RyIiwiY21kIiwiY3RsUHR4IiwiY3RsUHR5IiwicHJldkNtZCIsInBzaSIsImZhIiwiZnMiLCJjb21tYW5kIiwicGF0aEFycmF5IiwiX3BhcnNlUGF0aERhdGEiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiRHJvcGxldCIsIm15IiwiY3JlYXRlUGF0aCIsInBzIiwiaHIiLCJ2ciIsImRyYXdFbGxpcHNlIiwiX2RyYXdUeXBlT25seSIsIklzb2dvbiIsIkxpbmUiLCJSZWN0IiwiZ2V0Q3NzT3JkZXJBcnIiLCJHIiwiZHJhd1JlY3QiLCJfYnVpbGRSYWRpdXNQYXRoIiwiU2VjdG9yIiwicmVnQW5nbGUiLCJpc1JpbmciLCJyMCIsIm15TWF0aCIsImNsb2Nrd2lzZSIsImdldFJlZ0FuZ2xlIiwicDREaXJlY3Rpb24iLCJpbkFuZ2xlUmVnIiwicmVnSW4iLCJnZXRSZWN0Rm9ybVBvaW50TGlzdCIsIkNhbnZheCIsIkRpc3BsYXkiLCJTaGFwZXMiLCJFdmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxNQUFJLEVBQVI7QUFDQSxJQUFJQyxVQUFVLEVBQWQ7QUFDQSxJQUFJQyxhQUFhQyxNQUFNQyxTQUF2QjtJQUFrQ0MsV0FBV0MsT0FBT0YsU0FBcEQ7QUFDQSxJQUNBRyxXQUFtQkYsU0FBU0UsUUFENUI7SUFFQUMsaUJBQW1CSCxTQUFTRyxjQUY1Qjs7QUFJQSxJQUNBQyxnQkFBcUJQLFdBQVdRLE9BRGhDO0lBRUFDLGVBQXFCVCxXQUFXVSxNQUZoQztJQUdBQyxnQkFBcUJYLFdBQVdZLE9BSGhDO0lBSUFDLGdCQUFxQlosTUFBTWEsT0FKM0I7SUFLQUMsYUFBcUJYLE9BQU9ZLElBTDVCOztBQU9BbEIsSUFBRW1CLE1BQUYsR0FBVyxVQUFTQyxHQUFULEVBQWM7TUFDbkJGLE9B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QUFFLElBQUksR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7U0FDMUI7OztRQUdELElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQzdDOztJQUVELFlBQVksQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDOztJQUUxRCxPQUFPLFNBQVMsQ0FBQztDQUNwQjs7O0FBR0QsU0FBUyxVQUFVLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRTtJQUNsRCxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUM7O0lBRVosSUFBSSxTQUFTLE1BQU0sVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ3ZELEtBQUssQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDdkYsTUFBTTtRQUNILEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLElBQUksR0FBRyxFQUFFLElBQUksR0FBRyxVQUFVLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJ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Q0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7UUFDL0MsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7S0FDZDs7SUFFRCxPQUFPLElBQUksQ0FBQztDQUNmOztBQUVELFNBQVMsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtJQUN4QyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSTtRQUNaLENBQUMsR0FBRyxHQUFHO1FBQ1AsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7O0lBRWpCLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sS0FBSyxDQUFDOzs7SUFHckMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7SUFHMUUsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7UUFDN0MsSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7OztJQUdsRCxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDOztJQUVsQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRTtRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSTtZQUNoQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxD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
